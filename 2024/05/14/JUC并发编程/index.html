<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>JUC 并发编程 | thr's blog</title><meta name="author" content="thr"><meta name="copyright" content="thr"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="JUC 学习视频：【狂神说Java】JUC并发编程最新版通俗易懂_哔哩哔哩_bilibili  1. 基本介绍 JUC：java.util.concurrent 包，简称 JUC，是 Java 5 引入的并发工具包，提供了大量的并发编程工具和高级特性，用于简化多线程编程 进程和线程： 进程：计算机中正在执行的独立程序，每个进程拥有独立的内存空间和系统资源，进程是CPU资源分配的最小单位 线程：进程">
<meta property="og:type" content="article">
<meta property="og:title" content="JUC 并发编程">
<meta property="og:url" content="https://tangsmallrong.github.io/2024/05/14/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/index.html">
<meta property="og:site_name" content="thr&#39;s blog">
<meta property="og:description" content="JUC 学习视频：【狂神说Java】JUC并发编程最新版通俗易懂_哔哩哔哩_bilibili  1. 基本介绍 JUC：java.util.concurrent 包，简称 JUC，是 Java 5 引入的并发工具包，提供了大量的并发编程工具和高级特性，用于简化多线程编程 进程和线程： 进程：计算机中正在执行的独立程序，每个进程拥有独立的内存空间和系统资源，进程是CPU资源分配的最小单位 线程：进程">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://tangsmallrong.github.io/img/avatar.jpg">
<meta property="article:published_time" content="2024-05-14T03:49:25.000Z">
<meta property="article:modified_time" content="2024-05-14T03:54:22.725Z">
<meta property="article:author" content="thr">
<meta property="article:tag" content="juc">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://tangsmallrong.github.io/img/avatar.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://tangsmallrong.github.io/2024/05/14/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: thr","link":"链接: ","source":"来源: thr's blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'JUC 并发编程',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-05-14 11:54:22'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.0.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/./img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">13</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">12</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="thr's blog"><span class="site-name">thr's blog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">JUC 并发编程</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-05-14T03:49:25.000Z" title="发表于 2024-05-14 11:49:25">2024-05-14</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-05-14T03:54:22.725Z" title="更新于 2024-05-14 11:54:22">2024-05-14</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/">Java</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">23.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>90分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="JUC 并发编程"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><h1 id="JUC"><a href="#JUC" class="headerlink" title="JUC"></a>JUC</h1><blockquote>
<p>学习视频：<br><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1B7411L7tE/?spm_id_from=333.337.search-card.all.click&vd_source=ce97d263f08af76fc25ff49de530fe92">【狂神说Java】JUC并发编程最新版通俗易懂_哔哩哔哩_bilibili</a></p>
</blockquote>
<h2 id="1-基本介绍"><a href="#1-基本介绍" class="headerlink" title="1. 基本介绍"></a>1. 基本介绍</h2><ul>
<li><strong>JUC</strong>：<code>java.util.concurrent</code> 包，简称 JUC，是 Java 5 引入的并发工具包，提供了大量的并发编程工具和高级特性，用于简化多线程编程</li>
<li><strong>进程和线程</strong>：<ul>
<li><strong>进程</strong>：计算机中<strong>正在执行的独立程序</strong>，每个进程拥有独立的内存空间和系统资源，进程是CPU<strong>资源分配的最小单位</strong></li>
<li><strong>线程</strong>：进程内部的执行单元，<strong>一个进程可以包含多个线程</strong>，线程共享进程的内存空间和资源，线程是CPU<strong>调度和执行的最小单位</strong><ul>
<li><strong>Java 默认有2个线程</strong> &#x3D;&#x3D;&gt; main线程、GC线程</li>
</ul>
</li>
</ul>
</li>
<li><strong>Java 真的可以开启线程？</strong><ul>
<li>从源码看，Java 是使用本地 native 方法调用底层的 C&#x2F;C++ 代码来开启线程</li>
<li><code>start0</code> 是 <code>Thread</code> 类的私有本地方法，由 JVM 通过 C&#x2F;C++ 代码实现</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++ 底层, Java是没有权限操作底层硬件的</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">start0</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (threadStatus != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalThreadStateException</span>();</span><br><span class="line">    group.add(<span class="built_in">this</span>);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">started</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        start0();  <span class="comment">// 本地方法，实际启动线程</span></span><br><span class="line">        started = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!started) &#123;</span><br><span class="line">                group.threadStartFailed(<span class="built_in">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ignore) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>并发和并行</strong>：并发编程的<strong>本质：充分利用CPU的资源！</strong></p>
<ul>
<li><strong>并发</strong>：在<strong>单核</strong>处理器上模拟出多条线程，任务通过操作系统的调度，轮流占用CPU时间片，从<strong>宏观上看似乎是同时进行</strong>（多线程操作同一个资源）</li>
<li><strong>并行</strong>：在多核处理器上，多个任务可以真正同时在不同的处理器核心上运行，<strong>可以使用线程池提高性能</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//获取cpu的核数</span></span><br><span class="line">        System.out.println(Runtime.getRuntime().availableProcessors());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>多线程</strong> 是实现并发的<strong>一种方式</strong>，通过并发（交替或同时）执行多个线程实现</p>
</li>
<li><p><strong>Java 中线程的 6 种状态</strong>：NEW,RUNNABLE,BLOCKED,WAITING,TIMED_WAITING,TERMINATED</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">State</span> &#123;</span><br><span class="line">    <span class="comment">// 新生</span></span><br><span class="line">    NEW,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 运行</span></span><br><span class="line">    RUNNABLE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞</span></span><br><span class="line">    BLOCKED,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待</span></span><br><span class="line">    WAITING,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 超时等待</span></span><br><span class="line">    TIMED_WAITING,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 终止</span></span><br><span class="line">    TERMINATED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-wait-和-sleep-的区别"><a href="#2-wait-和-sleep-的区别" class="headerlink" title="2. wait 和 sleep 的区别"></a>2. wait 和 sleep 的区别</h2><ul>
<li><strong>来自不同的类</strong>：<ul>
<li>wait &#x3D;&gt; Object</li>
<li>sleep &#x3D;&gt; Thread</li>
</ul>
</li>
</ul>
<p>一般情况企业中使用休眠是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 来自 java.util.concurrent 包下的 TimeUnit 类</span></span><br><span class="line">TimeUnit.DAYS.sleep(<span class="number">1</span>); <span class="comment">// 休眠1天</span></span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">1</span>); <span class="comment">// 休眠1s</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>关于锁的释放</strong>：<ul>
<li>wait 会释放锁对象，使其他等待该锁的线程能够获得锁并继续执行</li>
<li>sleep 不会释放锁 &#x3D;&#x3D;&gt; 抱着锁睡觉</li>
</ul>
</li>
<li><strong>使用的范围不同</strong>：<ul>
<li>wait 必须在同步方法&#x2F;同步代码块中调用，否则会抛出 <code>IllegalMonitorStateException</code> 异常</li>
<li>sleep 可以在任何地方睡</li>
</ul>
</li>
<li><strong>是否需要捕获异常</strong>：<ul>
<li>都需要捕获 <code>InterruptedException</code> 异常</li>
</ul>
</li>
</ul>
<h2 id="3-Lock-锁-重点"><a href="#3-Lock-锁-重点" class="headerlink" title="3. Lock 锁(重点)"></a>3. Lock 锁(重点)</h2><h3 id="3-1-传统的-Synchronized-锁"><a href="#3-1-传统的-Synchronized-锁" class="headerlink" title="3.1 传统的 Synchronized 锁"></a>3.1 传统的 Synchronized 锁</h3><ul>
<li><strong>减少耦合</strong>：线程就是一个单独的资源类，没有任何的附属操作！</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 真正的多线程开发</span></span><br><span class="line"><span class="comment"> * 线程就是一个单独的资源类，没有任何的附属操作！</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SaleTicketDemo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 多线程操作</span></span><br><span class="line">        <span class="comment">// 并发：多线程操作同一个资源类，把资源类丢入线程</span></span><br><span class="line">        <span class="type">Ticket</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Ticket</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Runnable 是 @FunctionalInterface 函数式接口 </span></span><br><span class="line">        <span class="comment">// jdk1.8 之后使用 lambda 表达式</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">40</span>; i++) &#123;</span><br><span class="line">                ticket.sale();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">40</span>; i++) &#123;</span><br><span class="line">                ticket.sale();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">40</span>; i++) &#123;</span><br><span class="line">                ticket.sale();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;C&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 资源类: 属性+方法 oop思想</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Ticket</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 卖票的方式</span></span><br><span class="line">    <span class="comment">// synchronized 本质：队列+锁</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sale</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (number &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 卖出了第 &quot;</span> + (number--) + <span class="string">&quot; 张票,剩余：&quot;</span> + number + <span class="string">&quot; 张票&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-Lock-锁"><a href="#3-2-Lock-锁" class="headerlink" title="3.2 Lock 锁"></a>3.2 Lock 锁</h3><ul>
<li><strong>加锁解锁</strong>：<code>lock()</code>、<code>unlock()</code></li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B.assets/image-20240509203720427.png" alt="image-20240509203720427"></p>
<ul>
<li><strong>3个实现类</strong>：<ul>
<li><strong><code>ReentrantLock</code>：</strong> 可重入锁</li>
<li><strong><code>ReentrantReadWriteLock.ReadLock</code>：</strong> 可重入读锁</li>
<li><strong><code>ReentrantReadWriteLock.WriteLock</code>：</strong> 可重入写锁</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B.assets/image-20240509203744318.png" alt="image-20240509203744318"></p>
<ul>
<li><strong>公平锁与非公平锁：</strong><ul>
<li><strong>公平锁：</strong> 必须先来后到</li>
<li><strong>非公平锁：</strong> 可以插队**(默认为非公平锁)**</li>
</ul>
</li>
<li><strong>使用 <code>Lock</code> 的三步曲：</strong><ul>
<li>创建 <code>Lock</code> 对象：<code>Lock lock = new ReentrantLock();</code></li>
<li>加锁：<code>lock.lock();</code></li>
<li>解锁：在 <code>finally</code> 块中解锁 <code>lock.unlock();</code></li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SaleTicketDemo02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//多线程操作</span></span><br><span class="line">        <span class="comment">//并发：多线程操作同一个资源类，把资源类丢入线程</span></span><br><span class="line">        <span class="type">Ticket2</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Ticket2</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">40</span>; i++) ticket.sale();</span><br><span class="line">        &#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">40</span>; i++) ticket.sale();</span><br><span class="line">        &#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">40</span>; i++) ticket.sale();</span><br><span class="line">        &#125;, <span class="string">&quot;C&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// lock三部曲</span></span><br><span class="line"><span class="comment">// 1. Lock lock=new ReentrantLock();</span></span><br><span class="line"><span class="comment">// 2. lock.lock() 加锁</span></span><br><span class="line"><span class="comment">// 3. finally=&gt; 解锁：lock.unlock();</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Ticket2</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//卖票的方式</span></span><br><span class="line">    <span class="comment">// 使用Lock 锁</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sale</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//加锁</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//业务代码</span></span><br><span class="line">            <span class="keyword">if</span> (number &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 卖出了第&quot;</span> + (number--) + <span class="string">&quot; 张票,剩余：&quot;</span> + number + <span class="string">&quot; 张票&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//解锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-3-Synchronized-VS-Lock"><a href="#3-3-Synchronized-VS-Lock" class="headerlink" title="3.3 Synchronized VS. Lock"></a>3.3 Synchronized VS. Lock</h3><ul>
<li><p><strong>锁的实现</strong>：</p>
<ul>
<li><strong>Synchronized</strong>：<strong>内置的 Java 关键字</strong>，直接由 JVM 实现</li>
<li><strong>Lock</strong>：接口，由 Java 类实现，需要显式调用 <code>lock</code> 和 <code>unlock</code> 方法</li>
</ul>
</li>
<li><p><strong>获取锁状态</strong>：</p>
<ul>
<li><strong>Synchronized</strong>：无法判断获取锁的状态</li>
<li><strong>Lock</strong>： 可以通过 <code>tryLock</code> 方法判断是否成功获得锁</li>
</ul>
</li>
<li><p><strong>锁的释放</strong>：</p>
<ul>
<li><strong>Synchronized</strong>： 出了同步块或方法范围后，自动释放锁</li>
<li><strong>Lock</strong>：需要手动加锁和手动释放锁，<strong>如果没有释放锁，可能会导致死锁</strong></li>
</ul>
</li>
<li><p><strong>锁等待行为</strong>：</p>
<ul>
<li><p><strong>Synchronized</strong>：线程1获得锁，线程2必须等待，直到线程1释放锁</p>
</li>
<li><p><strong>Lock</strong>：可以通过 <code>tryLock</code> 方法尝试获取锁，<strong>不会导致长时间等待</strong></p>
</li>
</ul>
</li>
<li><p><strong>可重入性</strong>：又称<strong>递归锁</strong>，指一个线程在持有锁的情况下可以再次获取该锁的能力；当一个线程已经获得了某个锁，可以再次获取该锁而不会被阻塞；<strong>每次获取锁的计数增加 1，每次释放锁的计数减少 1，直到计数为 0 时，锁才真正被释放</strong></p>
<ul>
<li><strong>Synchronized</strong>：是可重入锁，不可以中断的，非公平的</li>
<li><strong>Lock</strong>：<code>ReentrantLock</code> 实现了可重入锁，可以判断锁，可以自己设置公平锁和非公平锁</li>
</ul>
</li>
<li><p><strong>使用场景</strong>：</p>
<ul>
<li><strong>Synchronized</strong>：适合锁定<strong>少量代码的同步问题</strong></li>
<li><strong>Lock</strong>：适合<strong>锁定大量同步代码的复杂场景</strong></li>
</ul>
</li>
</ul>
<p><strong>锁到底是什么？ 如何判断锁的是谁？</strong></p>
<ul>
<li><strong>锁：</strong> 一种并发控制机制，用于协调多个线程对共享资源的访问，确保数据的正确性和一致性</li>
<li><strong>锁的粒度</strong>：锁可以锁定方法、代码块或对象实例</li>
<li><strong>锁的持有者</strong>：可以使用调试工具或日志记录来判断哪个线程当前持有锁</li>
</ul>
<h2 id="4-生产者和消费者问题-线程通信"><a href="#4-生产者和消费者问题-线程通信" class="headerlink" title="4. 生产者和消费者问题-线程通信"></a>4. 生产者和消费者问题-线程通信</h2><blockquote>
<p>面试常考：单例模式、排序算法、生产者和消费者、死锁</p>
</blockquote>
<h3 id="4-1-Synchronized-版"><a href="#4-1-Synchronized-版" class="headerlink" title="4.1 Synchronized 版"></a>4.1 Synchronized 版</h3><ul>
<li><code>wait</code>、<code>notify</code> 和 <code>notifyAll</code> 的使用中必须谨防虚假唤醒</li>
<li><strong>虚假唤醒</strong>：多线程环境下，有多个线程执行了wait()方法，需要其他线程执行notify()或者notifyAll()方法去唤醒它们，假如多个线程都被唤醒了，但是只有其中一部分是有用的唤醒操作，其余的唤醒都是无用功；对于不应该被唤醒的线程而言，便是虚假唤醒</li>
<li><strong>防止虚假唤醒问题</strong>：<code>wait</code> 方法的调用应该始终放在循环（<code>while</code>）中，而不是条件判断（<code>if</code>）中<ul>
<li>当某个线程被错误地唤醒后，如果使用 <code>if</code> 判断条件，线程会继续执行，而不是重新检查条件是否满足，导致逻辑错误</li>
</ul>
</li>
</ul>
<blockquote>
<p>目前只有 A 和 B 两个线程，一个 +1，一个 -1，用 if 不会出问题，但是<strong>如果增加 C 和 D 线程</strong>，就会变成两个 +1，两个 -1，<strong>此时用 if ，可能会出现问题</strong>，如：</p>
<p>A先执行，执行时调用了<strong>wait方法</strong>，那它会等待，此时<strong>会释放锁</strong>，如果线程C获得锁并且也会执行wait方法，两个加线程一起等待被唤醒，此时减线程中的某一个线程执行完毕并且唤醒了这俩加线程，那么A获取了锁并且加1，执行完毕之后B再执行，如果是if的话，那么A修改完num后，B不会再去判断num的值，直接会给num+1。如果是while的话，A执行完之后，B还会去判断num的值，因此就不会执行</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程之间的通信问题: 生产者和消费者问题  等待唤醒、通知唤醒</span></span><br><span class="line"><span class="comment"> * 线程交替执行 A B 操作同一个变量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Data</span> <span class="variable">data</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Data</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 线程操作资源类, 降低耦合</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    data.increment();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    data.decrement();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断等待 =&gt; 业务 =&gt; 通知</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Data</span> &#123;  <span class="comment">// 数字  资源类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// +1</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">while</span> (number != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 等待操作</span></span><br><span class="line">            <span class="built_in">this</span>.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        number++;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;=&gt;&quot;</span> + number);</span><br><span class="line">        <span class="comment">// 通知其他线程 我+1完毕了</span></span><br><span class="line">        <span class="built_in">this</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// -1</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">decrement</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">while</span> (number == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 等待操作</span></span><br><span class="line">            <span class="built_in">this</span>.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        number--;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;=&gt;&quot;</span> + number);</span><br><span class="line">        <span class="comment">// 通知其他线程  我-1完毕了</span></span><br><span class="line">        <span class="built_in">this</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-2-Lock-版"><a href="#4-2-Lock-版" class="headerlink" title="4.2 Lock 版"></a>4.2 Lock 版</h3><ul>
<li>对应于 synchronized，JUC 版本下，Lock 锁也有对应的唤醒与停止方法，分别是 <strong>condition接口下的signal()与await()</strong></li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B.assets/image-20240510113250698.png" alt="image-20240510113250698"></p>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B.assets/image-20240510113305892.png" alt="image-20240510113305892"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Data2</span> <span class="variable">data</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Data2</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++) &#123;</span><br><span class="line">            data.increment();</span><br><span class="line">        &#125;</span><br><span class="line">                       &#125;,<span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++) &#123;</span><br><span class="line">            data.decrement();</span><br><span class="line">        &#125;&#125;,<span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++) &#123;</span><br><span class="line">            data.increment();</span><br><span class="line">        &#125;</span><br><span class="line">                       &#125;,<span class="string">&quot;C&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++) &#123;</span><br><span class="line">            data.decrement();</span><br><span class="line">        &#125;</span><br><span class="line">                       &#125;,<span class="string">&quot;D&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Data2</span>&#123;</span><br><span class="line">    <span class="comment">//数字  资源类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//lock锁</span></span><br><span class="line">    <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//+1</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span>  &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//业务</span></span><br><span class="line">            <span class="keyword">while</span> (number!=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//等待操作</span></span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            number++;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;=&gt;&quot;</span>+number);</span><br><span class="line">            <span class="comment">//通知其他线程 我+1完毕了</span></span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//-1</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">decrement</span><span class="params">()</span>  &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//业务</span></span><br><span class="line">            <span class="keyword">while</span> (number==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//等待操作</span></span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            number--;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;=&gt;&quot;</span>+number);</span><br><span class="line">            <span class="comment">//通知其他线程 我+1完毕了</span></span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>Condition 的优势？</strong><ul>
<li><strong>可以实现精准的通知和唤醒线程</strong>，如：在A线程执行完后精准唤醒B线程执行，B线程执行完后精准唤醒C线程执行，C线程执行完后精准唤醒A线程执行</li>
<li><strong>线程 A：</strong> 其他同理<ul>
<li>通过 <code>condition1.await()</code> 等待 <code>number</code> 变为 1。</li>
<li>打印 <code>AAAAA</code>，设置 <code>number</code> 为 2，唤醒 <code>condition2</code> 上的等待线程（B）</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A 执行完 调用B</span></span><br><span class="line"><span class="comment"> * B 执行完 调用C</span></span><br><span class="line"><span class="comment"> * C 执行完 调用A</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Data3</span> <span class="variable">data3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Data3</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                data3.printA();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                data3.printB();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                data3.printC();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;C&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Data3</span> &#123;  <span class="comment">// 资源类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">condition1</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">condition2</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">condition3</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">1</span>;  <span class="comment">// 1A 2B 3C</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printA</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 判断 -&gt; 执行 -&gt; 通知</span></span><br><span class="line">            <span class="keyword">while</span> (number != <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">//等待</span></span><br><span class="line">                condition1.await();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 执行</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;,AAAAA&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 唤醒指定的线程</span></span><br><span class="line">            number = <span class="number">2</span>;</span><br><span class="line">            condition2.signal();  <span class="comment">// 唤醒2</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printB</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 判断 -&gt; 执行 -&gt; 通知</span></span><br><span class="line">            <span class="keyword">while</span> (number != <span class="number">2</span>) &#123;</span><br><span class="line">                condition2.await();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;,BBBBB&quot;</span>);</span><br><span class="line">            <span class="comment">// 唤醒3</span></span><br><span class="line">            number = <span class="number">3</span>;</span><br><span class="line">            condition3.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printC</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 判断 -&gt; 执行 -&gt; 通知</span></span><br><span class="line">            <span class="keyword">while</span> (number != <span class="number">3</span>) &#123;</span><br><span class="line">                condition3.await();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;,CCCCC&quot;</span>);</span><br><span class="line">            <span class="comment">// 唤醒1</span></span><br><span class="line">            number = <span class="number">1</span>;</span><br><span class="line">            condition1.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-8锁现象"><a href="#5-8锁现象" class="headerlink" title="5. 8锁现象"></a>5. 8锁现象</h2><ul>
<li><strong>如何判断锁锁的到底是谁？</strong><ul>
<li><strong>锁：</strong> 线程同步的机制，用来确保多个线程能够安全访问共享资源</li>
<li>锁的是谁：<ul>
<li><strong>实例方法的锁：</strong> 锁的是调用方法的实例对象</li>
<li><strong>静态方法的锁：</strong> 锁的是该类的 <code>Class</code> 对象</li>
</ul>
</li>
</ul>
</li>
<li>从 <strong>8 个锁相关问题</strong>深刻理解锁</li>
</ul>
<h3 id="5-1-一对象，两同步"><a href="#5-1-一对象，两同步" class="headerlink" title="5.1 一对象，两同步"></a>5.1 一对象，两同步</h3><blockquote>
<p><strong>同一个对象，两个同步方法，</strong>标准情况下是先发短信还是打电话</p>
</blockquote>
<ul>
<li><strong>问题：</strong> 两个同步实例方法 <code>sendSms</code> 和 <code>call</code>，哪个先执行？</li>
<li><strong>结论：</strong> 先发短信，再打电话，因为<strong>两个方法用的是同一个锁</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 8锁,就是关于锁的8个问题</span></span><br><span class="line"><span class="comment"> * 1. 标准情况下是先发短信还是打电话</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       <span class="type">Phone</span> <span class="variable">phone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; phone.sendSms(), <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; phone.call(), <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Phone</span> &#123;</span><br><span class="line">    <span class="comment">// synchronized 锁的对象是方法的调用者</span></span><br><span class="line">    <span class="comment">// 两个方法用的是同一个锁, 谁先拿到谁先执行</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendSms</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;sendSms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;call&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-2-一对象，两同步，延迟4s"><a href="#5-2-一对象，两同步，延迟4s" class="headerlink" title="5.2 一对象，两同步，延迟4s"></a>5.2 一对象，两同步，延迟4s</h3><blockquote>
<p><strong>同一个对象，两个同步方法</strong></p>
</blockquote>
<ul>
<li><strong>问题：</strong> 如果 <code>sendSms</code> 方法延迟 4 秒，哪个先执行？</li>
<li><strong>结论：</strong> 还是先发短信，再打电话，因为<strong>两个方法用的是同一个锁</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Phone</span> &#123;</span><br><span class="line">    <span class="comment">// 同步实例方法，锁的对象是调用者</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendSms</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">4</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;sendSms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;call&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Phone</span> <span class="variable">phone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; phone.sendSms(), <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; phone.call(), <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-3-一对象，一同步，一普通"><a href="#5-3-一对象，一同步，一普通" class="headerlink" title="5.3 一对象，一同步，一普通"></a>5.3 一对象，一同步，一普通</h3><blockquote>
<p><strong>同一个对象，一个同步方法，一个普通方法</strong></p>
</blockquote>
<ul>
<li><p><strong>问题：</strong> 如果<strong>增加一个普通方法</strong> <code>hello</code>，是先执行发短信还是 hello？</p>
</li>
<li><p><strong>结论：</strong> 先执行 <code>hello</code>，再执行发短信，因为<strong>普通方法没有锁，不受同步方法的影响</strong></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Phone2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendSms</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">4</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;sendSms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;call&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 普通方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Phone2</span> <span class="variable">phone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone2</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; phone.sendSms(), <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; phone.hello(), <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-4-两对象，两同步"><a href="#5-4-两对象，两同步" class="headerlink" title="5.4 两对象，两同步"></a>5.4 两对象，两同步</h3><blockquote>
<p><strong>两个对象，两个同步方法</strong></p>
</blockquote>
<ul>
<li><strong>问题：</strong> 两个不同的对象，分别调用同步方法 <code>call</code> 和 <code>sendSms</code>，哪个先执行？</li>
<li><strong>结论：</strong> 先打电话，再发短信，因为<strong>两个不同的对象对应不同的锁</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Phone2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendSms</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">4</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;sendSms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;call&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Phone2</span> <span class="variable">phone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone2</span>();</span><br><span class="line">        <span class="type">Phone2</span> <span class="variable">phone2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone2</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; phone.sendSms(), <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; phone2.call(), <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-5-一对象，两静态同步"><a href="#5-5-一对象，两静态同步" class="headerlink" title="5.5 一对象，两静态同步"></a>5.5 一对象，两静态同步</h3><blockquote>
<p><strong>一个对象，两个静态同步方法</strong></p>
</blockquote>
<ul>
<li><strong>问题：</strong> 如果修改为两个静态同步方法，哪个先执行？</li>
<li><strong>结论：</strong> 先发短信，再打电话，因为<strong>两个方法用的是同一个锁，即 <code>Class</code> 对象</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Phone3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendSms</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">4</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;sendSms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;call&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Phone3</span> <span class="variable">phone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone3</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; phone.sendSms(), <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; phone.call(), <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-6-两对象，两静态同步"><a href="#5-6-两对象，两静态同步" class="headerlink" title="5.6 两对象，两静态同步"></a>5.6 两对象，两静态同步</h3><blockquote>
<p><strong>两个对象，两个静态同步方法</strong></p>
</blockquote>
<ul>
<li><strong>问题：</strong> 两个不同的对象，分别调用静态同步方法 <code>sendSms</code> 和 <code>call</code>，哪个先执行？</li>
<li><strong>结论：</strong>先发短信，再打电话，因为<strong>静态方法锁的是 <code>Class</code> 对象，两个对象共享一个 <code>Class</code> 锁</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Phone3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendSms</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">4</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;sendSms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;call&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Phone3</span> <span class="variable">phone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone3</span>();</span><br><span class="line">        <span class="type">Phone3</span> <span class="variable">phone2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone3</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; phone.sendSms(), <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; phone2.call(), <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-7-一对象，一同步，一静态同步"><a href="#5-7-一对象，一同步，一静态同步" class="headerlink" title="5.7 一对象，一同步，一静态同步"></a>5.7 一对象，一同步，一静态同步</h3><blockquote>
<p><strong>一个对象，一个静态同步方法，一个普通同步方法</strong></p>
</blockquote>
<ul>
<li><strong>问题：</strong> 同一个对象上调用静态同步方法 <code>sendSms</code> 和普通同步方法 <code>call</code>，哪个先执行？</li>
<li><strong>结论：</strong> 先打电话，再发短信，因为<strong>静态同步方法和普通同步方法锁定的是不同的对象，一个是 <code>Class</code> 对象，一个是实例对象</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Phone4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendSms</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">4</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;sendSms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;call&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Phone4</span> <span class="variable">phone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone4</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; phone.sendSms(), <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; phone.call(), <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-8-两对象，一同步，一静态同步"><a href="#5-8-两对象，一同步，一静态同步" class="headerlink" title="5.8 两对象，一同步，一静态同步"></a>5.8 两对象，一同步，一静态同步</h3><blockquote>
<p><strong>两个对象，一个静态同步方法，一个普通的同步方法</strong></p>
</blockquote>
<ul>
<li><strong>问题：</strong> 两个不同的对象，分别调用静态同步方法 <code>sendSms</code> 和普通同步方法 <code>call</code>，哪个先执行？</li>
<li><strong>结论：</strong> 还是先打电话，再发短信，因为<strong>静态同步方法和普通同步方法锁定的是不同的对象，一个是 <code>Class</code> 对象，一个是实例对象</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Phone4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendSms</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">4</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;sendSms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;call&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Phone4</span> <span class="variable">phone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone4</span>();</span><br><span class="line">        <span class="type">Phone4</span> <span class="variable">phone2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone4</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; phone.sendSms(), <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; phone2.call(), <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-线程不安全的集合类"><a href="#6-线程不安全的集合类" class="headerlink" title="6. 线程不安全的集合类"></a>6. 线程不安全的集合类</h2><h3 id="6-1-List"><a href="#6-1-List" class="headerlink" title="6.1 List"></a>6.1 List</h3><ul>
<li><strong>并发修改异常：</strong> <code>ArrayList</code> 在多线程并发修改下不安全，可能会导致 <strong><code>ConcurrentModificationException</code></strong></li>
<li><strong>解决方案</strong>：<ul>
<li><strong>使用 <code>Vector</code>：</strong><ul>
<li><code>Vector</code> 是早期集合框架的一部分，实现了线程安全</li>
<li>内部方法大多通过 <code>synchronized</code> 关键字同步，但性能较低</li>
</ul>
</li>
<li><strong>使用 <code>Collections.synchronizedList</code>：</strong><ul>
<li>提供线程安全的 <code>List</code> 封装</li>
<li>通过<strong>内部的同步代码块</strong>实现安全性</li>
</ul>
</li>
<li><strong>使用 <code>CopyOnWriteArrayList</code>：</strong>写入时复制！ <strong>COW 计算机程序设计领域的一种优化策略</strong><ul>
<li>高效的线程安全 <code>List</code> 实现</li>
<li><strong>读写分离，写操作时复制整个底层数组，写入效率较低但读取效率高</strong><ul>
<li><strong>写操作</strong>：<ul>
<li>每次写操作都会复制整个数组，保证写入操作的原子性</li>
<li>使用 <code>ReentrantLock</code> 锁实现线程安全</li>
</ul>
</li>
<li><strong>读操作</strong>：<ul>
<li>读取操作不加锁，使用数组副本提供一致性读</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CopyOnWriteArrayList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * java.util.ConcurrentModificationException 并发修改异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 并发下 ArrayList 不安全的</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 解决方案：</span></span><br><span class="line"><span class="comment">         * 1、List&lt;String&gt; list = new Vector&lt;&gt;();</span></span><br><span class="line"><span class="comment">         * 2、List&lt;String&gt; list = Collections.synchronizedList(new ArrayList&lt;&gt;());</span></span><br><span class="line"><span class="comment">         * 3、List&lt;String&gt; list = new CopyOnWriteArrayList&lt;&gt;();</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// CopyOnWrite 写入时复制 COW 计算机程序设计领域的一种优化策略</span></span><br><span class="line">        <span class="comment">// 多个线程调用的时候，list，读取的时候固定的，写入（覆盖）</span></span><br><span class="line">        <span class="comment">// 在写入的时候避免覆盖，造成数据问题！</span></span><br><span class="line">        <span class="comment">// 读写分离</span></span><br><span class="line">        <span class="comment">// CopyOnWriteArrayList 比Vector 好在哪里?（看源码）</span></span><br><span class="line">        <span class="comment">// vector底层运用大量的synchronized关键字，而CopyOnWriteArrayList底层运用的是ReentrantLock锁</span></span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">2000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                list.add(UUID.randomUUID().toString().substring(<span class="number">0</span>, <span class="number">5</span>));</span><br><span class="line">                System.out.println(list);</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>性能对比</strong>：</p>
<ul>
<li><strong><code>Vector</code> 性能较低的原因：</strong><ul>
<li>每个方法都使用 <code>synchronized</code> 关键字锁定整个对象，导致锁争用严重，特别是在多线程环境下。</li>
<li>无论读写操作，均需获取锁，降低了并发性能。</li>
</ul>
</li>
<li><strong><code>Collections.synchronizedList</code>：</strong><ul>
<li>使用独立的锁对象，避免锁定整个 <code>List</code> 对象。</li>
<li>提供线程安全的 <code>List</code> 封装，通过内部的同步代码块实现安全性。</li>
</ul>
</li>
</ul>
<blockquote>
<p><code>Vector</code> 与 <code>Collections.synchronizedList</code> 在性能上差异较小，因为都使用 <code>synchronized</code> 关键字同步</p>
</blockquote>
<ul>
<li><strong><code>CopyOnWriteArrayList</code> 性能较高的原因：</strong><ul>
<li>读写分离，读操作无需加锁，写操作时使用 <code>ReentrantLock</code> 锁实现线程安全。</li>
<li>适用于读多写少的场景，提高了读取性能。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="6-2-Set"><a href="#6-2-Set" class="headerlink" title="6.2 Set"></a>6.2 Set</h3><ul>
<li><strong>HashSet 的底层就是 HashMap</strong>，都是线程不安全的，也就是在在多线程环境下可能会出现 <code>ConcurrentModificationException</code> 或数据丢失等问题</li>
<li><strong>解决方案</strong>：<ul>
<li><strong><code>Collections.synchronizedSet</code>：</strong><ul>
<li>使用 <code>Collections</code> 工具类提供线程安全封装</li>
<li>通过内部的同步代码块保证线程安全</li>
</ul>
</li>
<li><strong><code>CopyOnWriteArraySet</code>：</strong><ul>
<li>基于 <code>CopyOnWriteArrayList</code> 实现的线程安全 <code>Set</code></li>
<li>读写分离，读操作无需加锁，写操作复制底层数组</li>
<li>适用于读多写少的场景</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CopyOnWriteArraySet;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 同理可证：ConcurrentModificationException</span></span><br><span class="line"><span class="comment"> * 1、Set&lt;String&gt; set = Collections.synchronizedSet(new HashSet&lt;&gt;());</span></span><br><span class="line"><span class="comment"> * 2、Set&lt;String&gt; set = new CopyOnWriteArraySet&lt;&gt;();</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SetTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//        Set&lt;String&gt; set = Collections.synchronizedSet(new HashSet&lt;&gt;());</span></span><br><span class="line">        <span class="comment">//        Set&lt;String&gt; set = new CopyOnWriteArraySet&lt;&gt;();</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">30</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                set.add(UUID.randomUUID().toString().substring(<span class="number">0</span>, <span class="number">5</span>));</span><br><span class="line">                System.out.println(set);</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-3-Map"><a href="#6-3-Map" class="headerlink" title="6.3 Map"></a>6.3 Map</h3><ul>
<li><code>HashMap</code> 是线程不安全的</li>
<li><strong>解决方案</strong>：<ul>
<li><strong><code>Hashtable</code>：</strong><ul>
<li>早期集合框架中的线程安全 <code>Map</code> 实现</li>
<li>内部通过 <code>synchronized</code> 关键字同步</li>
<li>性能较低，因为所有方法都需要获取锁</li>
</ul>
</li>
<li><strong><code>Collections.synchronizedMap</code>：</strong><ul>
<li>使用 <code>Collections</code> 工具类提供线程安全封装</li>
<li>内部通过同步代码块实现线程安全</li>
</ul>
</li>
<li><strong><code>ConcurrentHashMap</code>：</strong><ul>
<li>JUC 包中提供的高效线程安全 <code>Map</code> 实现</li>
<li>使用<strong>分段锁定技术</strong>，允许更高的并发度</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 使用 ConcurrentHashMap</span></span><br><span class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">30</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                map.put(Thread.currentThread().getName(), UUID.randomUUID().toString().substring(<span class="number">0</span>, <span class="number">5</span>));</span><br><span class="line">                System.out.println(map);</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-4-总结"><a href="#6-4-总结" class="headerlink" title="6.4 总结"></a>6.4 总结</h3><ul>
<li><strong>线程安全集合的选择：</strong><ul>
<li><strong><code>List</code>：</strong> <code>Collections.synchronizedList</code>, <code>CopyOnWriteArrayList</code></li>
<li><strong><code>Set</code>：</strong> <code>Collections.synchronizedSet</code>, <code>CopyOnWriteArraySet</code></li>
<li><strong><code>Map</code>：</strong> <code>Collections.synchronizedMap</code>, <code>ConcurrentHashMap</code></li>
</ul>
</li>
<li><strong>线程安全集合框架对比：</strong></li>
</ul>
<table>
<thead>
<tr>
<th>集合类型</th>
<th>线程安全性</th>
<th>锁机制</th>
<th>读操作性能</th>
<th>写操作性能</th>
</tr>
</thead>
<tbody><tr>
<td><code>ArrayList</code></td>
<td>线程不安全</td>
<td>无</td>
<td>高</td>
<td>高</td>
</tr>
<tr>
<td><code>Vector</code></td>
<td>线程安全</td>
<td><code>synchronized</code>同步方法</td>
<td>低</td>
<td>低</td>
</tr>
<tr>
<td><code>Collections.synchronizedList</code></td>
<td>线程安全</td>
<td><code>synchronized</code>同步代码块</td>
<td>低</td>
<td>低</td>
</tr>
<tr>
<td><code>CopyOnWriteArrayList</code></td>
<td>线程安全</td>
<td><code>ReentrantLock</code></td>
<td>高</td>
<td>中（复制成本）</td>
</tr>
<tr>
<td><code>HashSet</code></td>
<td>线程不安全</td>
<td>无</td>
<td>高</td>
<td>高</td>
</tr>
<tr>
<td><code>Collections.synchronizedSet</code></td>
<td>线程安全</td>
<td><code>synchronized</code></td>
<td>低</td>
<td>低</td>
</tr>
<tr>
<td><code>CopyOnWriteArraySet</code></td>
<td>线程安全</td>
<td><code>ReentrantLock</code></td>
<td>高</td>
<td>中（复制成本）</td>
</tr>
<tr>
<td><code>HashMap</code></td>
<td>线程不安全</td>
<td>无</td>
<td>高</td>
<td>高</td>
</tr>
<tr>
<td><code>Hashtable</code></td>
<td>线程安全</td>
<td><code>synchronized</code></td>
<td>低</td>
<td>低</td>
</tr>
<tr>
<td><code>Collections.synchronizedMap</code></td>
<td>线程安全</td>
<td><code>synchronized</code></td>
<td>低</td>
<td>低</td>
</tr>
<tr>
<td><code>ConcurrentHashMap</code></td>
<td>线程安全</td>
<td>分段锁定（<code>ReentrantLock</code>）</td>
<td>高</td>
<td>高</td>
</tr>
</tbody></table>
<h2 id="7-Callable-接口"><a href="#7-Callable-接口" class="headerlink" title="7. Callable 接口"></a>7. Callable 接口</h2><ul>
<li><p>类似 Runnable 接口，但 Callable 接口：</p>
<ul>
<li><p><strong>可以有返回值，可以抛出异常</strong></p>
</li>
<li><p>重写的方法不同，Runnable 是 run()，而 <strong>Callable 是 call()</strong></p>
</li>
</ul>
</li>
<li><p><strong>如何启动 Callable？</strong> </p>
<ul>
<li><strong><code>FutureTask</code> 接受一个 <code>Callable</code> 实现，作为适配器，使其可以作为 <code>Runnable</code> 传递给 <code>Thread</code> 构造器</strong></li>
<li><strong>原理</strong>：<code>FutureTask</code> 实现了 <code>Runnable</code> 接口的子接口<code>RunnableFuture</code>，<code>FutureTask</code> 有一个带 <code>Callable</code> 类型参数的构造器，所以 <code>FutureTask</code> 可以作为 <code>Runnable</code> 接口的实现类传到 <code>Thread</code> 的构造器中</li>
</ul>
</li>
<li><p><strong>结果缓存机制</strong>：</p>
<ul>
<li><code>FutureTask</code> 通过内部<strong>状态 <code>state</code> 管理</strong>任务的执行和结果缓存，共有 5 种状态：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> state;</span><br><span class="line"><span class="comment">// NEW: 初始状态，任务未启动</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">NEW</span>          <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">// COMPLETING: 任务正在完成中</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">COMPLETING</span>   <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="comment">// NORMAL: 任务成功完成</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">NORMAL</span>       <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"><span class="comment">// EXCEPTIONAL: 任务抛出了异常</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">EXCEPTIONAL</span>  <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"><span class="comment">// CANCELLED: 任务被取消</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CANCELLED</span>    <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line"><span class="comment">// INTERRUPTING/INTERRUPTED: 任务正在被中断</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">INTERRUPTING</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">INTERRUPTED</span>  <span class="operator">=</span> <span class="number">6</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>源码分析</strong>：<ul>
<li><code>FutureTask</code> 的 <code>run()</code> 方法负责执行 <code>Callable</code>，并在执行后保存结果</li>
<li>只有当 <code>state</code> 为 <code>NEW</code> 时才会执行任务，否则直接返回</li>
<li>执行过程中会将 <code>state</code> 更新为 <code>COMPLETING</code>，然后再更新为 <code>NORMAL</code> 或 <code>EXCEPTIONAL</code></li>
</ul>
</li>
<li>当一个 <code>Callable</code> 被 <code>FutureTask</code> 包装后，任务执行后会缓存其结果，避免重复执行</li>
</ul>
</li>
<li><p><strong><code>FutureTask</code> 线程安全机制：</strong></p>
<ul>
<li><strong>CAS：</strong> 使用 <code>Unsafe</code> 类的 CAS 操作保证状态变更的原子性</li>
<li><strong>锁：</strong> 使用 <code>ReentrantLock</code> 锁控制任务执行和结果获取的同步</li>
</ul>
</li>
<li><p><strong>阻塞调用：</strong></p>
<ul>
<li><code>get()</code> 方法会阻塞等待任务完成，如果任务已经完成，则直接返回结果（缓存机制）</li>
<li>可以使用异步方式获取结果，例如结合 <code>ExecutorService</code></li>
</ul>
</li>
<li><p><strong>代码示例</strong>：为什么结果只打印出了一个 call() ?</p>
<ul>
<li><strong>线程 A：</strong><ul>
<li>首次启动 <code>Thread</code>，执行 <code>futureTask.run()</code></li>
<li><code>state</code> 为 <code>NEW</code>，成功进入执行逻辑</li>
<li>执行 <code>call()</code> 方法，打印 “call()” 并返回结果</li>
<li>更新 <code>state</code> 为 <code>NORMAL</code>，缓存结果</li>
</ul>
</li>
<li><strong>线程 B：</strong><ul>
<li>启动 <code>Thread</code>，再次执行 <code>futureTask.run()</code></li>
<li><strong><code>state</code> 已经是 <code>NORMAL</code>（或其他非 <code>NEW</code> 状态），直接返回</strong></li>
<li>任务没有被再次执行</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CallableTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        <span class="type">FutureTask</span> <span class="variable">futureTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FutureTask</span>(thread);<span class="comment">// 适配类</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask,<span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask,<span class="string">&quot;B&quot;</span>).start();  <span class="comment">//结果会被缓存，效率高</span></span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">o</span> <span class="operator">=</span> (String)futureTask.get();  <span class="comment">//获取Callable的返回结果; 这个get方法可能会产生阻塞！把它放在最后</span></span><br><span class="line">        <span class="comment">// FutureTask.get()是一个阻塞调用，它会等待直到任务完成才能返回结果。这就是为什么在多线程编程中，我们通常使用FutureTask或者类似的任务，以便在后台线程上执行长时间运行的任务，而不会阻塞主线程。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//或者使用异步通信来处理！</span></span><br><span class="line">        System.out.println(o);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;call()&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;fsaf&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果希望两个线程都能执行 <code>call()</code>，需要为每个线程创建独立的 <code>FutureTask</code> 实例：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FutureTask&lt;String&gt; futureTask1 = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(thread);</span><br><span class="line">FutureTask&lt;String&gt; futureTask2 = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(thread);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask1, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask2, <span class="string">&quot;B&quot;</span>).start();</span><br></pre></td></tr></table></figure>

<h2 id="8-常用的辅助类"><a href="#8-常用的辅助类" class="headerlink" title="8. 常用的辅助类"></a>8. 常用的辅助类</h2><h3 id="8-1-CountDownLatch"><a href="#8-1-CountDownLatch" class="headerlink" title="8.1 CountDownLatch"></a>8.1 CountDownLatch</h3><blockquote>
<p>组团插队</p>
</blockquote>
<ul>
<li><strong>作用</strong>：允许一组线程等待另一组线程完成特定任务之后再继续执行，可以用于线程之间的协调和同步<ul>
<li>可以看作一个减法计数器，当计数器归零时，所有等待的线程被唤醒</li>
</ul>
</li>
<li><strong>主要方法</strong><ul>
<li><code>countDown()</code>：<ul>
<li>将计数器减 1</li>
<li>当计数器变为 0 时，所有阻塞在 <code>await()</code> 方法的线程将被唤醒</li>
</ul>
</li>
<li><code>await()</code>：使当前线程阻塞，直到计数器归零就唤醒，再继续向下运行</li>
</ul>
</li>
<li><strong>使用限制：</strong><ul>
<li><strong>一次性工具：</strong> 不能复用</li>
<li><strong>计数器不可重置：</strong> 每次需要新的 <code>CountDownLatch</code> 实例</li>
</ul>
</li>
<li><strong>代码示例</strong>：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例：计数器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CountDownLatchDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 初始化计数器，总数为 6</span></span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建并启动 6 个线程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">6</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; Go out&quot;</span>);</span><br><span class="line">                countDownLatch.countDown(); <span class="comment">// 计数器减 1</span></span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待计数器归零，然后继续执行</span></span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        System.out.println(<span class="string">&quot;Close Door&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>工作原理</strong>：<ul>
<li><strong>计数器初始化：</strong> 在创建 <code>CountDownLatch</code> 对象时，指定计数器的初始值（如 <code>new CountDownLatch(6)</code>）</li>
<li><strong>任务线程执行：</strong> 每个线程执行任务后调用 <code>countDown()</code>，使计数器减 1</li>
<li><strong>等待线程阻塞：</strong> 调用 <code>await()</code> 的线程进入阻塞状态，等待计数器归零</li>
<li><strong>计数器归零：</strong> 当所有任务线程执行完毕（即计数器减为 0），所有等待线程被唤醒，继续执行后续代码</li>
</ul>
</li>
</ul>
<h3 id="8-2-CyclicBarrier"><a href="#8-2-CyclicBarrier" class="headerlink" title="8.2 CyclicBarrier"></a>8.2 CyclicBarrier</h3><ul>
<li><p>允许一组线程彼此等待，直到所有线程都到达某个公共屏障点。与 <code>CountDownLatch</code> 不同的是，它是一种<strong>可重用的屏障机制</strong></p>
</li>
<li><p><strong>主要特性：</strong></p>
<ul>
<li><strong>加法计数器：</strong> 指定线程数的栅栏点，只有所有线程都达到该点后才会继续执行</li>
<li><strong>可重用：</strong> 计数器归零后可以重新使用，不同于 <code>CountDownLatch</code> 的一次性计数器</li>
<li><strong>公共屏障点：</strong> 可以在所有线程到达屏障点后执行特定任务</li>
</ul>
</li>
<li><p><strong>主要方法：</strong></p>
<ul>
<li><strong><code>await()</code>：</strong><ul>
<li>使当前线程等待，直到所有线程都调用 <code>await()</code> 并达到屏障点</li>
<li>当所有线程都调用该方法时，将执行可选的 <code>barrierAction</code></li>
</ul>
</li>
<li><strong><code>getNumberWaiting()</code>：</strong><ul>
<li>返回当前等待屏障点的线程数</li>
</ul>
</li>
<li><strong><code>isBroken()</code>：</strong><ul>
<li>返回屏障是否被打破</li>
<li>若某个线程在等待时被中断或超时，屏障被打破，所有等待线程抛出 <code>BrokenBarrierException</code></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>应用场景：</strong></p>
<ul>
<li><strong>并行任务协调：</strong> 等待一组线程都到达某个屏障点再继续执行</li>
<li><strong>分阶段执行：</strong> 分批次执行多线程任务</li>
</ul>
</li>
<li><p><strong>源码分析</strong>：</p>
<ul>
<li><strong>构造方法：</strong>初始化计数器和可选的屏障动作</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">CyclicBarrier</span><span class="params">(<span class="type">int</span> parties, Runnable barrierAction)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (parties &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    <span class="built_in">this</span>.parties = parties;</span><br><span class="line">    <span class="built_in">this</span>.count = parties;</span><br><span class="line">    <span class="built_in">this</span>.barrierCommand = barrierAction;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong><code>await()</code> 方法：</strong><ul>
<li>调用 <code>dowait()</code> 方法等待</li>
<li>计数器减 1，当减到 0 时，执行屏障动作并重置计数器</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dowait</span><span class="params">(<span class="type">boolean</span> timed, <span class="type">long</span> nanos)</span></span><br><span class="line">    <span class="keyword">throws</span> InterruptedException, BrokenBarrierException, TimeoutException &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> --count;</span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">0</span>) &#123; </span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>代码示例</strong>：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CyclicBarrierDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个屏障点，指定 7 个线程，并在最后一个线程到达后执行召唤神龙的任务</span></span><br><span class="line">        <span class="type">CyclicBarrier</span> <span class="variable">cyclicBarrier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(<span class="number">7</span>, () -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;召唤神龙成功！&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建并启动 7 个线程，模拟收集 7 颗龙珠的过程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">7</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 收集第 &quot;</span> + temp + <span class="string">&quot; 颗龙珠&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    cyclicBarrier.await(); <span class="comment">// 等待其他线程到达屏障点</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>工作原理：</strong><ul>
<li><strong>计数器初始化：</strong> 创建 <code>CyclicBarrier</code> 时，指定需要互相等待的线程数（<code>parties</code>）</li>
<li><strong>线程等待：</strong> 每个线程调用 <code>await()</code> 方法，计数器减 1，并阻塞等待</li>
<li><strong>屏障点到达</strong>： 当计数器减到 0 时：<ul>
<li>执行可选的 <code>barrierAction</code>。</li>
<li>唤醒所有等待线程。</li>
<li>重置计数器，以便屏障重新使用。</li>
</ul>
</li>
<li><strong>屏障被打破</strong>： 当等待的线程被中断或超时：<ul>
<li>抛出 <code>BrokenBarrierException</code>。</li>
<li>屏障被打破，所有等待线程不再阻塞。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="8-3-Semaphore"><a href="#8-3-Semaphore" class="headerlink" title="8.3 Semaphore"></a>8.3 Semaphore</h3><ul>
<li>一种信号量实现，用于<strong>控制对共享资源的访问</strong><ul>
<li>信号量维护了一个计数器，计数器的值表示当前可用的资源数</li>
<li>线程可以<strong>通过信号量获取或释放资源，从而控制同时访问共享资源的线程数量</strong></li>
</ul>
</li>
<li><strong>主要方法：</strong><ul>
<li><strong><code>acquire()</code>：</strong><ul>
<li>获取一个许可，如果没有可用许可，则阻塞等待</li>
<li>可重载为 <code>acquire(int permits)</code> 来获取多个许可</li>
</ul>
</li>
<li><strong><code>release()</code>：</strong><ul>
<li>释放一个许可，增加可用许可的数量</li>
<li>可重载为 <code>release(int permits)</code> 来释放多个许可</li>
</ul>
</li>
</ul>
</li>
<li><strong>构造方法：</strong><ul>
<li><code>Semaphore(int permits)</code>：构造一个具有指定许可数量的信号量</li>
<li><code>Semaphore(int permits, boolean fair)</code>：构造一个具有指定许可数量的信号量，并指定公平性<ul>
<li><code>fair</code> 为 <code>true</code> 时，实现公平性，按照线程的等待顺序分配许可</li>
</ul>
</li>
</ul>
</li>
<li><strong>应用场景</strong>：<ul>
<li><strong>限流控制：</strong> 控制同时访问的线程数量，类似于限制并发访问的连接池（如：限制 Web 服务的最大并发请求数）</li>
<li><strong>资源互斥：</strong> 访问资源时确保互斥性，类似于互斥锁的实现</li>
<li><strong>多线程协作：</strong> 控制任务的执行顺序，实现多个线程间的协调</li>
</ul>
</li>
<li><strong>代码示例</strong>：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SemaphoreDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个具有 3 个许可的信号量</span></span><br><span class="line">        <span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模拟 6 辆车争抢 3 个停车位</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">6</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 获取一个停车位</span></span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 抢到车位&quot;</span>);</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 离开车位&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// 释放停车位</span></span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="string">&quot;车&quot;</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>工作原理：</strong><ul>
<li><strong>信号量初始化：</strong><ul>
<li>创建 <code>Semaphore</code> 对象时，指定初始的许可数量（<code>permits</code>）</li>
<li>内部通过 AQS（<code>AbstractQueuedSynchronizer</code>）的状态来维护许可数量</li>
</ul>
</li>
<li><strong>获取资源：</strong><code>acquire()</code><ul>
<li>如果可用资源大于 0，则直接减 1 并返回</li>
<li>否则，当前线程进入等待队列，<strong>阻塞等待资源释放</strong></li>
</ul>
</li>
<li><strong>释放资源：</strong><code>release()</code><ul>
<li>增加可用资源数量，<strong>唤醒等待队列中的第一个线程</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="9-读写锁-ReadWriteLock"><a href="#9-读写锁-ReadWriteLock" class="headerlink" title="9. 读写锁 ReadWriteLock"></a>9. 读写锁 ReadWriteLock</h2><h3 id="9-1-概述"><a href="#9-1-概述" class="headerlink" title="9.1 概述"></a>9.1 概述</h3><ul>
<li><p><code>ReadWriteLock</code> 是 JUC 中的一种高级锁，实现了读写锁机制</p>
<ul>
<li><code>ReentrantReadWriteLock</code> 是 <code>ReadWriteLock</code> 接口的实现类，包含<strong>内部类</strong> <code>ReadLock</code> 和 <code>WriteLock</code></li>
<li><code>ReadLock</code> 和 <code>WriteLock</code> 实现了 <code>Lock</code> 接口</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReentrantReadWriteLock</span> <span class="keyword">implements</span> <span class="title class_">ReadWriteLock</span>, java.io.Serializable &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ReadLock</span> <span class="keyword">implements</span> <span class="title class_">Lock</span>, java.io.Serializable &#123;  <span class="comment">// 读锁</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">WriteLock</span> <span class="keyword">implements</span> <span class="title class_">Lock</span>, java.io.Serializable &#123;  <span class="comment">// 写锁</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="9-2-读写锁特点"><a href="#9-2-读写锁特点" class="headerlink" title="9.2 读写锁特点"></a>9.2 读写锁特点</h3><ul>
<li><p><strong>读锁与写锁的互斥关系</strong>：</p>
<ul>
<li><strong>共享锁（读锁）：</strong> 多个线程可以同时持有读锁</li>
<li><strong>独占锁（写锁）：</strong> 只能有一个线程持有写锁</li>
</ul>
</li>
<li><p><strong>读写锁特点：</strong></p>
<ul>
<li><strong>读-读共存：</strong> 允许多个线程同时读取数据</li>
<li><strong>读-写互斥：</strong> 读操作和写操作不能同时进行(保证读操作读取到一致的已提交数据)</li>
<li><strong>写-写互斥：</strong> 只允许一个线程执行写操作</li>
</ul>
</li>
<li><p><strong>读写锁的作用：</strong></p>
<ul>
<li><p>提高多线程环境下读操作的并发性，适用于读多写少的场景</p>
</li>
<li><p>提供锁降级机制，实现数据一致性和性能的平衡</p>
</li>
</ul>
</li>
<li><p><strong>与其他锁的对比：</strong></p>
<ul>
<li><strong><code>synchronized</code>：</strong> 独占锁，每次只能一个线程访问</li>
<li><strong><code>ReentrantLock</code>：</strong> 独占锁，具备可重入性和公平性</li>
<li><strong><code>ReentrantReadWriteLock</code>：</strong> 读写锁，读读共享、读写互斥</li>
</ul>
</li>
<li><p><strong>应用场景：</strong>适用于读多写少的场景，提高读操作并发性</p>
<ul>
<li>如：缓存系统、配置中心</li>
</ul>
</li>
<li><p><strong>代码示例</strong>：使用读写锁的缓存实现</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyCacheLock</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Map&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">ReadWriteLock</span> <span class="variable">rwLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(String key, Object value)</span> &#123;</span><br><span class="line">        rwLock.writeLock().lock(); <span class="comment">// 加写锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 写入 &quot;</span> + value);</span><br><span class="line">            map.put(key, value);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 写入成功&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            rwLock.writeLock().unlock(); <span class="comment">// 释放写锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">get</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        rwLock.readLock().lock(); <span class="comment">// 加读锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 读取 &quot;</span> + key);</span><br><span class="line">            <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 读取成功&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            rwLock.readLock().unlock(); <span class="comment">// 释放读锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-3-锁降级"><a href="#9-3-锁降级" class="headerlink" title="9.3 锁降级"></a>9.3 锁降级</h3><ul>
<li><strong>读写锁的锁降级：</strong>指将持有的写锁降级为读锁，在持有写锁的情况下获取读锁，然后释放写锁的过程<ul>
<li><strong>作用</strong>：在一边读一边写的情况下提高性能<ul>
<li>确保数据的一致性和可见性</li>
</ul>
</li>
<li><strong>锁降级和不降级的区别</strong>：<ul>
<li><strong>降级步骤</strong>：<strong>获取写锁 &#x3D;&gt; 获取读锁 &#x3D;&gt; 释放写锁 &#x3D;&gt; 持有读锁，确保数据一致性</strong><ul>
<li>保证数据的可见性，<strong>在释放写锁后继续保持读锁</strong>，确保在写锁被释放后，其他线程不能立即获取写锁修改数据（写了之后读完了别人才能写）</li>
<li>降低锁的竞争，<strong>提高读操作的并发性</strong></li>
</ul>
</li>
<li><strong>不降级步骤</strong>：获取写锁 &#x3D;&gt; 释放写锁 &#x3D;&gt; 获取读锁 &#x3D;&gt; 释放读锁<ul>
<li>直接释放写锁并获取读锁，可能存在数据被其他写操作修改的风险</li>
<li>在高并发场景中，可能会出现读到不一致的数据，降低数据的一致性</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyCacheWithLockDowngrade</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Map&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReadWriteLock</span> <span class="variable">rwLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入操作，带锁降级</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(String key, Object value)</span> &#123;</span><br><span class="line">        rwLock.writeLock().lock(); <span class="comment">// 获取写锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 写入 &quot;</span> + value);</span><br><span class="line">            map.put(key, value);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 写入成功&quot;</span>);</span><br><span class="line"></span><br><span class="line">            rwLock.readLock().lock(); <span class="comment">// 锁降级</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            rwLock.writeLock().unlock(); <span class="comment">// 释放写锁</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 读取 &quot;</span> + key + <span class="string">&quot; after write&quot;</span>);</span><br><span class="line">            <span class="type">Object</span> <span class="variable">readValue</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 读取成功: &quot;</span> + readValue);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            rwLock.readLock().unlock(); <span class="comment">// 释放读锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">get</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        rwLock.readLock().lock(); <span class="comment">// 获取读锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 读取 &quot;</span> + key);</span><br><span class="line">            <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 读取成功: &quot;</span> + o);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            rwLock.readLock().unlock(); <span class="comment">// 释放读锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="10-阻塞队列"><a href="#10-阻塞队列" class="headerlink" title="10. 阻塞队列"></a>10. 阻塞队列</h2><h3 id="10-1-基本介绍"><a href="#10-1-基本介绍" class="headerlink" title="10.1 基本介绍"></a>10.1 基本介绍</h3><ul>
<li>阻塞队列是 Java 并发包中的一种数据结构，提供了一种线程安全的队列操作方式，具有阻塞特性，即<strong>在队列满或空时，添加或移除元素的操作会被阻塞，直到队列发生变化</strong></li>
<li><strong>继承关系</strong>：<ul>
<li><code>BlockingQueue</code> 接口是 <code>Queue</code> 接口的子接口，位于 <code>java.util.concurrent</code> 包中</li>
<li>阻塞队列的实现类有 <code>ArrayBlockingQueue</code>、<code>LinkedBlockingQueue</code>、<code>SynchronousQueue</code> 等</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B.assets/image-20240511145808363.png" alt="image-20240511145808363"></p>
<ul>
<li><strong>应用场景</strong>：<ul>
<li>多线程并发处理场景：用于生产者-消费者模式等</li>
<li>线程池：用于任务调度和任务队列管理</li>
</ul>
</li>
</ul>
<h3 id="10-2-四组-API"><a href="#10-2-四组-API" class="headerlink" title="10.2 四组 API"></a>10.2 四组 API</h3><ul>
<li>阻塞队列提供了四组 API，分别适用于不同的场景，具体如下：<ul>
<li><strong>抛出异常：</strong> 在操作失败时，抛出异常</li>
<li><strong>不抛出异常，有返回值：</strong> 在操作失败时，返回特定值或标识</li>
<li><strong>阻塞等待：</strong> 在操作失败时，线程会阻塞等待</li>
<li><strong>超时等待：</strong> 在操作失败时，线程会阻塞等待一段时间后返回</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>方式</th>
<th>抛出异常</th>
<th>有返回值,不抛出异常</th>
<th>阻塞等待</th>
<th>超时等待</th>
</tr>
</thead>
<tbody><tr>
<td>添加</td>
<td>add(E e)</td>
<td>offer(E e)</td>
<td>put()</td>
<td>offer(E e, long timeout, TimeUnit unit)</td>
</tr>
<tr>
<td>移除</td>
<td>remove()</td>
<td>poll()</td>
<td>take()</td>
<td>poll(long timeout, TimeUnit unit)</td>
</tr>
<tr>
<td>获取队首元素</td>
<td>element()</td>
<td>peek()</td>
<td>-</td>
<td>-</td>
</tr>
</tbody></table>
<ul>
<li><p><strong>代码测试</strong>：</p>
<ul>
<li><strong>抛出异常</strong>：<code>add()</code> 方法底层调用的 <code>offer()</code> 方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    BlockingQueue&lt;String&gt; blockingQueue = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取队首元素 队首不存抛异常: NoSuchElementException</span></span><br><span class="line">        <span class="comment">// System.out.println(blockingQueue.element()); </span></span><br><span class="line">    System.out.println(blockingQueue.add(<span class="string">&quot;a&quot;</span>));  <span class="comment">// true</span></span><br><span class="line">    System.out.println(blockingQueue.add(<span class="string">&quot;b&quot;</span>));  <span class="comment">// true</span></span><br><span class="line">    System.out.println(blockingQueue.add(<span class="string">&quot;c&quot;</span>));  <span class="comment">// true</span></span><br><span class="line">    System.out.println(blockingQueue.element());  <span class="comment">// a 获取队首元素</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 抛出异常: IllegalStateException: Queue full</span></span><br><span class="line">    <span class="comment">// System.out.println(blockingQueue.add(&quot;d&quot;));</span></span><br><span class="line"></span><br><span class="line">    System.out.println(blockingQueue.remove());  <span class="comment">// a</span></span><br><span class="line">    System.out.println(blockingQueue.remove());  <span class="comment">// b</span></span><br><span class="line">    System.out.println(blockingQueue.remove());  <span class="comment">// c</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 抛出异常: NoSuchElementException</span></span><br><span class="line">    <span class="comment">// System.out.println(blockingQueue.remove());</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>不抛出异常</strong>：而是返回特殊值（通常是 <code>false</code> 或 <code>null</code>）<ul>
<li><code>offer()</code> 方法的源码第一句就是判断是否为 null，也就是不能添加 null 值；而 <code>add()</code> 方法底层也是直接调用的 <code>offer()</code> 方法，所以也不可以添加 null 值</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    BlockingQueue&lt;String&gt; blockingQueue = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取队首元素 队首不存在不抛异常</span></span><br><span class="line">    System.out.println(blockingQueue.peek());  <span class="comment">// null</span></span><br><span class="line">    System.out.println(blockingQueue.offer(<span class="string">&quot;a&quot;</span>));  <span class="comment">// true</span></span><br><span class="line">    System.out.println(blockingQueue.offer(<span class="string">&quot;b&quot;</span>));  <span class="comment">// true</span></span><br><span class="line">    System.out.println(blockingQueue.offer(<span class="string">&quot;c&quot;</span>));  <span class="comment">// true</span></span><br><span class="line">    <span class="comment">// 不抛出异常</span></span><br><span class="line">    System.out.println(blockingQueue.offer(<span class="string">&quot;d&quot;</span>));  <span class="comment">// false</span></span><br><span class="line">    System.out.println(blockingQueue.peek());  <span class="comment">// a</span></span><br><span class="line"></span><br><span class="line">    System.out.println(blockingQueue.poll());  <span class="comment">// a</span></span><br><span class="line">    System.out.println(blockingQueue.poll());  <span class="comment">// b</span></span><br><span class="line">    System.out.println(blockingQueue.poll());  <span class="comment">// c</span></span><br><span class="line">    <span class="comment">// 不抛出异常</span></span><br><span class="line">    System.out.println(blockingQueue.poll());  <span class="comment">// null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>阻塞等待</strong>：线程在操作不能立即执行时阻塞等待，直到操作可以执行</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    BlockingQueue&lt;String&gt; blockingQueue = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    blockingQueue.put(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">    blockingQueue.put(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">    blockingQueue.put(<span class="string">&quot;c&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此时队列已满, 控制台窗口会一直阻塞等待</span></span><br><span class="line">    <span class="comment">// blockingQueue.put(&quot;d&quot;);</span></span><br><span class="line"></span><br><span class="line">    System.out.println(blockingQueue.take());  <span class="comment">// a</span></span><br><span class="line">    System.out.println(blockingQueue.take());  <span class="comment">// b</span></span><br><span class="line">    System.out.println(blockingQueue.take());  <span class="comment">// c</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此时队列已空, 控制台窗口会一直阻塞等待</span></span><br><span class="line">    <span class="comment">// System.out.println(blockingQueue.take());</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>超时等待</strong>：线程在操作不能立即执行时阻塞等待一定的时间，如果在指定的时间内操作不能执行，则返回特殊值</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    BlockingQueue&lt;String&gt; blockingQueue = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    blockingQueue.offer(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">    blockingQueue.offer(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">    blockingQueue.offer(<span class="string">&quot;c&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试在2秒内添加元素，如果不能添加则放弃</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">status</span> <span class="operator">=</span> blockingQueue.offer(<span class="string">&quot;d&quot;</span>, <span class="number">2</span>, TimeUnit.SECONDS);</span><br><span class="line">    System.out.println(status);  <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">    System.out.println(blockingQueue.poll());  <span class="comment">// a</span></span><br><span class="line">    System.out.println(blockingQueue.poll());  <span class="comment">// b</span></span><br><span class="line">    System.out.println(blockingQueue.poll());  <span class="comment">// c</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试在2秒内取出元素，如果队列空则放弃</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">element</span> <span class="operator">=</span> blockingQueue.poll(<span class="number">2</span>, TimeUnit.SECONDS);</span><br><span class="line">    System.out.println(element);  <span class="comment">// null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="10-3-SynchronousQueue-同步队列"><a href="#10-3-SynchronousQueue-同步队列" class="headerlink" title="10.3 SynchronousQueue 同步队列"></a>10.3 SynchronousQueue 同步队列</h3><ul>
<li><p><code>SynchronousQueue</code> 是阻塞队列的特殊实现(一种无缓冲的等待队列)，没有容量，也可以视为容量为1的队列</p>
<ul>
<li>相对于有缓冲的 BlockingQueue 来说，少了一个中间经销商的环节（缓冲区）</li>
</ul>
</li>
<li><p><strong>特点</strong>：添加一个元素必须等待另一个线程取走，否则一直阻塞</p>
</li>
<li><p><strong>方法</strong>：</p>
<ul>
<li><code>put(E e)</code>：将元素放入队列中。如果没有其他线程正在尝试取走元素，此方法会阻塞</li>
<li><code>take()</code>：取走队列中的元素。如果没有元素可取，此方法会阻塞，使用<strong>Lock 锁保证线程安全</strong></li>
</ul>
</li>
<li><p><strong>公平性选择</strong>：构造 <code>SynchronousQueue</code> 时可以选择公平性。如果设置为公平模式，则线程按照等待时间的长短获得访问权；非公平模式则随机分配</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果输出不一致可能是因为 System.out.println 导致的竞态条件或线程调度问题</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronousQueueDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        BlockingQueue&lt;String&gt; synchronousQueue = <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; Put 1&quot;</span>);</span><br><span class="line">                synchronousQueue.put(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; Put 2&quot;</span>);</span><br><span class="line">                synchronousQueue.put(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; Put 3&quot;</span>);</span><br><span class="line">                synchronousQueue.put(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;T1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; Take &quot;</span> + synchronousQueue.take());</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; Take &quot;</span> + synchronousQueue.take());</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; Take &quot;</span> + synchronousQueue.take());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;T2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="11-线程池-重点"><a href="#11-线程池-重点" class="headerlink" title="11. 线程池(重点)"></a>11. 线程池(重点)</h2><h3 id="11-1-概述"><a href="#11-1-概述" class="headerlink" title="11.1 概述"></a>11.1 概述</h3><ul>
<li><p>线程池是一种<strong>基于池化技术的资源管理工具</strong>，用于有效管理线程资源</p>
</li>
<li><p><strong>线程池的好处</strong>：线程可以复用，可以控制最大并发量，管理线程</p>
<ul>
<li><strong>降低资源消耗</strong>：通过重复利用已创建的线程<strong>降低线程创建和销毁的开销</strong></li>
<li><strong>提高响应速度</strong>：减少了线程创建的时间，改善了程序的响应速度</li>
<li><strong>方便线程管理</strong>：线程池可以统一分配、调优和监控线程</li>
</ul>
</li>
<li><p><strong>Java线程池关键组件</strong></p>
<ul>
<li>Executor 框架：Java 提供的线程池实现框架，包括以下几个关键类：<ul>
<li><code>Executor</code>：负责线程使用和调度的根接口。</li>
<li><code>Executors</code>：工厂类，用于创建不同类型的线程池。</li>
<li><code>ExecutorService</code>：继承自Executor接口，定义了线程池的生命周期管理方法，如启动、关闭、提交任务等。</li>
<li><code>AbstractExecutorService</code>：ExecutorService 接口的抽象实现类，提供了 ExecutorService 的基本实现。  </li>
<li><code>ThreadPoolExecutor</code>：AbstractExecutorService 的具体实现类，提供了创建线程池的完整功能。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B.assets/image-20240511171447844.png" alt="image-20240511171447844"></p>
<ul>
<li>线程池：三大方法,7大参数,4种拒绝策略</li>
</ul>
<h3 id="11-2-三大方法"><a href="#11-2-三大方法" class="headerlink" title="11.2 三大方法"></a>11.2 三大方法</h3><ul>
<li><p><strong>线程池的三种常用创建方式（通过Executors）</strong></p>
<ul>
<li><strong>SingleThreadExecutor</strong>：单个后台线程的线程池</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">singleThreadExecutor</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>FixedThreadPool</strong>：固定大小的线程池</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">fixedThreadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">5</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>CachedThreadPool</strong>：大小不固定的线程池，根据需求自动更改数量</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">cachedThreadPool</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>代码示例</strong>：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Executors 三大方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();<span class="comment">//单个线程</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">threadPool2</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">5</span>); <span class="comment">//创建一个固定的线程池的大小</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">threadPool3</span> <span class="operator">=</span> Executors.newCachedThreadPool(); <span class="comment">//可伸缩的</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 线程池用完必须要关闭线程池</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;=<span class="number">100</span> ; i++) &#123;</span><br><span class="line">                <span class="comment">//通过线程池创建线程</span></span><br><span class="line">                threadPool.execute(()-&gt;&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+ <span class="string">&quot; ok&quot;</span>);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            threadPool.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>注意</strong>：阿里开发规范文档指出 &#x3D;&gt; <strong>线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式</strong>，这样的处理方式让编写人员更加明确线程池的运行规则，同时规避资源耗尽的风险，<strong>Executors 各个方法的弊端</strong>：<ul>
<li><strong>FixedThreadPool</strong> 和 <strong>SingleThreadExecutor</strong>：允许的请求队列长度为 <code>Integer.MAX_VALUE</code>，可能会堆积大量的请求，从而导致 OOM</li>
<li><strong>CachedThreadPool</strong> 和 <strong>ScheduledThreadPool</strong>：允许创建的线程数量为 <code>Integer.MAX_VALUE</code>(约为21亿)，可能会创建大量的线程，从而导致 OOM</li>
</ul>
</li>
</ul>
<h3 id="11-3-七大参数-自定义线程池"><a href="#11-3-七大参数-自定义线程池" class="headerlink" title="11.3 七大参数-自定义线程池"></a>11.3 七大参数-自定义线程池</h3><ul>
<li><strong>Executors 创建方式底层源码分析</strong>：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newSingleThreadExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 核心线程数和最大线程数都为1，即只有一个线程</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FinalizableDelegatedExecutorService</span></span><br><span class="line">        (<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThreads)</span> &#123;</span><br><span class="line">    <span class="comment">// 创建 ThreadPoolExecutor 实例，核心线程数和最大线程数都为指定的线程数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newCachedThreadPool</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 创建 ThreadPoolExecutor 实例，核心线程数为0，最大线程数为 Integer.MAX_VALUE，表示大小不固定</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>本质</strong>：三种方法都是调用的 <strong>ThreadPoolExecutor</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolExecutorAnalysis</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,  // 核心线程池大小</span></span><br><span class="line"><span class="params">                              <span class="type">int</span> maximumPoolSize, // 最大的线程池大小</span></span><br><span class="line"><span class="params">                              <span class="type">long</span> keepAliveTime,  // 超时了没有人调用就会释放</span></span><br><span class="line"><span class="params">                              TimeUnit unit, // 超时单位</span></span><br><span class="line"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue, // 阻塞队列</span></span><br><span class="line"><span class="params">                              ThreadFactory threadFactory, // 线程工厂 创建线程的 一般不用动</span></span><br><span class="line"><span class="params">                              RejectedExecutionHandler handler // 拒绝策略</span></span><br><span class="line"><span class="params">    )</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> || maximumPoolSize &lt;= <span class="number">0</span> || maximumPoolSize &lt; corePoolSize || keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">        <span class="keyword">if</span> (workQueue == <span class="literal">null</span> || threadFactory == <span class="literal">null</span> || handler == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将传入的参数赋值给对应的属性</span></span><br><span class="line">        <span class="built_in">this</span>.corePoolSize = corePoolSize; <span class="comment">// 设置核心线程池大小</span></span><br><span class="line">        <span class="built_in">this</span>.maximumPoolSize = maximumPoolSize; <span class="comment">// 设置最大的线程池大小</span></span><br><span class="line">        <span class="built_in">this</span>.workQueue = workQueue; <span class="comment">// 设置阻塞队列</span></span><br><span class="line">        <span class="built_in">this</span>.keepAliveTime = unit.toNanos(keepAliveTime); <span class="comment">// 设置超时时间</span></span><br><span class="line">        <span class="built_in">this</span>.threadFactory = threadFactory; <span class="comment">// 设置线程工厂</span></span><br><span class="line">        <span class="built_in">this</span>.handler = handler; <span class="comment">// 设置拒绝策略</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>推荐使用底层线程池手动创建方式</strong>：使用 <code>ThreadPoolExecutor</code> 直接构造，这种方式允许自定义参数，更灵活，可以明确线程池的运行规则，避免资源耗尽的风险，<strong>七大参数：</strong><ul>
<li><strong>corePoolSize</strong>：核心线程数，即不被回收的线程数量，除非设置了<code>allowCoreThreadTimeOut</code>。</li>
<li><strong>maximumPoolSize</strong>：最大线程数，能容纳的最大线程数量。</li>
<li><strong>keepAliveTime</strong>：线程空闲后的存活时长。</li>
<li><strong>unit</strong>：时间单位，与 <code>keepAliveTime</code> 配合使用。</li>
<li><strong>workQueue</strong>：任务队列，被提交但未执行的任务。</li>
<li><strong>threadFactory</strong>：线程工厂，用于创建线程。</li>
<li><strong>handler</strong>：拒绝策略，当任务太多来不及处理时，如何拒绝任务。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomThreadPoolExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 自定义线程池，设置核心线程数为2，最大线程数为5，线程空闲时间为3秒，</span></span><br><span class="line">        <span class="comment">// 使用有界队列 LinkedBlockingQueue 容量为3，使用默认线程工厂，使用丢弃最旧任务的拒绝策略</span></span><br><span class="line">        <span class="type">ThreadPoolExecutor</span> <span class="variable">threadPoolExecutor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">                <span class="number">2</span>, <span class="comment">// 核心线程池大小</span></span><br><span class="line">                <span class="number">5</span>, <span class="comment">// 最大线程池大小</span></span><br><span class="line">                <span class="number">3</span>, <span class="comment">// 超时时间</span></span><br><span class="line">                TimeUnit.SECONDS, <span class="comment">// 超时单位</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="number">3</span>), <span class="comment">// 使用有界队列 LinkedBlockingQueue，容量为3</span></span><br><span class="line">                Executors.defaultThreadFactory(), <span class="comment">// 默认线程工厂</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.DiscardOldestPolicy() <span class="comment">// 丢弃最旧任务的拒绝策略</span></span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最大承载：队列容量 + 最大线程数</span></span><br><span class="line">        <span class="comment">// 提交8个任务给自定义线程池执行</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 使用线程池来执行任务</span></span><br><span class="line">            threadPoolExecutor.execute(() -&gt; &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; ok&quot;</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭线程池</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            threadPoolExecutor.shutdown();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>底层工作原理</strong>：</p>
<ul>
<li>假设来了9个线程，在执行execute()方法才创建线程</li>
<li>第1-2个线程进入线程池创建</li>
<li>第3-5个线程进入阻塞队列</li>
<li>第6-8个线程会为他们创建新线程执行（直接运行线程6而非线程3）</li>
<li>第9个线程会被拒绝</li>
</ul>
<blockquote>
<p>总结：先到常驻线程，满了之后再到阻塞队列进行等待，阻塞队列满了之后，在往外扩容线程，扩容线程不能大于最大线程数。<strong>大于最大线程数和阻塞队列之和后，会执行拒绝策略</strong></p>
</blockquote>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B.assets/image-20240511192424588.png" alt="image-20240511192424588"></p>
<h3 id="11-4-四种策略"><a href="#11-4-四种策略" class="headerlink" title="11.4 四种策略"></a>11.4 四种策略</h3><ul>
<li><code>new ThreadPoolExecutor.AbortPolicy()</code>：<strong>默认策略，抛出异常</strong>阻止系统正常运行</li>
<li><code>new ThreadPoolExecutor.CallerRunsPolicy()</code>：调用者运行，<strong>将任务回退到调用者</strong>，降低新任务流量</li>
<li><code>new ThreadPoolExecutor.DiscardPolicy()</code>：<strong>丢弃任务，不抛出异常</strong></li>
<li><code>new ThreadPoolExecutor.DiscardOldestPolicy()</code>：<strong>抛弃队列中等待最久的任务，尝试再次提交当前任务</strong></li>
</ul>
<h3 id="11-5-如何设置线程池的最大大小"><a href="#11-5-如何设置线程池的最大大小" class="headerlink" title="11.5 如何设置线程池的最大大小"></a>11.5 如何设置线程池的最大大小</h3><blockquote>
<p>在设置线程池的最大大小时，针对CPU密集型和IO密集型任务有不同考虑</p>
<p>对于不同类型的任务，应该根据任务的特点和系统资源情况来灵活设置线程池的最大大小，以提高系统的效率和性能</p>
</blockquote>
<ul>
<li><strong>CPU密集型任务</strong>：<ul>
<li>设置线程池的最大大小为处理器核心数，这样可以最大程度地利用CPU资源，避免线程过多导致线程切换频繁而降低效率</li>
<li>可以通过代码获取处理器核心数，然后将最大线程数设置为相应的核心数</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">coreCount</span> <span class="operator">=</span> Runtime.getRuntime().availableProcessors();</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>IO密集型任务</strong>：<ul>
<li>根据程序中IO操作的情况来确定最大线程池大小</li>
<li>通常情况下，可以将最大线程数设置为大约是最大I&#x2F;O数的一倍到两倍之间，以保证足够的线程处理IO任务</li>
</ul>
</li>
</ul>
<h2 id="12-四大函数式接口-必须掌握！"><a href="#12-四大函数式接口-必须掌握！" class="headerlink" title="12. 四大函数式接口(必须掌握！)"></a>12. 四大函数式接口(必须掌握！)</h2><blockquote>
<p>Java 程序员必须掌握：</p>
<p><strong>泛型、枚举、反射</strong></p>
<p><strong>lambda表达式、链式编程、函数式接口、Stream流式计算</strong></p>
</blockquote>
<h3 id="12-1-概述"><a href="#12-1-概述" class="headerlink" title="12.1 概述"></a>12.1 概述</h3><ul>
<li><strong>函数式接口</strong>：仅定义一个抽象方法的接口</li>
<li>函数式接口通常标注了<code>@FunctionalInterface</code>注解，这不是必需的，但有助于编译器检查接口是否符合函数式接口的定义</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>Java 8引入的四大函数式接口分别是<code>Consumer</code>、<code>Function</code>、<code>Predicate</code>、和<code>Supplier</code>，这些接口主要用于常见的操作：消费、转换、断言和提供</p>
</li>
<li><p><strong>应用场景</strong>：</p>
<ul>
<li><strong>Function</strong>：适用于转换数据，如从一种类型映射到另一种类型</li>
<li><strong>Predicate</strong>：常用于筛选数据，如在集合操作中进行条件过滤</li>
<li><strong>Consumer</strong>：常用于处理从数据源消费数据，如打印、存储操作</li>
<li><strong>Supplier</strong>：适用于需要多次返回结果的场景，如工厂方法、构造器引用等</li>
</ul>
</li>
<li><p>在特定的应用场景下，还可以定义自己的函数式接口来更好地满足需求</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CheckedFunction</span>&lt;T, R&gt; &#123;</span><br><span class="line">    R <span class="title function_">apply</span><span class="params">(T t)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="12-2-Function-接口"><a href="#12-2-Function-接口" class="headerlink" title="12.2 Function 接口"></a>12.2 Function 接口</h3><ul>
<li><strong>函数型接口</strong>：接受一个输入参数，返回一个结果</li>
<li><strong>源码</strong>：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Function</span>&lt;T, R&gt; &#123;</span><br><span class="line">    R <span class="title function_">apply</span><span class="params">(T t)</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>代码测试</strong>：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Function函数型接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Function&lt;String,String&gt; function = (str) -&gt;&#123;<span class="keyword">return</span> str;&#125;;</span><br><span class="line">        System.out.println(function.apply(<span class="string">&quot;starasdas&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="12-3-Predicate-接口"><a href="#12-3-Predicate-接口" class="headerlink" title="12.3 Predicate 接口"></a>12.3 Predicate 接口</h3><ul>
<li><strong>断定型接口</strong>：接受一个输入参数，返回一个布尔值</li>
<li><strong>源码</strong>：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Predicate</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">test</span><span class="params">(T t)</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>代码测试</strong>：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 断定型接口：有一个输入参数，返回值只能是 布尔值！</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//判断字符串是否为空</span></span><br><span class="line">        Predicate&lt;String&gt; predicate = (str)-&gt;&#123;<span class="keyword">return</span> str.isEmpty();&#125;;</span><br><span class="line">        System.out.println(predicate.test(<span class="string">&quot;11&quot;</span>));</span><br><span class="line">        System.out.println(predicate.test(<span class="string">&quot;&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="12-4-Consumer-接口"><a href="#12-4-Consumer-接口" class="headerlink" title="12.4 Consumer 接口"></a>12.4 Consumer 接口</h3><ul>
<li><strong>消费型接口</strong>：接受单一输入参数，不返回结果</li>
<li><strong>源码</strong>：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Consumer</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(T t)</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>代码测试</strong>：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 消费型接口 没有返回值！只有输入！</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Consumer&lt;String&gt; consumer = (str)-&gt;&#123;</span><br><span class="line">            System.out.println(str);</span><br><span class="line">        &#125;;</span><br><span class="line">        consumer.accept(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="12-5-Supplier-接口"><a href="#12-5-Supplier-接口" class="headerlink" title="12.5 Supplier 接口"></a>12.5 Supplier 接口</h3><ul>
<li><strong>供给型接口</strong>：无参数，返回一个结果</li>
<li><strong>源码</strong>：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Supplier</span>&lt;T&gt; &#123;</span><br><span class="line">    T <span class="title function_">get</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>代码测试</strong>：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 供给型接口，只返回，不输入</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Supplier&lt;String&gt; supplier = ()-&gt;&#123;<span class="keyword">return</span> <span class="string">&quot;1024&quot;</span>;&#125;;</span><br><span class="line">        System.out.println(supplier.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="13-Stream-流式计算"><a href="#13-Stream-流式计算" class="headerlink" title="13. Stream 流式计算"></a>13. Stream 流式计算</h2><ul>
<li><p>Stream 流式计算是Java 8中引入的一项强大的新特性，它<strong>允许以声明性方式处理数据集合</strong></p>
<ul>
<li>通过 <strong>Stream API 对数据进行高效的查询、过滤、转换、聚合等操作</strong>，无需编写冗长的代码</li>
<li>对集合对象功能的增强，专注于对集合对象进行各种便捷和高效的聚合操作或大批量数据操作，借鉴了函数式编程语言的许多概念，利用更丰富的语法对集合数据进行查询和处理</li>
</ul>
</li>
<li><p><strong>特点</strong>：</p>
<ul>
<li><strong>不是数据结构</strong>：Stream不存储数据，它只是在源数据（如集合、数组）的基础上提供了一种对数据的高效处理方式</li>
<li><strong>只能遍历一次</strong>：和迭代器类似，流一旦遍历过一次，便不能重复使用或“倒带”</li>
<li><strong>延迟执行</strong>：很多Stream操作都是延迟执行的，只有在需要结果的时候才执行（只有在终端操作执行时，所有中间操作才会被实际执行）<ul>
<li>可以避免对数据的不必要处理，特别是在链式调用中，可以合并多个操作，减少遍历次数</li>
</ul>
</li>
<li><strong>支持并行处理</strong>：Stream有串行和并行两种模式，通过并行模式可以利用多核处理器的优势，提高执行效率</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>);</span><br><span class="line"><span class="comment">// 并行处理一组数字，筛选出偶数并计算它们的和</span></span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> numbers.parallelStream()</span><br><span class="line">    .filter(n -&gt; n % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">    .mapToInt(Integer::intValue)</span><br><span class="line">    .sum();</span><br><span class="line">System.out.println(<span class="string">&quot;Sum of even numbers: &quot;</span> + sum);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>核心操作</strong>：Stream 操作可以分为中间操作和终端操作两种：</p>
<ul>
<li><strong>中间操作</strong>：中间操作都会<strong>返回一个新的 Stream</strong>。常见的中间操作有<code>filter</code>（过滤）、<code>map</code>（映射）、<code>sorted</code>（排序）等</li>
<li><strong>终端操作</strong>：终端操作会从 Stream <strong>产生结果</strong>，之后不能再使用Stream。常见的终端操作包括<code>forEach</code>( 遍历流中的每个元素，执行给定的操作)、<code>collect</code>(将Stream转换成不同类型的结果)、<code>reduce</code>(通过某个连接操作将所有元素汇聚成一个汇总结果)、<code>findAny</code>(返回流中的任意元素)等</li>
</ul>
</li>
<li><p><strong>代码示例</strong>：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">1</span>, <span class="string">&quot;a&quot;</span>, <span class="number">21</span>);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">2</span>, <span class="string">&quot;b&quot;</span>, <span class="number">22</span>);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">3</span>, <span class="string">&quot;c&quot;</span>, <span class="number">23</span>);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">4</span>, <span class="string">&quot;d&quot;</span>, <span class="number">24</span>);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">5</span>, <span class="string">&quot;e&quot;</span>, <span class="number">25</span>);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">6</span>, <span class="string">&quot;f&quot;</span>, <span class="number">26</span>);</span><br><span class="line">        List&lt;User&gt; list = Arrays.asList(user1, user2, user3, user4, user5, user6);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算交给流，使用链式编程</span></span><br><span class="line">        list.stream()</span><br><span class="line">            .filter(u -&gt; u.getId() % <span class="number">2</span> == <span class="number">0</span>)   <span class="comment">// 筛选出ID为偶数的用户</span></span><br><span class="line">            .filter(u -&gt; u.getAge() &gt; <span class="number">23</span>)      <span class="comment">// 进一步筛选出年龄大于23的用户</span></span><br><span class="line">            .map(u -&gt; u.getName().toUpperCase()) <span class="comment">// 将用户的名字转换为大写</span></span><br><span class="line">            .sorted((uu1, uu2) -&gt; uu2.compareTo(uu1)) <span class="comment">// 按名字降序排序, 也可直接 Comparator.reverseOrder()</span></span><br><span class="line">            .limit(<span class="number">1</span>)  <span class="comment">// 限制结果数量为1</span></span><br><span class="line">            .forEach(System.out::println); <span class="comment">// 打印最终结果  F</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// list.stream()</span></span><br><span class="line">        <span class="comment">//         .filter(u -&gt; u.getId() % 2 == 0)   // 筛选出ID为偶数的用户</span></span><br><span class="line">        <span class="comment">//         .filter(u -&gt; u.getAge() &gt; 23)      // 进一步筛选出年龄大于23的用户</span></span><br><span class="line">        <span class="comment">//         .map(u-&gt;&#123;u.setName(u.getName().toUpperCase()); return u;&#125;) // 将用户的名字转换为大写</span></span><br><span class="line">        <span class="comment">//         .sorted((uu1, uu2) -&gt; uu2.getName().compareTo(uu1.getName())) // 按名字降序排序, 也可直接 Comparator.reverseOrder()</span></span><br><span class="line">        <span class="comment">//         .limit(1)  // 限制结果数量为1</span></span><br><span class="line">        <span class="comment">//         .forEach(System.out::println); // 打印最终结果  User&#123;id=6, name=&#x27;F&#x27;, age=26&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>应用场景</strong>：</p>
<ul>
<li><p><strong>数据筛选和转换</strong>：如从数据库查询到的记录进行预处理，例如过滤、转换等</p>
</li>
<li><p><strong>聚合统计</strong>：如统计某个字段的平均值、最大值、最小值等</p>
</li>
<li><p><strong>并行运算</strong>：利用Stream的并行流大幅提高数据处理速度</p>
</li>
</ul>
</li>
</ul>
<h2 id="14-Fork-Join-分支合并"><a href="#14-Fork-Join-分支合并" class="headerlink" title="14. Fork&#x2F;Join 分支合并"></a>14. Fork&#x2F;Join 分支合并</h2><h3 id="14-1-概述"><a href="#14-1-概述" class="headerlink" title="14.1 概述"></a>14.1 概述</h3><ul>
<li><p>Fork&#x2F;Join 框架是自 Java 7 引入的一个用于并行执行任务的工具，尤其适合处理那些可以递归方式拆分成更小任务的大问题</p>
<ul>
<li><strong>基于“分治法”的设计思想</strong>，旨在充分利用多核处理器的计算能力来提高应用性能</li>
</ul>
</li>
<li><p><strong>特点</strong>：<strong>工作窃取（Work Stealing）</strong></p>
<ul>
<li>Fork&#x2F;Join 框架采用工作窃取算法来平衡工作负载。<strong>每个线程都维护一个双端队列</strong>，忙碌的线程可以将部分任务（从队列尾部拿取）转移给空闲的线程（从队列头部拿取）</li>
</ul>
</li>
<li><p><strong>实现原理</strong>：<strong>双端队列</strong></p>
<ul>
<li>每个工作线程都有自己的双端队列，用来存放分配给自己的任务</li>
<li>线程主要从自己的队列中取任务执行，当自己的队列空时，可以从其他线程的队列尾部“窃取”任务</li>
</ul>
</li>
<li><p><strong>核心</strong>：Fork&#x2F;Join 框架的核心在于两个操作：<code>fork()</code> 和 <code>join()</code></p>
<ul>
<li><strong>Fork</strong>：将<strong>大任务拆分成若干子任务</strong>，子任务可以并行执行</li>
<li><strong>Join</strong>：等待子任务完成，并将所有子任务的结果合并成总结果</li>
</ul>
</li>
<li><p><strong>使用场景</strong>：</p>
<ul>
<li>大数据处理</li>
<li>图像处理</li>
<li>大规模数值处理</li>
</ul>
</li>
<li><p><strong>使用方法</strong>：</p>
<ul>
<li><strong>创建 ForkJoinPool</strong>：所有 ForkJoin 任务都需要通过 ForkJoinPool 来执行，ForkJoinPool 是任务管理和执行的核心</li>
<li><strong>定义任务</strong>：创建继承自<code>ForkJoinTask</code>（通常是它的子类 <code>RecursiveAction</code> 或 <code>RecursiveTask</code>）的类<ul>
<li><code>RecursiveTask</code>（有返回值）</li>
<li><code>RecursiveAction</code>（无返回值）</li>
</ul>
</li>
<li><strong>启动任务</strong>：通过 <code>ForkJoinPool</code> 的 <code>invoke()</code> 或 <code>submit()</code> 方法启动任务</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B.assets/image-20240512150955213.png" alt="image-20240512150955213"></p>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B.assets/image-20240512151114324.png" alt="image-20240512151114324"></p>
<h3 id="14-2-代码示例"><a href="#14-2-代码示例" class="headerlink" title="14.2 代码示例"></a>14.2 代码示例</h3><ul>
<li><p><strong>ForkJoinDemo 类</strong>：继承自 <code>RecursiveTask&lt;Long&gt;</code>，是一个可以返回结果的任务	</p>
<ul>
<li><p>**临界值 (<code>temp</code>)**：用于控制任务分解的粒度。如果任务的大小小于此值，则不再继续分解任务，而是直接进行计算。</p>
</li>
<li><p>**fork()**：将子任务推送到ForkJoinPool的工作队列。</p>
</li>
<li><p>**join()**：等待子任务完成，并获取其结果。</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ForkJoinDemo</span> <span class="keyword">extends</span> <span class="title class_">RecursiveTask</span>&lt;Long&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> star;  <span class="comment">// 任务的起始点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> end;   <span class="comment">// 任务的结束点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//临界值，当任务的规模小于这个值时直接进行计算而不再继续分解</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">1000000L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ForkJoinDemo</span><span class="params">(<span class="type">long</span> star, <span class="type">long</span> end)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.star = star;</span><br><span class="line">        <span class="built_in">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Long <span class="title function_">compute</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ((end - star) &lt;= temp) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">long</span> <span class="variable">i</span> <span class="operator">=</span> star; i &lt;= end; i++) &#123;</span><br><span class="line">                sum += i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 当任务大于临界值时，继续分解任务</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">middle</span> <span class="operator">=</span> (star + end) / <span class="number">2</span>;</span><br><span class="line">            <span class="type">ForkJoinDemo</span> <span class="variable">task1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinDemo</span>(star, middle);</span><br><span class="line">            task1.fork();  <span class="comment">// 将任务推送到ForkJoinPool的工作队列</span></span><br><span class="line">            <span class="type">ForkJoinDemo</span> <span class="variable">task2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinDemo</span>(middle + <span class="number">1</span>, end);</span><br><span class="line">            task2.fork();</span><br><span class="line">            <span class="comment">// 等待任务执行结束并合并结果</span></span><br><span class="line">            <span class="keyword">return</span> task1.join() + task2.join();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>测试类</strong>：使用三种不同的方法来计算从 1 到 20亿的整数和<ul>
<li>**test1()**：使用单线程迭代的方法计算总和</li>
<li>**test2()**：使用 ForkJoin 框架执行同样的计算。通过 <code>ForkJoinPool.invoke()</code> 方法启动 ForkJoin 任务</li>
<li>**test3()**：使用 Java 8 Stream API 的并行流进行计算。Stream API 的并行流内部使用的也是 ForkJoinPool<ul>
<li><code>.parallel().reduce(0, Long::sum)</code> 使用并行流来执行归约操作，这里用于计算一个长整型数列的总和</li>
<li>**.parallel()**：用于将流转换为并行流，并行流利用Java的Fork&#x2F;Join框架，允许在多核处理器上并行处理任务，从而加快执行速度</li>
<li>**.reduce(0, Long::sum)**：通过指定的函数来合并流中的元素，这里使用的是两参数版本的 <code>reduce</code> 方法<ul>
<li>第一个参数 <code>0</code> 是流为空时的默认结果</li>
<li>第二个参数 <code>Long::sum</code> 是一个方法引用，指向一个接受两个参数并返回它们的和的方法。它定义了如何合并流中的元素</li>
</ul>
</li>
<li>reduce 方法的<strong>优点</strong>：灵活、不需要存储中间状态，并行性能高、不会修改原始数据源</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        test1(); <span class="comment">// 普通迭代方法  sum=2000000001000000000 时间：539</span></span><br><span class="line">        <span class="comment">//test2(); // 使用 ForkJoin  sum=2000000001000000000 时间：184</span></span><br><span class="line">        <span class="comment">//test3(); // 使用 Stream 并行流  sum=2000000001000000000 时间：160</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">long</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">20_0000_0000L</span>; i++) &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;sum=&quot;</span> + sum + <span class="string">&quot; 时间：&quot;</span> + (end - start));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">ForkJoinPool</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinPool</span>();</span><br><span class="line">        ForkJoinTask&lt;Long&gt; task = <span class="keyword">new</span> <span class="title class_">ForkJoinDemo</span>(<span class="number">0L</span>, <span class="number">20_0000_0000L</span>);</span><br><span class="line">        <span class="type">Long</span> <span class="variable">result</span> <span class="operator">=</span> pool.invoke(task);</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;sum=&quot;</span> + result + <span class="string">&quot; 时间：&quot;</span> + (end - start));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> LongStream.rangeClosed(<span class="number">0L</span>, <span class="number">20_0000_0000L</span>).parallel().reduce(<span class="number">0</span>, Long::sum);</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;sum=&quot;</span> + sum + <span class="string">&quot; 时间：&quot;</span> + (end - start));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Stream 并行流提供了最好的性能和最简洁的代码。</li>
<li>Fork&#x2F;Join 框架提供了较好的性能提升，适用于更复杂的任务分解和自定义并行处理逻辑。</li>
<li>普通迭代方法虽然实现最简单，但在处理大数据量时性能最低。</li>
</ul>
<blockquote>
<p>对于<strong>大多数大规模计算任务</strong>，推荐使用 Stream 并行流或 Fork&#x2F;Join 框架来利用现代多核 CPU 的计算能力</p>
</blockquote>
<h2 id="15-异步回调"><a href="#15-异步回调" class="headerlink" title="15. 异步回调"></a>15. 异步回调</h2><h3 id="15-1-同步和异步"><a href="#15-1-同步和异步" class="headerlink" title="15.1 同步和异步"></a>15.1 同步和异步</h3><ul>
<li><strong>同步操作</strong>：程序按顺序执行，必须等待当前操作完全完成后才能继续到下一步<ul>
<li>例如，从数据库读取数据或从网络加载资源，线程会被<strong>阻塞</strong>，直到操作完成</li>
</ul>
</li>
<li><strong>异步操作</strong>：程序可以在等待操作完成的同时继续执行其他任务。<ul>
<li>异步操作常见于不希望阻塞主线程的场景，例如GUI应用程序、大规模计算和高性能Web服务器</li>
</ul>
</li>
</ul>
<h3 id="15-2-CompletableFuture"><a href="#15-2-CompletableFuture" class="headerlink" title="15.2 CompletableFuture"></a>15.2 CompletableFuture</h3><ul>
<li><code>CompletableFuture</code> 是在Java 8中引入的，用于增强现有的<code>Future</code>接口，主要用于异步编程<ul>
<li>异步通常意味着非阻塞，可以使得我们的任务单独运行在与主线程分离的其他线程中，并且可以通过回调在主线程中获取异步任务的执行状态、完成情况以及异常信息等</li>
<li>CompletableFuture 实现了 Future，CompletionStage 接口，使得它既兼容现有的线程池框架，又提供了异步编程的接口抽象</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B.assets/image-20240512185425536.png" alt="image-20240512185425536"></p>
<ul>
<li><strong>常用方法</strong>：<ul>
<li>runAsync：执行没有返回值的异步任务</li>
<li>supplyAsync：执行有返回值的异步任务</li>
</ul>
</li>
<li><strong>特点</strong>：<ul>
<li>支持手动完成，可以显式地设置其结果</li>
<li>提供了异常处理机制</li>
<li>支持回调函数，当<code>Future</code>完成时可以自动触发</li>
<li>支持链式调用，允许将多个异步操作的结果串联起来</li>
<li>支持合并多个<code>CompletableFuture</code>，可以等待多个<code>CompletableFuture</code>完成后再继续执行</li>
</ul>
</li>
<li><strong>代码示例</strong>：<ul>
<li><code>whenComplete</code>：此方法接收两个参数：<code>t</code> 和 <code>u</code><ul>
<li>t：代表<strong>正常返回的结果</strong></li>
<li>u：代表<strong>抛出异常的错误信息</strong></li>
</ul>
</li>
<li>异常处理：<ul>
<li><code>exceptionally</code>：当异步操作发生异常时，可以通过该方法来定义一个回调函数，用于处理异常，该方法接收一个函数，该函数的输入是引发问题的异常对象，并返回一个替代值来“修复”异常情况，继续后续的处理流程</li>
<li><code>get</code> 方法在调用时会阻塞直到异步操作完成。如果操作成功完成，则返回正常的结果；如果操作中发生异常且没有被 <code>exceptionally</code> 方法处理，则会抛出一个 <code>ExecutionException</code>。如果使用 <code>exceptionally</code> 处理了异常，则 <code>get</code> 将返回 <code>exceptionally</code> 中定义的替代值</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 没有返回值的异步回调</span></span><br><span class="line">    CompletableFuture&lt;Void&gt; voidCompletableFuture = CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; run&quot;</span>);  <span class="comment">// ForkJoinPool.commonPool-worker-9 run</span></span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(<span class="string">&quot;发起了异步请求&quot;</span>);</span><br><span class="line">    <span class="comment">// 阻塞等待任务完成</span></span><br><span class="line">    voidCompletableFuture.get();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有返回值的异步回调</span></span><br><span class="line">    <span class="comment">// 模拟异步操作，例如ajax请求，成功和失败回调</span></span><br><span class="line">    CompletableFuture&lt;Integer&gt; completableFuture = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        <span class="comment">// completableFuture ForkJoinPool.commonPool-worker-9</span></span><br><span class="line">        System.out.println(<span class="string">&quot;completableFuture &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">        <span class="comment">// 模拟异常情况</span></span><br><span class="line">        <span class="comment">// int i = 10 / 0;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1024</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用whenComplete处理正常返回结果和异常</span></span><br><span class="line">    System.out.println(completableFuture.whenComplete((t, u) -&gt; &#123;  <span class="comment">// 1024 / 233</span></span><br><span class="line">        <span class="keyword">if</span> (u == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 正常的返回结果</span></span><br><span class="line">            System.out.println(<span class="string">&quot;正常结果：&quot;</span> + t);  <span class="comment">// 正常结果：1024</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 异常信息：java.util.concurrent.CompletionException: java.lang.ArithmeticException: / by zero</span></span><br><span class="line">            System.out.println(<span class="string">&quot;异常信息：&quot;</span> + u);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).exceptionally((e) -&gt; &#123;</span><br><span class="line">        <span class="comment">// 异常处理</span></span><br><span class="line">        System.out.println(<span class="string">&quot;发生异常：&quot;</span> + e.getMessage());  <span class="comment">// 发生异常：java.lang.ArithmeticException: / by zero</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">233</span>;</span><br><span class="line">    &#125;).get()); <span class="comment">// 阻塞等待任务完成，并获取最终结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="15-3-Future-VS-CompletableFuture"><a href="#15-3-Future-VS-CompletableFuture" class="headerlink" title="15.3 Future VS. CompletableFuture"></a>15.3 Future VS. CompletableFuture</h3><ul>
<li><p><strong>Futrue</strong> 在 Java 里面，通常用来表示一个异步任务的引用，比如我们将任务提交到线程池里面，然后我们会得到一个 Futrue，在 Future 里面有 isDone 方法来 判断任务是否处理结束，还有 get 方法可以一直阻塞直到任务结束然后获取结果</p>
<ul>
<li>但整体来说这种方式，还<strong>是同步的</strong>，因为需要客户端不断阻塞等待或者不断轮询才能知道任务是否完成</li>
</ul>
</li>
<li><p>对比Future和CompletableFuture，<strong>CompletableFuture优势</strong>：</p>
<ul>
<li><p><strong>支持非阻塞回调</strong>：<code>CompletableFuture</code>支持在任务完成时，自动执行某些函数（回调），而<code>Future</code>则需要调用者不断检查</p>
</li>
<li><p><strong>更丰富的操作</strong>：<code>CompletableFuture</code>支持更丰富的方法和流式操作，如<code>thenApply</code>, <code>thenAccept</code>, <code>thenCompose</code>, 和<code>combine</code>等，这些都是<code>Future</code>所不具备的</p>
</li>
<li><p><strong>异常处理</strong>：<code>CompletableFuture</code>提供了异常处理的直接支持，而<code>Future</code>则没有</p>
</li>
</ul>
</li>
</ul>
<h2 id="16-JMM"><a href="#16-JMM" class="headerlink" title="16. JMM"></a>16. JMM</h2><ul>
<li><p><strong>JMM(Java Memory Model)<strong>：JAVA 内存模型，</strong>是一个抽象的概念</strong>或约定，用于定义Java程序中变量的访问规则以及在多线程环境下如何进行线程间的通信</p>
<ul>
<li>它描述了程序中各种变量（包括类实例字段、静态字段和构造数组对象）的访问方式</li>
</ul>
</li>
<li><p><strong>JMM 的同步约定</strong>：</p>
<ul>
<li><strong>线程解锁前必须立即将共享变量刷新回主存</strong>：确保释放锁时，对变量的修改能够被接下来获取该锁的其他线程看到</li>
<li><strong>线程加锁前必须读取主存中的最新值到工作内存中</strong>：确保获取锁后，工作内存中的变量是最新的</li>
<li><strong>加锁和解锁必须是同一把锁</strong>：保证锁的获取和释放的一致性</li>
</ul>
</li>
<li><p><strong>线程内存交互操作</strong>：Java 内存模型定义了以下<strong>8种操作</strong>来控制线程对内存的交互</p>
<ul>
<li>**Read(读取)**：从主内存中读取变量到线程的工作内存</li>
<li>**Load(载入)**：在工作内存中对变量赋值(跟随Read操作)</li>
<li>**Use(使用)**：使用工作内存中的变量</li>
<li>**Assign(赋值)**：向工作内存中的变量赋新值</li>
<li>**Store(存储)**：将工作内存中的变量的值写回主内存(准备写入操作)</li>
<li>**Write(写入)**：将Store的值真正写入主内存</li>
<li>**Lock(锁定)**：标记变量在主内存中开始处于锁定状态</li>
<li>**Unlock(解锁)**：标记变量在主内存中结束锁定状态</li>
</ul>
</li>
<li><p><strong>JMM 的操作规定</strong>：</p>
<ul>
<li><strong>Read和Load、Store和Write操作必须成对出现</strong>：保证内存值的正确传递</li>
<li><strong>线程对变量的修改必须同步回主内存</strong>：保证其他线程能看到最新值</li>
<li><strong>初始化变量必须在主内存中进行</strong>：避免使用未初始化的数据</li>
<li><strong>变量锁定和解锁必须一致</strong>：确保每次只有一个线程可以修改变量</li>
</ul>
</li>
<li><p><strong>代码示例问题分析</strong>：<code>num</code> 变量的更新可能对另一个线程不可见，因为没有适当的同步措施。这可能导致程序无法如预期终止，因为线程1可能永远看不到 <code>num</code> 的更新</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;  <span class="comment">// 线程1</span></span><br><span class="line">        <span class="keyword">while</span> (num == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 这里可能永远看不到num变化</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">    num = <span class="number">1</span>;  <span class="comment">// 主线程更新num</span></span><br><span class="line">    System.out.println(num);</span><br><span class="line">    <span class="comment">// 线程1可能不知道num已更新</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为解决这一问题，可以通过添加<code>volatile</code>关键字来声明<code>num</code>变量，这将保证每次读写都直接从主内存完成，从而保证了可见性</p>
<h2 id="17-Volatile"><a href="#17-Volatile" class="headerlink" title="17. Volatile"></a>17. Volatile</h2><h3 id="17-1-概述"><a href="#17-1-概述" class="headerlink" title="17.1 概述"></a>17.1 概述</h3><ul>
<li><strong>Volatile</strong> 是 Java 虚拟机提供的一种<strong>轻量级的同步机制</strong></li>
<li><strong>特点</strong>：<ul>
<li><strong>保证可见性</strong>：确保一个线程修改了该变量的值后，其他线程能够立即得知这个修改</li>
<li><strong>不保证原子性</strong>：虽然 volatile 变量的读写是原子的，但复合操作（如递增）不是原子的</li>
<li><strong>禁止指令重排</strong>：确保编译器在编译过程中不会对涉及 volatile变量的指令进行重排序，这是通过插入<strong>内存屏障</strong>来实现的</li>
</ul>
</li>
</ul>
<h3 id="17-2-保证可见性"><a href="#17-2-保证可见性" class="headerlink" title="17.2 保证可见性"></a>17.2 保证可见性</h3><ul>
<li><strong>代码示例</strong>：使用 volatile 防止死循环<ul>
<li>不使用<code>volatile</code>修饰<code>number</code>，其他线程可能无法看到<code>number</code>的改变，导致无限循环</li>
<li>使用<code>volatile</code>后，一旦<code>number</code>的值被修改，所有线程都能立即看到这一变化</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JMMDemo01</span> &#123;</span><br><span class="line">    <span class="comment">// 如果不加 volatile 程序会死循环</span></span><br><span class="line">    <span class="comment">// 加了 volatile 是可以保证可见性的</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="type">Integer</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (number == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 循环等待number变化</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        number = <span class="number">1</span>;</span><br><span class="line">        System.out.println(number);  <span class="comment">// 1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="17-3-不保证原子性"><a href="#17-3-不保证原子性" class="headerlink" title="17.3 不保证原子性"></a>17.3 不保证原子性</h3><ul>
<li><strong>原子性</strong>：不可分割，线程在执行任务的时候要么同时成功，要么同时失败</li>
<li><strong>代码示例</strong>：验证 volatile 不保证原子性<ul>
<li>代码中即使<code>number</code>是volatile变量，<code>number++</code>操作的非原子性导致最终结果可能不是预期的20000</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 不保证原子性</span></span><br><span class="line"><span class="comment"> * number &lt;= 2w</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VDemo02</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span> &#123;</span><br><span class="line">        number++;  <span class="comment">// ++ 不是原子性操作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 理论上number  === 20000</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">20</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= <span class="number">1000</span>; j++) &#123;</span><br><span class="line">                    add();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (Thread.activeCount() &gt; <span class="number">2</span>) &#123;  <span class="comment">// main  gc</span></span><br><span class="line">            <span class="comment">// 只要除了主线程和可能的垃圾收集线程之外还有其他线程在运行, 循环就会继续</span></span><br><span class="line">            <span class="comment">// 确保主线程（或任何等待所有其他线程完成的线程）最后执行</span></span><br><span class="line">            Thread.<span class="keyword">yield</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;,num=&quot;</span> + number);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>如何保证原子性</strong>？除了使用<code>lock</code>和<code>synchronized</code>关键字？<ul>
<li>Java 还提供了<strong>基于<code>java.util.concurrent.atomic </code>包中的一系列原子类</strong></li>
<li>这些原子类使用了<strong>高效</strong>的机制来保证单个变量操作的原子性，通常是<strong>通过底层的CAS（Compare-And-Swap）操作实现</strong></li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 适用 AtomicInteger 类代替普通的 int 变量</span></span><br><span class="line"><span class="comment">// 确保在多线程环境中对数值的原子性增加操作</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">AtomicInteger</span> <span class="variable">number</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span>&#123;</span><br><span class="line">    number.incrementAndGet();  <span class="comment">// 底层是CAS保证的原子性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>底层原理</strong>：<ul>
<li><strong>原子类的工作原理</strong>：原子类在底层使用了CAS操作<ul>
<li>CAS操作涉及三个操作数：内存位置（在这里是<code>number</code>的值）、预期原值和新值</li>
<li>如果内存位置的当前值与预期原值相匹配，那么处理器会自动将该位置值更新为新值。这个过程是原子的，即不可中断，保证了更新操作的原子性</li>
</ul>
</li>
<li><strong><code>Unsafe</code>类</strong>：原子类的实现依赖于<code>Unsafe</code>类，这是 Java 中一个<strong>提供底层、不安全操作的类</strong>，如直接内存访问和非常规的对象实例化等。<code>Unsafe</code>类使得Java能够执行类似指针的操作，并且<strong>能够进行底层的内存操作</strong></li>
</ul>
</li>
</ul>
<blockquote>
<p>使用<code>AtomicInteger</code>类和其他原子类是在不想使用显式同步（例如<code>synchronized</code>或Java锁API）时确保数据完整性的一种有效方式。它们特别适用于计数器或累加器，以及任何只需要对单个变量进行原子操作的场景。这些原子类不仅效率高，而且代码简洁，易于理解和维护</p>
</blockquote>
<h3 id="17-4-防止指令重排"><a href="#17-4-防止指令重排" class="headerlink" title="17.4 防止指令重排"></a>17.4 防止指令重排</h3><ul>
<li><strong>指令重排</strong>：指计算机程序执行过程中，<strong>为了优化性能和利用硬件的并行处理能力，编译器和处理器可能会改变指令的执行顺序</strong>。重排可以发生在多个阶段：<ul>
<li><strong>编译器优化重排</strong>：编译器在生成机器代码时，可能会重新安排指令顺序以提高执行效率</li>
<li><strong>指令并行重排</strong>：现代处理器可能会并行执行多个指令，无需严格按照程序中的原始顺序</li>
<li><strong>内存系统重排</strong>：处理器和内存系统可能会改变操作执行的顺序，这与缓存和内存访问的优化有关</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">源代码–&gt;编译器优化重排–&gt;指令并行也可能会重排–&gt;内存系统也会重排–&gt;执行</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>数据依赖性</strong>：处理器<strong>在进行重排时会考虑到指令之间的数据依赖性</strong>。如果一条指令的结果依赖于前一条指令的结果，处理器会保留这种依赖关系，<strong>确保程序的执行结果符合逻辑的预期</strong></p>
<ul>
<li>如：理论上，执行顺序可能变为 <code>2-1-3-4</code> 或 <code>1-3-2-4</code>，但不会是 <code>4-1-2-3</code>，因为 <code>4</code> 操作依赖于 <code>3</code> 操作的结果</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span>;  <span class="comment">// 1</span></span><br><span class="line"><span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">2</span>;  <span class="comment">// 2</span></span><br><span class="line">x = x + <span class="number">5</span>;  <span class="comment">// 3</span></span><br><span class="line">y = x * x;  <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>volatile 防止指令重排</strong>：使用 <strong>volatile 变量时，JVM 会插入内存屏障来防止指令重排</strong></p>
<ul>
<li><strong>内存屏障</strong>：是一种CPU指令，用于实现以下两个主要目的：<ul>
<li><strong>保证特定操作的执行顺序</strong>：防止屏障前后的指令进行重排</li>
<li><strong>保证变量的内存可见性</strong>：确保屏障前的写操作在屏障后的读操作可见</li>
</ul>
</li>
<li>通过插入读屏障和写屏障，<code>volatile</code>确保在读取<code>volatile</code>变量之前的所有操作完成，且结果对后续的读取可见；写入<code>volatile</code>变量后的操作不会被重排到写操作之前，示例如下：<ul>
<li>理论上，最终<code>x</code>和<code>y</code>的值可能是 <code>(0,1)</code>, <code>(1,0)</code>, <code>(1,1)</code>，但由于<code>volatile</code>的使用，不会出现 <code>(0,0)</code>，因为每个线程对<code>a</code>或<code>b</code>的写入在另一个线程读取之前已经完成和可见</li>
<li><strong>情况 <code>(1, 0)</code></strong><ul>
<li><strong>线程B</strong> 执行 <code>b = 1</code> 完成后的写内存屏障确保 <code>b</code> 的更新对所有其他线程可见</li>
<li><strong>线程A</strong> 在执行 <code>x = b</code> 时，必须通过读内存屏障，确保看到 <code>b</code> 的最新值（即1）。但在此之前，<code>a</code> 可能还未被 <strong>线程B</strong> 读到，所以 <code>y</code> 可能仍是0</li>
</ul>
</li>
<li><strong>情况 <code>(0, 1)</code></strong><ul>
<li><strong>线程A</strong> 执行 <code>a = 1</code> 完成后的写内存屏障确保 <code>a</code> 的更新对所有其他线程可见</li>
<li><strong>线程B</strong> 在执行 <code>y = a</code> 时，必须通过读内存屏障，确保看到 <code>a</code> 的最新值（即1）。但在此之前，<code>b</code> 可能还未被 <strong>线程A</strong> 读到，所以 <code>x</code> 可能仍是0</li>
</ul>
</li>
<li><strong>情况 <code>(1, 1)</code></strong><ul>
<li>如果 <strong>线程A</strong> 和 <strong>线程B</strong> 的写操作（<code>a = 1</code> 和 <code>b = 1</code>）都完成，并且各自的写内存屏障生效之后，对方线程的读操作（<code>x = b</code> 和 <code>y = a</code>）发生。这意味着每个线程都能看到对方的变量更新，结果就是 <code>(1, 1)</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程A</span></span><br><span class="line"><span class="type">Thread</span> <span class="variable">A</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    a = <span class="number">1</span>;            <span class="comment">// A1: 写操作，后面跟着写内存屏障</span></span><br><span class="line">    <span class="comment">// ---- 写屏障 (确保a的写入对所有线程可见，且之前的写操作不会被重排到屏障后面)</span></span><br><span class="line">    x = b;            <span class="comment">// A2: 读操作，前面有读内存屏障</span></span><br><span class="line">    <span class="comment">// ---- 读屏障 (确保读取b时获取的是最新值，且之后的读操作不会被重排到屏障前面)</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程B</span></span><br><span class="line"><span class="type">Thread</span> <span class="variable">B</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    b = <span class="number">1</span>;            <span class="comment">// B1: 写操作，后面跟着写内存屏障</span></span><br><span class="line">    <span class="comment">// ---- 写屏障 (确保b的写入对所有线程可见，且之前的写操作不会被重排到屏障后面)</span></span><br><span class="line">    y = a;            <span class="comment">// B2: 读操作，前面有读内存屏障</span></span><br><span class="line">    <span class="comment">// ---- 读屏障 (确保读取a时获取的是最新值，且之后的读操作不会被重排到屏障前面)</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>在单例模式等场景中，<code>volatile</code>常被用于确保对象创建过程的安全性</strong>，防止对象未完全构造就被其他线程访问</p>
<h2 id="18-单例模式"><a href="#18-单例模式" class="headerlink" title="18. 单例模式"></a>18. 单例模式</h2><ul>
<li>单例模式是一种设计模式，<strong>用于确保一个类只有一个实例，并提供一个全局访问点</strong></li>
<li>在 Java 中，单例模式的实现主要有几种方式：<strong>饿汉式、懒汉式（DCL双重检查锁定实现）、静态内部类和枚举方式</strong></li>
</ul>
<h3 id="18-1-饿汉式"><a href="#18-1-饿汉式" class="headerlink" title="18.1 饿汉式"></a>18.1 饿汉式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 饿汉式单例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hungry</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有构造函数防止外部实例化(虽然反正了多线程并发对单例的破坏, 但还是有可能被反射破坏单例模式)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Hungry</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内部创建类的实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Hungry</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hungry</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 全局访问点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Hungry <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用反射破坏饿汉式单例模式</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Class&lt;?&gt; clazz = Hungry.class;</span><br><span class="line">        Constructor&lt;?&gt; constructor = clazz.getDeclaredConstructor();</span><br><span class="line">        constructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">Hungry</span> <span class="variable">instance1</span> <span class="operator">=</span> (Hungry) constructor.newInstance();</span><br><span class="line">        <span class="type">Hungry</span> <span class="variable">instance2</span> <span class="operator">=</span> Hungry.getInstance();</span><br><span class="line">        System.out.println(<span class="string">&quot;instance1 == instance2: &quot;</span> + (instance1 == instance2)); <span class="comment">// 输出false，单例被破坏</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="18-2-懒汉式-DCL实现"><a href="#18-2-懒汉式-DCL实现" class="headerlink" title="18.2 懒汉式-DCL实现"></a>18.2 懒汉式-DCL实现</h3><ul>
<li><strong>DCL懒汉式单例</strong> 是在需要时才创建实例，利用<strong>双重检查锁定机制确保只创建一个实例，同时使用 <code>volatile</code> 关键字防止指令重排，确保线程安全</strong><ul>
<li>通过在私有构造器中使用同步代码块和标识量来防止反射破解。然而，<strong>由于反射机制可以绕过私有构造器的限制，所以即使在构造器中使用了同步代码块和标识量，也无法阻止反射机制创建新的实例</strong></li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * DCL 懒汉式单例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LazyMan</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">LazyMan</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">key</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 即使在私有构造器里添加同步代码块, 反射也能破坏单例模式 =&gt; 使用反射获取类的私有构造器的引用</span></span><br><span class="line">    <span class="comment">// 尝试通过设置一个标识量 key 防止反射破坏单例模式 =&gt; 还是能使用反射获取到实例来修改类中的标识量 key</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">LazyMan</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (LazyMan.class) &#123;</span><br><span class="line">            <span class="keyword">if</span> (key == <span class="literal">false</span>) &#123;</span><br><span class="line">                key = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;不要试图使用反射破坏异常&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; ok&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 双重检测锁模式 简称 DCL 懒汉式</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> LazyMan <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 加锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (LazyMan.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">LazyMan</span>();</span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">                     * 此步骤非原子操作, 对于指令重排问题 =&gt; volatile 解决</span></span><br><span class="line"><span class="comment">                     * 1、分配内存空间</span></span><br><span class="line"><span class="comment">                     * 2、执行构造方法，初始化对象</span></span><br><span class="line"><span class="comment">                     * 3、把这个对象指向这个空间</span></span><br><span class="line"><span class="comment">                     *</span></span><br><span class="line"><span class="comment">                     *  就有可能出现指令重排问题</span></span><br><span class="line"><span class="comment">                     *  比如执行的顺序是1 3 2 等</span></span><br><span class="line"><span class="comment">                     *  可以添加volatile保证指令重排问题</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用反射破坏 DCL 懒汉式单例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException, IllegalAccessException,</span><br><span class="line">    InvocationTargetException, InstantiationException, NoSuchFieldException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 反射获取标识量</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">key</span> <span class="operator">=</span> LazyMan.class.getDeclaredField(<span class="string">&quot;key&quot;</span>);</span><br><span class="line">        key.setAccessible(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 反射获取私有构造器的引用</span></span><br><span class="line">        Constructor&lt;LazyMan&gt; declaredConstructor = LazyMan.class.getDeclaredConstructor(<span class="literal">null</span>);</span><br><span class="line">        declaredConstructor.setAccessible(<span class="literal">true</span>);  <span class="comment">// 无视了私有的构造器</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用反射获取的构造器创建实例</span></span><br><span class="line">        <span class="type">LazyMan</span> <span class="variable">lazyMan1</span> <span class="operator">=</span> declaredConstructor.newInstance();</span><br><span class="line">        key.set(lazyMan1, <span class="literal">false</span>);  <span class="comment">// 绕过标识量的限制</span></span><br><span class="line">        <span class="type">LazyMan</span> <span class="variable">instance</span> <span class="operator">=</span> declaredConstructor.newInstance();</span><br><span class="line"></span><br><span class="line">        System.out.println(instance);  <span class="comment">// com.thr.singleton.LazyMan@1540e19d</span></span><br><span class="line">        System.out.println(lazyMan1);  <span class="comment">// com.thr.singleton.LazyMan@677327b6</span></span><br><span class="line">        System.out.println(instance == lazyMan1);  <span class="comment">// false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="18-3-静态内部类"><a href="#18-3-静态内部类" class="headerlink" title="18.3 静态内部类"></a>18.3 静态内部类</h3><ul>
<li>使用<strong>静态内部类</strong>可以达到懒加载的效果，并且由于类加载机制保证了实例的唯一性和线程安全性<ul>
<li>还是防止不了反射，因为还是有私有构造器</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Holder</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Holder</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">InnerClass</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Holder</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Holder</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Holder <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> InnerClass.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="18-4-枚举-防止反射破坏单例"><a href="#18-4-枚举-防止反射破坏单例" class="headerlink" title="18.4 枚举-防止反射破坏单例"></a>18.4 枚举-防止反射破坏单例</h3><ul>
<li><p>Java的<strong>枚举</strong>提供了一种简洁的方式来实现单例</p>
<ul>
<li><strong>枚举自带防反射和防序列化破坏的功能</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.lang.reflect.Constructor.java 源码</span></span><br><span class="line"><span class="comment">// 可以看到在使用反射获取的构造器创建实例的源码底层设计了禁止通过反射创建枚举对象</span></span><br><span class="line"><span class="comment">// 如果是枚举类型，就会抛出异常</span></span><br><span class="line"><span class="keyword">if</span> ((clazz.getModifiers() &amp; Modifier.ENUM) != <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Cannot reflectively create enum objects&quot;</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>使用枚举不仅简单，而且由于<strong>Java虚拟机从根本上保证了每个枚举常量的唯一性</strong>，因此通过枚举实现的单例模式也是线程安全的</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// enum 本身就是一个 Class 类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">EnumSingle</span> &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> EnumSingle <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException &#123;</span><br><span class="line">        <span class="type">EnumSingle</span> <span class="variable">instance1</span> <span class="operator">=</span> EnumSingle.INSTANCE;</span><br><span class="line">        <span class="comment">// 查看枚举类的源码, 找到构造器, 尝试用反射获取</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            protected Enum(String name, int ordinal) &#123;</span></span><br><span class="line"><span class="comment">                this.name = name;</span></span><br><span class="line"><span class="comment">                this.ordinal = ordinal;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Constructor&lt;EnumSingle&gt; declaredConstructor = EnumSingle.class.getDeclaredConstructor(String.class, <span class="type">int</span>.class);</span><br><span class="line">        declaredConstructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用反射获取的构造器创建实例</span></span><br><span class="line">        <span class="comment">// 报错: java.lang.NoSuchMethodException: com.ogj.single.EnumSingle.&lt;init&gt;()</span></span><br><span class="line">        <span class="type">EnumSingle</span> <span class="variable">instance2</span> <span class="operator">=</span> declaredConstructor.newInstance();</span><br><span class="line">        System.out.println(instance1);</span><br><span class="line">        System.out.println(instance2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="19-CAS"><a href="#19-CAS" class="headerlink" title="19. CAS"></a>19. CAS</h2><h3 id="19-1-概述"><a href="#19-1-概述" class="headerlink" title="19.1 概述"></a>19.1 概述</h3><ul>
<li><p><strong>CAS（Compare-And-Swap）</strong>是一种用于实现同步原语的技术，广泛用于<strong>多线程编程中实现无锁的并发算法</strong></p>
<ul>
<li><strong>锁-Free机制</strong>：不依赖传统的锁机制（如互斥锁、读写锁）来同步线程的访问，而是通过原子操作来保证代码的安全执行</li>
</ul>
</li>
<li><p><strong>操作元素</strong>：CAS涉及三个基本操作数</p>
<ul>
<li>**V (内存位置)**：需要更新的内存地址</li>
<li>**A (预期原值)**：期望内存位置的值</li>
<li>**B (新值)**：如果位置的当前值与预期相符，需要写入的新值</li>
</ul>
</li>
<li><p><strong>工作原理</strong>：CAS操作会原子性地执行以下步骤</p>
<ul>
<li><strong>读取当前值</strong>：从内存位置V读取当前值</li>
<li><strong>比较当前值与预期值</strong>：检查内存位置的当前值是否与预期值A相等</li>
<li><strong>条件更新</strong>：如果当前值与预期值相等，那么将内存位置的值更新为新值B</li>
</ul>
</li>
<li><p><strong>缺点</strong>：</p>
<ul>
<li><strong>循环时间长、开销大</strong>：如果多个线程同时尝试更新同一变量，可能导致高CPU占用，因为线程需要在循环中不断尝试</li>
<li><strong>仅保证单一变量的原子性</strong>：对于涉及多个变量的复合操作，CAS无法直接保障其原子性</li>
<li><strong>ABA问题</strong>：变量在被更新前后可能会被改变多次，导致CAS认为没有变化，实际上值已经被修改过<ul>
<li>eg. 变量V先从A变为B，然后又从B变回A，那么使用CAS进行检查时会认为这个变量没有被修改过，但实际上它已经被修改了两次</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="19-2-代码示例"><a href="#19-2-代码示例" class="headerlink" title="19.2 代码示例"></a>19.2 代码示例</h3><ul>
<li>在 Java 中利用原子操作类实现，<code>java.util.concurrent.atomic</code> 包下的类例如<code>AtomicBoolean</code>，<code>AtomicInteger</code>，<code>AtomicLong</code>  以Atomic开头的包装类提供了 CAS 功能。它们分别用于 Boolean，Integer，Long 类型的原子性操作</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CASDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AtomicInteger</span> <span class="variable">atomicInteger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">2020</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// CAS操作：如果当前值为2020，则更新为2021</span></span><br><span class="line">        System.out.println(atomicInteger.compareAndSet(<span class="number">2020</span>, <span class="number">2021</span>)); <span class="comment">// true</span></span><br><span class="line">        System.out.println(atomicInteger.get()); <span class="comment">// 2021</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>Unsafe</code>类在Java中提供了一个低级别的非安全机制，包括对内存的直接操作和对CAS操作的支持<ul>
<li><code>Unsafe</code>提供的<code>compareAndSwap</code>方法<strong>直接映射到硬件的原子指令，使得Java能够利用这些底层指令来实现原子操作</strong></li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Unsafe.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndAddInt</span><span class="params">(Object var1, <span class="type">long</span> var2, <span class="type">int</span> var4)</span> &#123;</span><br><span class="line">    <span class="type">int</span> var5;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        var5 = <span class="built_in">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">    &#125; <span class="keyword">while</span>(!<span class="built_in">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));  <span class="comment">// 自旋锁</span></span><br><span class="line">    <span class="comment">// 比较当前工作内存中的值 和 主内存中的值，如果这个值是期望的，那么则执行操作！如果不是就一直循环，使用的是自旋锁</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 本地 native 方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">compareAndSwapInt</span><span class="params">(Object var1, <span class="type">long</span> var2, <span class="type">int</span> var4, <span class="type">int</span> var5)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="19-3-ABA-问题"><a href="#19-3-ABA-问题" class="headerlink" title="19.3 ABA 问题"></a>19.3 ABA 问题</h3><ul>
<li>本质是 CAS 操作只能检查变量当前的值是否与预期的值相同，但它不能检测在操作间隙内该值是否被修改过<ul>
<li>如果一个变量的值原先是A，被改变为B，然后又被改回A，使用CAS进行比较时将无法识别出变量已经被修改过</li>
</ul>
</li>
<li>举例：<ul>
<li><strong>初始状态</strong>：小童的账户余额为1000元</li>
<li><strong>操作序列</strong>：<ul>
<li><strong>线程1</strong>：尝试从账户中提取500元。它检查余额是否为1000元，并准备更新为500元</li>
<li><strong>线程1</strong> 成功执行，账户余额现在是500元</li>
<li><strong>线程2</strong> 也想从账户中提取500元。它开始时检查余额为1000元，但在它执行时，<strong>线程1</strong> 已经将余额改为500元。此时，<strong>线程2</strong> 被暂停或阻塞</li>
<li><strong>线程3</strong>（小童的妈妈）为账户汇入500元，余额恢复为1000元</li>
<li><strong>线程2</strong> 恢复执行，检查余额仍然为其记忆中的1000元，然后尝试将余额更新为500元。由于当前余额确实是1000元，CAS检查通过，余额被更新为500元</li>
</ul>
</li>
<li><strong>结果</strong>：账户本应仅被扣款500元，最终却被错误地扣款两次，余额变为500元</li>
</ul>
</li>
</ul>
<h3 id="19-4-解决-ABA-问题-带版本号的原子引用"><a href="#19-4-解决-ABA-问题-带版本号的原子引用" class="headerlink" title="19.4 解决 ABA 问题-带版本号的原子引用"></a>19.4 解决 ABA 问题-带版本号的原子引用</h3><ul>
<li>为了<strong>解决ABA问题，可以使用带版本号的原子引用</strong></li>
<li><code>AtomicStampedReference</code> 是Java提供的一个用于解决ABA问题的类。它通过维护一个“时间戳”（或称为版本号）来管理每个变量的版本，从而防止ABA问题<ul>
<li>每次变量更新都伴随一个版本号的增加，即使数据再次回到原始状态，版本号也会不同，从而避免ABA问题</li>
</ul>
</li>
<li>代码示例：<ul>
<li><strong>线程a</strong>：成功地两次改变了值，并且每次操作后版本号都递增了</li>
<li><strong>线程b</strong>：尽管在它执行时值又回到了1，但由于它的操作基于过时的版本号1，所以它的更新操作失败</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ABASolution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化AtomicStampedReference，初始值为1，初始版本号为1</span></span><br><span class="line">        AtomicStampedReference&lt;Integer&gt; objectAtomicStampedReference = <span class="keyword">new</span> <span class="title class_">AtomicStampedReference</span>&lt;&gt;(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第一个线程，模拟值的变更和版本号的更新</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">stamp</span> <span class="operator">=</span> objectAtomicStampedReference.getStamp(); <span class="comment">// 获取当前版本号</span></span><br><span class="line">            System.out.println(<span class="string">&quot;a1-&gt;&quot;</span> + stamp);  <span class="comment">// a1-&gt;1</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>); <span class="comment">// 线程休眠1秒，模拟操作延迟</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            objectAtomicStampedReference.compareAndSet(<span class="number">1</span>, <span class="number">2</span>,</span><br><span class="line">                    objectAtomicStampedReference.getStamp(), objectAtomicStampedReference.getStamp() + <span class="number">1</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;a2-&gt;&quot;</span> + objectAtomicStampedReference.getStamp());  <span class="comment">// a2-&gt;2</span></span><br><span class="line">            objectAtomicStampedReference.compareAndSet(<span class="number">2</span>, <span class="number">1</span>,</span><br><span class="line">                    objectAtomicStampedReference.getStamp(), objectAtomicStampedReference.getStamp() + <span class="number">1</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;a3-&gt;&quot;</span> + objectAtomicStampedReference.getStamp());  <span class="comment">// a3-&gt;3</span></span><br><span class="line">        &#125;, <span class="string">&quot;a&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第二个线程，尝试基于原始的版本号进行修改</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">stamp</span> <span class="operator">=</span> objectAtomicStampedReference.getStamp(); <span class="comment">// 获取版本号</span></span><br><span class="line">            System.out.println(<span class="string">&quot;b1-&gt;&quot;</span> + stamp);  <span class="comment">// b1-&gt;1</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>); <span class="comment">// 线程休眠2秒，等待第一个线程先行执行</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            objectAtomicStampedReference.compareAndSet(<span class="number">1</span>, <span class="number">6</span>, stamp, stamp + <span class="number">1</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;b2-&gt;&quot;</span> + objectAtomicStampedReference.getStamp());  <span class="comment">// b2-&gt;3</span></span><br><span class="line">            <span class="comment">// 值看似匹配，版本号不匹配，更新操作失败。打印最终的版本号，仍为b2-&gt;3（未能更新，版本号没有变化）</span></span><br><span class="line">        &#125;, <span class="string">&quot;b&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>注意</strong>：</p>
<ul>
<li><strong><code>compareAndSet</code>方法内部使用<code>==</code>来比较当前引用和传入的期望引用</strong>。对于<code>Integer</code>类型，这种比较是基于对象的内存地址，而非其数值</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">compareAndSet</span><span class="params">(V   expectedReference,</span></span><br><span class="line"><span class="params">                             V   newReference,</span></span><br><span class="line"><span class="params">                             <span class="type">int</span> expectedStamp,</span></span><br><span class="line"><span class="params">                             <span class="type">int</span> newStamp)</span> &#123;</span><br><span class="line">    Pair&lt;V&gt; current = pair;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">        expectedReference == current.reference &amp;&amp;</span><br><span class="line">        expectedStamp == current.stamp &amp;&amp;</span><br><span class="line">        ((newReference == current.reference &amp;&amp;</span><br><span class="line">          newStamp == current.stamp) ||</span><br><span class="line">         casPair(current, Pair.of(newReference, newStamp)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>自动装箱问题</strong>：<ul>
<li>在Java中，整数类型如<code>Integer</code>在-128到127之间使用了对象缓存机制。超出这个范围，或者在特定情况下，整数会被重新装箱成新的对象，导致即使数值相同，内存地址也可能不同</li>
<li>在<code>compareAndSet</code>操作中，如果期望的引用数值是通过字面量或计算得出的新<code>Integer</code>对象，可能会因为对象地址不同而导致比较失败</li>
<li>所以使用 Integer 作为泛型进行测试时，如果使用的数字大于128了，使用原子引用时就不会进行版本上升</li>
</ul>
</li>
<li>正常业务操作中，我们一般使用的是对象类型作为泛型(如 User 类)，一般情况不会遇到这种情况</li>
</ul>
</li>
</ul>
<h2 id="20-理解各种锁"><a href="#20-理解各种锁" class="headerlink" title="20. 理解各种锁"></a>20. 理解各种锁</h2><h3 id="20-1-公平锁、非公平锁"><a href="#20-1-公平锁、非公平锁" class="headerlink" title="20.1 公平锁、非公平锁"></a>20.1 公平锁、非公平锁</h3><ul>
<li><strong>公平锁</strong>：<ul>
<li>确保获取锁的顺序按照线程请求锁的顺序来进行，即<strong>先到先得</strong></li>
<li>可以防止线程饥饿，但可能导致整体吞吐量较低，因为每次都需要在多个线程中严格排序</li>
</ul>
</li>
<li><strong>非公平锁</strong>：<ul>
<li>允许插队，不保证请求锁的顺序，可以<strong>减少线程切换的开销</strong>，提高系统整体的吞吐量</li>
<li><strong>可能导致线程饥饿</strong>，即某些线程可能长时间获取不到锁</li>
</ul>
</li>
<li><strong>用法：</strong> 在创建可重入锁时，想构造器中传入true</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">fairLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(<span class="literal">true</span>); <span class="comment">// 公平锁</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">unfairLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(); <span class="comment">// 非公平锁，默认为非公平</span></span><br></pre></td></tr></table></figure>

<ul>
<li>ReentrantLock 的构造器源码如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">()</span> &#123;  <span class="comment">// 公平锁</span></span><br><span class="line">    sync = <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">(<span class="type">boolean</span> fair)</span> &#123;  <span class="comment">// 非公平锁</span></span><br><span class="line">    sync = fair ? <span class="keyword">new</span> <span class="title class_">FairSync</span>() : <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="20-2-可重入锁-递归锁"><a href="#20-2-可重入锁-递归锁" class="headerlink" title="20.2 可重入锁(递归锁)"></a>20.2 可重入锁(递归锁)</h3><ul>
<li><strong>可重入锁</strong>允许线程进入任何一个它已经拥有的锁同步的代码块<ul>
<li>synchronized 和 lock 都是可重入锁</li>
</ul>
</li>
<li><code>synchronized</code>关键字提供的锁是内置的Java关键字，并且是<strong>隐式的可重入锁</strong>，不用手工上锁与解锁</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Phone</span> <span class="variable">phone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            phone.sms();</span><br><span class="line">        &#125;,<span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            phone.sms();</span><br><span class="line">        &#125;,<span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Phone</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sms</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;=&gt; sms&quot;</span>);</span><br><span class="line">        call(); <span class="comment">// 再次获取同一把对象锁</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;=&gt; call&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>Lock</code>是<strong>显式的可重入</strong>锁，必须手动地锁定和解锁</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Phone2</span> &#123;</span><br><span class="line">    <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sms</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// lock锁必须配对，否则会死锁</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;=&gt; sms&quot;</span>);</span><br><span class="line">            call(); <span class="comment">// 再次获取同一把锁</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;=&gt; call&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="20-3-自旋锁"><a href="#20-3-自旋锁" class="headerlink" title="20.3 自旋锁"></a>20.3 自旋锁</h3><ul>
<li><p><strong>自旋锁</strong>是指尝试获取锁的线程不会立即阻塞，而是<strong>采用循环的方式尝试获取锁</strong>，这样可以减少线程上下文切换的消耗，提高效率</p>
</li>
<li><p><strong>代码示例</strong>：设计一个自己的锁</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpinLock</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">AtomicBoolean</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicBoolean</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取锁的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (!lock.compareAndSet(<span class="literal">false</span>, <span class="literal">true</span>)) &#123;</span><br><span class="line">            <span class="comment">// 自旋等待直到锁被释放</span></span><br><span class="line">            <span class="comment">// 在这里进行自旋等待意味着不停地循环，直到获取到锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放锁的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.set(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>测试类</strong>：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestSpinLock</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">SpinLock</span> <span class="variable">spinLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SpinLock</span>();  <span class="comment">// 创建自旋锁的实例</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 线程1尝试获取锁，然后睡眠3秒，最后释放锁</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 尝试获取锁&quot;</span>);</span><br><span class="line">            spinLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 获取到锁&quot;</span>);</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                spinLock.unlock();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 释放锁&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 让主线程稍微延迟1秒，确保t1线程先运行</span></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 线程2也尝试获取锁，然后同样睡眠3秒，之后释放锁</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 尝试获取锁&quot;</span>);</span><br><span class="line">            spinLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 获取到锁&quot;</span>);</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                spinLock.unlock();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 释放锁&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>运行过程</strong>：<ul>
<li><strong>t1线程</strong>首先启动，尝试并成功获取自旋锁。获取锁后，它将持有锁3秒钟，期间其他线程不能获取锁</li>
<li><strong>t2线程</strong>随后启动，由于t1线程已经持有锁，<strong>t2线程会进入自旋状态</strong>，不断尝试获取锁，直到t1线程释放锁</li>
<li>当t1线程释放锁后，t2线程立即获取锁，然后也保持3秒后释放</li>
</ul>
</li>
</ul>
<h3 id="20-4-死锁"><a href="#20-4-死锁" class="headerlink" title="20.4 死锁"></a>20.4 死锁</h3><ul>
<li><p>死锁是多个线程在执行过程中因争夺资源而造成的一种僵局</p>
</li>
<li><p><strong>代码示例</strong>：<strong>背</strong></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadLockDemo</span> &#123;</span><br><span class="line">    <span class="comment">// 创建两个资源</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">resource1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">resource2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (resource1) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 持有资源1，试图获取资源2&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (resource2) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 获取资源2&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;Thread-1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (resource2) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 持有资源2，试图获取资源1&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (resource1) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 获取资源1&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;Thread-2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>检测死锁</strong>：</p>
<ul>
<li><strong>jps（Java Virtual Machine Process Status Tool）</strong>：<ul>
<li>用于查看在系统中运行的Java进程</li>
<li>命令：<code>jps -l</code>（列出系统中所有Java进程的PID和主类的全名）</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B.assets/image-20240513214925881.png" alt="image-20240513214925881"></p>
<ul>
<li><strong>jstack</strong>：<ul>
<li>用于生成Java虚拟机当前时刻的线程快照（<strong>堆栈跟踪</strong>）</li>
<li>命令：<code>jstack [pid]</code>（<code>pid</code>是通过<code>jps</code>查到的Java进程ID）</li>
<li>死锁信息通常出现在输出的最后部分，标识为Deadlock</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B.assets/image-20240513214900923.png" alt="image-20240513214900923"></p>
</li>
</ul>
<blockquote>
<p>排查问题的方法：日志、堆栈信息</p>
</blockquote>
<h3 id="20-5-乐观-悲观锁"><a href="#20-5-乐观-悲观锁" class="headerlink" title="20.5 乐观&#x2F;悲观锁"></a>20.5 乐观&#x2F;悲观锁</h3><ul>
<li><p>在Java中，乐观锁和悲观锁是用于管理并发操作中数据一致性和完整性的两种策略</p>
</li>
<li><p><strong>悲观锁</strong>：假设最坏的情况，即认为数据在被读取的同时，一定会有其他线程来尝试修改这些数据</p>
<ul>
<li>因此，<strong>悲观锁在数据被读取时立即对其进行锁定，直到事务完成才释放锁</strong>。这种锁的主要目的是避免数据被其他事务修改</li>
<li>在Java中，悲观锁可以通过<code>synchronized</code>关键字或<code>Lock</code>接口实现的各种锁（如<code>ReentrantLock</code>）实现</li>
</ul>
</li>
<li><p><strong>乐观锁</strong>：基于数据不会被频繁修改的假设，每次去更新数据时，它都会假设没有其他线程对这些数据进行修改</p>
<ul>
<li>乐观锁通常会使用版本号或时间戳来实现</li>
<li>Java 中使用<code>Atomic</code>类（如<code>AtomicInteger</code>, <code>AtomicReference</code>）提供的原子操作实现乐观锁</li>
</ul>
</li>
<li><p><strong>使用场景比较</strong>：</p>
<ul>
<li><p><strong>悲观锁</strong>更适合写操作多的场景，可以避免数据更新的冲突</p>
</li>
<li><p><strong>乐观锁</strong>适用于读操作多的场景，减少了锁的开销，可以提高查询性能，但需要处理更新失败的情况</p>
</li>
</ul>
</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://tangsmallrong.github.io">thr</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://tangsmallrong.github.io/2024/05/14/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">https://tangsmallrong.github.io/2024/05/14/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://tangsmallrong.github.io" target="_blank">thr's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/juc/">juc</a></div><div class="post_share"></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/07/14/Lua%E8%84%9A%E6%9C%AC/" title="Lua 脚本"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Lua 脚本</div></div></a></div><div class="next-post pull-right"><a href="/2024/05/01/Java%E9%9B%86%E5%90%88/" title="Java 集合"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Java 集合</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#JUC"><span class="toc-text">JUC</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="toc-text">1. 基本介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-wait-%E5%92%8C-sleep-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">2. wait 和 sleep 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Lock-%E9%94%81-%E9%87%8D%E7%82%B9"><span class="toc-text">3. Lock 锁(重点)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E4%BC%A0%E7%BB%9F%E7%9A%84-Synchronized-%E9%94%81"><span class="toc-text">3.1 传统的 Synchronized 锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-Lock-%E9%94%81"><span class="toc-text">3.2 Lock 锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-Synchronized-VS-Lock"><span class="toc-text">3.3 Synchronized VS. Lock</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E7%94%9F%E4%BA%A7%E8%80%85%E5%92%8C%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98-%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1"><span class="toc-text">4. 生产者和消费者问题-线程通信</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-Synchronized-%E7%89%88"><span class="toc-text">4.1 Synchronized 版</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-Lock-%E7%89%88"><span class="toc-text">4.2 Lock 版</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-8%E9%94%81%E7%8E%B0%E8%B1%A1"><span class="toc-text">5. 8锁现象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-%E4%B8%80%E5%AF%B9%E8%B1%A1%EF%BC%8C%E4%B8%A4%E5%90%8C%E6%AD%A5"><span class="toc-text">5.1 一对象，两同步</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-%E4%B8%80%E5%AF%B9%E8%B1%A1%EF%BC%8C%E4%B8%A4%E5%90%8C%E6%AD%A5%EF%BC%8C%E5%BB%B6%E8%BF%9F4s"><span class="toc-text">5.2 一对象，两同步，延迟4s</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-%E4%B8%80%E5%AF%B9%E8%B1%A1%EF%BC%8C%E4%B8%80%E5%90%8C%E6%AD%A5%EF%BC%8C%E4%B8%80%E6%99%AE%E9%80%9A"><span class="toc-text">5.3 一对象，一同步，一普通</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-%E4%B8%A4%E5%AF%B9%E8%B1%A1%EF%BC%8C%E4%B8%A4%E5%90%8C%E6%AD%A5"><span class="toc-text">5.4 两对象，两同步</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5-%E4%B8%80%E5%AF%B9%E8%B1%A1%EF%BC%8C%E4%B8%A4%E9%9D%99%E6%80%81%E5%90%8C%E6%AD%A5"><span class="toc-text">5.5 一对象，两静态同步</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-6-%E4%B8%A4%E5%AF%B9%E8%B1%A1%EF%BC%8C%E4%B8%A4%E9%9D%99%E6%80%81%E5%90%8C%E6%AD%A5"><span class="toc-text">5.6 两对象，两静态同步</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-7-%E4%B8%80%E5%AF%B9%E8%B1%A1%EF%BC%8C%E4%B8%80%E5%90%8C%E6%AD%A5%EF%BC%8C%E4%B8%80%E9%9D%99%E6%80%81%E5%90%8C%E6%AD%A5"><span class="toc-text">5.7 一对象，一同步，一静态同步</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-8-%E4%B8%A4%E5%AF%B9%E8%B1%A1%EF%BC%8C%E4%B8%80%E5%90%8C%E6%AD%A5%EF%BC%8C%E4%B8%80%E9%9D%99%E6%80%81%E5%90%8C%E6%AD%A5"><span class="toc-text">5.8 两对象，一同步，一静态同步</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84%E9%9B%86%E5%90%88%E7%B1%BB"><span class="toc-text">6. 线程不安全的集合类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-List"><span class="toc-text">6.1 List</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-Set"><span class="toc-text">6.2 Set</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-Map"><span class="toc-text">6.3 Map</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-%E6%80%BB%E7%BB%93"><span class="toc-text">6.4 总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-Callable-%E6%8E%A5%E5%8F%A3"><span class="toc-text">7. Callable 接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E5%B8%B8%E7%94%A8%E7%9A%84%E8%BE%85%E5%8A%A9%E7%B1%BB"><span class="toc-text">8. 常用的辅助类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-CountDownLatch"><span class="toc-text">8.1 CountDownLatch</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-CyclicBarrier"><span class="toc-text">8.2 CyclicBarrier</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-Semaphore"><span class="toc-text">8.3 Semaphore</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E8%AF%BB%E5%86%99%E9%94%81-ReadWriteLock"><span class="toc-text">9. 读写锁 ReadWriteLock</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-1-%E6%A6%82%E8%BF%B0"><span class="toc-text">9.1 概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-%E8%AF%BB%E5%86%99%E9%94%81%E7%89%B9%E7%82%B9"><span class="toc-text">9.2 读写锁特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-3-%E9%94%81%E9%99%8D%E7%BA%A7"><span class="toc-text">9.3 锁降级</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97"><span class="toc-text">10. 阻塞队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#10-1-%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="toc-text">10.1 基本介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-2-%E5%9B%9B%E7%BB%84-API"><span class="toc-text">10.2 四组 API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-3-SynchronousQueue-%E5%90%8C%E6%AD%A5%E9%98%9F%E5%88%97"><span class="toc-text">10.3 SynchronousQueue 同步队列</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-%E7%BA%BF%E7%A8%8B%E6%B1%A0-%E9%87%8D%E7%82%B9"><span class="toc-text">11. 线程池(重点)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#11-1-%E6%A6%82%E8%BF%B0"><span class="toc-text">11.1 概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-2-%E4%B8%89%E5%A4%A7%E6%96%B9%E6%B3%95"><span class="toc-text">11.2 三大方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-3-%E4%B8%83%E5%A4%A7%E5%8F%82%E6%95%B0-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-text">11.3 七大参数-自定义线程池</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-4-%E5%9B%9B%E7%A7%8D%E7%AD%96%E7%95%A5"><span class="toc-text">11.4 四种策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-5-%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AE%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%9C%80%E5%A4%A7%E5%A4%A7%E5%B0%8F"><span class="toc-text">11.5 如何设置线程池的最大大小</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-%E5%9B%9B%E5%A4%A7%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3-%E5%BF%85%E9%A1%BB%E6%8E%8C%E6%8F%A1%EF%BC%81"><span class="toc-text">12. 四大函数式接口(必须掌握！)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#12-1-%E6%A6%82%E8%BF%B0"><span class="toc-text">12.1 概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-2-Function-%E6%8E%A5%E5%8F%A3"><span class="toc-text">12.2 Function 接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-3-Predicate-%E6%8E%A5%E5%8F%A3"><span class="toc-text">12.3 Predicate 接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-4-Consumer-%E6%8E%A5%E5%8F%A3"><span class="toc-text">12.4 Consumer 接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-5-Supplier-%E6%8E%A5%E5%8F%A3"><span class="toc-text">12.5 Supplier 接口</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-Stream-%E6%B5%81%E5%BC%8F%E8%AE%A1%E7%AE%97"><span class="toc-text">13. Stream 流式计算</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-Fork-Join-%E5%88%86%E6%94%AF%E5%90%88%E5%B9%B6"><span class="toc-text">14. Fork&#x2F;Join 分支合并</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#14-1-%E6%A6%82%E8%BF%B0"><span class="toc-text">14.1 概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-2-%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B"><span class="toc-text">14.2 代码示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-%E5%BC%82%E6%AD%A5%E5%9B%9E%E8%B0%83"><span class="toc-text">15. 异步回调</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#15-1-%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5"><span class="toc-text">15.1 同步和异步</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-2-CompletableFuture"><span class="toc-text">15.2 CompletableFuture</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-3-Future-VS-CompletableFuture"><span class="toc-text">15.3 Future VS. CompletableFuture</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-JMM"><span class="toc-text">16. JMM</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-Volatile"><span class="toc-text">17. Volatile</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#17-1-%E6%A6%82%E8%BF%B0"><span class="toc-text">17.1 概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-2-%E4%BF%9D%E8%AF%81%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="toc-text">17.2 保证可见性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-3-%E4%B8%8D%E4%BF%9D%E8%AF%81%E5%8E%9F%E5%AD%90%E6%80%A7"><span class="toc-text">17.3 不保证原子性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-4-%E9%98%B2%E6%AD%A2%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92"><span class="toc-text">17.4 防止指令重排</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="toc-text">18. 单例模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#18-1-%E9%A5%BF%E6%B1%89%E5%BC%8F"><span class="toc-text">18.1 饿汉式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-2-%E6%87%92%E6%B1%89%E5%BC%8F-DCL%E5%AE%9E%E7%8E%B0"><span class="toc-text">18.2 懒汉式-DCL实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-3-%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-text">18.3 静态内部类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-4-%E6%9E%9A%E4%B8%BE-%E9%98%B2%E6%AD%A2%E5%8F%8D%E5%B0%84%E7%A0%B4%E5%9D%8F%E5%8D%95%E4%BE%8B"><span class="toc-text">18.4 枚举-防止反射破坏单例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19-CAS"><span class="toc-text">19. CAS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#19-1-%E6%A6%82%E8%BF%B0"><span class="toc-text">19.1 概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-2-%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B"><span class="toc-text">19.2 代码示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-3-ABA-%E9%97%AE%E9%A2%98"><span class="toc-text">19.3 ABA 问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-4-%E8%A7%A3%E5%86%B3-ABA-%E9%97%AE%E9%A2%98-%E5%B8%A6%E7%89%88%E6%9C%AC%E5%8F%B7%E7%9A%84%E5%8E%9F%E5%AD%90%E5%BC%95%E7%94%A8"><span class="toc-text">19.4 解决 ABA 问题-带版本号的原子引用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20-%E7%90%86%E8%A7%A3%E5%90%84%E7%A7%8D%E9%94%81"><span class="toc-text">20. 理解各种锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#20-1-%E5%85%AC%E5%B9%B3%E9%94%81%E3%80%81%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81"><span class="toc-text">20.1 公平锁、非公平锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-2-%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81-%E9%80%92%E5%BD%92%E9%94%81"><span class="toc-text">20.2 可重入锁(递归锁)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-3-%E8%87%AA%E6%97%8B%E9%94%81"><span class="toc-text">20.3 自旋锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-4-%E6%AD%BB%E9%94%81"><span class="toc-text">20.4 死锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-5-%E4%B9%90%E8%A7%82-%E6%82%B2%E8%A7%82%E9%94%81"><span class="toc-text">20.5 乐观&#x2F;悲观锁</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By thr</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>