<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Java 集合 | thr's blog</title><meta name="author" content="thr"><meta name="copyright" content="thr"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="Java 集合 学习视频：【韩顺平讲Java】Java集合专题 -ArrayList HashMap HashSet List Map TreeMap TreeSet等_哔哩哔哩_bilibili  1. 集合介绍 数组的不足：不够灵活 长度开始时必须指定，而且一旦指定，不能更改 保存的必须为同一类型的元素 使用数组进行增加元素的示意代码比较麻烦    12345678&#x2F;&#x2F; 数组扩容示例代码Per">
<meta property="og:type" content="article">
<meta property="og:title" content="Java 集合">
<meta property="og:url" content="https://tangsmallrong.github.io/2024/05/01/Java%E9%9B%86%E5%90%88/index.html">
<meta property="og:site_name" content="thr&#39;s blog">
<meta property="og:description" content="Java 集合 学习视频：【韩顺平讲Java】Java集合专题 -ArrayList HashMap HashSet List Map TreeMap TreeSet等_哔哩哔哩_bilibili  1. 集合介绍 数组的不足：不够灵活 长度开始时必须指定，而且一旦指定，不能更改 保存的必须为同一类型的元素 使用数组进行增加元素的示意代码比较麻烦    12345678&#x2F;&#x2F; 数组扩容示例代码Per">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://tangsmallrong.github.io/img/avatar.jpg">
<meta property="article:published_time" content="2024-05-01T12:32:34.000Z">
<meta property="article:modified_time" content="2024-05-14T03:50:02.964Z">
<meta property="article:author" content="thr">
<meta property="article:tag" content="collection">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://tangsmallrong.github.io/img/avatar.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://tangsmallrong.github.io/2024/05/01/Java%E9%9B%86%E5%90%88/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: thr","link":"链接: ","source":"来源: thr's blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java 集合',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-05-14 11:50:02'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.0.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/./img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">12</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">12</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="thr's blog"><span class="site-name">thr's blog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">Java 集合</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-05-01T12:32:34.000Z" title="发表于 2024-05-01 20:32:34">2024-05-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-05-14T03:50:02.964Z" title="更新于 2024-05-14 11:50:02">2024-05-14</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/">Java</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">24.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>94分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Java 集合"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><h1 id="Java-集合"><a href="#Java-集合" class="headerlink" title="Java 集合"></a>Java 集合</h1><blockquote>
<p>学习视频：<br><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1YA411T76k/?spm_id_from=333.999.0.0">【韩顺平讲Java】Java集合专题 -ArrayList HashMap HashSet List Map TreeMap TreeSet等_哔哩哔哩_bilibili</a></p>
</blockquote>
<h2 id="1-集合介绍"><a href="#1-集合介绍" class="headerlink" title="1. 集合介绍"></a>1. 集合介绍</h2><ul>
<li><strong>数组的不足</strong>：<strong>不够灵活</strong><ul>
<li>长度开始时必须指定，而且一旦指定，不能更改</li>
<li>保存的必须为同一类型的元素</li>
<li>使用数组进行增加元素的示意代码比较麻烦</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组扩容示例代码</span></span><br><span class="line">Person[] pers = <span class="keyword">new</span> <span class="title class_">Person</span>[<span class="number">1</span>];</span><br><span class="line">pers[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩容</span></span><br><span class="line">Person[] pers2 = <span class="keyword">new</span> <span class="title class_">Person</span>[pers.length + <span class="number">1</span>]  <span class="comment">// 创建新数组</span></span><br><span class="line"><span class="keyword">for</span>() &#123;&#125;  <span class="comment">// 拷贝 pers 数组的元素到 pers2</span></span><br><span class="line">pers2[pers2.length - <span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">Person</span>();  <span class="comment">// 添加新的对象</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>集合的好处</strong>：<ul>
<li>可以<strong>动态保存</strong>任意多个对象，使用比较方便</li>
<li>提供了一系列方便的操作对象的方法(crud)：add、remove、set、get 等</li>
<li>使用集合添加，删除新元素代码更加简洁</li>
</ul>
</li>
</ul>
<h2 id="2-集合的框架体系-背"><a href="#2-集合的框架体系-背" class="headerlink" title="2. 集合的框架体系-背"></a>2. 集合的框架体系-背</h2><ul>
<li><strong>Collection 接口</strong>继承了 Iterable 接口<ul>
<li>List Set 接口继承了 Collection 接口</li>
<li>List 接口常用的实现类有 ArrayList,LinkedList</li>
<li>Set 接口常用的实现类有 HashSet,TreeSet</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/Java%E9%9B%86%E5%90%88.assets/image-20240429195653117.png" alt="image-20240429195653117"></p>
<ul>
<li><strong>Map 接口</strong><ul>
<li>常见实现类：HashMap、LinkedHashMap、TreeMap</li>
<li>LinkedHashMap 继承了 HashMap 的同时实现了 Map 接口</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/Java%E9%9B%86%E5%90%88.assets/image-20240420134000294.png" alt="image-20240420134000294"></p>
<ul>
<li>集合主要有2组：<ul>
<li>一组是<strong>单列集合</strong>（集合里面放的是单个对象）<ul>
<li>Collection 接口有 List 和 Set 这两个主要的接口，他们的实现类都是单列集合</li>
</ul>
</li>
<li>另一组是<strong>双列集合</strong>（存储的往往是键值对形式的）<ul>
<li>Map 接口的实现子类是双列集合，存放 key 和 value 数据</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="3-Collection"><a href="#3-Collection" class="headerlink" title="3. Collection"></a>3. Collection</h2><h3 id="3-1-Collection-接口实现类的特点"><a href="#3-1-Collection-接口实现类的特点" class="headerlink" title="3.1 Collection 接口实现类的特点"></a>3.1 Collection 接口实现类的特点</h3><ul>
<li><strong>接口声明</strong>： <code>Collection</code> 是一个泛型接口，继承自 <code>Iterable</code> 接口，允许其实现类的对象能被迭代</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Collection</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">Iterable</span>&lt;E&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>Collection 实现子类可以存放多个元素，每个元素可以是Object</li>
<li>不同的 Collection 实现具有不同的元素存储特性：<ul>
<li><strong>允许重复元素</strong>：例如 <code>List</code> 实现类（如 <code>ArrayList</code>, <code>LinkedList</code>）允许插入重复元素。</li>
<li><strong>不允许重复元素</strong>：<code>Set</code> 实现类（如 <code>HashSet</code>, <code>TreeSet</code>）保证元素唯一性。</li>
</ul>
</li>
<li>集合是否有序取决于具体实现：<ul>
<li><strong>有序集合</strong>：<code>List</code> 接口的实现类保持元素插入的顺序。</li>
<li><strong>无序集合</strong>：<code>Set</code> 接口的实现类通常不保持任何特定顺序（<code>LinkedHashSet</code> 除外，它按照插入顺序维护元素）。</li>
</ul>
</li>
<li>Collection 接口没有直接的实现子类，是通过它的子接口 Set 和 List 来实现的</li>
</ul>
<h3 id="3-2-Collection-接口常用方法"><a href="#3-2-Collection-接口常用方法" class="headerlink" title="3.2 Collection 接口常用方法"></a>3.2 Collection 接口常用方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Collection 接口常用方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CollectionMethod</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// add: 添加单个元素</span></span><br><span class="line">        list.add(<span class="string">&quot;hhh&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;10&quot;</span>);  <span class="comment">// 自动装箱 相当于 list.add(new Integer(10))</span></span><br><span class="line">        list.add(<span class="literal">true</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;list = &quot;</span> + list);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// remove: 删除指定元素</span></span><br><span class="line">        <span class="comment">// list.remove(0);  // 删除第一个元素</span></span><br><span class="line">        list.remove(<span class="literal">true</span>);  <span class="comment">// 指定删除某个元素</span></span><br><span class="line">        System.out.println(<span class="string">&quot;list = &quot;</span> + list);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// contains: 查找元素是否存在</span></span><br><span class="line">        System.out.println(list.contains(<span class="string">&quot;hhh&quot;</span>));  <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// size: 获取元素个数</span></span><br><span class="line">        System.out.println(list.size());  <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// isEmpty: 判断是否为空</span></span><br><span class="line">        System.out.println(list.isEmpty());  <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// clear: 清空</span></span><br><span class="line">        list.clear();</span><br><span class="line">        System.out.println(<span class="string">&quot;list = &quot;</span> + list);  <span class="comment">// list = []</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// addAll: 添加多个元素</span></span><br><span class="line">        ArrayList&lt;Object&gt; list2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list2.add(<span class="string">&quot;111&quot;</span>);</span><br><span class="line">        list2.add(<span class="string">&quot;222&quot;</span>);</span><br><span class="line">        list2.add(<span class="string">&quot;333&quot;</span>);</span><br><span class="line">        list.addAll(list2);</span><br><span class="line">        System.out.println(<span class="string">&quot;list = &quot;</span> + list);  <span class="comment">// list = [111, 222, 333]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// containsAll: 查找多个元素是否都存在</span></span><br><span class="line">        System.out.println(list.containsAll(list2));  <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// removeAll: 删除多个元素</span></span><br><span class="line">        list.add(<span class="string">&quot;444&quot;</span>);</span><br><span class="line">        list.removeAll(list2);</span><br><span class="line">        System.out.println(<span class="string">&quot;list = &quot;</span> + list);  <span class="comment">// list = [444]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/Java%E9%9B%86%E5%90%88.assets/image-20240420141355143.png" alt="image-20240420141355143"></p>
<h3 id="3-3-Collection-接口遍历元素"><a href="#3-3-Collection-接口遍历元素" class="headerlink" title="3.3 Collection 接口遍历元素"></a>3.3 Collection 接口遍历元素</h3><h4 id="遍历元素方式1—使用-Iterator-迭代器"><a href="#遍历元素方式1—使用-Iterator-迭代器" class="headerlink" title="遍历元素方式1—使用 Iterator 迭代器"></a>遍历元素方式1—使用 Iterator 迭代器</h4><ul>
<li><p>迭代器是一个对象，这个对象实现了 <code>Iterator</code> 接口，主要用于遍历 Collection 集合中的元素，该接口包含几个方法：</p>
<ul>
<li><code>hasNext()</code>: 检查集合中是否还有元素可以遍历。如果有，返回 <code>true</code>；如果没有，返回 <code>false</code>。</li>
<li><code>next()</code>: 迭代器将其内部游标向前移动到下一个元素的位置，同时返回游标所到达位置的元素。</li>
</ul>
<blockquote>
<p>在调用 next() 方法之前必须要调用 hasNext() 进行检测，若不调用且下一条记录无效，直接调用 next() 会抛出 NoSuchElementException 异常</p>
</blockquote>
<ul>
<li><code>remove()</code>: 删除最近通过 <code>next()</code> 方法返回的元素。这个方法是可选的，集合本身可以不支持这个操作。</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/Java%E9%9B%86%E5%90%88.assets/image-20240420145421113.png" alt="image-20240420145421113"></p>
<ul>
<li>使用迭代器可以<strong>通过一个统一的接口遍历不同类型的集合（如 <code>ArrayList</code>, <code>HashSet</code> 等），而不必关心它们内部是如何组织数据的</strong></li>
<li>所有<strong>实现了Collection 接口的集合类都有一个 iterator() 方法</strong>，用于返回一个实现了 Iterator 接口的对象，即可以返回一个迭代器</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/Java%E9%9B%86%E5%90%88.assets/image-20240420145934243.png" alt="image-20240420145934243"></p>
<ul>
<li><p><strong>Iterator 仅用于遍历集合，Iterator 本身不存放对象</strong></p>
</li>
<li><p><strong>代码示例</strong>：快捷键 <code>itit</code></p>
<ul>
<li>（提示所有快捷键的快捷键：<code>ctrl + j</code>）</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CollectionIterator</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Collection</span> <span class="variable">col</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line"></span><br><span class="line">        col.add(<span class="keyword">new</span> <span class="title class_">Book</span>(<span class="string">&quot;11&quot;</span>, <span class="string">&quot;1&quot;</span>, <span class="number">1.1</span>));</span><br><span class="line">        col.add(<span class="keyword">new</span> <span class="title class_">Book</span>(<span class="string">&quot;22&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="number">2.2</span>));</span><br><span class="line">        col.add(<span class="keyword">new</span> <span class="title class_">Book</span>(<span class="string">&quot;33&quot;</span>, <span class="string">&quot;3&quot;</span>, <span class="number">3.3</span>));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;col = &quot;</span> + col);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历集合</span></span><br><span class="line">        <span class="comment">// 1. 先得到 col 对应的迭代器</span></span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> col.iterator();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 使用 while 循环遍历, 快捷键 itit</span></span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;  <span class="comment">// 判断是否还有数据</span></span><br><span class="line">            <span class="comment">// 返回下一个元素, 类型为 Object</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">            System.out.println(<span class="string">&quot;obj = &quot;</span> + obj);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3. 当退出 while 循环后, 这时 iterator 迭代器指向最后的元素</span></span><br><span class="line">        <span class="comment">// 4. 若希望再次遍历, 需要重置迭代器</span></span><br><span class="line">        iterator = col.iterator();</span><br><span class="line">        System.out.println(<span class="string">&quot;======第二次遍历&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;  </span><br><span class="line">            <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">            System.out.println(<span class="string">&quot;obj = &quot;</span> + obj);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="遍历元素方式2—使用-for-循环增强"><a href="#遍历元素方式2—使用-for-循环增强" class="headerlink" title="遍历元素方式2—使用 for 循环增强"></a>遍历元素方式2—使用 for 循环增强</h4><ul>
<li>增强 for循环，可以代替 iterator 迭代器，特点：<strong>增强 for 就是简化版的 iterator</strong>，本质一样。只能用于<strong>遍历集合或数组</strong></li>
<li><strong>基本语法</strong>：</li>
<li>“元素类型”是集合或数组中包含的元素的数据类型</li>
<li>“元素变量”是在循环体内部用于访问当前遍历元素的变量名</li>
<li>“集合名或数组名”是要遍历的集合或数组的变量名</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (元素类型 元素变量 : 集合对象或数组) &#123;</span><br><span class="line">    <span class="comment">// 访问元素变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>代码示例</strong>：快捷键 <code>I</code> 或者 <code>集合对象.for</code><ul>
<li>补充：传统 for 循环的快捷键：<code>fori</code></li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用增强 for 遍历集合</span></span><br><span class="line"><span class="keyword">for</span> (Object book : col) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;book = &quot;</span> + book);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 增强 for 也可以直接在数组使用</span></span><br><span class="line"><span class="type">int</span>[] nums = &#123;<span class="number">1</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">90</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i : nums) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;i = &quot;</span> + i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>使用注意事项</strong>：</p>
<ul>
<li><p><strong>只读遍历</strong>：使用增强 <code>for</code> 循环时，不能修改正在遍历的集合的结构，例如添加或删除元素，这可能会导致 <code>ConcurrentModificationException</code> 异常。如果需要在遍历过程中修改集合，应使用显式的迭代器并调用其 <code>remove()</code> 方法</p>
</li>
<li><p><strong>遍历对象类型</strong>：增强 <code>for</code> 循环可以遍历任何实现了 <code>Iterable</code> 接口的集合类以及所有类型的数组</p>
</li>
<li><p><strong>局限性</strong>：尽管增强 <code>for</code> 循环语法简单，但它<strong>不适合在需要使用元素索引或需要从集合中间开始遍历的场景</strong>。在这种情况下，使用传统的 <code>for</code> 循环会更合适</p>
</li>
</ul>
</li>
</ul>
<h3 id="3-4-练习题"><a href="#3-4-练习题" class="headerlink" title="3.4 练习题"></a>3.4 练习题</h3><p>编写程序 <code>CollectionExercise</code>：</p>
<ul>
<li>创建3个Dog{name,age}对象,放入到ArrayList中，赋给List使用</li>
<li>用迭代器和增强for循环两种方式来遍历</li>
<li>重写Dog的toString方法，输出name和age</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CollectionEx</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Dog&gt; dogLists = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  <span class="comment">// 接口多态的传递</span></span><br><span class="line"></span><br><span class="line">        dogLists.add(<span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;aa&quot;</span>, <span class="string">&quot;1&quot;</span>));</span><br><span class="line">        dogLists.add(<span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;bb&quot;</span>, <span class="string">&quot;2&quot;</span>));</span><br><span class="line">        dogLists.add(<span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;cc&quot;</span>, <span class="string">&quot;3&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 迭代器遍历</span></span><br><span class="line">        Iterator&lt;Dog&gt; iterator = dogLists.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            <span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">            System.out.println(<span class="string">&quot;dog = &quot;</span> + dog);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;==============&quot;</span>);</span><br><span class="line">        <span class="comment">// 增强 for 遍历</span></span><br><span class="line">        <span class="keyword">for</span> (Dog dog : dogLists) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;dog = &quot;</span> + dog);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-List"><a href="#4-List" class="headerlink" title="4. List"></a>4. List</h2><h3 id="4-1-List-接口基本介绍"><a href="#4-1-List-接口基本介绍" class="headerlink" title="4.1 List 接口基本介绍"></a>4.1 List 接口基本介绍</h3><p>List 接口是 Collection 接口的子接口，特点如下：</p>
<ul>
<li><strong>有序性</strong>：List 集合类中元素<strong>有序</strong>(即添加顺序和取出顺序一致)</li>
<li><strong>元素重复</strong>：与 Set 接口不同，List 允许重复的元素，即同一个值可以出现多次</li>
<li><strong>索引访问</strong>：List 集合支持索引，每个元素都有其对应的顺序索引，开始于0</li>
<li><strong>整数型序号</strong>：List 容器中的元素都对应一个整数型的序号，记录其在容器中的位置，可以根据序号存取容器中的元素</li>
<li>List 接口的常用实现类有：<strong>ArrayList、LinkedList 和 Vector</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">List_</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. List集合类中元素有序(即添加顺序和取出顺序一致)、且可重复</span></span><br><span class="line">        <span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        list.add(<span class="string">&quot;jack&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;tom&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;list=&quot;</span> + list);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. List集合中的每个元素都有其对应的顺序索引, 即支持索引</span></span><br><span class="line">        <span class="comment">// 索引是从0开始的</span></span><br><span class="line">        System.out.println(list.get(<span class="number">1</span>));  <span class="comment">// tom</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-2-List-接口常用方法"><a href="#4-2-List-接口常用方法" class="headerlink" title="4.2 List 接口常用方法"></a>4.2 List 接口常用方法</h3><ul>
<li><code>void add(int index, Object ele)</code>：在index位置插入ele元素，没有index，默认在最后插入</li>
<li><code>boolean addAll(int index, Collection eles)</code>：从index位置开始将eles中的所有元素添加进来</li>
<li><code>Object get(int index)</code>：获取指定index位置的元素</li>
<li><code>int indexOf(Object obj)</code>：返回obj在集合中首次出现的位置</li>
<li><code>int lastIndexOf(Object obj)</code>：返回obj在当前集合中末次出现的位置</li>
<li><code>Object remove(int index)</code>：移除指定index位置的元素，并返回此元素</li>
<li><code>Object set(int index, Object ele)</code>：设置指定index位置的元素为ele , 相当于是替换</li>
<li><code>List subList(int fromIndex, int toIndex)</code>：返回从fromIndex到toIndex位置的子集合，注意返回的子集合 fromIndex &lt;&#x3D; subList &lt; toIndex</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListMethod</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        list.add(<span class="string">&quot;111&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;222&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// void add(int index, Object ele): 在index位置插入ele元素</span></span><br><span class="line">        <span class="comment">// 在 index = 1 的位置插入一个对象</span></span><br><span class="line">        list.add(<span class="number">1</span>, <span class="string">&quot;333&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;list = &quot;</span> + list);  <span class="comment">// list = [111, 333, 222]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// boolean addAll(int index, Collection eles): 从index位置开始将eles中的所有元素添加进来</span></span><br><span class="line">        <span class="type">List</span> <span class="variable">list2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        list2.add(<span class="string">&quot;44&quot;</span>);</span><br><span class="line">        list2.add(<span class="string">&quot;55&quot;</span>);</span><br><span class="line">        list.addAll(<span class="number">1</span>, list2);</span><br><span class="line">        System.out.println(<span class="string">&quot;list = &quot;</span> + list);  <span class="comment">// list=[111, 44, 55, 333, 222]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Object get(int index): 获取指定index位置的元素</span></span><br><span class="line">        System.out.println(list.get(<span class="number">1</span>));  <span class="comment">// 44</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// int indexOf(Object obj): 返回obj在集合中首次出现的位置</span></span><br><span class="line">        System.out.println(list.indexOf(<span class="string">&quot;44&quot;</span>));  <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// int lastIndexOf(Object obj): 返回obj在当前集合中末次出现的位置</span></span><br><span class="line">        list.add(<span class="string">&quot;333&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;list = &quot;</span> + list);  <span class="comment">// list=[111, 44, 55, 333, 222, 333]</span></span><br><span class="line">        System.out.println(list.lastIndexOf(<span class="string">&quot;333&quot;</span>));  <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Object remove(int index): 移除指定index位置的元素，并返回此元素</span></span><br><span class="line">        list.remove(<span class="number">0</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;list = &quot;</span> + list);  <span class="comment">// list = [44, 55, 333, 222, 333]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Object set(int index, Object ele): 设置指定index位置的元素为ele, 相当于是替换</span></span><br><span class="line">        list.set(<span class="number">1</span>, <span class="string">&quot;66&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;list = &quot;</span> + list);  <span class="comment">// list = [44, 66, 333, 222, 333]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// List subList(int fromIndex, int toIndex): 返回从fromIndex到toIndex位置的子集合</span></span><br><span class="line">        <span class="comment">// 注意返回的子集合 fromIndex &lt;= subList &lt; toIndex</span></span><br><span class="line">        <span class="type">List</span> <span class="variable">returnList</span> <span class="operator">=</span> list.subList(<span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;returnList = &quot;</span> + returnList);  <span class="comment">// returnList = [44, 66]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-3-List-的三种遍历方式"><a href="#4-3-List-的三种遍历方式" class="headerlink" title="4.3 List 的三种遍历方式"></a>4.3 List 的三种遍历方式</h3><blockquote>
<p> ArrayList, LinkedList,Vector 三种遍历使用的方式一致</p>
</blockquote>
<ul>
<li>方式一：使用<strong>迭代器</strong></li>
<li>方式二：<strong>增强for循环</strong></li>
<li>方式三：使用<strong>普通for循环</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// List 接口主要的实现子类</span></span><br><span class="line">        <span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line"><span class="comment">//        List list = new Vector();</span></span><br><span class="line"><span class="comment">//        List list = new LinkedList();</span></span><br><span class="line"></span><br><span class="line">        list.add(<span class="string">&quot;11&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;22&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;33&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;44&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历</span></span><br><span class="line">        <span class="comment">// 1. 迭代器</span></span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> list.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">            System.out.println(obj);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;=====增强for=====&quot;</span>);</span><br><span class="line">        <span class="comment">// 2. 增强 for</span></span><br><span class="line">        <span class="keyword">for</span> (Object o : list) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;o = &quot;</span> + o);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;=====普通for====&quot;</span>);</span><br><span class="line">        <span class="comment">// 3. 使用普通 for</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;对象 = &quot;</span> + list.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>练习</strong>：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    List&lt;Book&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//        List&lt;Book&gt; list = new LinkedList&lt;&gt;();</span></span><br><span class="line">    <span class="comment">//        List&lt;Book&gt; list = new Vector&lt;&gt;();</span></span><br><span class="line"></span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="title class_">Book</span>(<span class="string">&quot;11&quot;</span>, <span class="number">5.1</span>, <span class="string">&quot;aa&quot;</span>));</span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="title class_">Book</span>(<span class="string">&quot;22&quot;</span>, <span class="number">1.1</span>, <span class="string">&quot;bb&quot;</span>));</span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="title class_">Book</span>(<span class="string">&quot;33&quot;</span>, <span class="number">2.1</span>, <span class="string">&quot;cc&quot;</span>));</span><br><span class="line"></span><br><span class="line">    BubbleSort(list);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Book book : list) &#123;</span><br><span class="line">        System.out.println(book);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 冒泡排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">BubbleSort</span><span class="params">(List&lt;Book&gt; list)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; list.size() - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (list.get(j).getPrice() &gt; list.get(j + <span class="number">1</span>).getPrice()) &#123;</span><br><span class="line">                <span class="type">Book</span> <span class="variable">temp</span> <span class="operator">=</span> list.get(j);</span><br><span class="line">                list.set(j, list.get(j + <span class="number">1</span>));</span><br><span class="line">                list.set(j + <span class="number">1</span>, temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-4-List-接口实现类-ArrayList"><a href="#4-4-List-接口实现类-ArrayList" class="headerlink" title="4.4 List 接口实现类-ArrayList"></a>4.4 List 接口实现类-ArrayList</h3><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ul>
<li><strong>空元素支持</strong>：<code>ArrayList</code> 允许包含任意数量的 <code>null</code> 元素。这使得它在某些使用场景中非常灵活，例如在数据集中可能存在的缺失数据可以用 <code>null</code> 表示</li>
<li><strong>内部数据存储</strong>：<code>ArrayList</code> 是基于<strong>动态数组</strong>实现的，这意味着它的元素存放在数组中。这也解释了为什么 <code>ArrayList</code> 可以提供快速的随机访问能力</li>
<li><strong>与 <code>Vector</code> 的比较</strong>：<ul>
<li><strong>相似性</strong>：<code>ArrayList</code> 和 <code>Vector</code> 都是基于数组的实现，提供快速的随机访问和有序的元素存储</li>
<li><strong>线程安全</strong>：<code>ArrayList</code> 是非同步的，因此它是线程不安全的，而 <code>Vector</code> 是同步的，因此是线程安全的。这使得 <code>ArrayList</code> 在单线程环境下性能更优，但在多线程环境中可能需要外部同步措施</li>
</ul>
</li>
<li><strong>对于需要线程安全的 <code>ArrayList</code> 替代方案</strong>：<ul>
<li>使用 Vector 容器</li>
<li>使用 Collections 的静态方法 <code>synchronizedList(List&lt; T&gt; list)</code></li>
<li>采用 CopyOnWriteArrayList 容器</li>
</ul>
</li>
</ul>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_45668482/article/details/117396603">三种线程安全的List-CSDN博客</a></p>
<ul>
<li><strong>读多写少</strong>的情况下，推荐使用 <code>CopyOnWriteArrayList</code> 方式</li>
<li><strong>读少写多</strong>的情况下，推荐使用<code>Collections.synchronizedList()</code> 的方式</li>
</ul>
</blockquote>
<h4 id="底层结构和源码分析"><a href="#底层结构和源码分析" class="headerlink" title="底层结构和源码分析"></a>底层结构和源码分析</h4><ul>
<li>ArrayList 中维护了一个 Object 类型的数组 elementData</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// transient 表示瞬间，短暂的，表示该属性不能被序列化</span></span><br><span class="line"><span class="comment">// 序列化是将对象的状态信息转换为可以存储或传输的形式的过程</span></span><br><span class="line"><span class="keyword">transient</span> Object[] elementData;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在 Java 中，序列化通常指的是将对象转换为字节流，以便可以将其写入磁盘、通过网络等发送。反序列化是序列化的逆过程，它从字节流中重构对象。</p>
<p>序列化的目的是持久化存储&#x2F;网络通信等等，使 <code>elementData</code> 成为 <code>transient</code> 的原因：</p>
<ul>
<li><strong>空间效率</strong>：通常 <code>elementData</code> 的大小（容量）比实际存储的元素数量要大，如果 <code>elementData</code> 被序列化，那么即使数组中有大量未使用的空间，这些空间也会被序列化，导致不必要的存储和传输开销。</li>
<li><strong>时间效率</strong>：序列化和反序列化一个包含许多 <code>null</code> 值的大数组会显著降低性能，尤其是在网络传输等场景中。</li>
</ul>
</blockquote>
<ul>
<li><p>当创建 ArrayList 对象时，</p>
<ul>
<li>如果使用的是<strong>无参构造器</strong>，则初始 elementData 容量为0，<strong>第1次添加，则扩容 elementData 为 10</strong>，如果需要再次扩容，则扩容 elementData 为1.5倍</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);  <span class="comment">// 10 + 10/2 = 15 (即 10 的 1.5 倍)</span></span><br><span class="line"><span class="comment">// 0 =&gt; 10 =&gt; 15 =&gt; 22 =&gt; 33 =&gt; ...</span></span><br></pre></td></tr></table></figure>

<ul>
<li>如果使用的是<strong>指定大小的构造器</strong>，则<strong>初始 elementData 容量为指定大小</strong>，如果<strong>需要扩容，则直接扩容 elementData 为 1.5 倍</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设初始指定为 8, 则:</span></span><br><span class="line"><span class="comment">// 8 =&gt; 12(8+8/2) =&gt; 18 =&gt; 27 =&gt; ...</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/Java%E9%9B%86%E5%90%88.assets/image-20240421090400667.png" alt="image-20240421090400667"></p>
<ul>
<li><strong>注意</strong>：Idea 默认情况下，Debug 显示的数据是简化后的(比如数组不会显示 null 的元素)，如果希望看到完整的数据，需要做如下设置：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/Java%E9%9B%86%E5%90%88.assets/image-20240421085925779.png" alt="image-20240421085925779"></p>
<ul>
<li><strong>加断点分析源码</strong>：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 使用无参构造器创建 ArrayList 对象</span></span><br><span class="line">    <span class="type">ArrayList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    <span class="comment">// ArrayList list = new ArrayList(8);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 for 给 list 集合添加 1-10 数据</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">        list.add(i);  <span class="comment">// 触发 Integer 类的 valueOf(int i) 方法，自动装箱</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 for 给 list 集合添加 11-15 数据</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">11</span>; i &lt;= <span class="number">15</span>; i++) &#123;</span><br><span class="line">        list.add(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    list.add(<span class="number">100</span>);</span><br><span class="line">    list.add(<span class="number">200</span>);</span><br><span class="line">    list.add(<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>使用无参构造器，创建和使用 ArrayList</strong>：</p>
<ul>
<li>创建静态空数组 <code>elementData</code>，<code>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code> 是一个静态的空数组实例</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>添加元素</strong><ul>
<li>调用 <code>add(E e)</code> 来添加一个元素</li>
<li><code>add</code> 方法首先调用 <code>ensureCapacityInternal(size + 1)</code> 来确保容量</li>
<li><code>ensureCapacityInternal</code> 调用 <code>calculateCapacity</code> 来确定所需的容量，然后调用 <code>ensureExplicitCapacity</code></li>
<li><code>ensureExplicitCapacity</code> 检查当前容量是否足够，如果不够，调用 <code>grow</code> 来扩容</li>
<li>添加元素到数组，增加 <code>size</code></li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="comment">// 确保 ArrayList 有足够的空间来存储新添加的元素</span></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  </span><br><span class="line">    <span class="comment">// 将新元素 e 存储在 elementData 数组的 size 索引位置, 赋值完成后增加 size 的值</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 确保内部数组 elementData 有足够的容量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityInternal</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">// 调用 calculateCapacity 来确定所需的容量</span></span><br><span class="line">    <span class="comment">// 然后调用 ensureExplicitCapacity</span></span><br><span class="line">    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算并返回 ArrayList 所需的最小容量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">calculateCapacity</span><span class="params">(Object[] elementData, <span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">// 检查是否是默认空数组，如果是，意味着这是首次添加元素，此将容量设为 DEFAULT_CAPACITY = 10 和 minCapacity 中的较大值，以避免过早的数组扩容</span></span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);  <span class="comment">// max(10, 1)，返回 10</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果不是空数组，直接返回传入的 minCapacity</span></span><br><span class="line">    <span class="keyword">return</span> minCapacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ensureExplicitCapacity 检查当前容量是否足够，如果不够，调用 grow 来扩容</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureExplicitCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    modCount++;  <span class="comment">// 记录当前集合被修改的次数，防止多线程操作出现异常</span></span><br><span class="line">    <span class="comment">// 如果所需最小容量大于当前数组长度，则需要扩容</span></span><br><span class="line">    <span class="comment">// 10 - 0 &gt; 0 不够的</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩容</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;  <span class="comment">// 10</span></span><br><span class="line">    <span class="comment">// 获取旧容量</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;  <span class="comment">// 0</span></span><br><span class="line">    <span class="comment">// 新容量为旧容量的1.5倍</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);  <span class="comment">// 首次 0 + 0/2 = 0</span></span><br><span class="line">    <span class="comment">// 如果1.5倍仍不满足需求，则直接使用所需最小容量</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)  <span class="comment">// 0-10&lt;0 第一次由于初始容量为0，没法按照 1.5 倍机制扩容，所以新容量就是 newCapacity = 10</span></span><br><span class="line">        newCapacity = minCapacity;  </span><br><span class="line">    <span class="comment">// 如果新容量超出了最大数组大小，则调用 hugeCapacity 来处理</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// 将 elementData 数组扩展到 newCapacity 指定的大小，并保留所有现有元素，新扩展的部分（如果有）将初始化为 null</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理在数组需要扩容到非常大的尺寸时的特殊情况，，保证 ArrayList 不会因为数组大小请求不当而导致程序崩溃或安全问题</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">hugeCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果 minCapacity 小于 0，这通常是由于整数溢出导致的，抛出 OutOfMemoryError，表示内存溢出错误</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">OutOfMemoryError</span>();</span><br><span class="line">    <span class="comment">// Java 的数组最大长度是 MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8，因为某些 JVM 实现通过使用数组的一部分作为数组头部</span></span><br><span class="line">    <span class="comment">// 如果 minCapacity 要求的容量超过了 MAX_ARRAY_SIZE 但未溢出，方法返回 MAX_ARRAY_SIZE，即数组能达到的最大安全容量</span></span><br><span class="line">    <span class="comment">// 如果 minCapacity 请求超过了 Integer.MAX_VALUE，则方法返回 Integer.MAX_VALUE</span></span><br><span class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">        Integer.MAX_VALUE :</span><br><span class="line">    MAX_ARRAY_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/Java%E9%9B%86%E5%90%88.assets/image-20240421105512124.png" alt="image-20240421105512124"></p>
<ul>
<li><p><strong>使用指定大小的构造器，创建和使用 ArrayList</strong>：</p>
<ul>
<li><strong>创建一个指定大小的 elementData 数组</strong>：传入的初始化容量 (<code>initialCapacity</code>) 大于 0，构造函数会创建一个新的 <code>Object</code> 数组，其长度等于指定的 <code>initialCapacity</code></li>
<li>第一次扩容就按照elementData 的 1.5 倍扩容，其他步骤同无参构造器</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.elementData = <span class="keyword">new</span> <span class="title class_">Object</span>[initialCapacity];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果传入的初始化容量为 0，则构造函数不分配任何数据存储空间，而是将 elementData 初始化为 EMPTY_ELEMENTDATA（一个预定义的空数组）</span></span><br><span class="line">        <span class="built_in">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果传入的初始化容量小于 0，则构造函数抛出 IllegalArgumentException</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal Capacity: &quot;</span> +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="4-5-List-接口实现类-Vector"><a href="#4-5-List-接口实现类-Vector" class="headerlink" title="4.5 List 接口实现类-Vector"></a>4.5 List 接口实现类-Vector</h3><h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><ul>
<li>Vector 类的定义说明：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Vector</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">AbstractList</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Vector <strong>底层也是一个对象数组</strong>，</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object[] elementData</span><br></pre></td></tr></table></figure>

<ul>
<li>Vector 是线程同步的，即线程安全，Vector 类的操作方法基本都带有 <strong>synchronized</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    ensureCapacityHelper(elementCount + <span class="number">1</span>);</span><br><span class="line">    elementData[elementCount++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>开发中一般用 JUC 包中绝对线程安全的集合</strong>，Vector 只是相对安全，add、remove 这些方法不是原子操作，所以还是别用 Vector</li>
</ul>
<h4 id="Vector-VS-ArrayList"><a href="#Vector-VS-ArrayList" class="headerlink" title="Vector VS. ArrayList"></a>Vector VS. ArrayList</h4><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/Java%E9%9B%86%E5%90%88.assets/image-20240421151636473.png" alt="image-20240421151636473"></p>
<ul>
<li><code>Vector()</code>无参构造器内部调用了另一个构造器<code>Vector(int initialCapacity)</code>，并且传递了一个默认的初始容量值<code>10</code><ul>
<li>如果初始容量不是负数，这个构造器将创建一个新的对象数组<code>elementData</code>，数组的长度为<code>initialCapacity</code></li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Vector</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 若是有参构造器，就直接进入这个函数里，其他区别不大</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Vector</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(initialCapacity, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Vector</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">int</span> capacityIncrement)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="built_in">this</span>.elementData = <span class="keyword">new</span> <span class="title class_">Object</span>[initialCapacity];</span><br><span class="line">    <span class="built_in">this</span>.capacityIncrement = capacityIncrement;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>ArrayList</code>使用的是一种称为<strong>延迟初始化</strong>的策略（Lazy Initialization）。这意味着除非真正需要（即首次添加元素），否则不会创建存储元素的内部数组</p>
<p>在很多使用场景中，<code>ArrayList</code>可能仅仅是被实例化但并未使用，或者只添加了少量元素。使用延迟初始化可以避免在这些情况下分配不必要的内存，从而更高效地使用资源</p>
</blockquote>
<h4 id="Vector-的底层扩容结构"><a href="#Vector-的底层扩容结构" class="headerlink" title="Vector 的底层扩容结构"></a>Vector 的底层扩容结构</h4><ul>
<li>**调用 <code>add(E e)</code>**：开始添加元素。</li>
<li>**调用 <code>ensureCapacityHelper(int minCapacity)</code>**：确保有足够的容量。</li>
<li><strong>调用 <code>grow(int minCapacity)</code>（如果需要）</strong>：进行实际的数组扩容。</li>
<li>**完成 <code>add(E e)</code>**：元素添加到数组，方法结束。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加一个元素 e 到 Vector 的末尾</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    ensureCapacityHelper(elementCount + <span class="number">1</span>);</span><br><span class="line">    elementData[elementCount++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查并确保有足够的容量来存储至少 minCapacity 个元素</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityHelper</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果所需的最小容量 minCapacity 大于当前数组 elementData 的长度，则调用 grow 方法来扩容数组</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩容</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取旧容量</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;</span><br><span class="line">    <span class="comment">// 如果 capacityIncrement 大于 0，则新容量为 oldCapacity + capacityIncrement；否则，新容量为 oldCapacity * 2（默认行为是翻倍扩容）</span></span><br><span class="line">    <span class="comment">// capacityIncrement 是构造时指定的扩容大小(如果有)</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + ((capacityIncrement &gt; <span class="number">0</span>) ?</span><br><span class="line">                                     capacityIncrement : oldCapacity);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-6-List-接口实现类-LinkedList"><a href="#4-6-List-接口实现类-LinkedList" class="headerlink" title="4.6 List 接口实现类-LinkedList"></a>4.6 List 接口实现类-LinkedList</h3><h4 id="底层结构"><a href="#底层结构" class="headerlink" title="底层结构"></a>底层结构</h4><ul>
<li>LinkedList 实现了<strong>双向链表</strong>和<strong>双端队列</strong>特点<ul>
<li>双向链表的结构 <code>LinkedList</code> 不仅支持普通的列表操作（如添加、删除、查找等），还支持双端队列的操作</li>
<li>双端队列（deque，全称“double-ended queue”）是一种允许从两端添加和删除元素的队列，意味着 <code>LinkedList</code> 可以作为栈（后进先出）和队列（先进先出）使用</li>
</ul>
</li>
<li><strong>可以包含任意元素</strong>：可以添加任意元素(元素可以重复)，包括 null</li>
<li><strong>线程不安全</strong>：没有实现同步</li>
</ul>
<h4 id="操作机制"><a href="#操作机制" class="headerlink" title="操作机制"></a>操作机制</h4><ul>
<li><strong>双向链表结构</strong>：LinkedList 底层维护了一个双向链表，允许向前或向后遍历</li>
<li><strong>首尾节点引用</strong>：LinkedList 中维护了<strong>两个属性 first 和 last 分别指向首节点和尾节点</strong>，是管理链表添加或删除元素时的关键</li>
<li><strong>节点结构</strong>：每个节点(Node 对象)里又维护了 prev,next,item 三个属性，其中通过 prev 指向前一个，通过 next 指向后一个节点 ，最终实现双向链表</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/Java%E9%9B%86%E5%90%88.assets/image-20240421162220695.png" alt="image-20240421162220695"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;E&gt; &#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="built_in">this</span>.item = element;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">        <span class="built_in">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>添加和删除元素</strong>：LinkedList 的元素的添加和删除，不是通过数组完成的，相对来说效率较高</li>
</ul>
<h4 id="LinkedList-VS-ArrayList"><a href="#LinkedList-VS-ArrayList" class="headerlink" title="LinkedList VS. ArrayList"></a>LinkedList VS. ArrayList</h4><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/Java%E9%9B%86%E5%90%88.assets/image-20240421161629995.png" alt="image-20240421161629995"></p>
<p>如何选择 ArrayList和ListedList：</p>
<ul>
<li>如果改查的操作多，选择ArrayList</li>
<li>如果增删的操作多，选择ListedList</li>
<li>一般在程序中，80-90% 都是查询，大部分情况下会选择ArrayList</li>
<li>在项目中，会<strong>根据业务灵活选择</strong>，可能一个模块用ArrayList，另一个用ListedList</li>
</ul>
<h4 id="LinkedList-底层-crud-方法-debug-分析"><a href="#LinkedList-底层-crud-方法-debug-分析" class="headerlink" title="LinkedList 底层 crud 方法 debug 分析"></a>LinkedList 底层 crud 方法 debug 分析</h4><ul>
<li><code>LinkedList</code> 的无参构造器创建了一个空的 <code>LinkedList</code>，因为元素是通过节点 (<code>Node</code>) 动态连接的。以下是在这个构造器中隐式初始化的成员：<ul>
<li>**<code>size</code>**：追踪 <code>LinkedList</code> 中元素的数量，初始值为 <code>0</code></li>
<li>**<code>first</code>**：指向链表中的第一个节点，初始值为 <code>null</code></li>
<li>**<code>last</code>**：指向链表中的最后一个节点，初始值为 <code>null</code></li>
</ul>
</li>
</ul>
<blockquote>
<p>这些属性是 <code>transient</code> 的，这意味着它们不是由序列化机制自动保存和恢复的，这主要是出于<strong>链表元素的序列化需要特殊处理的考虑</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; first;</span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; last;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedList</span><span class="params">()</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>实现双向链表添加元素的核心代码</strong>：<ul>
<li><strong>获取当前尾节点</strong>：将当前的尾节点引用存储在局部变量 <code>l</code> 中。这是链表中最后一个节点，如果链表为空，则 <code>l</code> 为 <code>null</code></li>
<li><strong>创建新节点</strong>：创建一个新的节点 <code>newNode</code>，其数据域为 <code>e</code>，<code>prev</code> 指针指向当前的尾节点 <code>l</code>（如果存在），<code>next</code> 指针为 <code>null</code>（因为它将成为新的尾节点）</li>
<li><strong>更新尾节点引用</strong>：将 <code>last</code> 引用更新为新创建的节点 <code>newNode</code>，这样 <code>newNode</code> 现在正式成为链表的尾节点</li>
<li><strong>更新头节点引用（如果需要）</strong>：如果 <code>l</code> 为 <code>null</code>，意味着链表之前是空的（没有节点），因此新节点也是链表的第一个节点。故将 <code>first</code> 引用指向 <code>newNode</code></li>
<li><strong>链接前一个尾节点到新节点</strong>：如果链表不为空（即 <code>l</code> 不是 <code>null</code>），将原来尾节点的 <code>next</code> 指针指向新节点 <code>newNode</code></li>
<li><strong>增加链表大小</strong></li>
<li><strong>更新修改计数</strong>：增加 <code>modCount</code>，这是用于迭代器的快速失败机制（fail-fast behavior），即在迭代过程中如果检测到结构性修改，会抛出 <code>ConcurrentModificationException</code></li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 向 LinkedList 的末尾添加一个新元素 e</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">linkLast</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取当前尾节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="comment">// 创建新节点, 其数据域为 e，prev 指针指向当前的尾节点 l（如果存在），next 指针为 null（因为它将成为新的尾节点）</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(l, e, <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">// 更新尾节点引用, 将 last 引用更新为新创建的节点 newNode</span></span><br><span class="line">    last = newNode;</span><br><span class="line">    <span class="comment">// 如果 l 为 null，意味着链表之前是空的（没有节点），因此新节点也是链表的第一个节点, 故更新头节点引用</span></span><br><span class="line">    <span class="keyword">if</span> (l == <span class="literal">null</span>)</span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span>  <span class="comment">// 链接前一个尾节点到新节点</span></span><br><span class="line">        l.next = newNode;</span><br><span class="line">    size++;  <span class="comment">// 增加链表大小</span></span><br><span class="line">    modCount++;  <span class="comment">// 支持快速失败行为，确保集合在结构上的修改能够即时被迭代器感知，从而在发生并发修改时快速响应，抛出异常，避免迭代器行为不确定</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/Java%E9%9B%86%E5%90%88.assets/image-20240421193320578.png" alt="image-20240421193320578"></p>
<ul>
<li><strong>实现双向链表删除链表的第一个节点的核心代码</strong>：<ul>
<li><strong>获取和清除数据</strong>：<ul>
<li>存储第一个节点的值到局部变量 <code>element</code>。</li>
<li>将节点的 <code>item</code> 和 <code>next</code> 设置为 <code>null</code>，帮助垃圾收集器进行回收。</li>
</ul>
</li>
<li><strong>更新头部链接</strong>：<ul>
<li>将 <code>first</code> 更新为 <code>next</code>，如果 <code>next</code> 为 <code>null</code>（即原链表只有一个节点），则同时将 <code>last</code> 设置为 <code>null</code>。</li>
<li>如果 <code>next</code> 不是 <code>null</code>，更新 <code>next.prev</code> 为 <code>null</code>，断开它与原首节点的链接。</li>
</ul>
</li>
<li><strong>维护链表状态</strong>：<ul>
<li>减小 <code>size</code>。</li>
<li>增加 <code>modCount</code>，支持迭代器的快速失败行为。</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> removeFirst();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">removeFirst</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 获取首节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="literal">null</span>)  <span class="comment">// 若是空链表则抛异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">    <span class="keyword">return</span> unlinkFirst(f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除链表的第一个节点</span></span><br><span class="line"><span class="keyword">private</span> E <span class="title function_">unlinkFirst</span><span class="params">(Node&lt;E&gt; f)</span> &#123;</span><br><span class="line">    <span class="comment">// assert f == first &amp;&amp; f != null;</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">E</span> <span class="variable">element</span> <span class="operator">=</span> f.item;  <span class="comment">// 获取节点存储的元素</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = f.next;  <span class="comment">// 获取节点的下一个节点引用</span></span><br><span class="line">    f.item = <span class="literal">null</span>;  <span class="comment">// 清除节点的数据项，帮助垃圾收集器回收</span></span><br><span class="line">    f.next = <span class="literal">null</span>;  <span class="comment">// 断开节点的下一个链接，也是为了垃圾回收</span></span><br><span class="line">    first = next;  <span class="comment">// 将头指针更新为下一个节点</span></span><br><span class="line">    <span class="keyword">if</span> (next == <span class="literal">null</span>)  <span class="comment">// 如果下一个节点不存在，说明链表只有一个节点</span></span><br><span class="line">        last = <span class="literal">null</span>;  <span class="comment">// 更新尾指针为 null</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        next.prev = <span class="literal">null</span>;  <span class="comment">// 否则，设置新的头节点的前一个节点为 null</span></span><br><span class="line">    size--;  <span class="comment">// 链表大小减 1</span></span><br><span class="line">    modCount++;  <span class="comment">// 修改计数增加，用于迭代器的快速失败机制</span></span><br><span class="line">    <span class="keyword">return</span> element;  <span class="comment">// 返回被删除的元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-Set"><a href="#5-Set" class="headerlink" title="5. Set"></a>5. Set</h2><h3 id="5-1-Set-接口基本介绍"><a href="#5-1-Set-接口基本介绍" class="headerlink" title="5.1 Set 接口基本介绍"></a>5.1 Set 接口基本介绍</h3><ul>
<li><p><strong>特点</strong>：</p>
<ul>
<li><p><strong>无序性</strong>：<code>Set</code> 集合中的元素没有固定的顺序，元素的存储位置由 <code>Set</code> 的实现方式决定。添加和移除元素的顺序不保证一致性，也就是说，迭代 <code>Set</code> 时元素的返回顺序不一定反映它们被添加的顺序</p>
</li>
<li><p><strong>唯一性</strong>：<code>Set</code> 不允许重复的元素。每个元素在 <code>Set</code> 中只能出现一次。如果尝试添加重复的元素，添加操作通常会被忽略</p>
</li>
<li><p><strong>有限的 <code>null</code> 支持</strong>：大多数 <code>Set</code> 实现允许至少一个 <code>null</code> 元素（如果允许的话），但添加多个 <code>null</code> 会被视为重复</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以 Set 接口的实现类 HashSet 为例</span></span><br><span class="line"><span class="comment">// 1. set 接口的实现类的对象(Set接口对象), 不能存放重复的元素, 可以添加一个 null</span></span><br><span class="line"><span class="comment">// 2. set 接口对象存放数据是无序(即添加的顺序和取出的顺序不一致, 但取出顺序每次固定)</span></span><br><span class="line"><span class="type">Set</span> <span class="variable">set</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>();</span><br><span class="line">set.add(<span class="string">&quot;john&quot;</span>);</span><br><span class="line">set.add(<span class="string">&quot;lucy&quot;</span>);</span><br><span class="line">set.add(<span class="string">&quot;john&quot;</span>);  <span class="comment">// 重复</span></span><br><span class="line">set.add(<span class="string">&quot;jack&quot;</span>);</span><br><span class="line">set.add(<span class="literal">null</span>);  <span class="comment">// 添加 null</span></span><br><span class="line">set.add(<span class="literal">null</span>);  <span class="comment">// 再次添加null</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出 set, 3 次输出的顺序都是固定的</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;set = &quot;</span> + set);  <span class="comment">// set = [null, john, lucy, jack]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>JDK 中的 Set 接口实现类</strong>：</p>
<ul>
<li><p><strong><code>HashSet</code><strong>：</strong>基于哈希表</strong>的 <code>Set</code> 实现，提供快速的查询速度，不保证顺序</p>
</li>
<li><p><strong><code>TreeSet</code><strong>：</strong>基于红黑树</strong>实现，元素会按照自然顺序或创建 <code>TreeSet</code> 时提供的比较器进行排序</p>
</li>
<li><p><strong><code>LinkedHashSet</code><strong>：类似于 <code>HashSet</code>，但维护了一个运行于所有条目的双重链接列表，</strong>保留了插入的顺序</strong></p>
</li>
<li><p>….</p>
</li>
</ul>
</li>
<li><p><strong>常用方法</strong>： 和 List 接口一样， Set 接口也是 Collection 的子接口，因此，常用方法和 Collection 接口一样</p>
</li>
</ul>
<h3 id="5-2-Set-接口的遍历方式"><a href="#5-2-Set-接口的遍历方式" class="headerlink" title="5.2 Set 接口的遍历方式"></a>5.2 Set 接口的遍历方式</h3><blockquote>
<p><code>Set</code> 集合的遍历方式与 <code>Collection</code> 接口的其他实现相同，因为 <code>Set</code> 是 <code>Collection</code> 接口的一个子接口</p>
</blockquote>
<ul>
<li><strong>使用迭代器</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方式1: 使用迭代器</span></span><br><span class="line"><span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> set.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;  <span class="comment">// 快捷键: itit</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">    System.out.println(<span class="string">&quot;obj = &quot;</span> + obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>增强 for 循环</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Object o : set) &#123;  <span class="comment">// 快捷键: set.for</span></span><br><span class="line">    System.out.println(<span class="string">&quot;o=&quot;</span> + o);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>不能使用</strong>索引的方式来获取</p>
</li>
<li><p><strong>补充：Java 8 及更高版本的流</strong></p>
<blockquote>
<p>在 Java 8 引入的流（Streams）API 是一种高效处理集合（如 <code>List</code>、<code>Set</code> 等）的方法，特别适用于对集合执行复杂的查询和转换操作。流 API 可以用来遍历、筛选、映射、归约以及更多其它操作 <code>List</code> 或任何其他类型的 <code>Collection</code></p>
</blockquote>
<ul>
<li><strong>简单遍历</strong>：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set.stream().forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>更复杂的操作举例 List</strong>：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; items = List.of(<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;avocado&quot;</span>, <span class="string">&quot;cherry&quot;</span>, <span class="string">&quot;date&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用流过滤、转换并收集结果</span></span><br><span class="line">List&lt;String&gt; result = items.stream()</span><br><span class="line">    .filter(s -&gt; s.startsWith(<span class="string">&quot;a&quot;</span>))  <span class="comment">// 只选择以&quot;a&quot;开头的元素</span></span><br><span class="line">    .map(String::toUpperCase)        <span class="comment">// 将每个元素转换为大写</span></span><br><span class="line">    .sorted()                        <span class="comment">// 排序</span></span><br><span class="line">    .collect(Collectors.toList());   <span class="comment">// 收集为列表</span></span><br><span class="line"></span><br><span class="line">System.out.println(result);  <span class="comment">// 输出: [APPLE, AVOCADO]</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="5-3-Set-接口实现类-HashSet"><a href="#5-3-Set-接口实现类-HashSet" class="headerlink" title="5.3 Set 接口实现类-HashSet"></a>5.3 Set 接口实现类-HashSet</h3><h4 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h4><ul>
<li><strong>实现 Set 接口</strong>：<code>HashSet</code> 是 <code>Set</code> 接口的一个实现，提供了集合的基本操作，如添加、删除元素以及查询等，同时确保集合中的元素不重复</li>
<li><strong>底层使用 HashMap</strong>：<ul>
<li><code>HashSet</code> 内部实际上使用了一个 <code>HashMap</code> 来存储其元素，每个插入 <code>HashSet</code> 的元素都作为 <code>HashMap</code> 的键存储，而其值则使用一个固定的对象（通常是一个预定义的私有静态的 <code>final</code> 对象</li>
<li>使用 <code>HashMap</code> 支持使得 <code>HashSet</code> 在添加元素、删除元素和包含元素检查等操作上非常高效，时间复杂度为 O(1)</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">()</span> &#123;</span><br><span class="line">    map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>允许一个 null 值</strong>：<code>HashSet</code> 允许包含一个 <code>null</code> 元素，因为底层的 <code>HashMap</code> 允许其中一个键为 <code>null</code>。这对于某些需要表示特定场景的空值非常有用</li>
<li><strong>无序性</strong>：<ul>
<li><code>HashSet</code> 不保证集合中元素的顺序，元素的存储取决于它们的哈希码</li>
<li>当元素被添加到 <code>HashSet</code> 中时，其位置是根据哈希码计算得到的，这意味着<strong>元素的遍历顺序可能与添加顺序不同</strong></li>
</ul>
</li>
<li><strong>哈希冲突与重新哈希</strong>：当哈希表的负载因子达到一定程度（默认是 0.75）时，哈希表会进行扩容（通常扩容为原来的两倍），这个过程可能会改变现有元素的顺序</li>
<li><strong>不允许重复元素</strong>：<code>HashSet</code> 不允许重复元素。当尝试添加一个已存在的元素时，添加操作将不会改变集合，也不会抛出异常</li>
</ul>
<h4 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">HashSet</span> <span class="variable">set</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 在执行add方法后, 返回一个 boolean 值</span></span><br><span class="line"><span class="comment">// 2. 添加成功,返回 true, 否则返回 false</span></span><br><span class="line">System.out.println(set.add(<span class="string">&quot;john&quot;</span>));  <span class="comment">// T</span></span><br><span class="line">System.out.println(set.add(<span class="string">&quot;lucy&quot;</span>));  <span class="comment">// T</span></span><br><span class="line">System.out.println(set.add(<span class="string">&quot;john&quot;</span>));  <span class="comment">// F</span></span><br><span class="line">System.out.println(set.add(<span class="string">&quot;jack&quot;</span>));  <span class="comment">// T</span></span><br><span class="line">System.out.println(set.add(<span class="string">&quot;Rose&quot;</span>));  <span class="comment">// T</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 可以通过 remove 指定删除哪个对象</span></span><br><span class="line">set.remove(<span class="string">&quot;john&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;set = &quot;</span> + set);  <span class="comment">// 3个  set = [Rose, lucy, jack]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 重新实例化 set, 将 set 指向新的 HashSet, 原来的 HashSet 实例将失去引用</span></span><br><span class="line"><span class="comment">// 原来的 HashSet 实例被垃圾收集器回收（前提是没有其他引用指向它）</span></span><br><span class="line">set = <span class="keyword">new</span> <span class="title class_">HashSet</span>();</span><br><span class="line">System.out.println(<span class="string">&quot;set = &quot;</span> + set);  <span class="comment">// 0  set = []</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. Hashset 不能添加相同的元素/数据?</span></span><br><span class="line">set.add(<span class="string">&quot;lucy&quot;</span>);  <span class="comment">// 添加成功</span></span><br><span class="line">set.add(<span class="string">&quot;lucy&quot;</span>);  <span class="comment">// 加入不了</span></span><br><span class="line">set.add(<span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;tom&quot;</span>));  <span class="comment">// OK</span></span><br><span class="line">set.add(<span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;tom&quot;</span>));  <span class="comment">// Ok</span></span><br><span class="line">System.out.println(<span class="string">&quot;set = &quot;</span> + set);  <span class="comment">// set = [Dog&#123;name=&#x27;tom&#x27;&#125;, Dog&#123;name=&#x27;tom&#x27;&#125;, lucy]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 看源码, 即 add 到底发生了什么? =&gt; 底层机制</span></span><br><span class="line">set.add(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hhh&quot;</span>));  <span class="comment">// ok</span></span><br><span class="line">set.add(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hhh&quot;</span>));  <span class="comment">// 加入不了  set = [Dog&#123;name=&#x27;tom&#x27;&#125;, hhh, Dog&#123;name=&#x27;tom&#x27;&#125;, lucy]</span></span><br><span class="line"><span class="comment">// String 类重写了 equals() 和 hashCode() 方法</span></span><br><span class="line"><span class="comment">// String 的 hashCode() 方法确保所有内容相同的字符串对象返回相同的哈希码</span></span><br><span class="line"><span class="comment">// 而 equals() 方法确保只有当两个字符串对象的内容完全相同时才返回 true</span></span><br><span class="line"><span class="comment">// HashSet 使用这些方法来检查是否已经存在相等的字符串, 因此这次添加操作不会改变 set 的内容</span></span><br><span class="line">System.out.println(<span class="string">&quot;set = &quot;</span> + set);</span><br></pre></td></tr></table></figure>

<h4 id="模拟哈希表-数组-链表"><a href="#模拟哈希表-数组-链表" class="headerlink" title="模拟哈希表(数组+链表)"></a>模拟哈希表(数组+链表)</h4><ul>
<li><strong>HashSet 的底层是 HashMap，HashMap的底层是 数组+链表&#x2F;红黑树</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模拟一个 HashSet 的底层(其实也就是 HashMap 的底层结构)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 创建一个数组, 数组的类型是 Node[], 每个数组存放的元素可以理解为一个链表头</span></span><br><span class="line"><span class="comment">// 2. 有时也直接把 Node[] 数组称为 table 表</span></span><br><span class="line">Node[] table = <span class="keyword">new</span> <span class="title class_">Node</span>[<span class="number">16</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 创建结点,实现:</span></span><br><span class="line"><span class="comment">// [2]: john =&gt; jack =&gt; rose</span></span><br><span class="line"><span class="comment">// [3]: lucy</span></span><br><span class="line"><span class="type">Node</span> <span class="variable">john</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="string">&quot;john&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">table[<span class="number">2</span>] = john;</span><br><span class="line"></span><br><span class="line"><span class="type">Node</span> <span class="variable">jack</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="string">&quot;jack&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">john.next = jack;  <span class="comment">// 将 jack 结点挂载到 john</span></span><br><span class="line"></span><br><span class="line"><span class="type">Node</span> <span class="variable">rose</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="string">&quot;Rose&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">jack.next = rose;  <span class="comment">// 将 rose 结点挂载到 jack</span></span><br><span class="line"></span><br><span class="line"><span class="type">Node</span> <span class="variable">lucy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="string">&quot;lucy&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">table[<span class="number">3</span>] = lucy; <span class="comment">// 把 lucy 放到 table 表的索引为 3 的位置</span></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;table=&quot;</span> + table);</span><br></pre></td></tr></table></figure>

<h4 id="底层机制"><a href="#底层机制" class="headerlink" title="底层机制"></a>底层机制</h4><ul>
<li><strong>分析HashSet的添加元素底层是如何实现：hash() + equals()</strong><ul>
<li>HashSet 底层<strong>使用 HashMap 存储所有元素</strong>，在 HashSet 中添加一个元素实际上是将该元素作为键添加到内部的 HashMap 中</li>
<li>添加一个元素时，会得到 <strong>hash 值 -&gt; 索引值</strong></li>
<li><strong>处理哈希碰撞</strong>：找到存储数据表table，看这个索引位置是否已经存放了元素<ul>
<li>如果没有，直接将元素存储到该位置</li>
<li>如果有，调用 <code>equals()</code> 方法比较<ul>
<li>如果 <code>equals()</code> 返回 <code>true</code>，就放弃添加</li>
<li>如果 <code>equals()</code> 返回 <code>false</code>，则继续与链表中的下一个元素比较，直到找到相同的元素或链表结束</li>
</ul>
</li>
</ul>
</li>
<li><strong>链表与树化</strong>：<ul>
<li><strong>链表处理</strong>：如果一个索引位置上的冲突元素较多（但未达到树化阈值），则以链表形式存储</li>
<li>在 Java 8 及更高版本中，如果某个索引位置的链表长度 <code>&gt;= TREEIFY_THRESHOLD</code>（默认为8），并且整个 <code>HashMap</code> 的容量<code>&gt;= MIN_TREEIFY_CAPACITY</code>（默认为64），则这个链表会转化为红黑树，以提高搜索效率</li>
</ul>
</li>
<li><strong>添加成功与否</strong>：<ul>
<li>如果在整个链表或红黑树中没有找到相同的元素，则将新元素添加到链表的末尾或红黑树中</li>
<li><code>HashSet</code> 的 <code>add()</code> 方法返回一个 <code>boolean</code> 值，表示元素是否被添加。如果元素因为已存在而未被添加，则返回 <code>false4</code></li>
</ul>
</li>
</ul>
</li>
<li><strong>构造器</strong>：初始化一个 <code>HashSet</code> 实例时，内部实际上创建了一个 <code>HashMap</code> 来存储集合中的元素<ul>
<li><strong>默认负载因子</strong>：<code>HashMap</code> 默认的负载因子是 <code>0.75</code>，这意味着当 <code>HashMap</code> 的容量达到其容量的 75% 时，会自动扩容(重新调整内部数据结构的大小)</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HashSet.java 代码</span></span><br><span class="line"><span class="comment">// 构造器</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">()</span> &#123;</span><br><span class="line">    map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HashMap.java 代码</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">DEFAULT_LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong><code>HashSet</code>的<code>add</code> 方法</strong>：<code>HashSet</code> 添加元素实际上是调用内部 <code>HashMap</code> 的 <code>put</code> 方法，将元素 <code>e</code> 作为键存入。所有键共享同一个值 <code>PRESENT</code>，这只是一个占位符，没有实际意义</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// add 方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">PRESENT</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();  <span class="comment">// 方便让HashSet使用HashMap, 用一个Object作为 value 值进行占位</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> map.put(e, PRESENT)==<span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong><code>HashMap</code> 的 <code>put</code> 方法</strong>：<code>put</code> 方法首先计算键的哈希值，然后调用 <code>putVal</code> 方法处理实际的插入逻辑</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HashMap.java 代码</span></span><br><span class="line"><span class="comment">// 倒数第二个参数对应 putVal 方法的 onlyIfAbsent 参数, 决定了如果 key 已存在，是否要替换旧的值, false 表示如果发现 key 已存在，将替换旧值</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>计算哈希值(不等价于hashCode)<strong>：通过将对象的 <code>hashCode()</code> 结果与其自身右移 16 位的结果进行异或操作，从而</strong>减少高位和低位的冲突，改进了哈希碰撞的问题</strong>：(<code>h ^ (h &gt;&gt;&gt; 16)</code>)<ul>
<li><strong>异或</strong>：异1同0，用于混合原始哈希码的高位和低位，增加哈希码的随机性和均匀性</li>
<li>**无符号右移 (<code>&gt;&gt;&gt;</code>)**：将数值的二进制位向右移动指定的位数，右边超出的部分被丢弃，左边空出的位用 0 填充，用来混合哈希码，避免高位的信息在计算索引时被忽略</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// force step into 到 hash(key) 方法</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// String 类的 hashCode() 方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> hash; <span class="comment">// 默认为 0</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> hash;</span><br><span class="line">    <span class="comment">// 遍历字符串中的每个字符</span></span><br><span class="line">    <span class="comment">// 使用公式 h = 31 * h + val[i]; 计算哈希值</span></span><br><span class="line">    <span class="keyword">if</span> (h == <span class="number">0</span> &amp;&amp; value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">char</span> val[] = value;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 数字 31 被选择是因为它是一个奇质数，如果用更小的数字，容易造成哈希碰撞</span></span><br><span class="line">        <span class="comment">// 同时，计算 31*h 可以被 JVM 优化为 (h &lt;&lt; 5) - h，这是一次位移和一次减法，比乘法更快</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; value.length; i++) &#123;</span><br><span class="line">            h = <span class="number">31</span> * h + val[i];</span><br><span class="line">        &#125;</span><br><span class="line">        hash = h;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong><code>putVal</code> 方法</strong>：</p>
<ul>
<li><p><strong>寻找插入位置</strong>：首先检查是否需要扩容。如果对应的桶（数组位置）是空的，则直接插入新节点</p>
</li>
<li><p><strong>处理哈希碰撞</strong>：如果桶中已有元素，则通过链表或红黑树（当链表长度太长时转换为红黑树以优化搜索效率）处理碰撞</p>
<ul>
<li><strong>代码</strong>：既提高了性能（通过快速的引用比较），又保证了准确性（通过内容比较）<ul>
<li>引用比较 (<code>==</code>) 是一种<strong>非常快速的操作</strong>，比调用任何方法都要快，因为它直接比较内存地址。<strong>如果两个引用指向同一个对象，那么它们肯定相等</strong>，不需要进一步使用 <code>equals</code> 方法比较</li>
<li>即使两个对象的引用不同（它们位于内存中不同的位置），它们仍可能表示相同的数据。例如，两个不同的 <code>String</code> 对象可能包含相同的文本。通过 <code>equals</code> 方法，可以确保逻辑上相等的对象能够被正确识别</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">    ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">    e = p; </span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>键的比较</strong>：使用 <code>equals</code> 方法检查键是否已存在。如果已存在，根据 <code>onlyIfAbsent</code> 参数决定是否更新值</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"><span class="keyword">transient</span> <span class="type">int</span> size;  <span class="comment">// 默认为 0</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">UNTREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">    Node(<span class="type">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="built_in">this</span>.hash = hash;</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line">Node&lt;K,V&gt; <span class="title function_">newNode</span><span class="params">(<span class="type">int</span> hash, K key, V value, Node&lt;K,V&gt; next)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(hash, key, value, next);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">afterNodeInsertion</span><span class="params">(<span class="type">boolean</span> evict)</span> &#123; &#125;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; p)</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// putVal()</span></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,</span></span><br><span class="line"><span class="params">               <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 定义辅助变量</span></span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, i;</span><br><span class="line">    <span class="comment">// 2. 检查哈希表是否为空或者尚未初始化</span></span><br><span class="line">    <span class="comment">// table 就是 HashMap 的一个数组, 类型是 Node[]</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)  <span class="comment">// 如果为空，则进行初始化或扩容</span></span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 计算插入v的位置并检查该位置是否已有元素存在</span></span><br><span class="line">    <span class="comment">// (1) 计算索引: i = (n - 1) &amp; hash, 使用位与运算 &amp; 来确定元素在表中的索引位置</span></span><br><span class="line">    <span class="comment">// (1.1) 因为 n 是 2 的幂，n - 1 的二进制表示将是一个全 1 的序列（例如，如果 n 是 16，n - 1 是 15，二进制是 1111）</span></span><br><span class="line">    <span class="comment">// (1.2) 意味着 (n - 1) &amp; hash 将使用 hash 的低位作为数组索引。这是一个常用技巧，用于替代模运算（hash % n），因为位运算比模运算更高效</span></span><br><span class="line">    <span class="comment">// (2) 访问数组并赋值给 p: p = tab[i]</span></span><br><span class="line">    <span class="comment">// (3) 判断条件 (p == null)</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line">        <span class="comment">// 3.1 如果没有节点，则直接插入新节点, value 对象是共享的</span></span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;  <span class="comment">// 3.2 如果该位置已经有节点存在，则处理哈希碰撞</span></span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">// 3.2.1 检查当前节点的哈希值和键是否与插入的键相同</span></span><br><span class="line">        <span class="comment">// (1) 先检查当前节点 p 的哈希值是否与待插入键 key 的哈希值相同</span></span><br><span class="line">        <span class="comment">// (2) 键的比较</span></span><br><span class="line">        <span class="comment">// (2.1) 首先，p.key 被赋值给变量 k</span></span><br><span class="line">        <span class="comment">// (2.2) 使用 == 操作符检查 k 和 key 是否为同一个对象的引用</span></span><br><span class="line">        <span class="comment">// (2.3) 如果 k 和 key 不是同一个引用，那么继续使用 equals 方法检查两者的内容是否相等, 有一个额外的空值检查 key != null, 避免抛出 NPE</span></span><br><span class="line">        <span class="comment">// (3) 条件成立，执行赋值 (e = p)</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;  <span class="comment">// 如果节点已存在，将其赋给 e 用于后续操作</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3.2.2 如果当前节点是树节点，则调用树节点的插入方法</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3.2.3 如果是链表，则遍历链表</span></span><br><span class="line">        <span class="keyword">else</span> &#123;  </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 如果到达链表末尾，插入新节点</span></span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                    <span class="comment">// 如果链表长度达到阈值，则尝试将当前链表转换为红黑树</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1因为从0开始计数</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果在链表中找到了相同哈希且键相等的节点，则停止搜索</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;  <span class="comment">// 如果找到相同的键，停止遍历</span></span><br><span class="line">                p = e;  <span class="comment">// 继续遍历链表</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3.2.4 如果找到了已存在的节点，根据参数决定是否更新其值</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123; </span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新修改次数</span></span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 如果大小超过阈值，则进行扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    <span class="comment">// 对于 ashMap 来说, 这个方法是个空方法</span></span><br><span class="line">    afterNoeInsertion(evict);  <span class="comment">// 钩子方法，用于 LinkedHashMap 后续处理</span></span><br><span class="line">    <span class="comment">// 钩子方法通常是在基类中预定义的方法，它们在默认情况下可能不做任何事（即可能是空方法），或者提供默认行为。派生类可以根据需要重写这些方法来提供特定的行为</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/Java%E9%9B%86%E5%90%88.assets/image-20240428211648961.png" alt="image-20240428211648961"></p>
<ul>
<li><p><strong><code>resize</code> 扩容方法</strong>：</p>
<ul>
<li><p><strong>初始化和条件检查</strong>：</p>
<ul>
<li><strong>保存旧数组</strong>：首先，旧数组 <code>oldTab</code> 被保存，用于之后的元素迁移。</li>
<li><strong>检查旧容量</strong>：获取旧数组的长度 <code>oldCap</code>。如果数组未初始化（即为 <code>null</code>），<code>oldCap</code> 设为 <code>0</code>。</li>
<li><strong>旧阈值</strong>：保存旧的扩容阈值 <code>oldThr</code>。</li>
</ul>
</li>
<li><p><strong>判断是否需要扩容</strong>：</p>
<ul>
<li><p><strong>达到最大容量</strong>：如果旧容量已经等于最大可能容量 <code>MAXIMUM_CAPACITY</code>（即 <code>1 &lt;&lt; 30</code>），将阈值设置为 <code>Integer.MAX_VALUE</code> 并直接返回旧表，不再扩容。</p>
</li>
<li><p><strong>一般扩容条件</strong>：如果旧容量小于最大容量且大于默认初始容量，新容量 <code>newCap</code> 设为旧容量的两倍，新阈值 <code>newThr</code> 也相应翻倍。</p>
</li>
</ul>
</li>
<li><p><strong>处理特殊初始化条件</strong>：</p>
<ul>
<li><p><strong>初次初始化</strong>：如果是首次初始化（即旧阈值大于 <code>0</code> 且旧容量为 <code>0</code>），直接使用旧阈值作为新容量。</p>
</li>
<li><p><strong>默认初始化</strong>：如果旧容量和旧阈值都是 <code>0</code>（未初始化状态），设置新容量为默认初始容量（<code>16</code>），计算新阈值为容量与默认负载因子（<code>0.75</code>）的乘积。</p>
</li>
</ul>
</li>
<li><p><strong>重新计算新阈值</strong>：</p>
<ul>
<li><strong>阈值计算</strong>：如果新阈值未设定（即 <code>newThr == 0</code>），根据新容量和负载因子计算新阈值。如果计算结果接近最大容量，直接将阈值设置为 <code>Integer.MAX_VALUE</code>。</li>
</ul>
</li>
<li><p><strong>创建新数组并设置新表</strong>：</p>
<ul>
<li><p><strong>新数组创建</strong>：基于新容量创建新的节点数组 <code>newTab</code>。</p>
</li>
<li><p><strong>更新哈希表</strong>：将 <code>HashMap</code> 的 <code>table</code> 引用更新为新数组。</p>
</li>
</ul>
</li>
<li><p><strong>重新散列旧元素</strong>：</p>
<ul>
<li>遍历旧数组：遍历每个索引位置的旧数组元素。<ul>
<li><strong>单节点直接移动</strong>：如果该位置只有一个节点，直接计算新位置并放入新数组。</li>
<li>处理树或链表：如果节点形成了链表或树：<ul>
<li><strong>树节点分割</strong>：对于树节点，执行分割操作，将节点根据当前的容量分散到新的索引位置。</li>
<li><strong>链表重分布</strong>：对于链表，节点被分为两组，一组索引位置不变，另一组移动到 <code>原索引 + oldCap</code> 的位置。<ul>
<li><strong>链表节点迁移</strong>：根据节点哈希值的高位决定分组。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>返回新数组</strong>：<strong>返回新的哈希表数组</strong> <code>newTab</code>，完成扩容和重新散列过程。</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> threshold;  <span class="comment">// 默认为 0</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAXIMUM_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">30</span>;  <span class="comment">// 2^30</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">4</span>;  <span class="comment">// 默认容量 16 </span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">DEFAULT_LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>;  <span class="comment">// 默认负载因子</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    <span class="comment">// 保存旧数组</span></span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="comment">// 旧数组的容量</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCap</span> <span class="operator">=</span> (oldTab == <span class="literal">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldThr</span> <span class="operator">=</span> threshold;  <span class="comment">// 旧阈值</span></span><br><span class="line">    <span class="type">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 如果旧容量大于 0</span></span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果旧容量已达到最大值</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            <span class="comment">// 更新阈值为 int 最大值，防止进一步扩容</span></span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果旧容量小于最大容量，将容量翻倍</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            <span class="comment">// 翻倍阈值</span></span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果旧容量为 0，但旧阈值大于 0，通常是初始情况</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) </span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;  <span class="comment">// 使用默认容量和默认负载因子            </span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        <span class="comment">// 默认阈值: 16*0.75=12</span></span><br><span class="line">        newThr = (<span class="type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果新阈值为 0, 重新计算新阈值</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> (<span class="type">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="type">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;  <span class="comment">// 更新阈值</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>[newCap];  <span class="comment">// 创建新数组</span></span><br><span class="line">    table = newTab;  <span class="comment">// 将新数组设为当前表</span></span><br><span class="line">    <span class="comment">// 重新散列旧数组中的所有元素到新数组</span></span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="literal">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="literal">null</span>;</span><br><span class="line">                <span class="comment">// 如果节点没有后续节点，直接重新定位</span></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="literal">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="comment">// 如果是树节点，执行树相关的分割</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="built_in">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// 重新链接扩展的节点</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="comment">// 根据哈希的高位决定是放在原位置还是新位置</span></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="literal">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="literal">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="literal">null</span>);</span><br><span class="line">                     <span class="comment">// 重新链接低位链表和高位链表</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="literal">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="literal">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;  <span class="comment">// 返回新的哈希表数组</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong><code>treeifyBin</code> 转红黑树方法</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="type">int</span> hash)</span> &#123;</span><br><span class="line">    <span class="type">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="comment">// 如果表为空或表的长度小于最小树化容量，进行扩容</span></span><br><span class="line">    <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">        resize();</span><br><span class="line">    <span class="comment">// 如果表不为空且长度大于等于最小树化容量</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; hd = <span class="literal">null</span>, tl = <span class="literal">null</span>;  <span class="comment">// hd 用于保存头节点，tl 用于保存尾节点</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">// 将普通节点转换为树节点</span></span><br><span class="line">            TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="literal">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (tl == <span class="literal">null</span>)</span><br><span class="line">                hd = p;  <span class="comment">// 如果尾节点为空，表示这是第一个节点，设置为头节点</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                p.prev = tl;  <span class="comment">// 设置当前节点的前一个节点为尾节点</span></span><br><span class="line">                tl.next = p;  <span class="comment">// 将尾节点的下一个节点设置为当前节点</span></span><br><span class="line">            &#125;</span><br><span class="line">            tl = p;  <span class="comment">// 更新尾节点为当前节点</span></span><br><span class="line">        &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);  <span class="comment">// 遍历链表中的所有节点</span></span><br><span class="line">        <span class="comment">// 如果头节点不为空，开始树化操作</span></span><br><span class="line">        <span class="keyword">if</span> ((tab[index] = hd) != <span class="literal">null</span>)</span><br><span class="line">            hd.treeify(tab);  <span class="comment">// 将链表转换为红黑树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>扩容机制的触发</strong>？<ul>
<li>一种是总的键值对数量<strong>超过</strong>了负载因子与当前容量的乘积所定义的<strong>阈值</strong><ul>
<li><strong>初始设置</strong>：<code>HashMap</code> 默认的初始容量是 16 (<code>DEFAULT_INITIAL_CAPACITY</code>), 负载因子是 0.75 (<code>DEFAULT_LOAD_FACTOR</code>)。</li>
<li><strong>计算阈值</strong>：阈值 (<code>threshold</code>) 是触发扩容的点，计算为 <code>容量 * 负载因子</code>。初始情况下，阈值是 <code>16 * 0.75 = 12</code>。</li>
<li><strong>扩容条件</strong>：每次向 <code>HashMap</code> 添加元素后，如果哈希表中的元素数量超过当前阈值，就会触发扩容。扩容通常将容量翻倍（例如从 16 增加到 32，阈值相应地从 12 增加到 <code>24</code>）。</li>
<li><strong>扩容过程</strong>：在扩容过程中，旧数组中的元素会被重新计算索引并移动到新的数组中，这个过程称为重新散列（rehashing）。</li>
</ul>
</li>
<li>另一种是<strong>单个哈希桶（链表或树）的结构因为太长</strong>而需要转换<ul>
<li><strong>链表长度阈值</strong>：如果 <code>HashMap</code> 中某个桶的链表长度达到 <code>TREEIFY_THRESHOLD</code>（默认为 8），则可能触发树化。但<strong>树化之前还有一层检查，即桶数组的总容量是否足够大</strong>。</li>
<li><strong>最小树化容量</strong>：树化发生之前，桶数组的容量必须达到 <code>MIN_TREEIFY_CAPACITY</code>（默认为 64）。这意味着如果容量小于这个值，即使链表长度达到了 8，系统也会选择先扩容而不是树化。</li>
<li><strong>先扩容还是先树化</strong>：如果在链表长度达到 8 时容量已经达到或超过了 64，将直接进行树化；如果容量还不足 64，则会先进行扩容，容量通常翻倍，这有助于分散哈希碰撞并可能避免立即树化。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h4><ul>
<li>当一个对象作为哈希基础集合（如 <code>HashSet</code> 或 <code>HashMap</code>）的元素时，不仅该对象本身需要适当重写 <code>hashCode()</code> 和 <code>equals()</code> 方法，其<strong>内部属性对象</strong>（如果这些属性对等价性判断有影响）同样需要重写这些方法</li>
<li>eg. 当一个对象（如 <code>Emp</code>）的等价性判断依赖于另一个对象（如 <code>MyDate</code>）时，后者也必须正确实现 <code>hashCode()</code> 和 <code>equals()</code> 方法。这是因为前者的方法实现直接依赖于后者的等价性逻辑</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashSetPractice01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">HashSet</span> <span class="variable">hashSet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>();</span><br><span class="line">        hashSet.add(<span class="keyword">new</span> <span class="title class_">Emp</span>(<span class="string">&quot;111&quot;</span>, <span class="number">3000.0</span>, <span class="keyword">new</span> <span class="title class_">MyDate</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)));</span><br><span class="line">        hashSet.add(<span class="keyword">new</span> <span class="title class_">Emp</span>(<span class="string">&quot;111&quot;</span>, <span class="number">3000.0</span>, <span class="keyword">new</span> <span class="title class_">MyDate</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Object o : hashSet) &#123;</span><br><span class="line">            System.out.println(o);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyDate</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer year;</span><br><span class="line">    <span class="keyword">private</span> Integer month;</span><br><span class="line">    <span class="keyword">private</span> Integer day;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyDate</span><span class="params">(Integer year, Integer month, Integer day)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.year = year;</span><br><span class="line">        <span class="built_in">this</span>.month = month;</span><br><span class="line">        <span class="built_in">this</span>.day = day;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == o) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">MyDate</span> <span class="variable">myDate</span> <span class="operator">=</span> (MyDate) o;</span><br><span class="line">        <span class="keyword">return</span> Objects.equals(year, myDate.year) &amp;&amp; Objects.equals(month, myDate.month) &amp;&amp; Objects.equals(day, myDate.day);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(year, month, day);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Emp</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Double sal;</span><br><span class="line">    <span class="keyword">private</span> MyDate birthday;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Emp</span><span class="params">(String name, Double sal, MyDate birthday)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.sal = sal;</span><br><span class="line">        <span class="built_in">this</span>.birthday = birthday;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == o) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">Emp</span> <span class="variable">emp</span> <span class="operator">=</span> (Emp) o;</span><br><span class="line">        <span class="keyword">return</span> Objects.equals(name, emp.name) &amp;&amp; Objects.equals(birthday, emp.birthday);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(name, birthday);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-4-Set-接口实现类-LinkedHashSet"><a href="#5-4-Set-接口实现类-LinkedHashSet" class="headerlink" title="5.4 Set 接口实现类-LinkedHashSet"></a>5.4 Set 接口实现类-LinkedHashSet</h3><h4 id="基本介绍-2"><a href="#基本介绍-2" class="headerlink" title="基本介绍"></a>基本介绍</h4><ul>
<li><strong>继承关系</strong>：LinkedHashSet 是 HashSet 的子类</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedHashSet</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">HashSet</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">Set</span>&lt;E&gt;, Cloneable, java.io.Serializable &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>底层由 LinkedHashMap 实现</strong>：LinkedHashSet 底层是一个 LinkedHashMap，内部结构包括一个<strong>哈希表（用于存储数据）和一个双向链表（用于维护插入顺序）</strong><ul>
<li>每个添加到 <code>LinkedHashMap</code> 中的元素都会被插入到双向链表的尾部</li>
</ul>
</li>
<li><strong>元素顺序</strong>：LinkedHashSet 根据元素 hashCode 来决定元素的存储位置，同时使用链表维护元素的次序，这使得元素看起来是以插入顺序保存的</li>
<li><strong>不允许重复元素</strong>：同 <code>HashSet</code>，<code>LinkedHashSet</code> 也是基于集合的性质，不允许添加重复的元素。它使用 <code>hashCode()</code> 和 <code>equals()</code> 方法来检测重复</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/Java%E9%9B%86%E5%90%88.assets/image-20240428213615027.png" alt="image-20240428213615027"></p>
<h4 id="底层机制-1"><a href="#底层机制-1" class="headerlink" title="底层机制"></a>底层机制</h4><ul>
<li><strong>数据结构</strong>：<code>LinkedHashSet</code> 内部实际上使用了 <code>LinkedHashMap</code> 来存储元素。<code>LinkedHashMap</code> 本质上是 <code>HashMap</code> 的一个子类，但它在每个节点中额外维护了两个指针，分别指向链表中的前一个和后一个节点</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/Java%E9%9B%86%E5%90%88.assets/image-20240429190650048.png" alt="image-20240429190650048"></p>
<ul>
<li><p><strong>节点结构</strong>：</p>
<ul>
<li>除了键值对信息外，每个节点还有 <code>prev</code>（前驱）和 <code>next</code>（后继）两个属性，用于链接前一个和后一个节点，形成一个双向链表</li>
<li>这个链表通过头指针 <code>head</code> 和尾指针 <code>tail</code> 维护，确保插入顺序</li>
</ul>
</li>
<li><p><strong>节点类型</strong>：</p>
<ul>
<li>添加第一次时，直接将 数组 table 扩容到 16 ,存放的结点类型是 <code>LinkedHashMap$Entry</code></li>
<li>数组 table 是 <code>HashMap$Node[]</code> 存放的元素&#x2F;数据是 <code>LinkedHashMap$Entry</code> 类型，(数组多态？)，</li>
<li><code>LinkedHashMap.Entry</code> 类继承了 <code>HashMap.Node</code> 类(静态内部类，因为是通过类名去访问的)，不仅存储键值对（即数据部分），还包括两个额外的指针：<code>before</code>, <code>after</code>，用于维护节点的插入顺序</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">HashMap</span>.Node&lt;K,V&gt; &#123;</span><br><span class="line">    Entry&lt;K,V&gt; before, after;</span><br><span class="line">    Entry(<span class="type">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="built_in">super</span>(hash, key, value, next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>添加元素</strong>：</p>
<blockquote>
<p>这里其实都类似，就是功能增强，增加的双指针没有破坏原来的结构，感觉就是多了一个有序的功能</p>
</blockquote>
<ul>
<li>当添加一个新元素时，首先计算该元素的哈希值，然后根据哈希值计算其在哈希表中的索引</li>
<li>如果元素是首次添加（即在哈希表中找不到对应的条目），该元素将被封装为一个新的节点，并添加到双向链表的末尾（如果已经存在，不添加［原则和hashset一样］）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tail.next＝ newElement;  <span class="comment">// 简单指定</span></span><br><span class="line">newElement.pre tail;</span><br><span class="line">tail newEelment;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>遍历顺序</strong>：由于元素是按照添加顺序连续链接的，遍历 <code>LinkedHashSet</code> 时，可以通过从 <code>head</code> 开始，沿着 <code>next</code> 指针顺序遍历，确保遍历顺序与插入顺序一致</p>
</li>
</ul>
<h2 id="6-Map"><a href="#6-Map" class="headerlink" title="6. Map"></a>6. Map</h2><h3 id="6-1-Map-接口和常用方法"><a href="#6-1-Map-接口和常用方法" class="headerlink" title="6.1 Map 接口和常用方法"></a>6.1 Map 接口和常用方法</h3><blockquote>
<p>JDK8 的 Map 接口实现类的特点</p>
</blockquote>
<ul>
<li><strong>并列于 Collection</strong>：<code>Map</code> 接口是与 <code>Collection</code> 接口平行的一个独立接口。意味着 <code>Map</code> 和 <code>Collection</code> 处理的是不同类型的数据结构——<code>Map</code> 主要用于存储键值对，而 <code>Collection</code> 用于存储一组元素</li>
<li><strong>键值对存储</strong>：<code>Map</code> 存储的是键值对，每个键映射到一个特定的值。key 和 value 可以是任何引用类型的数据，封装到<code>HashMap$Node</code> 对象中，<code>HashMap$Node</code> 是 <code>HashMap</code> 中实现键值对存储的内部类，它封装了键（Key）和值（Value）</li>
</ul>
<blockquote>
<p>编译器使用 <code>$</code> 符号将外部类名和内部类名连接起来。例如，如果 <code>HashMap</code> 类中有一个名为 <code>Node</code> 的内部类，编译后的类名会是 <code>HashMap$Node</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;  <span class="comment">// HashMap$Node 实现了 Map$Entry</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>键（Key）的特性</strong>：</p>
<ul>
<li><strong>唯一性</strong>：每个键在 <code>Map</code> 中必须是唯一的。如果尝试插入一个已存在的键，其对应的值将被新的值替换（除非操作特别指定不这么做）</li>
<li><strong><code>null</code> 键</strong>：大多数 <code>Map</code> 实现（如 <code>HashMap</code>）允许有一个键为 <code>null</code> 的条目，这在使用时需要特别注意，因为不是所有的 <code>Map</code> 实现都支持 <code>null</code> 键（例如 <code>TreeMap</code> 默认不支持 <code>null</code> 键）</li>
</ul>
</li>
<li><p><strong>值（Value）的特性</strong>：<code>Map</code> 中的值可以重复，即不同的键可以映射到相同的值</p>
</li>
<li><p><strong>使用场景</strong>：</p>
<ul>
<li><p><strong>字符串键</strong>：<code>String</code> 类型是作为 <code>Map</code> 的键非常常见的选择，主要是因为其不变性和已经有效重写的 <code>hashCode()</code> 和 <code>equals()</code> 方法，这使得 <code>String</code> 作为键既安全又高效</p>
</li>
<li><p><strong>单向关联</strong>：每个键与一个值之间存在<strong>单向的一对一关系</strong>，通过键总能检索到一个确定的值，这是 <code>Map</code> 结构的核心特征</p>
</li>
</ul>
</li>
<li><p><strong>EntrySet、KeySet 和 ValueCollection</strong>：</p>
<ul>
<li>Map 中一对 k-v 最后是 <code>HashMap$Node node = newNode(hash, key, value, null)</code>，又因为Node 实现了 Entry 接口，有些书上也说一对 k-v 就是一个 Entry</li>
<li>为了方便 k-v  遍历，还会 创建 EntrySet 集合</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HashMap</span></span><br><span class="line"><span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>EntrySet</strong>：<ul>
<li><code>EntrySet</code> 是 <code>HashMap</code> 的一个视图，用于以 <code>Map.Entry</code> 对象的形式访问 <code>HashMap</code> 中的每一个键值对。每个 <code>Map.Entry</code> 实际上是 <code>HashMap</code> 内部节点 <code>Node</code> 的表示，它包含键和值的引用（地址）</li>
<li>遍历 <code>EntrySet</code> 时，实际上是在访问 <code>HashMap</code> 内部存储的每个节点，每个节点都是 <code>Map.Entry</code> 实例，它包含了键值对的信息</li>
</ul>
</li>
<li><strong>KeySet</strong>：<ul>
<li><code>KeySet</code> 也是 <code>HashMap</code> 的一个视图，它包含 <code>HashMap</code> 中所有的键。它是从 <code>EntrySet</code> 派生出来的，每个元素都是从 <code>EntrySet</code> 中的每个 <code>Entry</code>（即 <code>Node</code>）中提取的键</li>
<li>遍历 <code>KeySet</code> 或对其进行操作时，实际上是在间接操作那些存储在 <code>Node</code> 中的键</li>
</ul>
</li>
<li><strong>ValueCollection</strong>：<ul>
<li>类似地，<code>ValueCollection</code> 是 <code>HashMap</code> 中所有值的集合。它也是从 <code>EntrySet</code> 派生的，每个元素都是从 <code>EntrySet</code> 中的 <code>Entry</code>（即 <code>Node</code>）中提取的值</li>
<li><code>ValueCollection</code> 允许你遍历或查看所有值，但是和键不同，值是可以重复的</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/Java%E9%9B%86%E5%90%88.assets/image-20240430104936091.png" alt="image-20240430104936091"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个HashMap</span></span><br><span class="line">        HashMap&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向HashMap中添加一些键值对</span></span><br><span class="line">        map.put(<span class="string">&quot;apple&quot;</span>, <span class="number">10</span>);</span><br><span class="line">        map.put(<span class="string">&quot;banana&quot;</span>, <span class="number">20</span>);</span><br><span class="line">        map.put(<span class="string">&quot;orange&quot;</span>, <span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用entrySet()获取Map中的所有键值对</span></span><br><span class="line">        Set&lt;Map.Entry&lt;String, Integer&gt;&gt; entries = map.entrySet();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历entries集合</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : entries) &#123;</span><br><span class="line">            System.out.println(entry.getKey() + <span class="string">&quot; -&gt; &quot;</span> + entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>常用方法</strong>：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">    map.put(<span class="string">&quot;11&quot;</span>, <span class="keyword">new</span> <span class="title class_">Book</span>(<span class="string">&quot;&quot;</span>, <span class="number">100</span>));  <span class="comment">// OK</span></span><br><span class="line">    map.put(<span class="string">&quot;11&quot;</span>, <span class="string">&quot;22&quot;</span>);  <span class="comment">// 替换-&gt; 一会分析源码</span></span><br><span class="line">    map.put(<span class="string">&quot;33&quot;</span>, <span class="string">&quot;44&quot;</span>);  <span class="comment">// OK</span></span><br><span class="line">    map.put(<span class="string">&quot;55&quot;</span>, <span class="string">&quot;44&quot;</span>);  <span class="comment">// OK</span></span><br><span class="line">    map.put(<span class="string">&quot;66&quot;</span>, <span class="literal">null</span>);  <span class="comment">// OK</span></span><br><span class="line">    map.put(<span class="literal">null</span>, <span class="string">&quot;77&quot;</span>);  <span class="comment">// OK</span></span><br><span class="line">    map.put(<span class="string">&quot;88&quot;</span>, <span class="string">&quot;99&quot;</span>);  <span class="comment">// OK</span></span><br><span class="line">    map.put(<span class="string">&quot;hh&quot;</span>, <span class="string">&quot;ee&quot;</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;map = &quot;</span> + map);</span><br><span class="line">    <span class="comment">// map = &#123;11=22, 33=44, 55=44, 66=null, null=77, 88=99, hh=ee&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// remove: 根据键删除映射关系</span></span><br><span class="line">    map.remove(<span class="literal">null</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;map = &quot;</span> + map);</span><br><span class="line">    <span class="comment">// map = &#123;11=22, 33=44, 55=44, 66=null, 88=99, hh=ee&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// get: 根据键获取值</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">val</span> <span class="operator">=</span> map.get(<span class="string">&quot;88&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;val = &quot;</span> + val);  <span class="comment">// val = 99</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// size: 获取元素个数</span></span><br><span class="line">    System.out.println(<span class="string">&quot;k-v = &quot;</span> + map.size());  <span class="comment">// k-v = 6</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// isEmpty: 判断个数是否为 0</span></span><br><span class="line">    System.out.println(map.isEmpty());  <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// clear: 清除k-v</span></span><br><span class="line">    <span class="comment">// map.clear();</span></span><br><span class="line">    <span class="comment">// System.out.println(&quot;map = &quot; + map);  // map = &#123;&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// containsKey: 查找键是否存在</span></span><br><span class="line">    System.out.println(<span class="string">&quot;result = &quot;</span> + map.containsKey(<span class="string">&quot;hh&quot;</span>));  <span class="comment">// result = true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-2-Map-六大遍历方式"><a href="#6-2-Map-六大遍历方式" class="headerlink" title="6.2 Map 六大遍历方式"></a>6.2 Map 六大遍历方式</h3><blockquote>
<p>entrySet：获取所有的关系K-V</p>
<p>KeySet：获取所有的键</p>
<p>values：获取所有的值</p>
</blockquote>
<ul>
<li><p><strong>通过 <code>keySet()</code> 遍历键并获取对应的值</strong></p>
<ul>
<li><p><strong>增强 for 循环</strong>：直接遍历键集合，然后使用 <code>map.get(key)</code> 来获取每个键对应的值</p>
</li>
<li><p><strong>迭代器</strong>：使用迭代器来遍历键集合，同样使用 <code>map.get(key)</code> 获取值</p>
</li>
</ul>
</li>
<li><p><strong>通过 <code>values()</code> 遍历所有值</strong>：这种方法只关注值，不涉及键</p>
<ul>
<li><p><strong>增强 for 循环</strong>：直接遍历值集合</p>
</li>
<li><p><strong>迭代器</strong>：使用迭代器遍历值集合</p>
</li>
</ul>
</li>
<li><p><strong>通过 <code>entrySet()</code> 直接遍历键值对</strong>：</p>
<ul>
<li><p><strong>增强 for 循环</strong>：遍历 <code>Entry</code> 集合，可以直接使用 <code>Map.Entry</code> 接口的 <code>getKey()</code> 和 <code>getValue()</code> 方法访问键和值</p>
</li>
<li><p><strong>迭代器</strong>：使用迭代器遍历 <code>Entry</code> 集合，对于每个迭代出的对象，同样使用 <code>Map.Entry</code> 的方法来获取键和值</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一组: 先取出 所有的 Key, 通过 Key 取出对应的 Value</span></span><br><span class="line"><span class="type">Set</span> <span class="variable">keySet</span> <span class="operator">=</span> map.keySet();</span><br><span class="line"><span class="comment">// (1) 增强 for</span></span><br><span class="line">System.out.println(<span class="string">&quot;-----第一种方式-------&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (Object key : keySet) &#123;</span><br><span class="line">    System.out.println(key + <span class="string">&quot;-&quot;</span> + map.get(key));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// (2) 迭代器</span></span><br><span class="line">System.out.println(<span class="string">&quot;----第二种方式--------&quot;</span>);</span><br><span class="line"><span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> keySet.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">key</span> <span class="operator">=</span>  iterator.next();</span><br><span class="line">    System.out.println(key + <span class="string">&quot;-&quot;</span> + map.get(key));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二组: 把所有的 values 取出</span></span><br><span class="line"><span class="type">Collection</span> <span class="variable">values</span> <span class="operator">=</span> map.values();</span><br><span class="line"><span class="comment">// 这里可以使用所有的 Collections 使用的遍历方法</span></span><br><span class="line"><span class="comment">// (1) 增强 for</span></span><br><span class="line">System.out.println(<span class="string">&quot;---取出所有的value 增强for----&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (Object value : values) &#123;</span><br><span class="line">    System.out.println(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// (2) 迭代器</span></span><br><span class="line">System.out.println(<span class="string">&quot;---取出所有的value 迭代器----&quot;</span>);</span><br><span class="line"><span class="type">Iterator</span> <span class="variable">iterator2</span> <span class="operator">=</span> values.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator2.hasNext()) &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span>  iterator2.next();</span><br><span class="line">    System.out.println(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三组: 通过 EntrySet 来获取 k-v</span></span><br><span class="line"><span class="type">Set</span> <span class="variable">entrySet</span> <span class="operator">=</span> map.entrySet();  <span class="comment">// EntrySet&lt;Map.Entry&lt;K,V&gt;&gt;</span></span><br><span class="line"><span class="comment">// (1) 增强 for</span></span><br><span class="line">System.out.println(<span class="string">&quot;----使用 EntrySet 的 for 增强----&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (Object entry : entrySet) &#123;</span><br><span class="line">    <span class="comment">// 将 entry 转成 Map.Entry</span></span><br><span class="line">    Map.<span class="type">Entry</span> <span class="variable">m</span> <span class="operator">=</span> (Map.Entry) entry;</span><br><span class="line">    System.out.println(m.getKey() + <span class="string">&quot;-&quot;</span> + m.getValue());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// (2) 迭代器</span></span><br><span class="line">System.out.println(<span class="string">&quot;----使用 EntrySet 的 迭代器----&quot;</span>);</span><br><span class="line"><span class="type">Iterator</span> <span class="variable">iterator3</span> <span class="operator">=</span> entrySet.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator3.hasNext()) &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">entry</span> <span class="operator">=</span>  iterator3.next();</span><br><span class="line">    <span class="comment">// System.out.println(next.getClass());  // HashMap$Node -实现-&gt; Map.Entry (getKey,getValue), 后者提供了获取 k-v 的方法</span></span><br><span class="line">    <span class="comment">// 向下转型 Map.Entry</span></span><br><span class="line">    Map.<span class="type">Entry</span> <span class="variable">m</span> <span class="operator">=</span> (Map.Entry) entry;</span><br><span class="line">    System.out.println(m.getKey() + <span class="string">&quot;-&quot;</span> + m.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>使用 <code>forEach()</code> 方法（Java 8+）</strong>：使用 <code>forEach()</code> 方法和 Lambda 表达式来遍历 <code>Map</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">map.forEach((key, value) -&gt; &#123;</span><br><span class="line">    <span class="comment">// 处理键和值</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>注意</strong>：<ul>
<li>在遍历集合时尝试修改集合的结构（添加或删除元素）通常是不安全的，除非通过迭代器的 <code>remove()</code> 方法删除元素</li>
<li>修改集合中元素的内部状态（不是集合结构）通常是安全的，如更改对象的属性</li>
<li>增加对集合的任何操作，特别是在遍历过程中，都应该非常小心处理以避免运行时错误</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 练习</span></span><br><span class="line">Map&lt;Integer, Emp&gt; hashMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">hashMap.put(<span class="number">1</span>, <span class="keyword">new</span> <span class="title class_">Emp</span>(<span class="number">1</span>, <span class="string">&quot;h&quot;</span>, <span class="number">1.0</span>));</span><br><span class="line">hashMap.put(<span class="number">2</span>, <span class="keyword">new</span> <span class="title class_">Emp</span>(<span class="number">2</span>, <span class="string">&quot;hh&quot;</span>, <span class="number">2.0</span>));</span><br><span class="line">hashMap.put(<span class="number">3</span>, <span class="keyword">new</span> <span class="title class_">Emp</span>(<span class="number">3</span>, <span class="string">&quot;hhh&quot;</span>, <span class="number">3.0</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 增强 for keySet</span></span><br><span class="line">System.out.println(<span class="string">&quot;======使用增强for======&quot;</span>);</span><br><span class="line">Set&lt;Integer&gt; integers = hashMap.keySet();</span><br><span class="line"><span class="keyword">for</span> (Integer integer : integers) &#123;</span><br><span class="line">    <span class="keyword">if</span> (hashMap.get(integer).getSal() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        System.out.println(hashMap.get(integer));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代器 keySet</span></span><br><span class="line">System.out.println(<span class="string">&quot;=====使用迭代器=====&quot;</span>);</span><br><span class="line">Iterator&lt;Integer&gt; iteratorKey = integers.iterator();</span><br><span class="line"><span class="keyword">while</span> (iteratorKey.hasNext()) &#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">key</span> <span class="operator">=</span> iteratorKey.next();</span><br><span class="line">    <span class="keyword">if</span> (hashMap.get(key).getSal() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        System.out.println(hashMap.get(key));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 增强 for entrySet</span></span><br><span class="line">System.out.println(<span class="string">&quot;=====使用增强for=====&quot;</span>);</span><br><span class="line">Set&lt;Map.Entry&lt;Integer, Emp&gt;&gt; entries = hashMap.entrySet();</span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;Integer, Emp&gt; entry : entries) &#123;</span><br><span class="line">    <span class="keyword">if</span> (entry.getValue().getSal() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        System.out.println(entry.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代器 entrySet</span></span><br><span class="line">System.out.println(<span class="string">&quot;=====使用迭代器=====&quot;</span>);</span><br><span class="line">Iterator&lt;Map.Entry&lt;Integer, Emp&gt;&gt; iterator = entries.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    Map.Entry&lt;Integer, Emp&gt; entry = iterator.next();</span><br><span class="line">    <span class="keyword">if</span> (entry.getValue().getSal() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        System.out.println(entry.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-3-Map-接口实现类-HashMap"><a href="#6-3-Map-接口实现类-HashMap" class="headerlink" title="6.3 Map 接口实现类-HashMap"></a>6.3 Map 接口实现类-HashMap</h3><h4 id="基本介绍-3"><a href="#基本介绍-3" class="headerlink" title="基本介绍"></a>基本介绍</h4><ul>
<li><p>HashMap 是 Map 接口使用频率最高的实现类</p>
</li>
<li><p><strong>线程不安全</strong>：HashMap 没有实现同步</p>
</li>
</ul>
<h4 id="底层机制和源码"><a href="#底层机制和源码" class="headerlink" title="底层机制和源码"></a>底层机制和源码</h4><ul>
<li><strong>初始化和负载因子</strong>：<ul>
<li><strong>默认构造函数</strong>：在实例化 <code>HashMap</code> 时，内部数组 <code>table</code> 是 <code>null</code>。直到第一次插入元素时，才进行实际的内存分配</li>
<li><strong>负载因子</strong>：负载因子 <code>loadFactor</code> 默认为 <code>0.75</code>，这是空间和时间成本的折中选择。负载因子决定了 <code>HashMap</code> 扩容的时间点</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/Java%E9%9B%86%E5%90%88.assets/image-20240430144137292.png" alt="image-20240430144137292"></p>
<ul>
<li><p><strong>内部数组和节点</strong>：<code>HashMap</code> 使用 <code>Node</code> 类型的数组 <code>table</code> 来存储键值对。<code>Node</code> 是 <code>HashMap</code> 的一个内部静态类，每个 <code>Node</code> 对象包含一个键、一个值、一个哈希值和指向下一个节点的引用（链表结构）</p>
</li>
<li><p><strong>添加元素的处理</strong>：</p>
<ul>
<li><strong>索引计算</strong>：通过键的哈希值经过处理后确定在数组 <code>table</code> 中的索引位置</li>
<li><strong>无冲突时</strong>：如果计算得到的索引位置上没有元素，则直接添加</li>
<li><strong>有冲突时</strong>：如果位置上已有元素（链表头），则使用链地址法解决冲突：<ul>
<li>遍历链表，检查是否有相同的键：<ul>
<li>如果找到相同的键，则替换其值</li>
<li>如果未找到相同的键，根据链表的长度决定是添加到链表末尾还是树化</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>扩容与树化</strong>：</p>
<ul>
<li><p><strong>扩容</strong>：当 <code>HashMap</code> 的大小超过 <code>threshold</code>（容量 * 负载因子）时，进行扩容，通常是当前容量的两倍。在扩容时，元素需要重新计算索引并分配到新的数组中</p>
<ul>
<li>第一次添加，则需要扩容table容量为16，临界值（threshold）为12（16*0.75）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">else</span> &#123; </span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>[newCap];</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>以后再扩容，则需要扩容table容量为原来的的2倍（32），临界值为原来的2倍，即24，以此类推；</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">        threshold = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">return</span> oldTab;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">             oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">        newThr = oldThr &lt;&lt; <span class="number">1</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>树化</strong>：在 Java 8 中，如果某个索引位置上的链表长度 &gt;&#x3D; <code>TREEIFY_THRESHOLD</code>（默认为 8），并且数组大小 &gt;&#x3D; <code>MIN_TREEIFY_CAPACITY</code>（默认为 64），则链表转换为红黑树，以改善查找效率</p>
</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/Java%E9%9B%86%E5%90%88.assets/image-20240430143318938.png" alt="image-20240430143318938"></p>
<h3 id="6-4-Map-接口实现类-Hashtable"><a href="#6-4-Map-接口实现类-Hashtable" class="headerlink" title="6.4 Map 接口实现类-Hashtable"></a>6.4 Map 接口实现类-Hashtable</h3><h4 id="基本介绍-4"><a href="#基本介绍-4" class="headerlink" title="基本介绍"></a>基本介绍</h4><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/Java%E9%9B%86%E5%90%88.assets/image-20240430165920234.png" alt="image-20240430165920234"></p>
<ul>
<li><strong>键值对存储</strong>：<code>Hashtable</code> 是 Java 早期的一部分，用于存储键值对（K-V），每个键映射到一个特定的值。</li>
<li><strong>空值限制</strong>：在 <code>Hashtable</code> 中，键（Key）和值（Value）都不能为 <code>null</code>，尝试使用 <code>null</code> 作为键或值都会抛出 <code>NullPointerException</code></li>
<li><strong>线程安全</strong>：<code>Hashtable</code> 的每个方法几乎都是用 <code>synchronized</code> 关键字同步的，因此它是线程安全的，但这也导致了性能上的开销，其他使用方法基本上和 HashMap 一样</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hashtable</span>&lt;K,V&gt;</span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">Dictionary</span>&lt;K,V&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">Map</span>&lt;K,V&gt;, Cloneable, java.io.Serializable &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>逐渐被 <code>ConcurrentHashMap</code> 替代</strong>：<ul>
<li>尽管 <code>Hashtable</code> 是线程安全的，但它的一个主要缺点是它<strong>锁定整个集合来同步不同的方法调用</strong>，这可能导致严重的性能瓶颈</li>
<li>现代的替代品，如 <strong><code>ConcurrentHashMap</code>，提供了更高的并发性能，因为它使用分段锁</strong></li>
</ul>
</li>
</ul>
<h4 id="扩容机制"><a href="#扩容机制" class="headerlink" title="扩容机制"></a>扩容机制</h4><ul>
<li><strong>初始容量和负载因子</strong>：<code>Hashtable</code> 默认的初始容量是 11，而负载因子是 0.75。这意味着当 <code>Hashtable</code> 中的条目数量达到容量和负载因子乘积的结果时（大约是 8），<code>Hashtable</code> 会进行扩容</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Hashtable</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 默认构造函数创建一个初始容量为 11 和负载因子为 0.75 的 Hashtable</span></span><br><span class="line">    <span class="built_in">this</span>(<span class="number">11</span>, <span class="number">0.75f</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Hashtable</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal Load: &quot;</span>+loadFactor);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity==<span class="number">0</span>)</span><br><span class="line">        initialCapacity = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">this</span>.loadFactor = loadFactor;</span><br><span class="line">    table = <span class="keyword">new</span> <span class="title class_">Entry</span>&lt;?,?&gt;[initialCapacity];</span><br><span class="line">    <span class="comment">// 计算触发扩容的阈值，是初始容量与负载因子的乘积，但不超过 MAX_ARRAY_SIZE + 1</span></span><br><span class="line">    threshold = (<span class="type">int</span>)Math.min(initialCapacity * loadFactor, MAX_ARRAY_SIZE + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/Java%E9%9B%86%E5%90%88.assets/image-20240430155922235.png" alt="image-20240430155922235"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Hashtable 中的节点，存储每个键值对</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Entry&lt;K,V&gt; next;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>put 方法</strong>：<ul>
<li>使用 <code>synchronized</code> 关键字声明，确保在多线程环境中的线程安全</li>
<li>检查传入的 <code>value</code> 是否为 <code>null</code>，因为 <code>Hashtable</code> 不允许存储 <code>null</code> 值。如果 <code>value</code> 为 <code>null</code>，抛出 NPE</li>
<li>使用键的 <code>hashCode()</code> 方法计算哈希值，并通过与数组长度的取模操作得到数组索引</li>
<li>如果在链表中没有找到相同的键，调用 <code>addEntry</code> 方法将新的键值对添加到链表的头部</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="comment">// 确保值不为 null，Hashtable 不允许 null 值</span></span><br><span class="line">    <span class="keyword">if</span> (value == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取哈希表的引用</span></span><br><span class="line">    Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">    <span class="comment">// 计算键的哈希值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> key.hashCode();</span><br><span class="line">    <span class="comment">// 计算哈希值对应的索引，使用掩码 0x7FFFFFFF 确保索引为正数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">    <span class="comment">// 获取对应索引处的链表头节点</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    Entry&lt;K,V&gt; entry = (Entry&lt;K,V&gt;)tab[index];</span><br><span class="line">    <span class="comment">// 遍历链表，查找是否存在相同的键</span></span><br><span class="line">    <span class="keyword">for</span> (; entry != <span class="literal">null</span>; entry = entry.next) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((entry.hash == hash) &amp;&amp; entry.key.equals(key)) &#123;</span><br><span class="line">            <span class="comment">// 如果找到相同的键，则更新其值</span></span><br><span class="line">            <span class="type">V</span> <span class="variable">old</span> <span class="operator">=</span> entry.value;</span><br><span class="line">            entry.value = value;</span><br><span class="line">            <span class="comment">// 返回旧值</span></span><br><span class="line">            <span class="keyword">return</span> old;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果没有找到相同的键，添加新的键值对</span></span><br><span class="line">    addEntry(hash, key, value, index);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;  <span class="comment">// 插入新键值对时返回 null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>扩容过程</strong>：HashTable 用的头插，HashMap 用的尾插<ul>
<li><strong>添加新键值对（<code>addEntry()</code> 方法）</strong><ul>
<li>如果 <code>Hashtable</code> 中的元素数量达到了阈值（<code>threshold</code>），则触发 <code>rehash()</code> 方法进行扩容</li>
<li>扩容完成后，重新计算当前新元素键的哈希索引，以确定它在新表中的位置</li>
<li>在确定的索引位置，使用链表的头插法将新元素插入</li>
</ul>
</li>
<li><strong>执行扩容操作（<code>rehash()</code> 方法）</strong><ul>
<li>计算新容量</li>
<li>根据新的容量创建一个新的 <code>Entry</code> 数组并<strong>重新哈希旧元素</strong>，更新 <code>threshold</code> 为新容量与负载因子的乘积</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// addEntry()</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addEntry</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">    modCount++;  <span class="comment">// 增加修改次数，用于迭代器快速失败行为</span></span><br><span class="line"></span><br><span class="line">    Entry&lt;?,?&gt; tab[] = table;  <span class="comment">// 获取当前哈希表的引用</span></span><br><span class="line">    <span class="keyword">if</span> (count &gt;= threshold) &#123;  <span class="comment">// 检查当前元素数量是否达到阈值</span></span><br><span class="line">        rehash();  <span class="comment">// 执行扩容和重新哈希</span></span><br><span class="line"></span><br><span class="line">        tab = table;  <span class="comment">// 重新获取扩容后的哈希表引用</span></span><br><span class="line">        hash = key.hashCode();  <span class="comment">// 重新计算键的哈希值，因为数组大小已改变</span></span><br><span class="line">        index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;  <span class="comment">// 根据新的哈希表大小重新计算索引</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;) tab[index];  <span class="comment">// 获取当前索引位置的头节点</span></span><br><span class="line">    tab[index] = <span class="keyword">new</span> <span class="title class_">Entry</span>&lt;&gt;(hash, key, value, e);  <span class="comment">// 创建新节点并将其插入链表头部（头插法）</span></span><br><span class="line">    count++;  <span class="comment">// 增加Hashtable的元素计数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// rehash()</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">rehash</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> table.length;</span><br><span class="line">    Entry&lt;?,?&gt;[] oldMap = table;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新容量是旧容量的两倍加一</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> (oldCapacity &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 如果新容量超过了 MAX_ARRAY_SIZE</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 检查旧容量是否已是最大</span></span><br><span class="line">        <span class="keyword">if</span> (oldCapacity == MAX_ARRAY_SIZE)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 不是则调整为最大容量</span></span><br><span class="line">        newCapacity = MAX_ARRAY_SIZE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建新的 Entry 数组以容纳更多元素</span></span><br><span class="line">    Entry&lt;?,?&gt;[] newMap = <span class="keyword">new</span> <span class="title class_">Entry</span>&lt;?,?&gt;[newCapacity];</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    threshold = (<span class="type">int</span>)Math.min(newCapacity * loadFactor, MAX_ARRAY_SIZE + <span class="number">1</span>);</span><br><span class="line">    table = newMap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历旧数组，将每个元素重新哈希到新数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> oldCapacity ; i-- &gt; <span class="number">0</span> ;) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; old = (Entry&lt;K,V&gt;)oldMap[i] ; old != <span class="literal">null</span> ; ) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; e = old;</span><br><span class="line">            old = old.next;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 使用元素的哈希值和新容量计算新索引</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (e.hash &amp; <span class="number">0x7FFFFFFF</span>) % newCapacity;</span><br><span class="line">            <span class="comment">// 将元素重新链接到新数组的相应位置</span></span><br><span class="line">            e.next = (Entry&lt;K,V&gt;)newMap[index];</span><br><span class="line">            newMap[index] = e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-5-Map-接口实现类-Properties"><a href="#6-5-Map-接口实现类-Properties" class="headerlink" title="6.5 Map 接口实现类-Properties"></a>6.5 Map 接口实现类-Properties</h3><h4 id="基本介绍-5"><a href="#基本介绍-5" class="headerlink" title="基本介绍"></a>基本介绍</h4><ul>
<li><strong>继承和实现</strong>：<code>Properties</code> 类继承自 <code>Hashtable</code>。因此，它本质上是一个 <code>Hashtable</code>，键和值不允许为 <code>null</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Properties</span> <span class="keyword">extends</span> <span class="title class_">Hashtable</span>&lt;Object,Object&gt; &#123;</span><br><span class="line">	<span class="keyword">protected</span> Properties defaults;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Properties</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Properties</span><span class="params">(Properties defaults)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.defaults = defaults;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/Java%E9%9B%86%E5%90%88.assets/image-20240430171201601.png" alt="image-20240430171201601"></p>
<ul>
<li><p><strong>用途</strong>：<code>Properties</code> 主要用于管理配置数据，这些数据存储在键值对形式的属性文件（<code>.properties</code> 文件）中</p>
</li>
<li><p><strong>文件操作</strong>：<code>Properties</code> 提供了方便的方法来从文件加载数据 (<code>load()</code>) 和向文件写入数据 (<code>store()</code>)，使其非常适合读取和存储配置文件</p>
</li>
<li><p><strong>功能特点</strong>：</p>
<ul>
<li><strong>加载和存储</strong>：<ul>
<li><strong>加载（<code>load()</code> 方法）</strong>：可以从一个输入流（如文件输入流）中读取属性列表（键和元素对）。支持从 XML 和普通属性文件格式加载</li>
<li><strong>存储（<code>store()</code> 方法）</strong>：可以将 <code>Properties</code> 对象中的数据写入到输出流，同样支持 XML 和普通属性文件格式</li>
</ul>
</li>
<li><strong>与系统属性的交互</strong>：<ul>
<li><code>Properties</code> 类可以与系统属性直接交互，使用 <code>System.getProperties()</code> 获取当前系统属性</li>
</ul>
</li>
<li><strong>默认值机制</strong>：<ul>
<li><code>Properties</code> 可以指定一个包含默认值的 <code>Properties</code> 对象。如果主 <code>Properties</code> 对象中没有找到相应的键，那么将会搜索这个默认值 <code>Properties</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 解读</span></span><br><span class="line">    <span class="comment">// 1. Properties 继承  Hashtable</span></span><br><span class="line">    <span class="comment">// 2. 可以通过 k-v 存放数据, key 和 value 不能为 null</span></span><br><span class="line">    <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">    <span class="comment">// 增加</span></span><br><span class="line">    <span class="comment">// properties.put(null, &quot;abc&quot;);  // 抛出 空指针异常</span></span><br><span class="line">    <span class="comment">// properties.put(&quot;abc&quot;, null);  // 抛出 空指针异常</span></span><br><span class="line">    properties.put(<span class="string">&quot;john&quot;</span>, <span class="number">100</span>);  <span class="comment">// k-v</span></span><br><span class="line">    properties.put(<span class="string">&quot;lucy&quot;</span>, <span class="number">100</span>);</span><br><span class="line">    properties.put(<span class="string">&quot;lic&quot;</span>, <span class="number">100</span>);</span><br><span class="line">    properties.put(<span class="string">&quot;lic&quot;</span>, <span class="number">88</span>);  <span class="comment">// 如果有相同的 key, value被替换</span></span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;properties=&quot;</span> + properties);</span><br><span class="line">    <span class="comment">// properties=&#123;john=100, lic=88, lucy=100&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找, 通过 key 获取对应值</span></span><br><span class="line">    <span class="comment">// get(Object key) 方法来自 Hashtable 类，它返回与指定键关联的值</span></span><br><span class="line">    <span class="comment">// 这个方法会返回任何类型的对象</span></span><br><span class="line">    System.out.println(properties.get(<span class="string">&quot;lic&quot;</span>));  <span class="comment">// 88</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// getProperty(String key) 方法是 Properties 类特有的，它只返回字符串类型的值</span></span><br><span class="line">    <span class="comment">// 如果值不是字符串，getProperty 方法将返回 null</span></span><br><span class="line">    System.out.println(properties.getProperty(<span class="string">&quot;lic&quot;</span>));  <span class="comment">// null</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除</span></span><br><span class="line">    properties.remove(<span class="string">&quot;lic&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;properties = &quot;</span> + properties);  <span class="comment">// properties = &#123;john=100, lucy=100&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改</span></span><br><span class="line">    properties.put(<span class="string">&quot;john&quot;</span>, <span class="string">&quot;约翰&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;properties = &quot;</span> + properties);  <span class="comment">// properties = &#123;john=约翰, lucy=100&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>使用 <code>Properties</code> 类加载和存储属性文件的示例</strong>：</p>
<ul>
<li><code>config.properties</code> 示例：</li>
</ul>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">username</span>=<span class="string">admin</span></span><br><span class="line"><span class="attr">password</span>=<span class="string">secret</span></span><br><span class="line"><span class="attr">database</span>=<span class="string">localhost</span></span><br><span class="line"><span class="attr">port</span>=<span class="string">3306</span></span><br></pre></td></tr></table></figure>

<ul>
<li>代码示例：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PropertiesExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Properties</span> <span class="variable">props</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 加载属性文件</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;config.properties&quot;</span>);</span><br><span class="line">        props.load(in);</span><br><span class="line">        in.close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取属性</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> props.getProperty(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Username: &quot;</span> + username);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 修改/添加属性</span></span><br><span class="line">        props.setProperty(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;newUsername&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 存储修改后的属性文件</span></span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;config.properties&quot;</span>);</span><br><span class="line">        props.store(out, <span class="string">&quot;Updated username&quot;</span>);</span><br><span class="line">        out.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="7-TreeSet-和-TreeMap-源码分析"><a href="#7-TreeSet-和-TreeMap-源码分析" class="headerlink" title="7. TreeSet 和 TreeMap 源码分析"></a>7. TreeSet 和 TreeMap 源码分析</h2><h3 id="7-1-TreeSet-分析"><a href="#7-1-TreeSet-分析" class="headerlink" title="7.1 TreeSet 分析"></a>7.1 TreeSet 分析</h3><ul>
<li><code>TreeSet</code> 是基于 <code>TreeMap</code> 实现的，它利用 <code>TreeMap</code> 来保持元素的有序性和唯一性。<code>TreeMap</code> 本质上是一个红黑树实现的排序映射表，<code>TreeMap</code> 有一个属性是 <code>comparator</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TreeMap.java</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Comparator&lt;? <span class="built_in">super</span> K&gt; comparator;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">TreeMap</span><span class="params">()</span> &#123;</span><br><span class="line">    comparator = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">TreeMap</span><span class="params">(Comparator&lt;? <span class="built_in">super</span> K&gt; comparator)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.comparator = comparator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>TreeSet 实现了 Set 接口，与 HashSet 最大的区别是可以排序</li>
</ul>
<blockquote>
<p><code>TreeSet</code> 继承自 <code>AbstractSet</code>，后者提供了 <code>Set</code> 接口的骨架实现；<code>TreeSet</code> 实现了 <code>NavigableSet</code> 接口，该接口扩展了 <code>SortedSet</code> 并提供导航方法</p>
</blockquote>
<ul>
<li><p><strong>构造函数</strong>：</p>
<ul>
<li><strong>无参构造器</strong>：使用无参构造器创建 <code>TreeSet</code> 时，默认情况下是基于自然排序的，需要存储在 <code>TreeSet</code> 中的元素实现 <code>Comparable</code> 接口</li>
</ul>
<blockquote>
<p>自然排序指的是基于元素自身的特性进行排序，而不需要外部指定排序规则</p>
<p>对于整数，自然排序就是按照数字大小进行排序；对于字符串，自然排序是按照字典顺序进行排序</p>
<p>对于字符串，String 类实现了 Comparable 接口，因此它支持自然排序。String 类的 compareTo 方法会按照字典顺序比较字符串的大小</p>
</blockquote>
<ul>
<li><strong>带比较器构造器</strong>：如果提供了一个比较器(传入了匿名内部类并指定排序规则)，<code>TreeSet</code> 会使用这个比较器来创建一个 <code>TreeMap</code>，允许对元素进行自定义排序</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TreeSet.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeSet</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractSet</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">NavigableSet</span>&lt;E&gt;, Cloneable, java.io.Serializable &#123;</span><br><span class="line">    <span class="comment">// TreeSet 的内部使用了一个 NavigableMap 来存储其元素, 元素作为键存储在此 Map 中</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> NavigableMap&lt;E,Object&gt; m;</span><br><span class="line">    <span class="comment">// 用于与 TreeSet 中的每个元素（作为键）关联, 方便利用 TreeMap 来实现 TreeSet</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">PRESENT</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 无参数构造器, 内部会创建一个基于自然排序的 TreeMap</span></span><br><span class="line">    <span class="comment">// 意味着元素需要具有可比性, 即元素类型 E 必须实现 Comparable 接口</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TreeSet</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(<span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;E,Object&gt;());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 允许用户提供一个自定义的比较器 Comparator 用于元素的排序</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TreeSet</span><span class="params">(Comparator&lt;? <span class="built_in">super</span> E&gt; comparator)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(<span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;(comparator));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Comparator 接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Comparator</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>代码示例</strong>：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TreeSet treeSet = new TreeSet();</span></span><br><span class="line"><span class="comment">// 创建一个 TreeSet 实例，提供自定义的 Comparator 比较器</span></span><br><span class="line"><span class="type">TreeSet</span> <span class="variable">treeSet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeSet</span>(<span class="keyword">new</span> <span class="title class_">Comparator</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object o1, Object o2)</span> &#123;</span><br><span class="line">        <span class="comment">// 调用 String 的 compareTo 方法进行字符串大小比较，若字符串内容完全相同，则不再添加</span></span><br><span class="line">        <span class="comment">// o2 - o1 是从大到小, 此处若想从小到大可直接利用 String 的自然排序(无参构造即可)</span></span><br><span class="line">        <span class="comment">// 从大到小也有使用有参构造的更加方便的写法: new TreeSet&lt;&gt;(Comparator.reverseOrder());</span></span><br><span class="line">        <span class="comment">// return ((String) o2).compareTo((String) o1);  // treeSet=[tom, sp, jack, abc, a]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将对象 o1 和 o2 强制类型转换为 String，然后按照它们的长度进行比较，从而实现自定义排序</span></span><br><span class="line">        <span class="comment">// 如果 o1 的长度小于 o2 的长度，返回负数；如果长度相等，返回 0；如果 o1 的长度大于 o2 的长度，返回正数</span></span><br><span class="line">        <span class="comment">// 返回 0 时，TreeSet 认为这两个元素相等，因此不会添加重复长度的元素</span></span><br><span class="line">        <span class="comment">// 此处 o1 - o2 为从短到长排序</span></span><br><span class="line">        <span class="keyword">return</span> ((String) o1).length() - ((String) o2).length();  <span class="comment">// treeSet=[a, sp, tom, jack]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以用 lambda 表达式简写为:</span></span><br><span class="line"><span class="comment">// TreeSet treeSet = new TreeSet(Comparator.comparingInt(o -&gt; ((String) o).length()));</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加数据</span></span><br><span class="line">treeSet.add(<span class="string">&quot;jack&quot;</span>);</span><br><span class="line">treeSet.add(<span class="string">&quot;tom&quot;</span>);  <span class="comment">// 3</span></span><br><span class="line">treeSet.add(<span class="string">&quot;sp&quot;</span>);</span><br><span class="line">treeSet.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">treeSet.add(<span class="string">&quot;abc&quot;</span>);  <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;treeSet=&quot;</span> + treeSet);</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>String 类的 compareTo 方法</strong>：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(String anotherString)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取字符串的长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len1</span> <span class="operator">=</span> value.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len2</span> <span class="operator">=</span> anotherString.value.length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算两个字符串中长度较小的值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">lim</span> <span class="operator">=</span> Math.min(len1, len2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取字符串的字符数组</span></span><br><span class="line">        <span class="type">char</span> v1[] = value;</span><br><span class="line">        <span class="type">char</span> v2[] = anotherString.value;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 循环比较两个字符串的每个字符，直到其中一个字符串结束</span></span><br><span class="line">        <span class="keyword">while</span> (k &lt; lim) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c1</span> <span class="operator">=</span> v1[k];</span><br><span class="line">            <span class="type">char</span> <span class="variable">c2</span> <span class="operator">=</span> v2[k];</span><br><span class="line">            <span class="keyword">if</span> (c1 != c2) &#123;</span><br><span class="line">                <span class="comment">// 返回两个字符的差值，如果 c1 &lt; c2，结果为负，反之为正</span></span><br><span class="line">                <span class="keyword">return</span> c1 - c2;</span><br><span class="line">            &#125;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果所有比较的字符都相同，则比较字符串长度，返回长度差, 意味着较短的字符串被视为较小</span></span><br><span class="line">        <span class="keyword">return</span> len1 - len2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>带比较器构造器调用过程</strong>：<ul>
<li>构造器把传入的比较器对象，赋给了 <code>TreeSet</code> 底层的 <code>TreeMap</code> 的属性 <code>this.comparator</code></li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TreeSet.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">TreeSet</span><span class="params">(Comparator&lt;? <span class="built_in">super</span> E&gt; comparator)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(<span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;(comparator));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// TreeMap.java</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Comparator&lt;? <span class="built_in">super</span> K&gt; comparator;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">TreeMap</span><span class="params">(Comparator&lt;? <span class="built_in">super</span> K&gt; comparator)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.comparator = comparator;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TreeSet.java 的 add 方法</span></span><br><span class="line"><span class="comment">// NavigableMap 接口继承了 SortedMap 接口, 后者又继承自 Map 接口, 这里 NavigableMap 实际使用的是 TreeMap 实例</span></span><br><span class="line"><span class="comment">// 使用接口类型声明一个变量时, 可以将任何实现了该接口的类的实例赋值给这个变量, 变量在编译时表现为接口类型，在运行时表现为实际对象的类型</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> NavigableMap&lt;E,Object&gt; m;</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> m.put(e, PRESENT)==<span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TreeMap.java 里的 put 方法</span></span><br><span class="line"><span class="comment">//  内部使用红黑树的数据结构来存储键值对</span></span><br><span class="line"><span class="comment">// 插入、删除和查找操作的最坏情况时间复杂度为 O(log n)</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    Entry&lt;K,V&gt; t = root;  <span class="comment">// 从根节点开始</span></span><br><span class="line">    <span class="keyword">if</span> (t == <span class="literal">null</span>) &#123;  <span class="comment">// 如果树为空</span></span><br><span class="line">        <span class="comment">// 用于确保在没有提供 Comparator 的情况下，键 key 是可比较的</span></span><br><span class="line">        compare(key, key);  <span class="comment">// 验证 key 是否可比较</span></span><br><span class="line">        <span class="comment">// 第一次添加,把 k-v 封装到 Entry 对象放入root</span></span><br><span class="line">        root = <span class="keyword">new</span> <span class="title class_">Entry</span>&lt;&gt;(key, value, <span class="literal">null</span>);  <span class="comment">// 创建新的根节点</span></span><br><span class="line">        size = <span class="number">1</span>;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> cmp;</span><br><span class="line">    Entry&lt;K,V&gt; parent;</span><br><span class="line">    <span class="comment">// 获取比较器</span></span><br><span class="line">    Comparator&lt;? <span class="built_in">super</span> K&gt; cpr = comparator;  </span><br><span class="line">    <span class="keyword">if</span> (cpr != <span class="literal">null</span>) &#123;  <span class="comment">// 如果使用自定义比较器</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            parent = t;</span><br><span class="line">            <span class="comment">// 使用比较器比较键, 动态绑定到匿名内部类的 compare 方法</span></span><br><span class="line">            cmp = cpr.compare(key, t.key); </span><br><span class="line">            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">                t = t.left;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">                t = t.right;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> t.setValue(value);</span><br><span class="line">        &#125; <span class="keyword">while</span> (t != <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 没有比较器，键必须是可比较的</span></span><br><span class="line">        <span class="keyword">if</span> (key == <span class="literal">null</span>)  <span class="comment">// 键不能为 null</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">        Comparable&lt;? <span class="built_in">super</span> K&gt; k = (Comparable&lt;? <span class="built_in">super</span> K&gt;) key;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            parent = t;</span><br><span class="line">            <span class="comment">// 使用键的自然顺序比较</span></span><br><span class="line">            cmp = k.compareTo(t.key);</span><br><span class="line">            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">                t = t.left;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">                t = t.right;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> t.setValue(value);</span><br><span class="line">        &#125; <span class="keyword">while</span> (t != <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建新节点</span></span><br><span class="line">    Entry&lt;K,V&gt; e = <span class="keyword">new</span> <span class="title class_">Entry</span>&lt;&gt;(key, value, parent);</span><br><span class="line">    <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">        parent.left = e;  <span class="comment">// 添加为左子节点</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        parent.right = e;  <span class="comment">// 添加为右子节点</span></span><br><span class="line">    fixAfterInsertion(e);  <span class="comment">// 调整树以保持平衡</span></span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查是否有自定义的比较器 (Comparator) 提供</span></span><br><span class="line"><span class="comment">// 如果 没有提供比较器 (comparator==null)，那么假设 k1 必须实现 Comparable 接口。它尝试将 k1 强制类型转换为 Comparable，然后使用 compareTo 方法比较 k1 和 k2</span></span><br><span class="line"><span class="comment">// 如果 k1 没有实现 Comparable 接口，这个类型转换会失败，抛出 ClassCastException</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object k1, Object k2)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> comparator==<span class="literal">null</span> ? ((Comparable&lt;? <span class="built_in">super</span> K&gt;)k1).compareTo((K)k2)</span><br><span class="line">        : comparator.compare((K)k1, (K)k2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-2-TreeMap-分析"><a href="#7-2-TreeMap-分析" class="headerlink" title="7.2 TreeMap 分析"></a>7.2 TreeMap 分析</h3><ul>
<li><code>TreeMap</code> 是一个基于红黑树的有序映射，支持<strong>按照键的自然顺序或者根据指定的 <code>Comparator</code> 进行排序</strong></li>
<li><strong>插入元素的逻辑</strong>：<ul>
<li>首先<strong>检查根节点是否为空</strong>，如果是，则简单地将<strong>新元素设置为根节点</strong>（第一次添加，把 k-v 封装到 Entry 对象，放入root）</li>
<li>如果<strong>根节点不为空，则使用比较器</strong>（如果存在）或键的自然顺序来找到适当的插入位置<ul>
<li>涉及在树中逐级向下搜索正确的插入点，直到找到空位置插入新节点</li>
<li>如果找到相同键的节点，则更新该节点的值</li>
</ul>
</li>
<li>插入新节点后，可能需要进行红黑树的调整操作以保持树的平衡</li>
</ul>
</li>
<li><strong>代码示例</strong>：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">TreeMap</span> <span class="variable">treeMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeMap</span>(<span class="keyword">new</span> <span class="title class_">Comparator</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object o1, Object o2)</span> &#123;</span><br><span class="line">        <span class="comment">//按照 K(String) 的长度大小排序</span></span><br><span class="line">        <span class="keyword">return</span> ((String) o2).length() - ((String) o1).length();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">treeMap.put(<span class="string">&quot;jack&quot;</span>, <span class="string">&quot;杰克&quot;</span>);</span><br><span class="line">treeMap.put(<span class="string">&quot;tom&quot;</span>, <span class="string">&quot;汤姆&quot;</span>);</span><br><span class="line">treeMap.put(<span class="string">&quot;kristina&quot;</span>, <span class="string">&quot;克瑞斯提诺&quot;</span>);</span><br><span class="line">treeMap.put(<span class="string">&quot;smith&quot;</span>, <span class="string">&quot;斯密斯&quot;</span>);</span><br><span class="line">treeMap.put(<span class="string">&quot;hhh&quot;</span>, <span class="string">&quot;hhh&quot;</span>);  <span class="comment">// 加入不了, 并且会覆盖前面 tom 键所对应的值</span></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;treemap=&quot;</span> + treeMap);</span><br><span class="line"><span class="comment">// treemap=&#123;kristina=克瑞斯提诺, smith=斯密斯, jack=杰克, tom=hhh&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="8-集合选型规则"><a href="#8-集合选型规则" class="headerlink" title="8. 集合选型规则"></a>8. 集合选型规则</h2><blockquote>
<p>开发中如何选择集合实现类？</p>
<p>主要取决于业务操作特点，然后根据集合实现类特性进行选择</p>
</blockquote>
<p><strong>判断存储的类型</strong></p>
<ul>
<li><p><strong>一组对象[单列]（使用 <code>Collection</code> 接口</strong>）</p>
<ul>
<li><p><strong>允许重复</strong>：</p>
<ul>
<li><strong><code>List</code> 接口</strong>：<ul>
<li><strong><code>ArrayList</code><strong>：适用于</strong>查找和修改操作频繁</strong>的场景（底层维护 Object 类型的可变数组）</li>
<li><strong><code>LinkedList</code><strong>：适合于</strong>增加和删除操作频繁</strong>的场景（底层维护一个双向链表）</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>不允许重复</strong>：</p>
<blockquote>
<p>以下的无序指存取的顺序不一致，但是取出的顺序是固定一致的</p>
</blockquote>
<ul>
<li><code>Set</code> 接口：<ul>
<li><strong><code>HashSet</code><strong>：最常用的集合，提供快速访问，保持元素唯一，但元素是</strong>无序</strong>的。内部通过哈希表实现，包括数组、链表和红黑树（Java 8 及以上）</li>
<li><strong><code>TreeSet</code><strong>：当需要一个</strong>有序</strong>集合时选择，它根据元素的自然顺序或构造器提供的 <code>Comparator</code> 进行排序</li>
<li><strong><code>LinkedHashSet</code><strong>：</strong>维护元素插入顺序</strong>，性能略低于 <code>HashSet</code>，但迭代访问所有元素时有更高的性能（维护哈希表+双向链表）<ul>
<li>LinkedHashSet 底层是 LinkedHashMap；LinkedHashMap 的底层是 HashMap</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>一组键值对[双列]（使用 <code>Map</code> 接口）</strong></p>
<ul>
<li><p><strong><code>HashMap</code><strong>：是最常用的 <code>Map</code> 实现，</strong>键无序</strong>，按键的哈希码存储数据（底层数组+链表&#x2F;红黑树）</p>
</li>
<li><p><strong><code>TreeMap</code><strong>：基于红黑树的 <code>Map</code> 实现，它根据键的自然</strong>排序</strong>或构造器提供的 <code>Comparator</code> 对键进行排序。适用于需要按自然顺序或特定顺序遍历键时</p>
</li>
<li><p><strong><code>LinkedHashMap</code><strong>：</strong>保持插入顺序</strong>，通常比 <code>HashMap</code> 慢一点，但在迭代访问时更快</p>
</li>
</ul>
</li>
<li><p><strong>特殊用途</strong></p>
<ul>
<li><strong><code>Properties</code><strong>：用于</strong>读取 <code>.properties</code> 文</strong>件，适用于配置数据的加载和存储。它是 <code>Hashtable</code> 的一个子类，其中键和值都是字符串</li>
</ul>
</li>
</ul>
<h2 id="9-Collections-工具类"><a href="#9-Collections-工具类" class="headerlink" title="9. Collections 工具类"></a>9. Collections 工具类</h2><h3 id="9-1-基本介绍"><a href="#9-1-基本介绍" class="headerlink" title="9.1 基本介绍"></a>9.1 基本介绍</h3><ul>
<li><code>Collections</code> 是 Java 中的一个工具类，专门用于操作集合，如 <code>Set</code>、<code>List</code> 和 <code>Map</code> 等</li>
<li>该类提供了多种静态方法，用于执行集合上的操作，如排序、查询、修改等</li>
</ul>
<h3 id="9-2-主要方法"><a href="#9-2-主要方法" class="headerlink" title="9.2 主要方法"></a>9.2 主要方法</h3><blockquote>
<p>static操作</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建ArrayList 集合, 用于测试</span></span><br><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">list.add(<span class="string">&quot;tom&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;smith&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;king&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;milan&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;tom&quot;</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>排序和调整</strong>：<ul>
<li><code>reverse(List)</code>: 反转 <code>List</code> 中元素的顺序。</li>
<li><code>shuffle(List)</code>: 对 <code>List</code> 集合元素进行随机排序。</li>
<li><code>sort(List)</code>: 根据元素的自然顺序对指定 <code>List</code> 集合元素按升序排序。</li>
<li><code>sort(List, Comparator)</code>: 根据指定的 <code>Comparator</code> 定制的顺序对 <code>List</code> 集合元素进行排序。</li>
<li><code>swap(List, int, int)</code>: 将指定 <code>List</code> 集合中的 i 处元素和 j 处元素进行交换。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reverse(List): 反转 List 中元素的顺序</span></span><br><span class="line">Collections.reverse(list);</span><br><span class="line">System.out.println(<span class="string">&quot;list = &quot;</span> + list);  <span class="comment">// list = [tom, milan, king, smith, tom]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// shuffle(List): 对 List 集合元素进行随机排序</span></span><br><span class="line"><span class="comment">// for (int i = 0; i &lt; 5; i++) &#123;</span></span><br><span class="line"><span class="comment">//     Collections.shuffle(list);</span></span><br><span class="line"><span class="comment">//     System.out.println(&quot;list = &quot; + list);</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// sort(List): 根据元素的自然顺序对指定 List 集合元素按升序排序</span></span><br><span class="line">Collections.sort(list);</span><br><span class="line">System.out.println(<span class="string">&quot;=======自然排序后=========&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;list = &quot;</span> + list);  <span class="comment">// list = [king, milan, smith, tom, tom]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// sort(List，Comparator): 根据指定的 Comparator 产生的顺序对 List 集合元素进行排序</span></span><br><span class="line"><span class="comment">// 如: 按照字符串的长度大小排序, 传递匿名内部类</span></span><br><span class="line">Collections.sort(list, <span class="keyword">new</span> <span class="title class_">Comparator</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object o1, Object o2)</span> &#123;</span><br><span class="line">        <span class="comment">// 严谨些需要加入校验代码, 避免转型异常</span></span><br><span class="line">        <span class="comment">// 确保两个对象都是字符串类型</span></span><br><span class="line">        <span class="comment">// if (o1 instanceof String &amp;&amp; o2 instanceof String) &#123;</span></span><br><span class="line">        <span class="comment">//     // 正确的情况下，比较它们的长度</span></span><br><span class="line">        <span class="comment">//     return ((String) o2).length() - ((String) o1).length();  // 从长到短</span></span><br><span class="line">        <span class="comment">// &#125; else &#123;</span></span><br><span class="line">        <span class="comment">//     // 如果任一对象不是字符串，可以选择抛出异常或返回0</span></span><br><span class="line">        <span class="comment">//     // 抛出异常</span></span><br><span class="line">        <span class="comment">//     throw new IllegalArgumentException(&quot;Both objects must be strings&quot;);</span></span><br><span class="line">        <span class="comment">//     // 或者可以选择处理为相等，取决具体的业务逻辑</span></span><br><span class="line">        <span class="comment">//     // return 0;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="keyword">return</span> ((String) o2).length() - ((String) o1).length();  <span class="comment">// 从长到短</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(<span class="string">&quot;=======字符串长度大小排序后=========&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;list = &quot;</span> + list);  <span class="comment">// list = [milan, smith, king, tom, tom]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// swap(List，int， int): 将指定 list 集合中的 i 处元素和 j 处元素进行交换</span></span><br><span class="line">Collections.swap(list, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;=======交换后的情况=========&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;list = &quot;</span> + list);  <span class="comment">// list = [smith, milan, king, tom, tom]</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>查找和统计</strong>：<ul>
<li><code>max(Collection)</code>: 根据元素的自然顺序，返回给定集合中的最大元素。</li>
<li><code>max(Collection, Comparator)</code>: 根据 <code>Comparator</code> 指定的顺序，返回给定集合中的最大元素。</li>
<li><code>min(Collection)</code>: 返回集合中的最小元素，根据自然排序。</li>
<li><code>min(Collection, Comparator)</code>: 根据指定的比较器返回集合中的最小元素。</li>
<li><code>frequency(Collection, Object)</code>: 返回指定集合中指定元素的出现次数。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Object max(Collection): 根据元素的自然顺序，返回给定集合中的最大元素</span></span><br><span class="line">System.out.println(<span class="string">&quot;自然顺序最大元素 = &quot;</span> + Collections.max(list));  <span class="comment">// 自然顺序最大元素 = tom</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Object max(Collection，Comparator): 根据 Comparator 指定的顺序, 返回给定集合中的最大元素</span></span><br><span class="line"><span class="comment">// 比如: 返回长度最大的元素</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">maxObject</span> <span class="operator">=</span> Collections.max(list, <span class="keyword">new</span> <span class="title class_">Comparator</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object o1, Object o2)</span> &#123;</span><br><span class="line">        <span class="comment">// 从短到长 ==&gt; 返回长度最大</span></span><br><span class="line">        <span class="keyword">return</span> ((String) o1).length() - ((String) o2).length();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从长到短 ==&gt; 返回长度最小</span></span><br><span class="line">        <span class="comment">// return ((String) o2).length() - ((String) o1).length();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(<span class="string">&quot;长度最大的元素 = &quot;</span> + maxObject);  <span class="comment">// 长度最大的元素 = smith</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面两个方法参考 max 即可</span></span><br><span class="line"><span class="comment">// Object min(Collection)</span></span><br><span class="line"><span class="comment">// Object min(Collection，Comparator)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// int frequency(Collection，Object): 返回指定集合中指定元素的出现次数</span></span><br><span class="line">System.out.println(<span class="string">&quot;tom 出现的次数 = &quot;</span> + Collections.frequency(list, <span class="string">&quot;tom&quot;</span>));  <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>复制和替换</strong>：</p>
<ul>
<li><p><code>copy(List dest, List src)</code>: 将 <code>src</code> 中的内容复制到 <code>dest</code> 中，执行的是浅复制(如果列表中的元素是对象，那么两个列表中的相应位置将指向同一个对象)。</p>
</li>
<li><p><code>replaceAll(List, Object oldVal, Object newVal)</code>: 使用新值替换 <code>List</code> 对象中所有的旧值。</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// void copy(List dest, List src): 将 src 中的内容复制到 dest 中</span></span><br><span class="line"><span class="type">ArrayList</span> <span class="variable">dest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line"><span class="comment">// 先给 dest 赋值, 大小和 list.size() 一样</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">    dest.add(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 拷贝, 将 list 内容复制到 dest 中</span></span><br><span class="line">Collections.copy(dest, list);</span><br><span class="line">System.out.println(<span class="string">&quot;dest = &quot;</span> + dest);  <span class="comment">// dest = [smith, milan, king, tom, tom]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// boolean replaceAll(List list, Object oldVal, Object newVal): 使用新值替换 List 对象的所有旧值</span></span><br><span class="line"><span class="comment">// 如果list中, 有 tom 就替换成 汤姆</span></span><br><span class="line">Collections.replaceAll(list, <span class="string">&quot;tom&quot;</span>, <span class="string">&quot;汤姆&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;list 替换后 = &quot;</span> + list);  <span class="comment">// list 替换后 = [smith, milan, king, 汤姆, 汤姆]</span></span><br></pre></td></tr></table></figure>

<h2 id="10-课后习题"><a href="#10-课后习题" class="headerlink" title="10. 课后习题"></a>10. 课后习题</h2><h3 id="10-1-Homework01"><a href="#10-1-Homework01" class="headerlink" title="10.1 Homework01"></a>10.1 Homework01</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Homework01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;News&gt; news = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        news.add(<span class="keyword">new</span> <span class="title class_">News</span>(<span class="string">&quot;news01xxxxxxxxxxxxxxxxxxxxxx&quot;</span>));</span><br><span class="line">        news.add(<span class="keyword">new</span> <span class="title class_">News</span>(<span class="string">&quot;news02&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 倒序遍历+截取字符串(这里截取前按理来说要判断下标题非 null)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> news.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (news.get(i).getTitle().length() &gt; <span class="number">15</span>) &#123;</span><br><span class="line">                System.out.println(news.get(i).getTitle().substring(<span class="number">0</span>, <span class="number">15</span>) + <span class="string">&quot;...&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(news.get(i).getTitle());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="10-2-Homework03"><a href="#10-2-Homework03" class="headerlink" title="10.2 Homework03"></a>10.2 Homework03</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Homework03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Map&lt;String, Integer&gt; emps = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        emps.put(<span class="string">&quot;aa&quot;</span>, <span class="number">650</span>);</span><br><span class="line">        emps.put(<span class="string">&quot;bb&quot;</span>, <span class="number">1200</span>);</span><br><span class="line">        emps.put(<span class="string">&quot;cc&quot;</span>, <span class="number">2900</span>);</span><br><span class="line"></span><br><span class="line">        Set&lt;Map.Entry&lt;String, Integer&gt;&gt; entries = emps.entrySet();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : entries) &#123;</span><br><span class="line">            <span class="keyword">if</span> (entry.getKey().equals(<span class="string">&quot;22&quot;</span>)) &#123;</span><br><span class="line">                entry.setValue(<span class="number">2600</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            entry.setValue(entry.getValue() + <span class="number">100</span>);</span><br><span class="line">            System.out.println(entry);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="10-3-Homework04"><a href="#10-3-Homework04" class="headerlink" title="10.3 Homework04"></a>10.3 Homework04</h3><p><strong>分析下 HashSet 和 TreeSet 分别如何去重？</strong></p>
<ul>
<li><p><strong>HashSet 去重</strong>：</p>
<ul>
<li><strong>计算哈希值</strong>：通过调用元素的 <code>hashCode()</code> 方法计算其哈希值。</li>
<li><strong>确定位置</strong>：使用哈希值来确定在哈希表（底层的数组）中的索引位置。</li>
<li><strong>冲突处理</strong>：如果该位置已经有元素存在，则通过 equals() 方法与现有元素逐个比较：<ul>
<li>如果 <code>equals()</code> 返回 <code>true</code>（表示找到相等的元素），则不将新元素添加到集合中。</li>
<li>如果 <code>equals()</code> 返回 <code>false</code>（即所有比较都不相等），则根据内部结构（如链表或红黑树）添加新元素以解决哈希冲突。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>TreeSet 去重</strong>：</p>
<ul>
<li>如果初始化时传入了 Comparator 匿名内部类对象，就使用实现的 compare 方法去重，如果方法返回0，就认为是相同的元素&#x2F;数据，就不添加</li>
<li>如果没有传入 Comparator 匿名对象，则以添加的对象实现的 Compareable 接口的 compareTo 方法去重</li>
</ul>
<blockquote>
<p><code>Comparable</code> 接口用于定义对象的自然排序方式。类实现此接口以表明其实例具有内在的排序顺序</p>
<p><code>Comparator</code> 接口用于定义一种外部的、可定制的排序策略。它允许开发者提供自定义的排序顺序</p>
</blockquote>
</li>
</ul>
<h3 id="10-4-Homework05"><a href="#10-4-Homework05" class="headerlink" title="10.4 Homework05"></a>10.4 Homework05</h3><ul>
<li><strong>下面代码运行会不会抛出异常，并从源码层面说明原因？［考察读源码＋接口编程＋动态绑定］</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">TreeSet</span> <span class="variable">treeSet</span> <span class="operator">=</span>  <span class="keyword">new</span> <span class="title class_">TreeSet</span>();</span><br><span class="line">treeSet.add(<span class="keyword">new</span> <span class="title class_">Person</span>());</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>代码在运行时<strong>会抛出异常</strong>，原因在于 <code>TreeSet</code> 的工作机制要求存储的元素必须具备可比较性，即元素应该实现 <code>Comparable</code> 接口。而 <code>Person</code> 类没有实现 <code>Comparable</code> 接口，当 <code>TreeSet</code> 尝试比较两个 <code>Person</code> 实例来确定其排序位置时，会因为找不到比较方法而抛出 <code>ClassCastException</code></li>
</ul>
<h3 id="10-5-Homework06-坑！"><a href="#10-5-Homework06-坑！" class="headerlink" title="10.5 Homework06-坑！"></a>10.5 Homework06-坑！</h3><p><strong>分析下面代码的输出</strong>：</p>
<ul>
<li><strong>前提</strong>：Person 类重写了基于 id 和 name 的 equals 和 hashCode 方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">HashSet&lt;Person&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">1001</span>, <span class="string">&quot;AA&quot;</span>);</span><br><span class="line"><span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">1002</span>, <span class="string">&quot;BB&quot;</span>);</span><br><span class="line"></span><br><span class="line">set.add(p1);</span><br><span class="line">set.add(p2);</span><br><span class="line"><span class="comment">// [Person&#123;id=&#x27;1002&#x27;, name=&#x27;BB&#x27;&#125;, Person&#123;id=&#x27;1001&#x27;, name=&#x27;AA&#x27;&#125;]</span></span><br><span class="line">System.out.println(set);</span><br><span class="line"></span><br><span class="line">p1.name = <span class="string">&quot;CC&quot;</span>;</span><br><span class="line"><span class="comment">// [Person&#123;id=&#x27;1002&#x27;, name=&#x27;BB&#x27;&#125;, Person&#123;id=&#x27;1001&#x27;, name=&#x27;CC&#x27;&#125;]</span></span><br><span class="line">System.out.println(set);</span><br><span class="line"></span><br><span class="line">set.remove(p1);</span><br><span class="line"><span class="comment">// [Person&#123;id=&#x27;1002&#x27;, name=&#x27;BB&#x27;&#125;, Person&#123;id=&#x27;1001&#x27;, name=&#x27;CC&#x27;&#125;]</span></span><br><span class="line">System.out.println(set);</span><br><span class="line"></span><br><span class="line">set.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">1001</span>, <span class="string">&quot;CC&quot;</span>));</span><br><span class="line"><span class="comment">// [Person&#123;id=&#x27;1002&#x27;, name=&#x27;BB&#x27;&#125;, Person&#123;id=&#x27;1001&#x27;, name=&#x27;CC&#x27;&#125;, Person&#123;id=&#x27;1001&#x27;, name=&#x27;CC&#x27;&#125;]</span></span><br><span class="line">System.out.println(set);</span><br><span class="line"></span><br><span class="line">set.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">1001</span>, <span class="string">&quot;AA&quot;</span>));</span><br><span class="line"><span class="comment">// [Person&#123;id=&#x27;1002&#x27;, name=&#x27;BB&#x27;&#125;, Person&#123;id=&#x27;1001&#x27;, name=&#x27;CC&#x27;&#125;,</span></span><br><span class="line"><span class="comment">// Person&#123;id=&#x27;1001&#x27;, name=&#x27;CC&#x27;&#125;, Person&#123;id=&#x27;1001&#x27;, name=&#x27;AA&#x27;&#125;]</span></span><br><span class="line">System.out.println(set);</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>分析</strong>：</p>
<ul>
<li><strong>为什么 <code>remove</code> 没成功？</strong><ul>
<li>当 <code>p1</code> 被添加到 <code>HashSet</code> 时，它的哈希值是根据 <code>p1</code> 的 <code>id</code> 和 <code>name</code> 计算得到的。此时，<code>p1</code> 的状态是 <code>id=1001</code> 和 <code>name=AA</code></li>
<li>修改了 <code>p1</code> 的 <code>name</code> 属性为 <code>&quot;CC&quot;</code>。这改变了 <code>p1</code> 的内部状态，这意味着如果再次计算哈希值，将会得到一个不同的结果</li>
<li>使用 <code>set.remove(p1)</code> 时，<code>HashSet</code> 试图找到 <code>p1</code> 的哈希值对应的桶。但是，由于 <code>p1</code> 的哈希值已经因为内部状态改变而改变，所以 <code>remove</code> 方法可能无法找到正确的桶。如果找到了桶，其内的元素通过 <code>equals</code> 方法比较也可能失败，因为 <code>equals</code> 和 <code>hashCode</code> 都依赖于 <code>name</code>，而这已经被改变了</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/Java%E9%9B%86%E5%90%88.assets/image-20240501154923401.png" alt="image-20240501154923401"></p>
<ul>
<li><strong>为什么再次添加 <code>1001, &quot;CC&quot;</code> 和 <code>1001, &quot;AA&quot;</code> 都成功了？</strong><ul>
<li>由于 <code>p1</code> 的哈希值在其被修改后没有正确地更新（即哈希表中的位置不正确），因此再次添加同样的 <code>id</code> 和修改后的 <code>name</code> (<code>&quot;CC&quot;</code>) 时，会产生一个新的哈希值，并被存放在不同的位置。尽管 <code>p1</code> 的当前状态与新对象相同，但新对象会被视为不同的元素并被成功添加</li>
<li>添加一个新的 <code>Person(1001, &quot;AA&quot;)</code> 时，由于没有与此状态相同的 <code>Person</code> 对象在 <code>HashSet</code> 中（<code>p1</code> 的状态已经是 <code>1001, &quot;CC&quot;</code>），它同样被添加成功</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/Java%E9%9B%86%E5%90%88.assets/image-20240501155820692.png" alt="image-20240501155820692"></p>
</li>
<li><p><strong>根本原因</strong>：问题的根本原因是对象的可变性与 <code>HashSet</code> 的工作原理不兼容。当 <code>HashSet</code> 中的对象在添加后被修改，它的哈希值可能不再反映其在哈希表中的实际位置</p>
</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://tangsmallrong.github.io">thr</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://tangsmallrong.github.io/2024/05/01/Java%E9%9B%86%E5%90%88/">https://tangsmallrong.github.io/2024/05/01/Java%E9%9B%86%E5%90%88/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://tangsmallrong.github.io" target="_blank">thr's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/collection/">collection</a></div><div class="post_share"></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/05/14/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" title="JUC 并发编程"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">JUC 并发编程</div></div></a></div><div class="next-post pull-right"><a href="/2024/04/12/RabbitMQ%E5%85%A5%E9%97%A8/" title="RabbitMQ 入门"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">RabbitMQ 入门</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Java-%E9%9B%86%E5%90%88"><span class="toc-text">Java 集合</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E9%9B%86%E5%90%88%E4%BB%8B%E7%BB%8D"><span class="toc-text">1. 集合介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E9%9B%86%E5%90%88%E7%9A%84%E6%A1%86%E6%9E%B6%E4%BD%93%E7%B3%BB-%E8%83%8C"><span class="toc-text">2. 集合的框架体系-背</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Collection"><span class="toc-text">3. Collection</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-Collection-%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0%E7%B1%BB%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-text">3.1 Collection 接口实现类的特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-Collection-%E6%8E%A5%E5%8F%A3%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">3.2 Collection 接口常用方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-Collection-%E6%8E%A5%E5%8F%A3%E9%81%8D%E5%8E%86%E5%85%83%E7%B4%A0"><span class="toc-text">3.3 Collection 接口遍历元素</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%81%8D%E5%8E%86%E5%85%83%E7%B4%A0%E6%96%B9%E5%BC%8F1%E2%80%94%E4%BD%BF%E7%94%A8-Iterator-%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-text">遍历元素方式1—使用 Iterator 迭代器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%81%8D%E5%8E%86%E5%85%83%E7%B4%A0%E6%96%B9%E5%BC%8F2%E2%80%94%E4%BD%BF%E7%94%A8-for-%E5%BE%AA%E7%8E%AF%E5%A2%9E%E5%BC%BA"><span class="toc-text">遍历元素方式2—使用 for 循环增强</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E7%BB%83%E4%B9%A0%E9%A2%98"><span class="toc-text">3.4 练习题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-List"><span class="toc-text">4. List</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-List-%E6%8E%A5%E5%8F%A3%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="toc-text">4.1 List 接口基本介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-List-%E6%8E%A5%E5%8F%A3%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">4.2 List 接口常用方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-List-%E7%9A%84%E4%B8%89%E7%A7%8D%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F"><span class="toc-text">4.3 List 的三种遍历方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-List-%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0%E7%B1%BB-ArrayList"><span class="toc-text">4.4 List 接口实现类-ArrayList</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-text">注意事项</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84%E5%92%8C%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-text">底层结构和源码分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-List-%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0%E7%B1%BB-Vector"><span class="toc-text">4.5 List 接口实现类-Vector</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Vector-VS-ArrayList"><span class="toc-text">Vector VS. ArrayList</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Vector-%E7%9A%84%E5%BA%95%E5%B1%82%E6%89%A9%E5%AE%B9%E7%BB%93%E6%9E%84"><span class="toc-text">Vector 的底层扩容结构</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6-List-%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0%E7%B1%BB-LinkedList"><span class="toc-text">4.6 List 接口实现类-LinkedList</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84"><span class="toc-text">底层结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E6%9C%BA%E5%88%B6"><span class="toc-text">操作机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LinkedList-VS-ArrayList"><span class="toc-text">LinkedList VS. ArrayList</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LinkedList-%E5%BA%95%E5%B1%82-crud-%E6%96%B9%E6%B3%95-debug-%E5%88%86%E6%9E%90"><span class="toc-text">LinkedList 底层 crud 方法 debug 分析</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-Set"><span class="toc-text">5. Set</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-Set-%E6%8E%A5%E5%8F%A3%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="toc-text">5.1 Set 接口基本介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-Set-%E6%8E%A5%E5%8F%A3%E7%9A%84%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F"><span class="toc-text">5.2 Set 接口的遍历方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-Set-%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0%E7%B1%BB-HashSet"><span class="toc-text">5.3 Set 接口实现类-HashSet</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-1"><span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B"><span class="toc-text">代码示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E6%8B%9F%E5%93%88%E5%B8%8C%E8%A1%A8-%E6%95%B0%E7%BB%84-%E9%93%BE%E8%A1%A8"><span class="toc-text">模拟哈希表(数组+链表)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%95%E5%B1%82%E6%9C%BA%E5%88%B6"><span class="toc-text">底层机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%83%E4%B9%A0"><span class="toc-text">练习</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-Set-%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0%E7%B1%BB-LinkedHashSet"><span class="toc-text">5.4 Set 接口实现类-LinkedHashSet</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-2"><span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%95%E5%B1%82%E6%9C%BA%E5%88%B6-1"><span class="toc-text">底层机制</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-Map"><span class="toc-text">6. Map</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-Map-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">6.1 Map 接口和常用方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-Map-%E5%85%AD%E5%A4%A7%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F"><span class="toc-text">6.2 Map 六大遍历方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-Map-%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0%E7%B1%BB-HashMap"><span class="toc-text">6.3 Map 接口实现类-HashMap</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-3"><span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%95%E5%B1%82%E6%9C%BA%E5%88%B6%E5%92%8C%E6%BA%90%E7%A0%81"><span class="toc-text">底层机制和源码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-Map-%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0%E7%B1%BB-Hashtable"><span class="toc-text">6.4 Map 接口实现类-Hashtable</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-4"><span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6"><span class="toc-text">扩容机制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-5-Map-%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0%E7%B1%BB-Properties"><span class="toc-text">6.5 Map 接口实现类-Properties</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-5"><span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="toc-text">基本使用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-TreeSet-%E5%92%8C-TreeMap-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-text">7. TreeSet 和 TreeMap 源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-TreeSet-%E5%88%86%E6%9E%90"><span class="toc-text">7.1 TreeSet 分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-TreeMap-%E5%88%86%E6%9E%90"><span class="toc-text">7.2 TreeMap 分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E9%9B%86%E5%90%88%E9%80%89%E5%9E%8B%E8%A7%84%E5%88%99"><span class="toc-text">8. 集合选型规则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-Collections-%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-text">9. Collections 工具类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-1-%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="toc-text">9.1 基本介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-%E4%B8%BB%E8%A6%81%E6%96%B9%E6%B3%95"><span class="toc-text">9.2 主要方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-%E8%AF%BE%E5%90%8E%E4%B9%A0%E9%A2%98"><span class="toc-text">10. 课后习题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#10-1-Homework01"><span class="toc-text">10.1 Homework01</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-2-Homework03"><span class="toc-text">10.2 Homework03</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-3-Homework04"><span class="toc-text">10.3 Homework04</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-4-Homework05"><span class="toc-text">10.4 Homework05</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-5-Homework06-%E5%9D%91%EF%BC%81"><span class="toc-text">10.5 Homework06-坑！</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By thr</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>