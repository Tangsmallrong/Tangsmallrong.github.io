<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>RabbitMQ 入门 | thr's blog</title><meta name="author" content="thr"><meta name="copyright" content="thr"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="RabbitMQ 学习笔记：02-什么是MQ_哔哩哔哩_bilibili  1. 消息队列1.1 MQ 相关概念1.1.1 什么是 MQ MQ(message queue)，从字面意思上看，本质是个队列，FIFO 先入先出，只不过队列中存放的内容是 message 而已  还是一种跨进程的通信机制，用于上下游传递消息。在互联网架构中，MQ 是一种非常常见的上下游 “逻辑解耦+物理解耦” 的消息通信">
<meta property="og:type" content="article">
<meta property="og:title" content="RabbitMQ 入门">
<meta property="og:url" content="https://tangsmallrong.github.io/2024/04/12/RabbitMQ%E5%85%A5%E9%97%A8/index.html">
<meta property="og:site_name" content="thr&#39;s blog">
<meta property="og:description" content="RabbitMQ 学习笔记：02-什么是MQ_哔哩哔哩_bilibili  1. 消息队列1.1 MQ 相关概念1.1.1 什么是 MQ MQ(message queue)，从字面意思上看，本质是个队列，FIFO 先入先出，只不过队列中存放的内容是 message 而已  还是一种跨进程的通信机制，用于上下游传递消息。在互联网架构中，MQ 是一种非常常见的上下游 “逻辑解耦+物理解耦” 的消息通信">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://tangsmallrong.github.io/img/avatar.jpg">
<meta property="article:published_time" content="2024-04-12T11:24:20.000Z">
<meta property="article:modified_time" content="2024-04-12T11:50:45.714Z">
<meta property="article:author" content="thr">
<meta property="article:tag" content="RabbitMQ">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://tangsmallrong.github.io/img/avatar.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://tangsmallrong.github.io/2024/04/12/RabbitMQ%E5%85%A5%E9%97%A8/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: thr","link":"链接: ","source":"来源: thr's blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'RabbitMQ 入门',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-04-12 19:50:45'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.0.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/./img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">9</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">9</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="thr's blog"><span class="site-name">thr's blog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">RabbitMQ 入门</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-04-12T11:24:20.000Z" title="发表于 2024-04-12 19:24:20">2024-04-12</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-04-12T11:50:45.714Z" title="更新于 2024-04-12 19:50:45">2024-04-12</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/MQ/">MQ</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">26.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>92分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="RabbitMQ 入门"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><h1 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h1><blockquote>
<p>学习笔记：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1cb4y1o7zz?p=2">02-什么是MQ_哔哩哔哩_bilibili</a></p>
</blockquote>
<h2 id="1-消息队列"><a href="#1-消息队列" class="headerlink" title="1. 消息队列"></a>1. 消息队列</h2><h3 id="1-1-MQ-相关概念"><a href="#1-1-MQ-相关概念" class="headerlink" title="1.1 MQ 相关概念"></a>1.1 MQ 相关概念</h3><h4 id="1-1-1-什么是-MQ"><a href="#1-1-1-什么是-MQ" class="headerlink" title="1.1.1 什么是 MQ"></a>1.1.1 什么是 MQ</h4><ul>
<li><p>MQ(message queue)，从字面意思上看，<strong>本质是个队列</strong>，FIFO 先入先出，只不过队列中存放的内容是 message 而已</p>
</li>
<li><p>还是一种<strong>跨进程的通信机制，用于上下游传递消息</strong>。在互联网架构中，MQ 是一种非常常见的上下游 “逻辑解耦+物理解耦” 的消息通信服务</p>
<blockquote>
<p>a 给 b 发消息，a 就是上游，b 就是下游</p>
</blockquote>
</li>
<li><p>使用了 MQ 之后，消息发送上游只需要依赖 MQ，不用依赖其他服务</p>
</li>
</ul>
<h4 id="1-1-2-为什么要用-MQ"><a href="#1-1-2-为什么要用-MQ" class="headerlink" title="1.1.2 为什么要用 MQ"></a>1.1.2 为什么要用 MQ</h4><blockquote>
<p>MQ 有三大功能：</p>
</blockquote>
<ul>
<li><p><strong>流量削峰</strong></p>
<ul>
<li>举例：<ul>
<li>如果订单系统最多能处理一万次订单，这个处理能力应付正常时段的下单时绰绰有余，正常时段我们下单一秒后就能返回结果</li>
<li>但是在高峰期，如果有两万次下单操作系统是处理不了的，只能限制订单超过一万后不允许用户下单</li>
<li><strong>使用消息队列做缓冲</strong>，我们可以取消这个限制，<strong>把一秒内下的订单分散成一段时间来处理</strong>，这时有些用户可能在下单十几秒后才能收到下单成功的操作，但是比不能下单的体验要好</li>
</ul>
</li>
<li>图示说明：</li>
</ul>
<p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/1696320183594.png" alt="1696320156974"></p>
</li>
<li><p><strong>应用解耦</strong></p>
<ul>
<li>举例：<ul>
<li>以电商应用为例，应用中有订单系统、库存系统、物流系统、支付系统</li>
<li>用户创建订单后，如果耦合调用库存系统、物流系统、支付系统，任何一个子系统出了故障，都会造成下单操作异常</li>
<li>当<strong>转变成基于消息队列的方式后，系统间调用的问题会减少很多</strong>，比如物流系统因为发生故障，需要几分钟来修复</li>
<li>在这几分钟的时间里，<strong>物流系统要处理的内存被缓存在消息队列中，用户的下单操作可以正常完成</strong></li>
<li>当物流系统恢复后，继续处理订单信息即可，中单用户感受不到物流系统的故障，提升系统的可用性</li>
</ul>
</li>
<li>图示说明：</li>
</ul>
<p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/1696320368051.png" alt="1696320368051"></p>
</li>
<li><p><strong>异步处理</strong></p>
<ul>
<li>举例：<ul>
<li>有些服务间调用是异步的，例如 A 调用 B，B 需要花费很长时间执行，但是 A 需要知道 B 什么时候可以执行完</li>
<li>以前一般有两种方式，A 过一段时间去调用 B 的查询 api 查询；或者 A 提供一个 callback api，B 执行完之后调用 api 通知 A 服务</li>
<li>这两种方式都不是很优雅，使用消息总线，可以很方便解决这个问题，<strong>A 调用 B 服务后，只需要监听 B 处理完成的消息，当 B 处理完成后，会发送一条消息给 MQ，MQ 会将此消息转发给 A 服务</strong></li>
<li>这样 A 服务既不用循环调用 B 的查询 api，也不用提供 callback api。同样 B 服务也不用做这些操作。A 服务还能及时的得到异步处理成功的消息</li>
</ul>
</li>
<li>图示说明：</li>
</ul>
<p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/1696320559421.png" alt="1696320559421"></p>
</li>
</ul>
<h4 id="1-1-3-MQ-的分类"><a href="#1-1-3-MQ-的分类" class="headerlink" title="1.1.3 MQ 的分类"></a>1.1.3 MQ 的分类</h4><ul>
<li><strong>ActiveMQ</strong><ul>
<li>优点：单机吞吐量万级，时效性 ms 级，可用性高，基于主从架构实现高可用性，消息可靠性方面：较低的概率丢失数据</li>
<li>缺点：官方社区现在对 ActiveMQ 5.x <strong>维护越来越少，高吞吐量场景较少使用</strong></li>
</ul>
</li>
<li><strong>Kafka</strong><ul>
<li>大数据的杀手锏，谈到大数据领域内的消息传输，则绕不开 Kafka，这款为<strong>大数据而生</strong>的消息中间件，以其<strong>百万级 TPS</strong> 的吞吐量名声大噪，在数据采集、传输、存储的过程中发挥着举足轻重的作用，</li>
<li>优点：<ul>
<li>性能卓越，单机写入 TPS 约在百万条&#x2F;秒，最大的优点，就是<strong>吞吐量高</strong>。时效性 ms 级，可用性非常高</li>
<li>kafka 是分布式的，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用</li>
<li>消费者采用 Pull 方式获取消息，消息有序，通过控制能够保证所有消息被消费且仅被消费一次</li>
<li>有优秀的第三方Kafka Web 管理界面 Kafka-Manager</li>
<li>在日志领域比较成熟，被多家公司和多个开源项目使用</li>
<li>功能支持：功能较为简单，主要支持简单的 MQ 功能，在大数据领域的实时计算以及<strong>日志采集</strong>被大规模使用</li>
</ul>
</li>
<li>缺点：Kafka 单机超过 64 个队列&#x2F;分区，Load 会发生明显的飙高现象，队列越多，load 越高，发送消息响应时间变长，使用短轮询方式，实时性取决于轮询间隔时间，消费失败不支持重试；支持消息顺序，但是一台代理宕机后，就会产生消息乱序，<strong>社区更新较慢</strong></li>
</ul>
</li>
<li><strong>RocketMQ</strong><ul>
<li>RocketMQ 出自阿里巴巴的开源产品，用 Java 语言实现，在设计时参考了 Kafka，并做出了自己的一些改进</li>
<li>优点：<strong>单机吞吐量十万级</strong>，可用性非常高，分布式架构,<strong>消息可以做到 0 丢失</strong>，MQ 功能较为完善，还是分布式的，扩展性好，<strong>支持 10 亿级别的消息堆积</strong>，不会因为堆积导致性能下降，源码是 java 我们可以自己阅读源码，定制自己公司的 MQ</li>
<li>缺点：<strong>支持的客户端语言不多</strong>，目前是 java 及 c++，其中 c++不成熟；社区活跃度一般，没有在 MQ 核心中去实现 JMS 等接口，有些系统要迁移需要修改大量代码</li>
</ul>
</li>
<li><strong>RabbitMQ</strong>：<a target="_blank" rel="noopener" href="https://www.rabbitmq.com/news.html">https://www.rabbitmq.com/news.html</a> <ul>
<li>2007 年发布，是一个在 <strong>AMQP(高级消息队列协议)<strong>基础上完成的，可复用的企业消息系统，是</strong>当前最主流的消息中间件之一</strong></li>
<li>优点：由于 erlang 语言的<strong>高并发特性</strong>，性能较好；<strong>吞吐量到万级</strong>，MQ 功能比较完备,健壮、稳定、易用、跨平台、<strong>支持多种语言</strong> 如：Python、Ruby、.NET、Java、JMS、C、PHPActionScript等，支持 AJAX 文档齐全；开源提供的管理界面非常棒，用起来很好用，<strong>社区活跃度高</strong>；更新频率相当高</li>
<li>缺点：商业版需要收费，学习成本较高</li>
</ul>
</li>
</ul>
<h4 id="1-1-4-MQ-的选择"><a href="#1-1-4-MQ-的选择" class="headerlink" title="1.1.4 MQ 的选择"></a>1.1.4 MQ 的选择</h4><ul>
<li><p><strong>Kafka</strong></p>
<ul>
<li>Kafka 主要特点是基于 Pull 的模式来处理消息消费，追求高吞吐量，一开始的目的就是用于日志收集和传输</li>
<li>适合产生<strong>大量数据</strong>的互联网服务的数据收集业务。<strong>大型公司</strong>建议可以选用，如果有<strong>日志采集</strong>功能，肯定是首选 kafka 了</li>
</ul>
</li>
<li><p><strong>RocketMQ</strong></p>
<ul>
<li>天生为<strong>金融互联网</strong>领域而生，对于可靠性要求很高的场景，尤其是电商里面的订单扣款，以及业务削峰，在大量交易涌入时，后端可能无法及时处理的情况</li>
<li>RocketMQ 在稳定性上可能更值得信赖，这些业务场景在阿里双 11 已经经历了多次考验，如果你的业务有上述并发场景，建议可以选择 RocketMQ。</li>
</ul>
</li>
<li><p><strong>RabbitMQ</strong></p>
<ul>
<li>结合 erlang 语言本身的并发优势，性能好<strong>时效性微秒级</strong>，社区活跃度也比较高<strong>，管理界面用起来十分方便</strong></li>
<li><strong>如果你的数据量没有那么大</strong>，中小型公司优先选择功能比较完备的 RabbitMQ</li>
</ul>
</li>
</ul>
<h3 id="1-2-RabbitMQ"><a href="#1-2-RabbitMQ" class="headerlink" title="1.2 RabbitMQ"></a>1.2 RabbitMQ</h3><blockquote>
<p>RabbitMQ 是一个<strong>消息中间件</strong>：</p>
<p>它接受并转发消息，你可以把它当做一个快递站点，当你要发送一个包裹时，你把你的包裹放到快递站，快递员最终会把你的快递送到收件人那里，按照这种逻辑 RabbitMQ 是一个快递站，一个快递员帮你传递快件。</p>
<p>RabbitMQ 与快递站的主要区别在于，它不处理快件而是<strong>接收，存储和转发消息数据</strong></p>
</blockquote>
<h4 id="1-2-1-四大核心概念"><a href="#1-2-1-四大核心概念" class="headerlink" title="1.2.1 四大核心概念"></a>1.2.1 四大核心概念</h4><p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/1696322466173.png" alt="1696322466173"></p>
<ul>
<li><strong>生产者</strong><ul>
<li>产生数据发送消息的程序是生产者</li>
</ul>
</li>
<li><strong>交换机</strong><ul>
<li>交换机是 RabbitMQ 非常重要的一个部件，一方面<strong>它接收来自生产者的消息，另一方面它将消息推送到队列</strong>中</li>
<li>交换机必须确切知道如何处理它接收到的消息，是将这些消息推送到特定队列还是推送到多个队列，亦或者是把消息丢弃，这个得由交换机类型决定</li>
</ul>
</li>
<li><strong>队列</strong><ul>
<li>队列是 RabbitMQ 内部使用的一种数据结构，尽管消息流经 RabbitMQ 和应用程序，但它们只能存储在队列中</li>
<li>队列仅受主机的内存和磁盘限制的约束，本质上是一个大的消息缓冲区</li>
<li>许多生产者可以将消息发送到一个队列，许多消费者可以尝试从一个队列接收数据。这就是我们使用队列的方式</li>
</ul>
</li>
<li><strong>消费者</strong><ul>
<li>消费与接收具有相似的含义。消费者大多时候是一个等待接收消息的程序</li>
<li>请注意生产者，消费者和消息中间件很多时候并不在同一机器上，同一个应用程序既可以是生产者又是可以是消费者。</li>
</ul>
</li>
</ul>
<h4 id="1-2-3-RabbitMQ-核心部分"><a href="#1-2-3-RabbitMQ-核心部分" class="headerlink" title="1.2.3 RabbitMQ 核心部分"></a>1.2.3 RabbitMQ 核心部分</h4><blockquote>
<p>六大模式</p>
</blockquote>
<p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/1696322800780.png" alt="1696322800780"></p>
<h4 id="1-2-3-各个名词介绍"><a href="#1-2-3-各个名词介绍" class="headerlink" title="1.2.3 各个名词介绍"></a>1.2.3 各个名词介绍</h4><p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/1696322866484.png" alt="1696322866484"></p>
<ul>
<li><strong>Broker</strong>：接收和分发消息的应用，RabbitMQ Server就是Message Broker  (Broker:中间人、经济人)</li>
<li><strong>Virtual host</strong>：<ul>
<li>出于多租户和安全因素设计的，把 AMQP 的基本组件划分到一个虚拟的分组中，类似于网络中的 namespace 概念</li>
<li>当多个不同的用户使用同一个 RabbitMQ server 提供的服务时，可以划分出多个 vhost，每个用户在自己的 vhost 创建 exchange／queue 等</li>
</ul>
</li>
<li><strong>Connection</strong>：producer／consumer 和 broker 之间的 TCP 连接</li>
<li><strong>Channel</strong>：<ul>
<li>如果每一次访问 RabbitMQ 都建立一个 Connection，在消息量大的时候建立 TCPConnection 的开销将是巨大的，效率也较低</li>
<li>Channel 是在 connection 内部建立的逻辑连接，如果应用程序支持多线程，通常每个 thread 创建单独的 channel 进行通讯</li>
<li>AMQP method 包含了 channel id 帮助客户端和 message broker 识别 channel，所以 channel 之间是完全隔离的</li>
<li><strong>Channel 作为轻量级的Connection极大减少了操作系统建立 TCP connection 的开销</strong></li>
</ul>
</li>
<li><strong>Exchange</strong>：<ul>
<li>message 到达 broker 的第一站，根据分发规则，匹配查询表中的 routing key，分发消息到 queue 中去</li>
<li>常用的类型有：direct (point-to-point), topic (publish-subscribe) and fanout (multicast)</li>
</ul>
</li>
<li><strong>Queue</strong>：消息最终被送到这里等待 consumer 取走</li>
<li><strong>Binding</strong>：<strong>exchange 和 queue 之间的虚拟连接</strong>，binding 中可以包含 routing key，Binding 信息被保存到 exchange 中的查询表中，用于 message 的分发依据</li>
</ul>
<h4 id="1-2-4-安装"><a href="#1-2-4-安装" class="headerlink" title="1.2.4 安装"></a>1.2.4 安装</h4><blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_51560103/article/details/121492937">RabbitMQ安装教程（最新RabbitMQ安装，通用教程）_rabbitmq 安装教程-CSDN博客</a> </p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_45173404/article/details/116429302">RabbitMQ超详细安装教程（Linux）_rabbitmq安装-CSDN博客</a> </p>
<p>官网没看到 centos7 的，直接用课件里的下载吧，由于是基于 erlang 语言开发的，所以这个环境也得有</p>
</blockquote>
<ul>
<li><strong>官网地址</strong>：<code>https://www.rabbitmq.com/download.html</code></li>
</ul>
<p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/1696326762615.png" alt="1696326762615"></p>
<p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/1696326916721.png" alt="1696326916721"></p>
<ul>
<li><strong>安装文件(分别按照以下顺序安装)</strong></li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh erlang-21.3-1.el7.x86_64.rpm  # 语言环境</span><br><span class="line">yum install socat -y  # 依赖包</span><br><span class="line">rpm -ivh rabbitmq-server-3.8.8-1.el7.noarch.rpm</span><br></pre></td></tr></table></figure>

<p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/1696327263436.png" alt="1696327263436"></p>
<p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/1696327336516.png" alt="1696327336516"></p>
<p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/1696327406332.png" alt="1696327406332"></p>
<ul>
<li><p><strong>常用命令(按照以下顺序执行)</strong> </p>
<ul>
<li><p>添加开机启动 RabbitMQ 服务</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chkconfig rabbitmq-server on</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动服务</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/sbin/service rabbitmq-server start </span><br></pre></td></tr></table></figure>
</li>
<li><p>查看服务状态</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/sbin/service rabbitmq-server status</span><br></pre></td></tr></table></figure></li>
</ul>
<p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/1696327594120.png" alt="1696327594120"></p>
<ul>
<li>停止服务(选择执行)</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/sbin/service rabbitmq-server stop </span><br></pre></td></tr></table></figure>

<ul>
<li><strong>开启 web 管理插件</strong>(先停止服务再安装插件，安装完后再开启服务)</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmq-plugins enable rabbitmq_management</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>访问 web 页面的步骤</strong>：(前提是已经开启服务)</p>
<ul>
<li>查看防火墙状态</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl status firewalld</span><br></pre></td></tr></table></figure>

<ul>
<li>关闭防火墙</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop firewalld</span><br></pre></td></tr></table></figure>

<blockquote>
<p>除了直接关闭之外，刚学了 nginx，当时把80端口开放了，同理这里也可以把需要的端口开放即可，比如：<code>firewall-cmd --zone=public --add-port=15672/tcp --permanent</code></p>
<p>然后重启防火墙：<code>firewall-cmd --reload</code></p>
<p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/1696328294984.png" alt="1696328294984"></p>
<p>云服务器的话，还需要去官网控制台开下防火墙端口即可</p>
</blockquote>
<ul>
<li>访问页面：<code>192.168.3.195:15672</code></li>
</ul>
<blockquote>
<p>初始账号密码均为：<code>guest</code>，但是报错没有权限</p>
</blockquote>
<p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/1696328423232.png" alt="1696328423232"></p>
</li>
</ul>
<h4 id="1-2-5-添加用户并设置权限"><a href="#1-2-5-添加用户并设置权限" class="headerlink" title="1.2.5 添加用户并设置权限"></a>1.2.5 添加用户并设置权限</h4><ul>
<li><p><strong>添加一个新的用户</strong></p>
<ul>
<li>创建账号：<code>rabbitmqctl add_user admin 123</code></li>
</ul>
<blockquote>
<p>用户名为 admin，密码为 123</p>
</blockquote>
<ul>
<li>设置用户角色：<code>rabbitmqctl set_user_tags admin administrator</code></li>
<li>设置用户权限：<code>rabbitmqctl set_permissions -p &quot;/&quot; admin &quot;.*&quot; &quot;.*&quot; &quot;.*&quot;</code></li>
</ul>
<blockquote>
<p><code>set_permissions [-p &lt;vhostpath&gt;] &lt;user&gt; &lt;conf&gt; &lt;write&gt; &lt;read&gt;</code></p>
<p>用户 user_admin 具有&#x2F;vhost1 这个 virtual host 中所有资源的配置、写、读权限<br>    -  查看当前用户和角色：<code>rabbitmqctl list_users</code></p>
</blockquote>
</li>
</ul>
<p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/1696329829860.png" alt="1696329829860"></p>
<ul>
<li><strong>再次利用 admin 用户登录</strong></li>
</ul>
<p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/1696329911633.png" alt="1696329911633"></p>
<blockquote>
<p>可以看到当前的 vh 是 <code>/</code></p>
<p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/1696330008927.png" alt="1696330008927"></p>
</blockquote>
<ul>
<li><strong>重置命令</strong><ul>
<li>关闭应用的命令为：<code>rabbitmqctl stop_app</code></li>
<li>清除的命令为：<code>rabbitmqctl reset</code></li>
<li>重新启动命令为：<code>rabbitmqctl start_app</code></li>
</ul>
</li>
</ul>
<h2 id="2-Hello-World"><a href="#2-Hello-World" class="headerlink" title="2. Hello World"></a>2. Hello World</h2><blockquote>
<p>这一部分中，我们将用 Java 编写两个程序：发送单个消息的生产者和接收消息并打印出来的消费者；</p>
<p>在下图中，“ P”是我们的生产者，“ C”是我们的消费者。中间的框是一个队列-RabbitMQ 代表使用者保留的消息缓冲区</p>
<p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/1696330081432.png" alt="1696330081432"></p>
<p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/1696331108425.png" alt="1696331108425"></p>
</blockquote>
<h3 id="2-1-创建工程并添加依赖"><a href="#2-1-创建工程并添加依赖" class="headerlink" title="2.1 创建工程并添加依赖"></a>2.1 创建工程并添加依赖</h3><ul>
<li><strong>创建一个新的空工程</strong></li>
</ul>
<p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/1696330354476.png" alt="1696330354476"></p>
<p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/1696330513210.png" alt="1696330513210"></p>
<ul>
<li><strong>再创建一个新的maven模块</strong></li>
</ul>
<p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/1696330605542.png" alt="1696330605542"></p>
<p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/1696330703776.png" alt="1696330703776"></p>
<ul>
<li><strong>依赖</strong>：</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--指定 jdk 编译版本--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">source</span>&gt;</span>8<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">target</span>&gt;</span>8<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--rabbitmq 依赖客户端--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.rabbitmq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>amqp-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.8.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--操作文件流的一个依赖--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/1696330901573.png" alt="1696330901573"></p>
<h3 id="2-2-消息生产者"><a href="#2-2-消息生产者" class="headerlink" title="2.2 消息生产者"></a>2.2 消息生产者</h3><blockquote>
<p>连接超时的注意把防火墙关了！！或者再给防火墙开个端口：5672</p>
<p><code>firewall-cmd --zone=public --add-port=5672/tcp --permanent</code></p>
<p>然后重启防火墙：<code>firewall-cmd --reload</code></p>
</blockquote>
<ul>
<li><strong>代码</strong>：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 生产者: 发消息（发给队列）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Producer</span> &#123;</span><br><span class="line">    <span class="comment">// 队列名称 (快捷键 psf, 大写转换: ctrl+shift+U)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发消息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1. 创建一个连接工厂</span></span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 设置参数</span></span><br><span class="line">        <span class="comment">// 2.1 工厂 IP 连接 RabbitMQ 的队列</span></span><br><span class="line">        factory.setHost(<span class="string">&quot;192.168.3.196&quot;</span>);</span><br><span class="line">        <span class="comment">// 2.2 用户名</span></span><br><span class="line">        factory.setUsername(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        <span class="comment">// 2.3 密码</span></span><br><span class="line">        factory.setPassword(<span class="string">&quot;123&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 创建连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line">        <span class="comment">// 4. 通过连接创建信道</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 声明一个队列 参数:</span></span><br><span class="line">        <span class="comment">// (1)队列名称</span></span><br><span class="line">        <span class="comment">// (2)队列里的消息是否持久化(存在磁盘上), 默认情况(false)消息存储在内存中</span></span><br><span class="line">        <span class="comment">// (3)该队列是否只供一个消费者进行消费, 即是否进行消息的共享, true表示只供个消费者消费</span></span><br><span class="line">        <span class="comment">// (4)是否自动删除, 最后一个消费者端开连接后, 该队列是否自动删除, true表示自动删除</span></span><br><span class="line">        <span class="comment">// (5)其他参数</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6. 消息体</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7. 发消息 参数:</span></span><br><span class="line">        <span class="comment">// (1)表示发送到哪个交换机  这里暂时不考虑, 所以给了个空串</span></span><br><span class="line">        <span class="comment">// (2)路由的Key值是哪个  这里是队列名称</span></span><br><span class="line">        <span class="comment">// (3)其他参数信息</span></span><br><span class="line">        <span class="comment">// (4)发送消息的消息体 需要用二进制形式</span></span><br><span class="line">        channel.basicPublish(<span class="string">&quot;&quot;</span>, QUEUE_NAME, <span class="literal">null</span>, message.getBytes());</span><br><span class="line">        System.out.println(<span class="string">&quot;消息发送完毕&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>结果</strong>：</li>
</ul>
<p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/1696332830165.png" alt="1696332830165"></p>
<p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/1696332809480.png" alt="1696332809480"></p>
<p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/1696332790842.png" alt="1696332790842"></p>
<h3 id="2-3-消息消费者"><a href="#2-3-消息消费者" class="headerlink" title="2.3 消息消费者"></a>2.3 消息消费者</h3><ul>
<li><strong>代码</strong>：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 接收消息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer</span> &#123;</span><br><span class="line">    <span class="comment">// 队列名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接收消息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1. 创建连接工厂</span></span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 设置参数</span></span><br><span class="line">        <span class="comment">// 2.1 设置ip</span></span><br><span class="line">        factory.setHost(<span class="string">&quot;192.168.3.196&quot;</span>);</span><br><span class="line">        <span class="comment">// 2.2 设置用户名</span></span><br><span class="line">        factory.setUsername(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        <span class="comment">// 2.3 设置密码</span></span><br><span class="line">        factory.setPassword(<span class="string">&quot;123&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 创建连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line">        <span class="comment">// 4. 通过连接创建信道</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 声明回调接口（这里用 lambda 表达式声明）</span></span><br><span class="line">        <span class="comment">// 5.1 接收消息的回调:</span></span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, message) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(message.getBody()));</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 5.2 取消消息的回调:</span></span><br><span class="line">        <span class="type">CancelCallback</span> <span class="variable">cancelCallback</span> <span class="operator">=</span> (consumerTag) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;消费消息被中断&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6. 消费者消费消息 参数:</span></span><br><span class="line">        <span class="comment">// (1) queue: 消费哪个队列</span></span><br><span class="line">        <span class="comment">// (2) autoAck: 消费成功之后是否要自动应答  true代表自动应答 false代表手动应答</span></span><br><span class="line">        <span class="comment">// (3) deliverCallback: 当一个消息发送过来后的回调接口(也就是消费者成功消费的回调)</span></span><br><span class="line">        <span class="comment">// (4) cancelCallback: 消费者取消消费的回调</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME, <span class="literal">true</span>, deliverCallback, cancelCallback);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>结果</strong>：</li>
</ul>
<blockquote>
<p>注意这两都在运行</p>
<p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/1696334949148.png" alt="1696334949148"></p>
</blockquote>
<p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/1696334924600.png" alt="1696334924600"></p>
<p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/1696334983106.png" alt="1696334983106"></p>
<h2 id="3-Work-Queues"><a href="#3-Work-Queues" class="headerlink" title="3. Work Queues"></a>3. Work Queues</h2><blockquote>
<p>工作队列(又称任务队列)的主要思想是<strong>避免立即执行资源密集型任务，而不得不等待它完成</strong>，相反我们安排任务在之后执行，我们把任务封装为消息并将其发送到队列</p>
<p>在后台运行的工作进程将弹出任务并最终执行作业，<strong>当有多个工作线程时，这些工作线程将一起处理这些任务</strong></p>
</blockquote>
<p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/image-20240324193014618.png" alt="image-20240324193014618"></p>
<h3 id="3-1-轮询分发消息"><a href="#3-1-轮询分发消息" class="headerlink" title="3.1 轮询分发消息"></a>3.1 轮询分发消息</h3><p><strong>案例</strong>：启动两个工作线程，一个消息发送线程，观察工作线程如何工作</p>
<h4 id="3-1-1-抽取工具类"><a href="#3-1-1-抽取工具类" class="headerlink" title="3.1.1 抽取工具类"></a>3.1.1 抽取工具类</h4><ul>
<li>将创建 连接工厂 和 创建信道 作为公共部分抽取出来</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 连接工厂创建信道工具类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitMqUtils</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 得到一个连接的 channel</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Channel <span class="title function_">getChannel</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 创建一个连接工厂</span></span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置参数</span></span><br><span class="line">        factory.setHost(<span class="string">&quot;192.168.10.254&quot;</span>);</span><br><span class="line">        factory.setUsername(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        factory.setPassword(<span class="string">&quot;123&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过连接创建信道</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> channel;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-1-2-启动两个工作进程"><a href="#3-1-2-启动两个工作进程" class="headerlink" title="3.1.2 启动两个工作进程"></a>3.1.2 启动两个工作进程</h4><ul>
<li>先写消费者代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Worker01</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME=<span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtils.getChannel();</span><br><span class="line">        DeliverCallback deliverCallback=(consumerTag,delivery)-&gt;&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">receivedMessage</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody());</span><br><span class="line">            System.out.println(<span class="string">&quot;接收到消息:&quot;</span>+receivedMessage);</span><br><span class="line">        &#125;;</span><br><span class="line">        CancelCallback cancelCallback=(consumerTag)-&gt;&#123;</span><br><span class="line">            System.out.println(consumerTag+<span class="string">&quot;消费者取消消费接口回调逻辑&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(<span class="string">&quot;C2 消费者启动等待消费......&quot;</span>);</span><br><span class="line">        channel.basicConsume(QUEUE_NAME,<span class="literal">true</span>,deliverCallback,cancelCallback);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>利用 idea 设置，启动两次 代表 两个工作进程(消费者)</li>
</ul>
<p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/image-20240324195454613.png" alt="image-20240324195454613"></p>
<p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/image-20240324195905816.png" alt="image-20240324195905816"></p>
<h4 id="3-1-3-启动一个发送进程"><a href="#3-1-3-启动一个发送进程" class="headerlink" title="3.1.3 启动一个发送进程"></a>3.1.3 启动一个发送进程</h4><ul>
<li>编写生产者代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Task01</span> &#123;</span><br><span class="line">    <span class="comment">// 队列名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 发送大量消息</span></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtils.getChannel()) &#123;</span><br><span class="line">            <span class="comment">// 声明队列</span></span><br><span class="line">            channel.queueDeclare(QUEUE_NAME, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 从控制台当中接受信息</span></span><br><span class="line">            <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">            <span class="keyword">while</span> (scanner.hasNext()) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">                channel.basicPublish(<span class="string">&quot;&quot;</span>, QUEUE_NAME, <span class="literal">null</span>, message.getBytes());</span><br><span class="line">                System.out.println(<span class="string">&quot;发送消息完成:&quot;</span> + message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-1-4-结果"><a href="#3-1-4-结果" class="headerlink" title="3.1.4 结果"></a>3.1.4 结果</h4><p>通过程序执行发现生产者总共发送 4 个消息，消费者 1 和消费者 2 分别分得两个消息，并且是按照有序的一个接收一次消息</p>
<blockquote>
<p>谁接收到第一条消息都是正常的，只不过是必须是轮询的</p>
<p>C1 接收了 aa，那么 bb 必定是 C2 接收的</p>
</blockquote>
<p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/image-20240324200514301.png" alt="image-20240324200514301"></p>
<h3 id="3-2-消息应答"><a href="#3-2-消息应答" class="headerlink" title="3.2 消息应答"></a>3.2 消息应答</h3><h4 id="3-2-1-概念"><a href="#3-2-1-概念" class="headerlink" title="3.2.1 概念"></a>3.2.1 概念</h4><p>消费者完成一个任务可能需要一段时间，如果其中<strong>一个消费者处理一个长的任务并仅只完成了部分突然它挂掉了</strong>，会发生什么情况？ </p>
<p>RabbitMQ 一旦向消费者传递了一条消息，便立即将该消息标记为删除。在这种情况下，突然有个消费者挂掉了，我们将丢失正在处理的消息。以及后续发送给该消费这的消息，因为它无法接收到。</p>
<p><strong>为了保证消息在发送过程中不丢失</strong>，rabbitmq 引入<strong>消息应答机制</strong>，消息应答就是：<strong>消费者在接收到消息并且处理该消息之后，告诉 rabbitmq 它已经处理了，rabbitmq 可以把该消息删除了</strong> </p>
<p><strong>消息应答</strong>：</p>
<ul>
<li>自动应答  &#x3D;&#x3D;&gt; 并不完善</li>
<li>手动应答</li>
</ul>
<h4 id="3-2-2-自动应答"><a href="#3-2-2-自动应答" class="headerlink" title="3.2.2 自动应答"></a>3.2.2 自动应答</h4><blockquote>
<p>在自动应答模式下，一旦RabbitMQ将消息派发给消费者，它立即将该消息标记为确认</p>
</blockquote>
<ul>
<li>消息发送后立即被认为已经传送成功，这种模式需要在 <strong>高吞吐量和数据传输安全性方面做平衡</strong><ul>
<li>因为这种模式如果消息在接收到之前，消费者那边出现连接或者 channel 关闭，那么消息就丢失了</li>
<li>另一方面这种模式消费者那边可以传递过载的消息，<strong>没有对传递的消息数量进行限制</strong>，当然这样有可能使得消费者这边由于接收太多还来不及处理的消息，导致这些消息的积压，最终使得内存耗尽，最终这些消费者线程被操作系统杀死，</li>
<li><strong>所以这种模式仅适用在消费者可以高效并以某种速率能够处理这些消息的情况下使用</strong></li>
</ul>
</li>
</ul>
<h4 id="3-2-3-消息应答的方法"><a href="#3-2-3-消息应答的方法" class="headerlink" title="3.2.3 消息应答的方法"></a>3.2.3 消息应答的方法</h4><ul>
<li><strong>Channel.basicAck(用于肯定确认)</strong><ul>
<li>RabbitMQ 已知道该消息并且成功的处理消息，可以将其丢弃了</li>
<li>两个参数，<code>deliveryTag</code>（消息投递标签）和<code>multiple</code>（是否批量确认）</li>
</ul>
</li>
<li><strong>Channel.basicNack(用于否定确认)</strong><ul>
<li>支持批量否定确认（通过<code>multiple</code>参数）</li>
<li>除了<code>deliveryTag</code>和<code>multiple</code>参数，<code>basicNack</code>还有一个<code>requeue</code>参数<ul>
<li>如果<code>requeue</code>为<code>true</code>，RabbitMQ会将消息重新放回队列中</li>
<li>如果为<code>false</code>，则消息会被RabbitMQ丢弃或发送到死信队列（如果配置了的话）</li>
</ul>
</li>
</ul>
</li>
<li><strong>Channel.basicReject(用于否定确认)</strong><ul>
<li>与 Channel.basicNack 相比少一个参数 <code>multiple</code><ul>
<li><code>basicReject</code>有两个参数，<code>deliveryTag</code>和<code>requeue</code></li>
</ul>
</li>
<li>不处理该消息了直接拒绝，可以将其丢弃了</li>
</ul>
</li>
</ul>
<h4 id="3-2-4-Multiple-的解释"><a href="#3-2-4-Multiple-的解释" class="headerlink" title="3.2.4 Multiple 的解释"></a>3.2.4 Multiple 的解释</h4><p><strong>手动应答的好处是可以批量应答并且减少网络拥堵</strong></p>
<ul>
<li>multiple 的 true 和 false：<ul>
<li>true 代表批量应答 channel 上未应答的消息<ul>
<li>比如说 channel 上有传送 tag 的消息 5,6,7,8 </li>
<li>当前 tag 是 8 ，那么此时 5-8 的这些还未应答的消息都会被确认收到消息应答</li>
</ul>
</li>
<li>false 同上面相比<ul>
<li>只会应答 tag&#x3D;8 的消息 5,6,7 这三个消息依然不会被确认收到消息应答</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/image-20240324202504504.png" alt="image-20240324202504504"></p>
<h4 id="3-2-5-消息自动重新入队"><a href="#3-2-5-消息自动重新入队" class="headerlink" title="3.2.5 消息自动重新入队"></a>3.2.5 消息自动重新入队</h4><ul>
<li>当消费者接收到消息但由于某种原因无法处理时，可以选择让消息自动重新入队，这意味着消息会被放回队列中，等待再次被消费</li>
<li><strong>自动入队的工作原理</strong>：<ul>
<li><strong>未确认的消息</strong>：在手动应答模式下，如果消费者接收了一条消息但还没有对其进行确认（ack、nack或reject），那么在消费者连接断开时，这条消息会被RabbitMQ视为未确认的消息，并将其自动重新入队（通常会被放回队列的尾部）</li>
<li><strong>否定确认与重新入队</strong>：当使用<code>basicNack</code>或<code>basicReject</code>方法进行否定确认时，消费者可以指定是否要将消息重新入队。如果选择重新入队，该消息将再次成为队列中的一部分，可以被相同的消费者或其他消费者再次接收和处理</li>
</ul>
</li>
</ul>
<p>RabbitMQ 将了解到消息未完全处理，并将对其重新排队。如果此时其他消费者可以处理，它将很快将其重新分发给另一个消费者。</p>
<p>这样，即使某个消费者偶尔死亡，也可以确保不会丢失任何消息。</p>
<h4 id="3-2-6-消息手动应答代码"><a href="#3-2-6-消息手动应答代码" class="headerlink" title="3.2.6 消息手动应答代码"></a>3.2.6 消息手动应答代码</h4><p><strong>默认消息采用的是自动应答</strong>，所以我们要想实现消息消费过程中不丢失，需要把自动应答改为手动应答</p>
<p>消费者在之前代码的基础上增加修改代码：</p>
<ul>
<li>接收消息部分：改 autoAck 为 false 手动应答</li>
<li>消费者消费成功的回调函数中：增加代码表示是肯定的应答</li>
</ul>
<p>编写两个消费者代码：</p>
<ul>
<li>C1 等待接收消息处理的时间为 1 秒</li>
<li>C2 等待接收消息处理的时间为 30 秒</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Worker03</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 队列名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TASK_QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;ack_queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 通过工具类获取信道</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtils.getChannel();</span><br><span class="line">        System.out.println(<span class="string">&quot;C1 等待接收消息处理时间较短......&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接收消息</span></span><br><span class="line">        <span class="comment">// 消费者成功消费的回调</span></span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 睡眠 1s</span></span><br><span class="line">            SleepUtils.sleep(<span class="number">1</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">receivedMessage</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody());</span><br><span class="line">            System.out.println(<span class="string">&quot;接收到消息: &quot;</span> + receivedMessage);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 手动应答, 参数:</span></span><br><span class="line">            <span class="comment">// (1) 消息的标签</span></span><br><span class="line">            <span class="comment">// (2) 是否应该批量应答 ==&gt; 不应该, 否则容易出现消息丢失, 应处理一个应答一个</span></span><br><span class="line">            channel.basicAck(delivery.getEnvelope().getDeliveryTag(), <span class="literal">false</span>);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 消费者取消消费的回调</span></span><br><span class="line">        <span class="type">CancelCallback</span> <span class="variable">cancelCallback</span> <span class="operator">=</span> (consumerTag) -&gt; &#123;</span><br><span class="line">            System.out.println(consumerTag + <span class="string">&quot;消费者取消消费接口回调逻辑&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第二个参数 autoAck 为 true 为自动应答, 改为 false 后即为手动应答</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">autoAck</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        channel.basicConsume(TASK_QUEUE_NAME, autoAck, deliverCallback, cancelCallback);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>睡眠工具类</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SleepUtils</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">(<span class="type">int</span> second)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>*second);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException _ignored) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-2-7-手动应答效果演示"><a href="#3-2-7-手动应答效果演示" class="headerlink" title="3.2.7 手动应答效果演示"></a>3.2.7 手动应答效果演示</h4><ul>
<li><strong>测试目标</strong>：验证 消息在手动应答时不会丢失，而是放回队列中重新消费<ul>
<li>先运行生产者(因为目前还没创建信道)，再运行两个消费者</li>
</ul>
</li>
<li>正常情况下消息发送方发送两个消息 C1 和 C2 分别接收到消息并进行处理</li>
</ul>
<p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/image-20240324211852173.png" alt="image-20240324211852173"></p>
<ul>
<li>在发送者发送消息 dd，发出消息之后的把 C2 消费者停掉，按理说该 C2 来处理该消息，但是由于它处理时间较长，在还未处理完</li>
<li>也就是说 C2 还没有执行 ack 代码的时候，C2 被停掉了，此时会看到消息被 C1 接收到了，说明消息 dd 被重新入队，然后分配给能处理消息的 C1 处理了</li>
</ul>
<p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/image-20240324211954960.png" alt="image-20240324211954960"></p>
<h3 id="3-3-RabbitMQ-持久化"><a href="#3-3-RabbitMQ-持久化" class="headerlink" title="3.3 RabbitMQ 持久化"></a>3.3 RabbitMQ 持久化</h3><h4 id="3-3-1-概念"><a href="#3-3-1-概念" class="headerlink" title="3.3.1 概念"></a>3.3.1 概念</h4><p>如何保障当 RabbitMQ 服务停掉以后消息生产者发送过来的消息不丢失。</p>
<p>默认情况下 RabbitMQ 退出或由于某种原因崩溃时，它忽视队列和消息。确保消息不会丢失需要做两件事：<strong>我们需要将队列和消息都标记为持久化</strong></p>
<h4 id="3-3-2-队列如何实现持久化"><a href="#3-3-2-队列如何实现持久化" class="headerlink" title="3.3.2 队列如何实现持久化"></a>3.3.2 队列如何实现持久化</h4><ul>
<li>之前我们创建的队列都是非持久化的，rabbitmq 如果重启，该队列就会被删除掉，如果要队列实现持久化 需要<strong>在声明队列的时候把 durable 参数设置为持久化</strong> （这样即使重启 rabbitmq 队列也依然存在）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第二个参数 false =&gt; true</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">durable</span> <span class="operator">=</span> <span class="literal">true</span>;  <span class="comment">// 需要进行持久化</span></span><br><span class="line">channel.queueDeclare(TASK_QUEUE_NAME, durable, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>注意</strong>：如果之前声明的队列不是持久化的，<strong>需要把原先队列先删除，或者重新创建一个持久化的队列</strong>，不然就会出现错误<ul>
<li>先删：</li>
</ul>
</li>
</ul>
<p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/image-20240324213149448.png" alt="image-20240324213149448"></p>
<ul>
<li>出现了持久化标识：注意这表示队列持久化，而不是消息持久化</li>
</ul>
<p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/image-20240324212904947.png" alt="image-20240324212904947"></p>
<h4 id="3-3-3-消息实现持久化"><a href="#3-3-3-消息实现持久化" class="headerlink" title="3.3.3 消息实现持久化"></a>3.3.3 消息实现持久化</h4><ul>
<li>要想让消息实现持久化需要在消息<strong>生产者修改代码，<code>MessageProperties.PERSISTENT_TEXT_PLAIN</code> 添加文本持久化属性</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置生产者发送消息为持久化消息(要求保存到磁盘上), 不写就默认保存在内存中(会丢失)</span></span><br><span class="line">channel.basicPublish(<span class="string">&quot;&quot;</span>, TASK_QUEUE_NAME, MessageProperties.PERSISTENT_TEXT_PLAIN, message.getBytes());</span><br></pre></td></tr></table></figure>

<ul>
<li><p>将消息标记为持久化并不能完全保证不会丢失消息</p>
<ul>
<li>尽管它告诉 RabbitMQ 将消息保存到磁盘，但是这里依然存在<strong>当消息刚准备存储在磁盘的时候 但是还没有存储完，消息还在缓存的一个间隔点</strong>。</li>
<li>此时并没有真正写入磁盘。持久性保证并不强，但是对于简单任务队列而言，这已经绰绰有余了。</li>
</ul>
</li>
<li><p>如果需要<strong>更强有力的持久化策略，参考后边 8. 发布确认 章节</strong></p>
</li>
</ul>
<h4 id="3-3-4-不公平分发"><a href="#3-3-4-不公平分发" class="headerlink" title="3.3.4 不公平分发"></a>3.3.4 不公平分发</h4><ul>
<li><strong>默认情况下</strong>，RabbitMQ 分发消息采用的<strong>轮询分发</strong></li>
</ul>
<blockquote>
<p>如果所有消费者都能以相同的速率处理消息，轮询分发是一个公平且高效的策略</p>
</blockquote>
<ul>
<li>但是，如果某些消费者能够处理消息更快，而其他消费者处理得更慢，那么更快的消费者在完成工作后会空闲等待，因为RabbitMQ 仍然试图平等地分配消息给所有消费者</li>
<li>为了避免这种情况，我们可以<strong>通过设置较低的预取计数值来实现不公平分发</strong>，通常是1，意味着 RabbitMQ 一次只会向每个消费者发送一条消息，等待消费者处理完并发送ack之后，才会发送下一条消息。这样，更快的消费者能够更频繁地接收消息，而不是等待其他消费者处理完他们的消息</li>
<li>在两个<strong>消费者端</strong>，可以通过<code>basicQos</code>方法来设置预取计数值：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置不公平分发</span></span><br><span class="line"><span class="type">int</span> <span class="variable">prefetchCount</span> <span class="operator">=</span> <span class="number">1</span>;  <span class="comment">// 0 是公平分发, 1 是不公平分发</span></span><br><span class="line">channel.basicQos(prefetchCount);</span><br></pre></td></tr></table></figure>

<ul>
<li>意思就是如果这个任务我还没有处理完或者我还没有应答你，你先别分配给我，我目前只能处理一个任务</li>
<li>然后 rabbitmq 就会把该任务分配给没有那么忙的那个空闲消费者，当然如果所有的消费者都没有完成手上任务，队列还在不停的添加新任务，队列有可能就会遇到队列被撑满的情况，这个时候就只能添加新的 worker 或者改变其他存储任务的策略</li>
</ul>
<h4 id="3-3-5-预取值"><a href="#3-3-5-预取值" class="headerlink" title="3.3.5 预取值"></a>3.3.5 预取值</h4><blockquote>
<p>预取值控制着消息的流速以及如何基于消费者的能力来优化消息分发</p>
<p>主要目的是为了平衡各个消费者的负载，防止快速的消费者空闲，同时避免慢的消费者积累太多待处理的消息</p>
<p>告诉RabbitMQ不要同时给一个消费者发送超过设定数量的消息，除非这些消息已经被确认</p>
</blockquote>
<ul>
<li>异步消息发送意味着消息可以快速地发送给消费者，而不需要等待每条消息都被确认<ul>
<li>但这也可能导致一个快速的消费者接收到过多的消息，而来不及处理</li>
<li>通过设置预取值，RabbitMQ能够更智能地控制消息的流向，确保消费者能够以他们自己的速度处理消息。<strong>该值定义通道上允许的未确认消息的最大数量</strong>。一旦数量达到配置的数量，RabbitMQ 将停止在通道上传递更多消息，除非至少有一个未处理的消息被确认</li>
<li>例如，假设在通道上有未确认的消息 5、6、7，8，并且通道的预取计数设置为 4，此时 RabbitMQ 将不会在该通道上再传递任何消息，除非至少有一个未应答的消息被 ack。比方说 tag&#x3D;6 这个消息刚刚被确认 ACK，RabbitMQ 将会感知这个情况到并再发送一条消息</li>
</ul>
</li>
</ul>
<p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/image-20240324215642902.png" alt="image-20240324215642902"></p>
<ul>
<li>消息应答和 QoS 预取值对用户吞吐量有重大影响<ul>
<li>通常，增加预取将提高向消费者传递消息的速度。<strong>虽然自动应答传输消息速率是最佳的，但是，在这种情况下已传递但尚未处理的消息的数量也会增加，从而增加了消费者的</strong> <strong>RAM</strong> <strong>消耗</strong>(随机存取存储器)</li>
<li>应该小心使用具有无限预处理的自动确认模式或手动确认模式，消费者消费了大量的消息如果没有确认的话，会导致消费者连接节点的内存消耗变大</li>
<li>所以找到合适的预取值是一个反复试验的过程，<strong>不同的负载该值取值也不同</strong>，100 到 300 范围内的值通常可提供最佳的吞吐量，并且不会给消费者带来太大的风险</li>
<li>预取值为 1 是最保守的。当然这将使吞吐量变得很低，特别是消费者连接延迟很严重的情况下，特别是在消费者连接等待时间较长的环境中。对于大多数应用来说，稍微高一点的值将是最佳的</li>
</ul>
</li>
</ul>
<h2 id="4-发布确认"><a href="#4-发布确认" class="headerlink" title="4. 发布确认"></a>4. 发布确认</h2><h3 id="4-1-发布确认原理"><a href="#4-1-发布确认原理" class="headerlink" title="4.1 发布确认原理"></a>4.1 发布确认原理</h3><blockquote>
<p>发布确认（Publisher Confirms）机制是一种确保消息从生产者发送到 RabbitMQ 服务器的可靠方式</p>
<p>这种机制允许生产者知道其消息是否已成功到达目标队列</p>
</blockquote>
<p><strong>工作原理</strong>：</p>
<ul>
<li><strong>启用发布确认模式</strong>：生产者在通道上启用发布确认，启用后，该通道会进入发布确认模式。</li>
<li><strong>发送消息</strong>：生产者通过已启用发布确认的通道发送消息。发送消息时，<strong>生产者可以为每条消息指定一个唯一的标识符</strong>(从 1 开始)。</li>
<li><strong>等待确认</strong>：发送消息后，生产者等待来自RabbitMQ服务器的确认。服务器确认消息的两种方式：<ul>
<li><strong>确认（Ack）</strong>：如果<strong>消息被队列接受，RabbitMQ服务器会发送一个确认给生产者</strong>(包含消息的唯一 ID)，表明消息已被成功接收。</li>
<li><strong>未确认（Nack）</strong>：如果消息由于某些原因未能被队列接受，服务器会发送一个未确认给生产者，指出消息没有被成功处理。</li>
</ul>
</li>
<li><strong>处理确认</strong>：生产者根据收到的确认或未确认采取相应的行动。例如，如果收到未确认，生产者可能决定重新发送消息或记录错误。</li>
</ul>
<p>confirm 模式最大的好处在于他是异步的，一旦发布一条消息，<strong>生产者应用程序就可以在等信道返回确认的同时继续发送下一条消息</strong>，当消息最终得到确认之后，生产者应用便可以通过回调方法来处理该确认消息。</p>
<h3 id="4-2-发布确认策略"><a href="#4-2-发布确认策略" class="headerlink" title="4.2 发布确认策略"></a>4.2 发布确认策略</h3><blockquote>
<p>三种：单个确认、批量确认和异步确认</p>
</blockquote>
<h4 id="4-2-1-开启发布确认的方法"><a href="#4-2-1-开启发布确认的方法" class="headerlink" title="4.2.1 开启发布确认的方法"></a>4.2.1 开启发布确认的方法</h4><ul>
<li><p>发布确认<strong>默认是没有开启的</strong></p>
</li>
<li><p>如果要开启需要调用方法   <code>confirmSelect</code>，每当你要想使用发布确认，都需要在 channel 上调用该方法（<strong>获取了信道后开启发布确认</strong>）</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtils.getChannel();</span><br><span class="line">channel.confirmSelect();</span><br></pre></td></tr></table></figure>

<h4 id="4-2-2-单个确认发布"><a href="#4-2-2-单个确认发布" class="headerlink" title="4.2.2 单个确认发布"></a>4.2.2 单个确认发布</h4><ul>
<li>是一种<strong>同步确认发布</strong>的方式，也就是发布一个消息之后只有它被确认发布，后续的消息才能继续发布</li>
<li><code>waitForConfirmsOrDie(long)</code> 这个方法只有在消息被确认的时候才返回，如果在指定时间范围内这个消息没有被确认那么它将抛出异常。</li>
<li><strong>缺点</strong>：<strong>发布速度特别的慢</strong>，因为如果没有确认发布的消息就会阻塞所有后续消息的发布，这种方式<strong>最多提供每秒不超过数百条发布消息的吞吐量</strong>（对于某些应用程序来说这可能已经足够了）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 单个确认</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">publishMessageIndividually</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtils.getChannel()) &#123;</span><br><span class="line">        <span class="comment">// 队列名称 这里用 UUID 随机生成名称</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> UUID.randomUUID().toString();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 声明队列</span></span><br><span class="line">        channel.queueDeclare(queueName, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开启发布确认</span></span><br><span class="line">        channel.confirmSelect();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开始时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">begin</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 批量发消息</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; MESSAGE_COUNT; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> i + <span class="string">&quot;&quot;</span>;  <span class="comment">// 消息内容</span></span><br><span class="line">            <span class="comment">// 发消息</span></span><br><span class="line">            channel.basicPublish(<span class="string">&quot;&quot;</span>, queueName, <span class="literal">null</span>, message.getBytes());</span><br><span class="line">            <span class="comment">// 单个消息就马上进行发布确认</span></span><br><span class="line">            <span class="comment">// 服务端返回 false 或超时时间内未返回, 生产者可以消息重发</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> channel.waitForConfirms();</span><br><span class="line">            <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;消息发送成功&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 结束时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="comment">// 用时</span></span><br><span class="line">        System.out.println(<span class="string">&quot;发布&quot;</span> + MESSAGE_COUNT + <span class="string">&quot;个单独确认消息,耗时&quot;</span> + (end - begin) +</span><br><span class="line">                           <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-2-3-批量确认发布"><a href="#4-2-3-批量确认发布" class="headerlink" title="4.2.3 批量确认发布"></a>4.2.3 批量确认发布</h4><ul>
<li><p>与单个等待确认消息相比，<strong>先发布一批消息然后一起确认</strong>可以极大地<strong>提高吞吐量</strong></p>
</li>
<li><p><strong>缺点</strong>：当发生故障导致发布出现问题时，不知道是哪个消息出现问题了，我们必须将整个批处理保存在内存中，以记录重要的信息而后重新发布消息</p>
<ul>
<li>当然这种方案仍然是<strong>同步的</strong>，也一样阻塞消息的发布</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">publishMessageBatch</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtils.getChannel()) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> UUID.randomUUID().toString();</span><br><span class="line">        channel.queueDeclare(queueName, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="comment">// 开启发布确认</span></span><br><span class="line">        channel.confirmSelect();</span><br><span class="line">        <span class="comment">// 批量确认消息大小</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">batchSize</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        <span class="comment">// 未确认消息个数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">outstandingMessageCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 开始时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">begin</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="comment">// 批量发送消息, 批量发布确认</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; MESSAGE_COUNT; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> i + <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="comment">// 发消息</span></span><br><span class="line">            channel.basicPublish(<span class="string">&quot;&quot;</span>, queueName, <span class="literal">null</span>, message.getBytes());</span><br><span class="line">            outstandingMessageCount++;</span><br><span class="line">            <span class="comment">// 判断达到 100 条消息后, 批量确认一次</span></span><br><span class="line">            <span class="keyword">if</span> (outstandingMessageCount == batchSize) &#123;</span><br><span class="line">                channel.waitForConfirms();</span><br><span class="line">                outstandingMessageCount = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 为了确保还有剩余没有确认消息 再次确认</span></span><br><span class="line">        <span class="keyword">if</span> (outstandingMessageCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            channel.waitForConfirms();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;发布&quot;</span> + MESSAGE_COUNT + <span class="string">&quot;个批量确认消息,耗时&quot;</span> + (end - begin) +</span><br><span class="line">                           <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-2-4-异步确认发布"><a href="#4-2-4-异步确认发布" class="headerlink" title="4.2.4 异步确认发布"></a>4.2.4 异步确认发布</h4><ul>
<li>异步确认是一种高效的确认方式，无论是可靠性还是效率都很优秀，它是<strong>利用回调函数来达到消息可靠性传递</strong></li>
</ul>
<p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/image-20240329173344260.png" alt="image-20240329173344260"></p>
<ul>
<li><strong>如何处理异步未确认消息</strong> &#x3D;&#x3D;&gt; <strong>使用<code>ConcurrentSkipListMap</code>处理未确认消息</strong><ul>
<li><code>ConcurrentSkipListMap</code> 是 Java 并发包中的一种线程安全且排序的映射表<ul>
<li>内部使用跳表（Skip List）作为数据结构</li>
<li>跳表是一种概率性平衡的数据结构，通过多层索引来提高搜索、插入和删除操作的效率</li>
<li><code>ConcurrentSkipListMap</code> 提供了一种高效的并发访问和排序的映射结构</li>
</ul>
</li>
<li>用作<strong>发布线程和确认回调之间的桥梁</strong>(两个线程)，用于存储和传递未确认的消息<ul>
<li><strong>存储未确认消息</strong>：当生产者发送消息时，将该消息的标识（如消息ID或唯一标识符）和相关信息（如发送时间戳、重试次数等）存入<code>ConcurrentSkipListMap</code>。键可以是消息ID，值可以是包含消息详细信息和发送时间的对象</li>
<li><strong>访问和处理</strong>(移除已经确认的)：确认回调函数（即RabbitMQ向生产者确认消息时触发的回调）中，根据消息的标识（从确认通知中获得）查找<code>ConcurrentSkipListMap</code>中对应的条目，并将其移除。这表示消息已成功处理。对于识别出的超时未确认消息，可以执行重试逻辑，将消息重新发送</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 3. 异步批量确认</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">publishMessageAsync</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtils.getChannel()) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> UUID.randomUUID().toString();</span><br><span class="line">        channel.queueDeclare(queueName, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="comment">// 开启发布确认</span></span><br><span class="line">        channel.confirmSelect();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 线程安全有序的一个map ConcurrentSkipListMap, 底层是跳表, 适用于高并发的情况</span></span><br><span class="line">        <span class="comment">// 1. 轻松的将序号与消息进行关联</span></span><br><span class="line">        <span class="comment">// 2. 轻松批量删除条目 只要给到序列号</span></span><br><span class="line">        <span class="comment">// 3. 支持并发访问</span></span><br><span class="line">        ConcurrentSkipListMap&lt;Long, String&gt; outstandingConfirms = <span class="keyword">new</span></span><br><span class="line">            <span class="title class_">ConcurrentSkipListMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 消息确认成功回调函数, 两个参数:</span></span><br><span class="line">        <span class="comment">// 1. 消息序列号</span></span><br><span class="line">        <span class="comment">// 2. true 可以确认小于等于当前序列号的消息</span></span><br><span class="line">        <span class="comment">//    false 确认当前序列号消息</span></span><br><span class="line">        <span class="type">ConfirmCallback</span> <span class="variable">ackCallback</span> <span class="operator">=</span> (sequenceNumber, multiple) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (multiple) &#123;  <span class="comment">// 如果是批量, 就批量移除</span></span><br><span class="line">                <span class="comment">// 返回的是小于等于当前序列号的未确认消息 是一个 map</span></span><br><span class="line">                ConcurrentNavigableMap&lt;Long, String&gt; confirmed =</span><br><span class="line">                    outstandingConfirms.headMap(sequenceNumber, <span class="literal">true</span>);</span><br><span class="line">                <span class="comment">// 清除该部分未确认消息</span></span><br><span class="line">                confirmed.clear();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 如果是单个确认</span></span><br><span class="line">                <span class="comment">// 只清除当前序列号的消息</span></span><br><span class="line">                outstandingConfirms.remove(sequenceNumber);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 消息确认失败回调函数</span></span><br><span class="line">        <span class="type">ConfirmCallback</span> <span class="variable">nackCallback</span> <span class="operator">=</span> (sequenceNumber, multiple) -&gt; &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> outstandingConfirms.get(sequenceNumber);</span><br><span class="line">            System.out.println(<span class="string">&quot;发布的消息&quot;</span> + message + <span class="string">&quot;未被确认，序列号&quot;</span> + sequenceNumber);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加一个异步确认的监听器 监听哪些消息成功了, 哪些消息失败了 两个参数:</span></span><br><span class="line">        <span class="comment">// 1. 确认收到消息的回调 ==&gt; 监听成功</span></span><br><span class="line">        <span class="comment">// 2. 未收到消息的回调  ==&gt; 监听失败, 不需要就写 null</span></span><br><span class="line">        channel.addConfirmListener(ackCallback, nackCallback);</span><br><span class="line">        <span class="comment">// 开始时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">begin</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 批量发送消息</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; MESSAGE_COUNT; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;消息&quot;</span> + i;</span><br><span class="line">            <span class="comment">// channel.getNextPublishSeqNo() 从信道中获取下一个消息的序列号</span></span><br><span class="line">            <span class="comment">// 通过序列号与消息体进行一个关联, 全部都是未确认的消息体</span></span><br><span class="line">            outstandingConfirms.put(channel.getNextPublishSeqNo(), message);</span><br><span class="line">            channel.basicPublish(<span class="string">&quot;&quot;</span>, queueName, <span class="literal">null</span>, message.getBytes());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;发布&quot;</span> + MESSAGE_COUNT + <span class="string">&quot;个异步确认消息,耗时&quot;</span> + (end - begin) +</span><br><span class="line">                           <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-2-5-以上-3-种发布确认速度对比"><a href="#4-2-5-以上-3-种发布确认速度对比" class="headerlink" title="4.2.5 以上 3 种发布确认速度对比"></a>4.2.5 以上 3 种发布确认速度对比</h4><ul>
<li><strong>单独发布消息</strong><ul>
<li>同步等待确认，简单，但吞吐量非常有限。</li>
</ul>
</li>
<li><strong>批量发布消息</strong><ul>
<li>批量同步等待确认，简单，合理的吞吐量，一旦出现问题但很难推断出是哪条消息出现了问题</li>
</ul>
</li>
<li><strong>异步处理</strong><ul>
<li>最佳性能和资源使用，在出现错误的情况下可以很好地控制，但是实现起来稍微难些</li>
</ul>
</li>
</ul>
<h2 id="5-交换机"><a href="#5-交换机" class="headerlink" title="5. 交换机"></a>5. 交换机</h2><ul>
<li><strong>工作队列模式</strong>：<ul>
<li>任务（消息）被分配给多个消费者中的一个。每个任务都恰好由一个消费者处理，这种模式适用于分布式任务处理场景，其中每个任务只需要被处理一次</li>
</ul>
</li>
<li><strong>发布&#x2F;订阅模式</strong>：<ul>
<li>消息不是被发送给单个消费者，而是被广播给所有订阅了该消息的消费者。这意味着发布的每条消息可以被多个消费者同时接收和处理</li>
<li>如，<strong>日志系统</strong>：<ul>
<li><strong>系统组成</strong>：示例中的日志系统由两部分组成：日志消息的生产者（发布者）和消费者（订阅者）。<ul>
<li><strong>生产者</strong>：负责发出日志消息。</li>
<li><strong>消费者</strong>：接收并处理日志消息。示例中有两个消费者：一个将日志消息保存到磁盘，另一个将消息打印到屏幕上。</li>
</ul>
</li>
<li><strong>消息广播</strong>：在这个系统中，生产者发出的日志消息会被广播给所有消费者。每个消费者都会接收到所有的日志消息，而<strong>不是像工作队列模式那样，一个消息只被一个消费者接收</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="5-1-Exchanges"><a href="#5-1-Exchanges" class="headerlink" title="5.1 Exchanges"></a>5.1 Exchanges</h3><h4 id="5-1-1-概念"><a href="#5-1-1-概念" class="headerlink" title="5.1.1 概念"></a>5.1.1 概念</h4><ul>
<li>RabbitMQ 消息传递模型的<strong>核心思想</strong>：<strong>生产者生产的消息从不会直接发送到队列</strong><ul>
<li>实际上，通常生产者甚至都不知道这些消息传递传递到了哪些队列中</li>
<li>RabbitMQ中的消息传递模型通过<strong>引入交换机这一层，将生产者和队列解耦</strong>，提高了消息处理的灵活性和可扩展性</li>
<li><strong>生产者将消息发送到交换机，由交换机根据其类型和绑定规则决定消息的去向</strong>，这可以是一个队列、多个队列，或者在某些情况下，消息也可能被丢弃</li>
</ul>
</li>
</ul>
<p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/image-20240330161012976.png" alt="image-20240330161012976"></p>
<ul>
<li><p><strong>交换机（Exchange）的角色和工作机制</strong></p>
<ul>
<li><strong>交换机作为中介</strong>：一方面它接收来自生产者的消息，另一方面将它们推入队列。交换机是生产者和队列之间的中介</li>
<li><strong>处理规则由交换机类型决定</strong>：交换机根据自己的类型（如直接交换机、主题交换机、扇出交换机和头交换机）来决定如何处理接收到的消息。这包括：<ul>
<li><strong>放到特定的队列</strong>：根据规则，交换机可能将消息路由到一个或多个特定队列</li>
<li><strong>广播到多个队列</strong>：某些类型的交换机（如扇出交换机）会将消息发送到所有绑定到该交换机的队列</li>
<li><strong>丢弃消息</strong>：如果没有队列与交换机正确绑定，或者根据交换机的路由规则找不到合适的队列，消息可能会被丢弃</li>
</ul>
</li>
</ul>
</li>
<li><p>RabbitMQ 中常用的<strong>交换机类型</strong>：</p>
<ul>
<li><strong>直接</strong>(direct)  &#x3D;&#x3D;&gt; 一对一的消息分发</li>
<li><strong>扇出</strong>(fanout) &#x3D;&#x3D;&gt; <strong>发布订阅模式</strong></li>
<li><strong>主题</strong>(topic)  &#x3D;&#x3D;&gt; 根据消息的路由键和队列的绑定键之间的模式匹配来路由消息</li>
<li><strong>标题</strong>(headers)  &#x3D;&#x3D;&gt; 不咋用，根据消息内容而非路由键进行路由</li>
<li><strong>默认&#x2F;无名</strong>(default)</li>
</ul>
</li>
<li><p><strong>默认&#x2F;无名交换机</strong>：</p>
<ul>
<li>之前我们使用的就是默认交换，通过空字符串 <code>&quot;&quot;</code> 进行标识</li>
<li>第一个参数是交换机的名称，空字符串表示默认或无名交换机，直接将消息路由到与路由键同名的队列</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.basicPublish(<span class="string">&quot;&quot;</span>, queueName, <span class="literal">null</span>, message.getBytes());</span><br></pre></td></tr></table></figure>

<h3 id="5-2-临时队列"><a href="#5-2-临时队列" class="headerlink" title="5.2 临时队列"></a>5.2 临时队列</h3><ul>
<li><p>没有持久化的队列是临时队列，<strong>一旦我们断开了消费者的连</strong></p>
<p><strong>接，队列将被自动删除</strong></p>
</li>
<li><p><strong>创建临时队列</strong>的方式如下：RabbitMQ）会自动为其生成一个唯一的名称，避免命名冲突</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> channel.queueDeclare().getQueue();</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>创建效果</strong>：</li>
</ul>
<p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/image-20240330164500891.png" alt="image-20240330164500891"></p>
<h3 id="5-3-绑定"><a href="#5-3-绑定" class="headerlink" title="5.3 绑定"></a>5.3 绑定</h3><ul>
<li><strong>绑定（Binding）</strong>是定义交换机和队列之间关系的桥梁<ul>
<li>绑定充当路由规则，<strong>指示交换机</strong>如何根据消息的属性（如路由键或其他属性）<strong>将消息路由到一个或多个特定的队列</strong></li>
</ul>
</li>
<li>绑定可以包括一个<strong>路由键</strong>（Routing Key），交换机会使用这个路由键按照绑定的规则来路由消息。路由键的使用和重要性取决于交换机的类型。<ul>
<li>对于<strong>直接交换机</strong>，消息被发送到路由键完全匹配的队列。</li>
<li>对于<strong>主题交换机</strong>，路由键可以包含通配符，实现更灵活的匹配。</li>
<li><strong>扇出交换机</strong>忽略路由键，广播消息到所有绑定的队列。</li>
<li><strong>头交换机</strong>根据消息头而非路由键进行匹配。</li>
</ul>
</li>
</ul>
<h3 id="5-4-Fanout"><a href="#5-4-Fanout" class="headerlink" title="5.4 Fanout"></a>5.4 Fanout</h3><ul>
<li>扇出交换机（Fanout Exchange）是RabbitMQ中实现发布-订阅模式的一种交换机类型，它能够将接收到的消息广播到所有绑定到该交换机的队列中<ul>
<li>将接收到的所有消息<strong>广播</strong>到它知道的所有队列中</li>
<li>系统中默认自带一些交换机类型，咱们也可以自己自定义</li>
</ul>
</li>
</ul>
<p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/image-20240330165644277.png" alt="image-20240330165644277"></p>
<ul>
<li><strong>代码实现</strong>：写两个消费者，一个生产者<ul>
<li>交换机的创建可以由生产者或消费者来完成</li>
<li>RabbitMQ <strong>允许你重复创建相同配置的交换机，后续创建操作会被静默忽略</strong>，简化了管理逻辑</li>
</ul>
</li>
<li><strong>消费者</strong>：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReceiveLogs01</span> &#123;</span><br><span class="line">    <span class="comment">// 交换机名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;logs&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtils.getChannel();  <span class="comment">// 建立信道</span></span><br><span class="line">        <span class="comment">// 创建交换机, 参数为交换机名称和类型</span></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">&quot;fanout&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 声明一个临时队列 队列的名称是随机的</span></span><br><span class="line">        <span class="comment">// 当消费者断开和该队列的连接时 队列自动删除</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> channel.queueDeclare().getQueue();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 绑定临时队列和交换机</span></span><br><span class="line">        <span class="comment">// 其中 routingKey(也称之为 binding key)为空字符串</span></span><br><span class="line">        channel.queueBind(queueName, EXCHANGE_NAME, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;等待接收消息,把接收到的消息打印在屏幕.....&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;控制台打印接收到的消息&quot;</span> + message);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接收消息</span></span><br><span class="line">        channel.basicConsume(queueName, <span class="literal">true</span>, deliverCallback, consumerTag -&gt; &#123;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>生产者</strong>：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmitLog</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;logs&quot;</span>;  <span class="comment">// 交换机名称</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtils.getChannel()) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 声明一个 交换机</span></span><br><span class="line">            <span class="comment">// 1. exchange 的名称</span></span><br><span class="line">            <span class="comment">// 2. exchange 的类型</span></span><br><span class="line">            channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">&quot;fanout&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">            System.out.println(<span class="string">&quot;请输入信息&quot;</span>);</span><br><span class="line">            <span class="keyword">while</span> (sc.hasNext()) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> sc.nextLine();</span><br><span class="line">                <span class="comment">// 发送消息</span></span><br><span class="line">                channel.basicPublish(EXCHANGE_NAME, <span class="string">&quot;&quot;</span>, <span class="literal">null</span>, message.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">                System.out.println(<span class="string">&quot;生产者发出消息&quot;</span> + message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>CentOS 连不上了，测不了，试了下面这个，虽然能进去，但还是报关闭连接的错误：<br><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1722144">centOS7 桥接模式设置静态Ip的方法步骤-腾讯云开发者社区-腾讯云 (tencent.com)</a></p>
<p>用云服务器重新配了下环境，测了下，可以的，没毛病</p>
</blockquote>
<h3 id="5-5-Direct-exchange"><a href="#5-5-Direct-exchange" class="headerlink" title="5.5 Direct exchange"></a>5.5 Direct exchange</h3><ul>
<li><strong>扇出交换机 VS 直接&#x2F;路由交换机</strong><ul>
<li>扇出交换机<strong>忽略路由键(routing key)<strong>，当一条消息发送到扇出交换机时，它</strong>会将消息发送到所有与之绑定的队列</strong></li>
<li>直接交换机<strong>使用路由键(routing key)来路由消息</strong>，生产者在发送消息时会指定一个路由键，直接交换机<strong>根据这个路由键将消息路由到绑定时指定了相同路由键的队列</strong></li>
<li>如果需要将相同的消息广播给多个消费者，扇出交换机是合适的选择；如果需要根据某种标准（例如，消息类型或优先级等）将消息路由到特定的队列，直接交换机会更加适合</li>
</ul>
</li>
<li><strong>直接交换机的使用场景举例</strong>：<ul>
<li>构建日志系统时，如何根据日志的严重级别（例如错误、警告、信息）将消息分发到不同的队列</li>
<li>期望实现的功能是能够根据日志的级别（例如，仅将“错误”日志消息写入磁盘），以避免将警告或信息日志存储到磁盘中，从而节省磁盘空间</li>
</ul>
</li>
<li><strong>直接交换机工作原理</strong><ul>
<li>直接交换机根据发送到交换机的消息的路由键（routing key）和队列的绑定键（binding key）进行匹配，只将消息路由到完全匹配的队列</li>
<li>例如，假设有一个直接交换机X，它绑定了两个队列：队列Q1的绑定键为“orange”，而队列Q2的绑定键为“black”和“green” <strong>（一个队列可以绑多遍）</strong><ul>
<li>发送到交换机X，路由键为“orange”的消息将被路由到队列Q1</li>
<li>路由键为“black”或“green”的消息将被路由到队列Q2</li>
<li>其他不匹配的消息将被丢弃</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/image-20240330213930427.png" alt="image-20240330213930427"></p>
<ul>
<li><strong>多重绑定(类似扇出交换机)</strong><ul>
<li>当一个直接交换机绑定多个队列时，如果<strong>所有队列的绑定键都相同</strong>，那么尽管绑定类型是直接的，这种配置实际上会让交换机的行为类似于扇出交换机——<strong>相当于广播</strong>，因为所有绑定到该交换机的队列都会接收到相同的消息</li>
</ul>
</li>
</ul>
<p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/image-20240330214053865.png" alt="image-20240330214053865"></p>
<ul>
<li><strong>实战</strong>：</li>
</ul>
<p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/image-20240330214118580.png" alt="image-20240330214118580"></p>
<p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/image-20240331170351854.png" alt="image-20240331170351854"></p>
<ul>
<li><strong>消费者</strong><ul>
<li>写两个，这里就一个示例下</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReceiveLogsDirect02</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;direct_logs&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 获取信道</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtils.getChannel();</span><br><span class="line">        <span class="comment">// 声明直接交换机</span></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);</span><br><span class="line">        <span class="comment">// 声明队列</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> <span class="string">&quot;console&quot;</span>;</span><br><span class="line">        channel.queueDeclare(queueName, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="comment">// 绑定两个键</span></span><br><span class="line">        channel.queueBind(queueName, EXCHANGE_NAME, <span class="string">&quot;info&quot;</span>);</span><br><span class="line">        channel.queueBind(queueName, EXCHANGE_NAME, <span class="string">&quot;warning&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;等待接收消息.....&quot;</span>);</span><br><span class="line">        <span class="comment">// 接收消息的回调</span></span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot; 接收绑定键 :&quot;</span> + delivery.getEnvelope().getRoutingKey() + <span class="string">&quot;, 消息:&quot;</span> + message);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        channel.basicConsume(queueName, <span class="literal">true</span>, deliverCallback, consumerTag -&gt; &#123;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>生产者</strong><ul>
<li>生产者这边发送的消息是写死的，所以先运行消费者后再运行生产者</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmitLogDirect</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;direct_logs&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtils.getChannel()) &#123;</span><br><span class="line">            <span class="comment">// 声明一个直接交换机</span></span><br><span class="line">            channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建多个 bindingKey</span></span><br><span class="line">            Map&lt;String, String&gt; bindingKeyMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">            bindingKeyMap.put(<span class="string">&quot;info&quot;</span>, <span class="string">&quot;普通 info 信息&quot;</span>);</span><br><span class="line">            bindingKeyMap.put(<span class="string">&quot;warning&quot;</span>, <span class="string">&quot;警告 warning 信息&quot;</span>);</span><br><span class="line">            bindingKeyMap.put(<span class="string">&quot;error&quot;</span>, <span class="string">&quot;错误 error 信息&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// debug 没有消费这接收这个消息 所以就丢失了</span></span><br><span class="line">            bindingKeyMap.put(<span class="string">&quot;debug&quot;</span>, <span class="string">&quot;调试 debug 信息&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 生产者测试消息的发送, 发送消息和对应的路由键</span></span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; bindingKeyEntry : bindingKeyMap.entrySet()) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">bindingKey</span> <span class="operator">=</span> bindingKeyEntry.getKey();</span><br><span class="line">                <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> bindingKeyEntry.getValue();</span><br><span class="line">                channel.basicPublish(EXCHANGE_NAME, bindingKey, <span class="literal">null</span>,</span><br><span class="line">                                     message.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">                System.out.println(<span class="string">&quot;生产者发出消息:&quot;</span> + message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-6-Topics"><a href="#5-6-Topics" class="headerlink" title="5.6 Topics"></a>5.6 Topics</h3><h4 id="5-6-1-主题交换机的引入"><a href="#5-6-1-主题交换机的引入" class="headerlink" title="5.6.1 主题交换机的引入"></a>5.6.1 主题交换机的引入</h4><ul>
<li><strong>扇出交换机的局限</strong><ul>
<li><strong>扇出交换机</strong>广播所有接收到的消息到所有绑定的队列，没有路由逻辑，适用于简单的广播场景，但无法进行细粒度的消息路由</li>
</ul>
</li>
<li><strong>直接交换机的改进</strong><ul>
<li><strong>直接交换机</strong>允许根据消息的路由键和队列的绑定键进行精确匹配，从而实现有选择性地接收消息。这比扇出交换机提供了更高的灵活性，但它仍然有局限性，特别是当需求变得更复杂，需要基于多个条件进行消息路由时</li>
</ul>
</li>
<li><strong>主题交换机的引入</strong><ul>
<li><strong>主题交换机</strong>通过允许<strong>路由键和绑定键之间使用模式匹配</strong>来解决直接交换机的局限性。主题交换机使得可以根据多个标准灵活地路由消息，非常适合复杂的路由逻辑</li>
<li><strong>路由键的要求</strong>：发送到<strong>主题交换机的消息的路由键必须是由点号分隔的单词列表</strong>，例如：<code>stock.usd.nyse</code>。这提供了一种结构化的方式来指定消息的属性或类别</li>
<li><strong>替换符</strong>：允许进行更复杂的匹配逻辑<ul>
<li><code>*</code>（星号）：匹配路由键中的一个单词。</li>
<li><code>#</code>（井号）：匹配路由键中的零个或多个单词。</li>
</ul>
</li>
</ul>
</li>
<li><strong>示例</strong>：如果某个队列只想接收到以 <code>info.base</code> 为主题的日志消息，而另一个队列想接收所有以 <code>info</code> 开头的日志消息（无论是”info.base”还是”info.advantage”）使用主题交换机可以轻松实现这一需求<ul>
<li>例如，第一个队列可以使用绑定键 <code>&quot;info.base&quot;</code></li>
<li>而第二个队列可以使用绑定键 <code>&quot;info.#&quot;</code></li>
</ul>
</li>
</ul>
<h4 id="5-6-2-Topic-匹配案例"><a href="#5-6-2-Topic-匹配案例" class="headerlink" title="5.6.2 Topic 匹配案例"></a>5.6.2 Topic 匹配案例</h4><ul>
<li><p><strong>前提</strong>：</p>
<ul>
<li><p><strong>队列Q1</strong>：绑定键为<code>*.orange.*</code></p>
<ul>
<li>Q1 只接收包含三个单词，其中第二个单词是”orange”的消息</li>
</ul>
</li>
<li><p><strong>队列Q2</strong>：有两个绑定键，<code>*.*.rabbit</code>和<code>lazy.#</code></p>
<ul>
<li>Q2 将接收最后一个单词是”rabbit”的包含三个单词的消息，以及以”lazy”开头的任意长度的消息</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/image-20240331165905276.png" alt="image-20240331165905276"></p>
<ul>
<li><strong>案例</strong>：<ul>
<li><strong>quick.orange.rabbit</strong>：匹配Q1和Q2的绑定（因为它满足<code>*.orange.*</code>和<code>*.*.rabbit</code>），所以被两个队列接收。</li>
<li><strong>lazy.orange.elephant</strong>：同样匹配Q1和Q2的绑定（满足<code>*.orange.*</code>和<code>lazy.#</code>），被两个队列接收。</li>
<li><strong>quick.orange.fox</strong>：只匹配Q1的绑定（<code>*.orange.*</code>），只被Q1接收。</li>
<li><strong>lazy.brown.fox</strong>：只匹配Q2的<code>lazy.#</code>绑定，只被Q2接收。</li>
<li><strong>lazy.pink.rabbit</strong>：虽然同时满足Q2的两个绑定条件，但消息在队列中不会重复，所以它只被Q2接收一次。</li>
<li><strong>quick.brown.fox</strong>：不匹配任何绑定条件，被丢弃。</li>
<li><strong>quick.orange.male.rabbit</strong>：因为是四个单词，不满足任何队列的绑定条件，被丢弃。</li>
<li><strong>lazy.orange.male.rabbit</strong>：尽管是四个单词，但它满足Q2的<code>lazy.#</code>绑定条件，因此被Q2接收。</li>
</ul>
</li>
<li><strong>特殊情况</strong>：<ul>
<li><strong>全匹配（<code>#</code>）</strong>：如果一个队列的绑定键是<code>#</code>，那么这个队列会接收所有的消息，类似于扇出（fanout）交换机的行为。这种绑定键的设置使得队列成为一个”全订阅”者。</li>
<li><strong>直接匹配</strong>：如果一个队列的绑定键中不包含<code>#</code>和<code>*</code>，那么这个队列的绑定类型实际上就类似于直接（direct）交换机的行为。这意味着消息的路由键必须完全匹配绑定键，消息才会被路由到该队列。</li>
</ul>
</li>
</ul>
<p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/image-20240331185153187.png" alt="image-20240331185153187"></p>
<h4 id="5-6-3-代码实战"><a href="#5-6-3-代码实战" class="headerlink" title="5.6.3 代码实战"></a>5.6.3 代码实战</h4><blockquote>
<p>还是两个消费者Q1和Q2，一个生产者</p>
</blockquote>
<ul>
<li><strong>消费者</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReceiveLogsTopic02</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;topic_logs&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtils.getChannel();</span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">&quot;topic&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 声明 Q2 队列与绑定关系</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> <span class="string">&quot;Q2&quot;</span>;</span><br><span class="line">        channel.queueDeclare(queueName, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">        channel.queueBind(queueName, EXCHANGE_NAME, <span class="string">&quot;*.*.rabbit&quot;</span>);</span><br><span class="line">        channel.queueBind(queueName, EXCHANGE_NAME, <span class="string">&quot;lazy.#&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;等待接收消息.....&quot;</span>);</span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot; 接收队列 :&quot;</span> + queueName + <span class="string">&quot; 绑定键:&quot;</span> + delivery.getEnvelope().getRoutingKey()</span><br><span class="line">                               + <span class="string">&quot;, 消息:&quot;</span> + message);</span><br><span class="line">        &#125;;</span><br><span class="line">        channel.basicConsume(queueName, <span class="literal">true</span>, deliverCallback, consumerTag -&gt; &#123;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>生产者</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmitLogTopic</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;topic_logs&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtils.getChannel()) &#123;</span><br><span class="line">            <span class="comment">// 声明交换机</span></span><br><span class="line">            channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.TOPIC);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Q1--&gt;绑定的是</span></span><br><span class="line">            <span class="comment">// 中间带 orange 带 3 个单词的字符串(*.orange.*)</span></span><br><span class="line">            <span class="comment">// Q2--&gt;绑定的是</span></span><br><span class="line">            <span class="comment">// 最后一个单词是 rabbit 的 3 个单词(*.*.rabbit)</span></span><br><span class="line">            <span class="comment">// 第一个单词是 lazy 的多个单词(lazy.#)</span></span><br><span class="line">            Map&lt;String, String&gt; bindingKeyMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">            bindingKeyMap.put(<span class="string">&quot;quick.orange.rabbit&quot;</span>, <span class="string">&quot;被队列 Q1Q2 接收到&quot;</span>);</span><br><span class="line">            bindingKeyMap.put(<span class="string">&quot;lazy.orange.elephant&quot;</span>, <span class="string">&quot;被队列 Q1Q2 接收到&quot;</span>);</span><br><span class="line">            bindingKeyMap.put(<span class="string">&quot;quick.orange.fox&quot;</span>, <span class="string">&quot;被队列 Q1 接收到&quot;</span>);</span><br><span class="line">            bindingKeyMap.put(<span class="string">&quot;lazy.brown.fox&quot;</span>, <span class="string">&quot;被队列 Q2 接收到&quot;</span>);</span><br><span class="line">            bindingKeyMap.put(<span class="string">&quot;lazy.pink.rabbit&quot;</span>, <span class="string">&quot;虽然满足两个绑定但只被队列 Q2 接收一次&quot;</span>);</span><br><span class="line">            bindingKeyMap.put(<span class="string">&quot;quick.brown.fox&quot;</span>, <span class="string">&quot;不匹配任何绑定不会被任何队列接收到会被丢弃&quot;</span>);</span><br><span class="line">            bindingKeyMap.put(<span class="string">&quot;quick.orange.male.rabbit&quot;</span>, <span class="string">&quot;是四个单词不匹配任何绑定会被丢弃&quot;</span>);</span><br><span class="line">            bindingKeyMap.put(<span class="string">&quot;lazy.orange.male.rabbit&quot;</span>, <span class="string">&quot;是四个单词但匹配 Q2&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; bindingKeyEntry : bindingKeyMap.entrySet()) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">bindingKey</span> <span class="operator">=</span> bindingKeyEntry.getKey();</span><br><span class="line">                <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> bindingKeyEntry.getValue();</span><br><span class="line">                channel.basicPublish(EXCHANGE_NAME, bindingKey, <span class="literal">null</span>,</span><br><span class="line">                                     message.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">                System.out.println(<span class="string">&quot;生产者发出消息&quot;</span> + message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-死信队列"><a href="#6-死信队列" class="headerlink" title="6. 死信队列"></a>6. 死信队列</h2><h3 id="6-1-死信的概念和来源"><a href="#6-1-死信的概念和来源" class="headerlink" title="6.1 死信的概念和来源"></a>6.1 死信的概念和来源</h3><ul>
<li><p><strong>死信</strong>：无法被消费的消息，可能因为多种原因导致消息无法被正常处理，而死信队列就是用来收集这些无法处理的消息的特殊队列</p>
</li>
<li><p><strong>死信队列</strong>（DLQ, Dead Letter Queue）：用于处理无法被正常消费的消息</p>
</li>
<li><p><strong>死信的常见来源</strong>：</p>
<ul>
<li><strong>消息TTL过期</strong>：TTL（Time-To-Live），即消息的存活时间。如果一个消息在队列中的存活时间超过了它的TTL，它就会变成死信</li>
<li><strong>队列达到最大长度</strong>：如果队列已经达到了它的最大长度，新的消息就无法再添加到队列中。在这种情况下，如果队列配置了死信交换机和死信路由键，<strong>超出长度的消息会被发送到死信队列</strong></li>
<li><strong>消息被显式拒绝</strong>：当消费者通过<code>basic.reject</code>或<code>basic.nack</code>命令拒绝消息，并且设置<code>requeue=false</code>（不重新入队列）时，这个消息就会变成死信</li>
</ul>
</li>
<li><p><strong>应用场景</strong>：</p>
<ul>
<li><strong>保障业务的消息不丢失</strong>：比如订单处理系统，使用死信队列可以保证即使<strong>消费过程中发生异常，消息也不会丢失，而是被安全地移至死信队列中</strong>，后续可以对这些消息进行分析和再处理</li>
<li><strong>订单超时处理</strong>：在电商平台中，用户下单后可能存在未在规定时间内完成支付的情况。这时，可以通过<strong>设置消息的TTL来让未支付的订单消息过期，然后自动转移到死信队列中进行订单失效处理</strong></li>
</ul>
</li>
</ul>
<h3 id="6-2-死信实战"><a href="#6-2-死信实战" class="headerlink" title="6.2 死信实战"></a>6.2 死信实战</h3><blockquote>
<p>还是两个消费者，一个生产者</p>
<p>C1 代码需要声明两个交换机(包括死信交换机)，两个队列(包括死信队列)，还要涉及普通队列和死信交换机的捆绑问题</p>
<p>C2 只要接收死信队列的消息即可</p>
</blockquote>
<p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/image-20240331190302962.png" alt="image-20240331190302962"></p>
<h4 id="6-2-1-消息-TTL-过期"><a href="#6-2-1-消息-TTL-过期" class="headerlink" title="6.2.1 消息 TTL 过期"></a>6.2.1 消息 TTL 过期</h4><ul>
<li><strong>消费者1(启动之后关闭该消费者 模拟其接收不到消息)</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer01</span> &#123;</span><br><span class="line">    <span class="comment">// 普通交换机名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">NORMAL_EXCHANGE</span> <span class="operator">=</span> <span class="string">&quot;normal_exchange&quot;</span>;</span><br><span class="line">    <span class="comment">// 死信交换机名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEAD_EXCHANGE</span> <span class="operator">=</span> <span class="string">&quot;dead_exchange&quot;</span>;</span><br><span class="line">    <span class="comment">// 普通队列名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">NORMAL_QUEUE</span> <span class="operator">=</span> <span class="string">&quot;normal_queue&quot;</span>;</span><br><span class="line">    <span class="comment">// 死信队列名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEAD_QUEUE</span> <span class="operator">=</span> <span class="string">&quot;dead_queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtils.getChannel();</span><br><span class="line">        <span class="comment">// 声明死信和直接交换机 类型为 direct</span></span><br><span class="line">        channel.exchangeDeclare(NORMAL_EXCHANGE, BuiltinExchangeType.DIRECT);</span><br><span class="line">        channel.exchangeDeclare(DEAD_EXCHANGE, BuiltinExchangeType.DIRECT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 声明死信队列</span></span><br><span class="line">        channel.queueDeclare(DEAD_QUEUE, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="comment">// 死信队列绑定死信交换机与 routingKey</span></span><br><span class="line">        channel.queueBind(DEAD_QUEUE, DEAD_EXCHANGE, <span class="string">&quot;lisi&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 普通队列绑定死信队列的参数</span></span><br><span class="line">        Map&lt;String, Object&gt; params = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 可以由生产者指定过期时间 10s</span></span><br><span class="line">        <span class="comment">// params.put(&quot;x-message-ttl&quot;, 10000);</span></span><br><span class="line">        <span class="comment">// 参数1: 普通队列设置死信交换机 参数 key 是固定值</span></span><br><span class="line">        params.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, DEAD_EXCHANGE);</span><br><span class="line">        <span class="comment">// 参数2: 普通队列设置死信 routing-key 参数 key 是固定值</span></span><br><span class="line">        params.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>, <span class="string">&quot;lisi&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 声明普通队列</span></span><br><span class="line">        channel.queueDeclare(NORMAL_QUEUE, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, params);</span><br><span class="line">        <span class="comment">// 绑定到直接交换机与 routingKey</span></span><br><span class="line">        channel.queueBind(NORMAL_QUEUE, NORMAL_EXCHANGE, <span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;等待接收消息.....&quot;</span>);</span><br><span class="line">        <span class="comment">// 接收消息的回调</span></span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;Consumer01 接收到消息&quot;</span> + message);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 消费</span></span><br><span class="line">        channel.basicConsume(NORMAL_QUEUE, <span class="literal">true</span>, deliverCallback, consumerTag -&gt; &#123;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>普通交换机绑普通队列，死信交换机绑死信队列</p>
</blockquote>
<p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/image-20240331194218496.png" alt="image-20240331194218496"></p>
<ul>
<li><strong>生产者</strong>：设置过期时间 ttl<ul>
<li>在关闭了消费者后运行生产者，可以发现过了10秒后消息都到死信队列里了</li>
<li>然后再写个消费者2把死信队列里的消费掉即可，消费者2只用写个信道，然后接收死信队列消息即可</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Producer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">NORMAL_EXCHANGE</span> <span class="operator">=</span> <span class="string">&quot;normal_exchange&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtils.getChannel()) &#123;</span><br><span class="line">            <span class="comment">// 声明直接交换机</span></span><br><span class="line">            channel.exchangeDeclare(NORMAL_EXCHANGE, BuiltinExchangeType.DIRECT);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 设置消息的 TTL 时间  10s</span></span><br><span class="line">            AMQP.<span class="type">BasicProperties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AMQP</span>.BasicProperties()</span><br><span class="line">                .builder().expiration(<span class="string">&quot;10000&quot;</span>).build();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 该信息是用作演示队列个数限制</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; <span class="number">11</span>; i++) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;info&quot;</span> + i;</span><br><span class="line">                <span class="comment">// 设置 properties 参数</span></span><br><span class="line">                channel.basicPublish(NORMAL_EXCHANGE, <span class="string">&quot;zhangsan&quot;</span>, properties,</span><br><span class="line">                                     message.getBytes());</span><br><span class="line">                System.out.println(<span class="string">&quot;生产者发送消息:&quot;</span> + message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/image-20240331194650547.png" alt="image-20240331194650547"></p>
<h4 id="6-2-2-队列达到最大长度"><a href="#6-2-2-队列达到最大长度" class="headerlink" title="6.2.2 队列达到最大长度"></a>6.2.2 队列达到最大长度</h4><ul>
<li><p>队列达到最大长度后，<strong>超出长度的消息会被发送到死信队列</strong></p>
</li>
<li><p>修改代码：</p>
<ul>
<li>6.2.1 中，生产者代码中的 TTL 属性去掉，设置为 null</li>
<li>修改消费者1的代码，添加参数3：</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 普通队列绑定死信队列的参数</span></span><br><span class="line">Map&lt;String, Object&gt; params = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// 参数1: 普通队列设置死信交换机 参数 key 是固定值</span></span><br><span class="line">params.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, DEAD_EXCHANGE);</span><br><span class="line"><span class="comment">// 参数2: 普通队列设置死信 routing-key 参数 key 是固定值</span></span><br><span class="line">params.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>, <span class="string">&quot;lisi&quot;</span>);</span><br><span class="line"><span class="comment">// 参数3: 普通队列设置长度限制</span></span><br><span class="line">params.put(<span class="string">&quot;x-max-length&quot;</span>, <span class="number">6</span>);</span><br></pre></td></tr></table></figure>

<p><strong>注意测试时需要把原先普通队列删除，因为参数改变了</strong></p>
<ul>
<li>还是先运行消费者1，生成队列以及队列和死信交换机之间的关系，然后停止消费者1(为了看效果，让消息积压在队列中)，再运行生产者&#x3D;&#x3D;&gt;可以看到普通队列6个，死信里有4个</li>
</ul>
<p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/image-20240331200010021.png" alt="image-20240331200010021"></p>
<p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/image-20240331200144519.png" alt="image-20240331200144519"></p>
<ul>
<li>最后记得把消费者1和2都启动下，恢复初始状态方便后续测试</li>
</ul>
<h4 id="6-2-3-消息被拒"><a href="#6-2-3-消息被拒" class="headerlink" title="6.2.3 消息被拒"></a>6.2.3 消息被拒</h4><ul>
<li>修改代码：<ul>
<li>6.2.2 中消费者1添加的长度限制属性注释掉</li>
<li>设置消费者1拒绝消息，在接收回调的函数中设置<strong>拒绝</strong> <code>info5</code> <strong>消息，并且不允许放回普通队列</strong>，则只能进入死信队列</li>
<li>记得<strong>开启手动应答</strong>！因为自动应答只要队列发消息就算成功</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接收消息的回调</span></span><br><span class="line"><span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (message.equals(<span class="string">&quot;info5&quot;</span>)) &#123;  <span class="comment">// 拒绝 info5</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Consumer01 接收到消息&quot;</span> + message + <span class="string">&quot;并拒绝签收该消息&quot;</span>);</span><br><span class="line">        <span class="comment">// requeue 设置为 false 代表拒绝重新入队 该队列如果配置了死信交换机将发送到死信队列中</span></span><br><span class="line">        channel.basicReject(delivery.getEnvelope().getDeliveryTag(), <span class="literal">false</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Consumer01 接收到消息&quot;</span> + message);</span><br><span class="line">        channel.basicAck(delivery.getEnvelope().getDeliveryTag(), <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">autoAck</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">channel.basicConsume(NORMAL_QUEUE, autoAck, deliverCallback, consumerTag -&gt; &#123;&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>在 web 界面删除普通队列后，重新运行消费者1，然后再运行生产者，可以看到死信队列1条（其他 9 条被普通队列消费了已经），可以看到那一条确实是 info5</li>
</ul>
<p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/image-20240331201928728.png" alt="image-20240331201928728"></p>
<ul>
<li>最后运行下消费者2，即可消费掉这条 info5</li>
</ul>
<h2 id="7-延迟队列"><a href="#7-延迟队列" class="headerlink" title="7. 延迟队列"></a>7. 延迟队列</h2><h3 id="7-1-延迟队列的概念和使用场景"><a href="#7-1-延迟队列的概念和使用场景" class="headerlink" title="7.1 延迟队列的概念和使用场景"></a>7.1 延迟队列的概念和使用场景</h3><ul>
<li><p><strong>延迟队列</strong>：核心特性是能够<strong>控制消息在队列中的停留时间，只有当指定的时间到达时，消息才会被消费者处理</strong></p>
<ul>
<li>适合于需要在特定时间执行任务的场景</li>
</ul>
</li>
<li><p><strong>使用场景</strong>：</p>
<ul>
<li><strong>订单支付超时处理</strong>：对于在线支付场景，订单如果在一定时间（如10分钟）内未支付，系统需要自动取消这些订单</li>
<li><strong>提醒功能</strong>：对于新注册用户或新开店铺，如果在一定时间内未进行某些操作（如三天内未登录、十天内未上传商品），系统可以自动发送提醒</li>
<li><strong>退款处理提醒</strong>：对用户发起的退款请求，如果在一定时间（如三天）内未处理，系统可以自动提醒运营人员进行处理</li>
<li><strong>会议通知</strong>：对于预定的会议，系统可以在会议开始前十分钟自动通知与会人员</li>
</ul>
</li>
<li><p><strong>延迟队列与轮询的对比</strong>：</p>
<ul>
<li><strong>性能和效率</strong>：当数据量大时，使用定时任务不断轮询数据库检查哪些任务需要被执行是低效且对数据库压力大的。尤其是在高并发场景下，轮询可能无法在短时间内完成所有任务的检查，且对系统资源消耗大</li>
<li><strong>时效性</strong>：延迟队列可以精确控制任务的执行时间，确保任务能够在预定时间点准确执行，而轮询机制可能因为间隔时间设置不当导致执行时间的不精确</li>
</ul>
</li>
<li><p><strong>实现延迟队列的方法</strong>：在RabbitMQ中，可以<strong>通过设置消息的TTL（Time-To-Live，生存时间）和使用死信交换机（DLX）组合来实现延迟队列</strong>。具体步骤如下：</p>
<ul>
<li><strong>设置消息TTL</strong>：为消息设置一个TTL，即该消息在队列中可以存活的最长时间</li>
<li><strong>配置死信交换机</strong>：当消息因为TTL过期或其他原因变成死信后，它会被发送到配置的死信交换机，进而路由到一个或多个指定的队列</li>
<li><strong>消费死信队列中的消息</strong>：<strong>设置消费者监听死信队列，一旦消息因TTL过期被路由到死信队列，消费者即可进行处理</strong></li>
</ul>
</li>
</ul>
<h3 id="7-2-整合-SpringBoot"><a href="#7-2-整合-SpringBoot" class="headerlink" title="7.2 整合 SpringBoot"></a>7.2 整合 SpringBoot</h3><h4 id="7-2-1-创建项目"><a href="#7-2-1-创建项目" class="headerlink" title="7.2.1 创建项目"></a>7.2.1 创建项目</h4><p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/image-20240407190827899.png" alt="image-20240407190827899"> </p>
<p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/image-20240407190945485.png" alt="image-20240407190945485"></p>
<p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/image-20240407191045720.png" alt="image-20240407191045720"></p>
<h4 id="7-2-2-RabbitMQ-依赖"><a href="#7-2-2-RabbitMQ-依赖" class="headerlink" title="7.2.2 RabbitMQ 依赖"></a>7.2.2 RabbitMQ 依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--RabbitMQ 依赖--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.47<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--RabbitMQ 测试依赖--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.amqp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-rabbit-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--swagger--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="7-2-3-修改配置文件"><a href="#7-2-3-修改配置文件" class="headerlink" title="7.2.3 修改配置文件"></a>7.2.3 修改配置文件</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">xxx.xx.xx.xxx</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">admin</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123</span></span><br></pre></td></tr></table></figure>

<h4 id="7-2-4-添加-Swagger-配置类"><a href="#7-2-4-添加-Swagger-配置类" class="headerlink" title="7.2.4 添加 Swagger 配置类"></a>7.2.4 添加 Swagger 配置类</h4><ul>
<li><code>config/SwaggerConfig.java</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SwaggerConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Docket <span class="title function_">webApiConfig</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Docket</span>(DocumentationType.SWAGGER_2)</span><br><span class="line">            .groupName(<span class="string">&quot;webApi&quot;</span>)</span><br><span class="line">            .apiInfo(webApiInfo())</span><br><span class="line">            .select()</span><br><span class="line">            .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ApiInfo <span class="title function_">webApiInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ApiInfoBuilder</span>()</span><br><span class="line">            .title(<span class="string">&quot;rabbitmq 接口文档&quot;</span>)</span><br><span class="line">            .description(<span class="string">&quot;本文档描述了 rabbitmq 微服务接口定义&quot;</span>)</span><br><span class="line">            .version(<span class="string">&quot;1.0&quot;</span>)</span><br><span class="line">            .contact(<span class="keyword">new</span> <span class="title class_">Contact</span>(<span class="string">&quot;thr&quot;</span>, <span class="string">&quot;http://thr.com&quot;</span>,</span><br><span class="line">                                 <span class="string">&quot;hhh@qq.com&quot;</span>))</span><br><span class="line">            .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-3-RabbitMQ-中的-TTL"><a href="#7-3-RabbitMQ-中的-TTL" class="headerlink" title="7.3 RabbitMQ 中的 TTL"></a>7.3 RabbitMQ 中的 TTL</h3><ul>
<li><p>RabbitMQ中的TTL（Time-To-Live，生存时间）是<strong>指消息或队列中所有消息的最大存活时间</strong>，单位为毫秒</p>
<ul>
<li>这个特性允许消息在一定时间内未被消费则自动过期，过期的消息会变成死信（Dead Letter）。<strong>通过利用TTL和死信队列，我们可以在RabbitMQ中实现延迟队列的功能</strong></li>
</ul>
</li>
<li><p><strong>设置TTL的两种方式</strong>：</p>
<ul>
<li><strong>消息级别的TTL</strong>：可以为每条消息单独设置TTL。这种方式提供了灵活性，允许不同的消息有不同的生存时间。</li>
<li><strong>队列级别的TTL</strong>：在创建队列时，通过设置<code>x-message-ttl</code>属性为整个队列中的所有消息指定统一的TTL。队列级别的TTL<strong>适用于那些消息生存时间一致的场景</strong></li>
</ul>
</li>
<li><p><strong>两种方式的区别</strong>：</p>
<ul>
<li><strong>过期处理</strong>：<ul>
<li>如果设置了<strong>队列级TTL，一旦消息过期，就会被队列自动丢弃</strong>（如果配置了死信交换机，则被发送到死信队列）</li>
<li>而对于<strong>消息级别的TTL，消息是否过期是在消息即将被消费之前判定的</strong>。这意味着，如果队列中有大量积压的消息，即使某些消息已经过期，它们也可能会在队列中存活更长的时间，<strong>直到接近被消费时才被丢弃</strong></li>
</ul>
</li>
<li><strong>立即过期的消息</strong>：如果将TTL设置为0，表示这些消息除非能够立即被消费，否则将被立即丢弃</li>
</ul>
</li>
<li><p><strong>实现延迟队列</strong>：</p>
<ul>
<li><strong>配置死信交换机</strong>：为需要实现延迟的队列配置死信交换机（DLX），并指定死信路由键。</li>
<li><strong>设置TTL</strong>：根据需要，为队列或消息设置TTL。当消息在队列中存活时间超过TTL后，它会变成死信。</li>
<li><strong>死信转移</strong>：变成死信后的消息会被自动发送到绑定到死信交换机的队列（即死信队列）中。</li>
<li><strong>消费死信队列</strong>：消费者监听死信队列，处理到期的延迟消息。这样，消息在延迟特定时间后才被消费，实现了延迟队列的功能。</li>
</ul>
</li>
</ul>
<h3 id="7-4-队列-TTL"><a href="#7-4-队列-TTL" class="headerlink" title="7.4 队列 TTL"></a>7.4 队列 TTL</h3><h4 id="7-4-1-案例"><a href="#7-4-1-案例" class="headerlink" title="7.4.1 案例"></a>7.4.1 案例</h4><p>创建两个队列 QA 和 QB，两者队列 TTL 分别设置为 10S 和 40S，然后在创建一个交换机 X 和死信交换机 Y，它们的类型都是 direct，创建一个死信队列 QD，它们的绑定关系如下：</p>
<p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/image-20240407195336713.png" alt="image-20240407195336713"></p>
<blockquote>
<p>需要声明 2 个交换机 X 和 Y(死信)，以及 3 个队列 QA、QB、QD(死信)，绑定 QA 和 QB 到 X 和 Y 上</p>
</blockquote>
<h4 id="7-4-2-配置文件类代码"><a href="#7-4-2-配置文件类代码" class="headerlink" title="7.4.2 配置文件类代码"></a>7.4.2 配置文件类代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * TTL 队列 配置文件类代码</span></span><br><span class="line"><span class="comment"> * 需要声明 2 个交换机 X 和 Y(死信), 以及 3 个队列 QA、QB、QD(死信)</span></span><br><span class="line"><span class="comment"> * 绑定 QA 和 QB 到 X 和 Y 上</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TtlQueueConfig</span> &#123;</span><br><span class="line">    <span class="comment">// 普通交换机和普通队列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">X_EXCHANGE</span> <span class="operator">=</span> <span class="string">&quot;X&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_A</span> <span class="operator">=</span> <span class="string">&quot;QA&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_B</span> <span class="operator">=</span> <span class="string">&quot;QB&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 死信交换机和死信队列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">Y_DEAD_LETTER_EXCHANGE</span> <span class="operator">=</span> <span class="string">&quot;Y&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEAD_LETTER_QUEUE</span> <span class="operator">=</span> <span class="string">&quot;QD&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册两个直接交换机的 bean, 使得其他组件如消息生产者和消费者可以通过自动装配机制使用这些交换机</span></span><br><span class="line">    <span class="comment">// 声明 X 交换机, bean 名称在注入的时候有用</span></span><br><span class="line">    <span class="meta">@Bean(&quot;xExchange&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> DirectExchange <span class="title function_">xExchange</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DirectExchange</span>(X_EXCHANGE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明 xExchange</span></span><br><span class="line">    <span class="meta">@Bean(&quot;yExchange&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> DirectExchange <span class="title function_">yExchange</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DirectExchange</span>(Y_DEAD_LETTER_EXCHANGE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明队列 A ttl 为 10s 并绑定到对应的死信交换机</span></span><br><span class="line">    <span class="meta">@Bean(&quot;queueA&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">queueA</span><span class="params">()</span> &#123;</span><br><span class="line">        Map&lt;String, Object&gt; args = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">// 声明当前队列绑定的死信交换机</span></span><br><span class="line">        args.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, Y_DEAD_LETTER_EXCHANGE);</span><br><span class="line">        <span class="comment">// 声明当前队列的死信路由 key</span></span><br><span class="line">        args.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>, <span class="string">&quot;YD&quot;</span>);</span><br><span class="line">        <span class="comment">// 声明队列的 TTL</span></span><br><span class="line">        args.put(<span class="string">&quot;x-message-ttl&quot;</span>, <span class="number">10000</span>);</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(QUEUE_A).withArguments(args).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明队列 A 绑定 X 交换机</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">queueABindingX</span><span class="params">(<span class="meta">@Qualifier(&quot;queueA&quot;)</span> Queue queueA,</span></span><br><span class="line"><span class="params">                                  <span class="meta">@Qualifier(&quot;xExchange&quot;)</span> DirectExchange xExchange)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queueA).to(xExchange).with(<span class="string">&quot;XA&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明队列 B ttl 为 40s 并绑定到对应的死信交换机</span></span><br><span class="line">    <span class="meta">@Bean(&quot;queueB&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">queueB</span><span class="params">()</span> &#123;</span><br><span class="line">        Map&lt;String, Object&gt; args = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">// 声明当前队列绑定的死信交换机</span></span><br><span class="line">        args.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, Y_DEAD_LETTER_EXCHANGE);</span><br><span class="line">        <span class="comment">// 声明当前队列的死信路由 key</span></span><br><span class="line">        args.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>, <span class="string">&quot;YD&quot;</span>);</span><br><span class="line">        <span class="comment">// 声明队列的 TTL</span></span><br><span class="line">        args.put(<span class="string">&quot;x-message-ttl&quot;</span>, <span class="number">40000</span>);</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(QUEUE_B).withArguments(args).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明队列 B 绑定 X 交换机</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">queueBBindingX</span><span class="params">(<span class="meta">@Qualifier(&quot;queueB&quot;)</span> Queue queue1B,</span></span><br><span class="line"><span class="params">                                  <span class="meta">@Qualifier(&quot;xExchange&quot;)</span> DirectExchange xExchange)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue1B).to(xExchange).with(<span class="string">&quot;XB&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明死信队列 QD</span></span><br><span class="line">    <span class="meta">@Bean(&quot;queueD&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">queueD</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(DEAD_LETTER_QUEUE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明死信队列 QD 绑定关系</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">deadLetterBindingQDY</span><span class="params">(<span class="meta">@Qualifier(&quot;queueD&quot;)</span> Queue queueD,</span></span><br><span class="line"><span class="params">                                        <span class="meta">@Qualifier(&quot;yExchange&quot;)</span> DirectExchange yExchange)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queueD).to(yExchange).with(<span class="string">&quot;YD&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="7-4-3-消息生产者代码"><a href="#7-4-3-消息生产者代码" class="headerlink" title="7.4.3 消息生产者代码"></a>7.4.3 消息生产者代码</h4><ul>
<li><code>controller/SendMsgController</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 发送延迟消息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/ttl&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SendMsgController</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发消息</span></span><br><span class="line"><span class="comment">     * http://localhost:8080/ttl/sendMsg?msg=hhh</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msg 消息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/sendMsg&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMsg</span><span class="params">(<span class="meta">@RequestParam</span> String msg)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;当前时间: &#123;&#125;, 发送一条信息给两个 TTL 队列: &#123;&#125;&quot;</span>,</span><br><span class="line">                 <span class="keyword">new</span> <span class="title class_">Date</span>().toString(), msg);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送消息, 指定交换机和绑定键以及消息内容</span></span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">&quot;X&quot;</span>, <span class="string">&quot;XA&quot;</span>, <span class="string">&quot;消息来自 ttl 为 10s&quot;</span> + msg);</span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">&quot;X&quot;</span>, <span class="string">&quot;XB&quot;</span>, <span class="string">&quot;消息来自 ttl 为 40s&quot;</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="7-4-4-消息消费者代码"><a href="#7-4-4-消息消费者代码" class="headerlink" title="7.4.4 消息消费者代码"></a>7.4.4 消息消费者代码</h4><ul>
<li><code>consumer/DeadLetterQueueConsumer</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 队列 TTL 消费者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadLetterQueueConsumer</span> &#123;</span><br><span class="line">    <span class="comment">// 接受消息(监听)</span></span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;QD&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveD</span><span class="params">(Message message, Channel channel)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody());  <span class="comment">// 获取消息体</span></span><br><span class="line">        log.info(<span class="string">&quot;当前时间: &#123;&#125;, 收到死信队列的消息: &#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>().toString(), msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="7-4-5-启动测试"><a href="#7-4-5-启动测试" class="headerlink" title="7.4.5 启动测试"></a>7.4.5 启动测试</h4><ul>
<li><strong>报错</strong>：SpringBoot 项目集成了 springfox。将SpringBoot更新到2.6.0后，应用程序无法启动并抛出异常</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.context.ApplicationContextException: Failed to start bean &#x27;documentationPluginsBootstrapper&#x27;; nested exception is java.lang.NullPointerException</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>解决</strong>：除了将 SpringBoot 降级到 2.5.7 外，还可以在 yaml 文件里添加配置如下：</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">mvc:</span></span><br><span class="line">    <span class="attr">pathmatch:</span></span><br><span class="line">      <span class="attr">matching-strategy:</span> <span class="string">ANT_PATH_MATCHER</span></span><br></pre></td></tr></table></figure>

<ul>
<li>访问：<code>http://localhost:8080/ttl/sendMsg?msg=hhh</code> 即可，过一段时间就能从死信队列里获取到消息<ul>
<li>第一条消息在 10S 后变成了死信消息，然后被消费者消费掉，第二条消息在 40S 之后变成了死信消息，然后被消费掉，这样一个延时队列就打造完成了</li>
</ul>
</li>
</ul>
<p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/image-20240407205712499.png" alt="image-20240407205712499"></p>
<h3 id="7-5-延迟队列优化"><a href="#7-5-延迟队列优化" class="headerlink" title="7.5 延迟队列优化"></a>7.5 延迟队列优化</h3><blockquote>
<p>如果像 7.4 这样使用，则<strong>每增加一个新的时间需求，就要新增一个队列</strong>，这里只有 10S 和 40S 两个时间选项，如果需要一个小时后处理，那么就需要增加 TTL 为一个小时的队列，如果是预定会议室然后提前通知这样的场景，岂不是要增加无数个队列才能满足需求？</p>
</blockquote>
<h4 id="7-5-1-优化案例"><a href="#7-5-1-优化案例" class="headerlink" title="7.5.1 优化案例"></a>7.5.1 优化案例</h4><blockquote>
<p>允许生产者在发送每条消息时动态指定延迟时间。消息在延迟期满后才会被路由到绑定的队列中，消费者随后可以处理这些消息</p>
</blockquote>
<ul>
<li>在 7.4.1 的基础上<strong>新增一个队列 QC</strong>，绑定关系如下，该队列<strong>不设置 TTL 时间</strong></li>
</ul>
<p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/image-20240407210828320.png" alt="image-20240407210828320"></p>
<h4 id="7-5-2-配置文件类代码"><a href="#7-5-2-配置文件类代码" class="headerlink" title="7.5.2 配置文件类代码"></a>7.5.2 配置文件类代码</h4><ul>
<li>增加 QC</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TtlQueueConfig</span> &#123;</span><br><span class="line">    <span class="comment">// 新增普通队列 QC</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_C</span> <span class="operator">=</span> <span class="string">&quot;QC&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明队列 C 并绑定到对应的死信交换机</span></span><br><span class="line">    <span class="meta">@Bean(&quot;queueC&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">queueC</span><span class="params">()</span> &#123;</span><br><span class="line">        Map&lt;String, Object&gt; args = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">// 声明当前队列绑定的死信交换机</span></span><br><span class="line">        args.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, Y_DEAD_LETTER_EXCHANGE);</span><br><span class="line">        <span class="comment">// 声明当前队列的死信路由 key</span></span><br><span class="line">        args.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>, <span class="string">&quot;YD&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(QUEUE_A).withArguments(args).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明队列 C 绑定 X 交换机</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">queueCBindingX</span><span class="params">(<span class="meta">@Qualifier(&quot;queueC&quot;)</span> Queue queueC,</span></span><br><span class="line"><span class="params">                                  <span class="meta">@Qualifier(&quot;xExchange&quot;)</span> DirectExchange xExchange)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queueC).to(xExchange).with(<span class="string">&quot;XC&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="7-5-3-消息生产者代码"><a href="#7-5-3-消息生产者代码" class="headerlink" title="7.5.3 消息生产者代码"></a>7.5.3 消息生产者代码</h4><ul>
<li><code>convertAndSend</code>方法的最后一个参数是一个<code>MessagePostProcessor</code>，它允许在消息发送前修改消息<ul>
<li>在这个<code>MessagePostProcessor</code>内部，可以设置消息的TTL为<code>ttlTime</code>，消息就会带有一个TTL属性，并且如果消息在TTL时间内未被消费，它将成为死信（前提是配置了相应的死信交换机和队列）</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发消息, 设置 TTL</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/sendExpirationMsg&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMsg</span><span class="params">(<span class="meta">@RequestParam</span> String msg, <span class="meta">@RequestParam</span> String ttlTime)</span> &#123;</span><br><span class="line">    log.info(<span class="string">&quot;当前时间: &#123;&#125;, 发送一条时长 &#123;&#125; 毫秒 TTL 信息给队列 QC: &#123;&#125;&quot;</span>,</span><br><span class="line">             <span class="keyword">new</span> <span class="title class_">Date</span>().toString(), ttlTime, msg);</span><br><span class="line"></span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="string">&quot;X&quot;</span>, <span class="string">&quot;XC&quot;</span>, msg, message -&gt; &#123;</span><br><span class="line">        <span class="comment">// 设置发送消息的延迟时长</span></span><br><span class="line">        message.getMessageProperties().setExpiration(ttlTime);</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="7-5-4-启动测试"><a href="#7-5-4-启动测试" class="headerlink" title="7.5.4 启动测试"></a>7.5.4 启动测试</h4><ul>
<li><code>http://localhost:8080/sendExpirationMsg?msg=hello&amp;ttlTime=10000</code></li>
</ul>
<p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/image-20240407213653456.png" alt="image-20240407213653456"></p>
<h4 id="7-5-6-存在问题-基于死信的延迟队列"><a href="#7-5-6-存在问题-基于死信的延迟队列" class="headerlink" title="7.5.6 存在问题(基于死信的延迟队列)"></a>7.5.6 存在问题(基于死信的延迟队列)</h4><ul>
<li>如果使用在消息属性上设置 TTL 的方式，<strong>消息可能并不会按时“死亡“</strong>，因为 <strong>RabbitMQ</strong> <strong>只会检查第一个消息是否过期</strong>，如果过期则丢到死信队列，<strong>如果第一个消息的延时时长很长，而第二个消息的延时时长很短，第二个消息并不会优先得到执行</strong></li>
<li><strong>RabbitMQ的TTL检查机制</strong>：RabbitMQ 在处理带有 TTL 的消息时，只会检查队列头部（即第一个消息）是否已经过期。如果头部的消息还没有到达它的 TTL，那么 RabbitMQ 不会继续检查后面的消息。这意味着，只有当头部消息过期并被移除后，RabbitMQ 才会检查下一个消息是否过期</li>
</ul>
<p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/image-20240407222340941.png" alt="image-20240407222340941"></p>
<ul>
<li>使用死信队列实现延迟队列时，需要通过消息TTL和死信交换机配置，消息到期后转入死信队列，存在检查顺序限制，可能导致消息延迟处理<ul>
<li>而使用延迟消息交换机插件，可直接在消息上设置延迟时间，插件负责延时后递送，操作更直接灵活，无需死信队列间接实现，解决了消息延迟处理的顺序问题</li>
</ul>
</li>
</ul>
<h3 id="7-6-RabbitMQ-插件实现延迟队列"><a href="#7-6-RabbitMQ-插件实现延迟队列" class="headerlink" title="7.6 RabbitMQ 插件实现延迟队列"></a>7.6 RabbitMQ 插件实现延迟队列</h3><p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/image-20240407222601585.png" alt="image-20240407222601585"></p>
<h4 id="7-6-1-安装延时队列插件"><a href="#7-6-1-安装延时队列插件" class="headerlink" title="7.6.1 安装延时队列插件"></a>7.6.1 安装延时队列插件</h4><ul>
<li><strong>官网</strong>：<a target="_blank" rel="noopener" href="https://www.rabbitmq.com/community-plugins">https://www.rabbitmq.com/community-plugins</a></li>
<li><strong>下载</strong>：<a target="_blank" rel="noopener" href="https://github.com/rabbitmq/rabbitmq-delayed-message-exchange/releases">https://github.com/rabbitmq/rabbitmq-delayed-message-exchange/releases</a><ul>
<li>我载了 3.8.9 版本的到云服务器的 opt 目录下，发现自己已经有 3.8.0 版本了，不慌，直接用 3.8.9 试下（官网说 3.8.9 已经替代 3.8.x 了）</li>
</ul>
</li>
<li>下载 <strong>rabbitmq_delayed_message_exchange</strong> 插件，解压放到 RabbitMQ 的插件目录</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp rabbitmq_delayed_message_exchange-3.8.9-0199d11c.ez /usr/lib/rabbitmq/lib/rabbitmq_server-3.8.8/plugins</span><br></pre></td></tr></table></figure>

<p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/image-20240407220927691.png" alt="image-20240407220927691"></p>
<ul>
<li>进入 RabbitMQ 的安装目录下的 plgins 目录，执行命令让该<strong>插件生效</strong></li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/lib/rabbitmq/lib/rabbitmq_server-3.8.8/plugins</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">插件生效</span></span><br><span class="line">rabbitmq-plugins enable rabbitmq_delayed_message_exchange</span><br></pre></td></tr></table></figure>

<p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/image-20240407221120860.png" alt="image-20240407221120860"></p>
<ul>
<li><strong>重启 RabbitMQ</strong>：</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart rabbitmq-server.service</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>验证</strong>：安装成功后，web 页面新增交换机，类型会多一个延迟消息的选项，由交换机来延迟</li>
</ul>
<p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/image-20240407221525820.png" alt="image-20240407221525820"></p>
<h4 id="7-6-2-案例"><a href="#7-6-2-案例" class="headerlink" title="7.6.2 案例"></a>7.6.2 案例</h4><blockquote>
<p>安装了延迟消息交换机插件后，就可以直接使用这个插件来实现消息的延迟发送，而不再需要通过死信队列的方式来实现延迟队列了</p>
</blockquote>
<p>新增一个队列 delayed.queue，一个自定义交换机 delayed.exchange，绑定关系如下：</p>
<ul>
<li>生产者 -&gt; 延迟交换机 -&gt; 普通队列 -&gt; 消费者</li>
</ul>
<p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/image-20240407222649600.png" alt="image-20240407222649600"></p>
<h4 id="7-6-3-配置文件类代码"><a href="#7-6-3-配置文件类代码" class="headerlink" title="7.6.3 配置文件类代码"></a>7.6.3 配置文件类代码</h4><ul>
<li>需要声明交换机、队列以及它们之间的绑定键<ul>
<li>在<strong>声明交换机的时候，设置交换机是延迟类型的</strong></li>
<li><code>@Qualifier</code>注解用于指定自动装配（autowiring）时应注入哪个具体的bean，当有多个相同类型的bean可供选择时，<code>@Qualifier(&quot;beanName&quot;)</code>可以帮助指定注入哪一个</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DelayedQueueConfig</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DELAYED_QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;delayed.queue&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DELAYED_EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;delayed.exchange&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DELAYED_ROUTING_KEY</span> <span class="operator">=</span> <span class="string">&quot;delayed.routingkey&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明队列</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">delayedQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(DELAYED_QUEUE_NAME);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明自定义交换机 这里定义的是一个延迟交换机</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> CustomExchange <span class="title function_">delayedExchange</span><span class="params">()</span> &#123;</span><br><span class="line">        Map&lt;String, Object&gt; args = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 自定义交换机的类型</span></span><br><span class="line">        args.put(<span class="string">&quot;x-delayed-type&quot;</span>, <span class="string">&quot;direct&quot;</span>);</span><br><span class="line">        <span class="comment">// 参数: 名称、类型、持久化标识、自动删除标识、参数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CustomExchange</span>(DELAYED_EXCHANGE_NAME, <span class="string">&quot;x-delayed-message&quot;</span>,</span><br><span class="line">                                  <span class="literal">true</span>, <span class="literal">false</span>, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingDelayedQueue</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="meta">@Qualifier(&quot;delayedQueue&quot;)</span> Queue queue,</span></span><br><span class="line"><span class="params">        <span class="meta">@Qualifier(&quot;delayedExchange&quot;)</span> CustomExchange</span></span><br><span class="line"><span class="params">        delayedExchange)</span> &#123;  <span class="comment">// 这里@Qualifier()中就是方法名(默认的自定义名), 指定自动装配时应注入哪个具体的 bean</span></span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue).to(delayedExchange)</span><br><span class="line">            .with(DELAYED_ROUTING_KEY).noargs();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="7-6-4-消息生产者代码"><a href="#7-6-4-消息生产者代码" class="headerlink" title="7.6.4 消息生产者代码"></a>7.6.4 消息生产者代码</h4><ul>
<li><strong>延迟时间</strong> <code>delayTime</code>：是指消息从被发送到实际被投递到目标队列之间的等待时间</li>
<li><strong>存活时间</strong> <code>TTL</code>：是指消息一旦到达目标队列后能在队列中存活的最大时间如果消息在这段TTL时间内没有被消费，那么它会被移除或转移到死信队列</li>
</ul>
<p>简而言之，延迟时间控制消息发送到队列的延迟，而TTL控制消息在队列中的存活时间。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 发消息, 基于插件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> msg  消息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> delayTime 延迟时间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/sendDelayMsg&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMsg</span><span class="params">(<span class="meta">@RequestParam</span> String msg, <span class="meta">@RequestParam</span> Integer delayTime)</span> &#123;</span><br><span class="line">    log.info(<span class="string">&quot;当前时间: &#123;&#125;, 发送一条时长 &#123;&#125; 毫秒 信息给延迟队列 QC: &#123;&#125;&quot;</span>,</span><br><span class="line">             <span class="keyword">new</span> <span class="title class_">Date</span>().toString(), delayTime, msg);</span><br><span class="line"></span><br><span class="line">    rabbitTemplate.convertAndSend(DelayedQueueConfig.DELAYED_EXCHANGE_NAME,</span><br><span class="line">                                  DelayedQueueConfig.DELAYED_ROUTING_KEY, msg, message -&gt; &#123;</span><br><span class="line">                                      <span class="comment">// 设置发送消息的延迟时长</span></span><br><span class="line">                                      message.getMessageProperties().setDelay(delayTime);</span><br><span class="line">                                      <span class="keyword">return</span> message;</span><br><span class="line">                                  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="7-6-5-消息消费者代码"><a href="#7-6-5-消息消费者代码" class="headerlink" title="7.6.5 消息消费者代码"></a>7.6.5 消息消费者代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 消息消费者</span></span><br><span class="line"><span class="comment"> * 基于插件的延迟队列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DelayQueueConsumer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DELAYED_QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;delayed.queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编写 rabbit 监听类</span></span><br><span class="line">    <span class="meta">@RabbitListener(queues = DELAYED_QUEUE_NAME)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveDelayedQueue</span><span class="params">(Message message)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody());</span><br><span class="line">        log.info(<span class="string">&quot;当前时间：&#123;&#125;,收到延时队列的消息：&#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>().toString(), msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="7-6-6-测试"><a href="#7-6-6-测试" class="headerlink" title="7.6.6 测试"></a>7.6.6 测试</h4><ul>
<li><code>http://localhost:8080/ttl/sendDelayMsg?msg=hhh&amp;delayTime=20000</code></li>
<li><code>http://localhost:8080/ttl/sendDelayMsg?msg=eee&amp;delayTime=2000</code></li>
</ul>
<p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/image-20240408222411992.png" alt="image-20240408222411992"></p>
<h3 id="7-7-总结"><a href="#7-7-总结" class="headerlink" title="7.7 总结"></a>7.7 总结</h3><ul>
<li>延时队列在需要延时处理的场景下非常有用，使用 RabbitMQ 来实现延时队列可以很好的利用 RabbitMQ 的特性，如：消息可靠发送、消息可靠投递、<strong>死信队列来保障消息至少被消费一次以及未被正确处理的消息不会被丢弃</strong>。另外，通过 RabbitMQ 集群的特性，可以很好的解决单点故障问题，不会因为单个节点挂掉导致延时队列不可用或者消息丢失</li>
<li>延时队列还有很多其它选择，比如利用 Java 的 DelayQueue，利用 Redis 的 zset，利用 Quartz 或者利用 kafka 的时间轮，这些方式各有特点，看需要适用的场景</li>
</ul>
<p>延迟队列在RabbitMQ中可以通过两种主要方式实现：基于死信队列和基于插件。</p>
<ul>
<li><strong>基于死信队列</strong>：通过设置消息的TTL或队列长度限制，使<strong>消息在条件触发时转入死信队列</strong>，从而实现延迟效果。这种方法依赖于消息到期或队列状态改变，需要额外配置死信交换机和队列。</li>
<li><strong>基于插件</strong>：使用RabbitMQ的延迟消息交换机插件，直接在消息属性上设置延迟时间，使<strong>消息在指定时间后才被路由到目标队列</strong>。这种方式更直接，不依赖TTL导致的间接转移，适合需要精确控制延迟时间的场景。</li>
</ul>
<p>消息延迟的实现机制和处理顺序的影响：</p>
<ul>
<li><strong>基于死信队列</strong>：RabbitMQ只检查队列头部的消息是否过期。如果头部消息没有过期，即使后续消息已经到了过期时间，也不会被立即处理，直到它们移动到队列头部。这就可能导致即使设置了不同的TTL，消息处理也会受到队列头部消息状态的影响。</li>
<li><strong>基于插件</strong>：<strong>每条消息的延迟是独立处理的，当消息的延迟时间到了，它就会被立即投递，不受队列中其他消息状态的影响</strong>。这样，即使后续消息的延迟时间较短，也能按预期时间被处理，不会因为队列中其他消息的状态而延误。</li>
</ul>
<h2 id="8-发布确认高级"><a href="#8-发布确认高级" class="headerlink" title="8. 发布确认高级"></a>8. 发布确认高级</h2><p>从 3.3.3 处埋的坑，之前 4.发布确认 中，发送消息后，生产者等待来自RabbitMQ服务器的确认，但是如果服务器宕机了呢？</p>
<blockquote>
<p>之前我们的前提是假设RabbitMQ服务器是可达的，能够接收消息并返回确认或否认，如果RabbitMQ服务器不可用，生产者尝试发送的消息将无法到达RabbitMQ，这时候就需要一个额外的机制来确保消息不会丢失</p>
</blockquote>
<ul>
<li><p>在生产环境中由于一些不明原因，导致 RabbitMQ 重启，<strong>在 RabbitMQ 重启期间生产者消息投递失败，导致消息丢失，需要手动处理和恢复</strong></p>
</li>
<li><p>如何才能进行 RabbitMQ 的消息可靠投递呢？特别是在这样比较极端的情况，RabbitMQ 集群不可用的时候，无法投递的消息该如何处理呢？</p>
</li>
</ul>
<h3 id="8-1-发布确认-SpringBoot-版本"><a href="#8-1-发布确认-SpringBoot-版本" class="headerlink" title="8.1 发布确认 SpringBoot 版本"></a>8.1 发布确认 SpringBoot 版本</h3><p>考虑两种情况：</p>
<ul>
<li><strong>交换机接收不到消息</strong>：这种情况通常发生在消息从生产者发送到 RabbitMQ 时，由于RabbitMQ服务器宕机、网络问题或其他原因导致消息无法到达交换机。</li>
<li><strong>队列接收不到消息</strong>：即使消息成功到达了交换机，但因为某些原因（如队列不存在，或者路由规则导致消息无法路由到任何队列）消息不能被正确路由到目标队列。</li>
</ul>
<blockquote>
<p>8.1.6 将分析第一种情况</p>
<p>8.2 将分析第二种情况</p>
</blockquote>
<h4 id="8-1-1-确认机制方案"><a href="#8-1-1-确认机制方案" class="headerlink" title="8.1.1 确认机制方案"></a>8.1.1 确认机制方案</h4><ul>
<li>在生产者端实现一个消息缓存机制，来暂存那些因RabbitMQ不可用而无法发送的消息</li>
<li>生产者发送消息到直接交换机，一旦 mq 宕机了，或者生产者接收不到消息了，需要对消息进行缓存处理</li>
</ul>
<p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/image-20240409213649226.png" alt="image-20240409213649226"></p>
<h4 id="8-1-2-示例"><a href="#8-1-2-示例" class="headerlink" title="8.1.2 示例"></a>8.1.2 示例</h4><ul>
<li>用 SpringBoot 实现 4.发布确认 的代码</li>
</ul>
<p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/image-20240409214011083.png" alt="image-20240409214011083"></p>
<h4 id="8-1-3-配置文件和配置类"><a href="#8-1-3-配置文件和配置类" class="headerlink" title="8.1.3 配置文件和配置类"></a>8.1.3 配置文件和配置类</h4><ul>
<li><strong>配置文件添加一行</strong>：取值设置为 <code>correlated</code><ul>
<li>**<code>none</code>**：禁用发布确认机制。</li>
<li>**<code>correlated</code>**：启用发布确认，当需要明确知道每条消息是否成功到达RabbitMQ时使用。这种模式允许将每个消息的确认与其发送操作相关联，通过<code>CorrelationData</code>对象的使用，可以知道具体是哪条消息收到了确认或未被确认。</li>
<li>**<code>simple</code>**：启用发布确认，但不需要<code>CorrelationData</code>对象</li>
</ul>
</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">publisher-confirm-type:</span> <span class="string">correlated</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>配置交换机和队列</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfirmConfig</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">CONFIRM_EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;confirm.exchange&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">CONFIRM_QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;confirm.queue&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">CONFIRM_ROUTING_KEY</span> <span class="operator">=</span> <span class="string">&quot;key1&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明交换机</span></span><br><span class="line">    <span class="meta">@Bean(&quot;confirmExchange&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> DirectExchange <span class="title function_">confirmExchange</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DirectExchange</span>(CONFIRM_EXCHANGE_NAME);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明确认队列</span></span><br><span class="line">    <span class="meta">@Bean(&quot;confirmQueue&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">confirmQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(CONFIRM_QUEUE_NAME).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明确认队列绑定关系</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">queueBinding</span><span class="params">(<span class="meta">@Qualifier(&quot;confirmQueue&quot;)</span> Queue queue,</span></span><br><span class="line"><span class="params">                                <span class="meta">@Qualifier(&quot;confirmExchange&quot;)</span> DirectExchange exchange)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue).to(exchange).with(CONFIRM_ROUTING_KEY);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="8-1-4-消息生产者"><a href="#8-1-4-消息生产者" class="headerlink" title="8.1.4 消息生产者"></a>8.1.4 消息生产者</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/confirm&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProducerController</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/sendMsg&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMsg</span><span class="params">(<span class="meta">@RequestParam</span> String msg)</span> &#123;</span><br><span class="line">        <span class="comment">// 指定消息 id 为 1</span></span><br><span class="line">        <span class="type">CorrelationData</span> <span class="variable">correlationData1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CorrelationData</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        rabbitTemplate.convertAndSend(ConfirmConfig.CONFIRM_EXCHANGE_NAME,</span><br><span class="line">                                      ConfirmConfig.CONFIRM_ROUTING_KEY, msg + <span class="string">&quot;key1&quot;</span>, correlationData1);</span><br><span class="line">        log.info(<span class="string">&quot;发消息内容: &#123;&#125;&quot;</span>, msg + <span class="string">&quot;key1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 指定消息 id 为 2 ==&gt; 绑定键错误</span></span><br><span class="line">        <span class="type">CorrelationData</span> <span class="variable">correlationData2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CorrelationData</span>(<span class="string">&quot;2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        rabbitTemplate.convertAndSend(ConfirmConfig.CONFIRM_EXCHANGE_NAME,</span><br><span class="line">                                      ConfirmConfig.CONFIRM_ROUTING_KEY + <span class="string">&quot;2&quot;</span>, msg + <span class="string">&quot;key12&quot;</span>, correlationData2);</span><br><span class="line">        log.info(<span class="string">&quot;发消息内容: &#123;&#125;&quot;</span>, msg + <span class="string">&quot;key12&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="8-1-5-回调接口"><a href="#8-1-5-回调接口" class="headerlink" title="8.1.5 回调接口"></a>8.1.5 回调接口</h4><ul>
<li><p><strong>使用<code>@PostConstruct</code>进行初始化</strong></p>
<ul>
<li><p>使用<code>@PostConstruct</code>注解的<code>init</code>方法确保了只有在<code>MyCallBack</code>类实例化并<code>RabbitTemplate</code>注入完成后，才设置确认回调。这样可以避免在<code>RabbitTemplate</code>完全配置前误调用回调方法的风险</p>
</li>
<li><p><code>setConfirmCallback(this)</code>的调用设置了当前实例（<code>MyCallBack</code>）作为消息确认的回调处理器。这意味着每当消息被发送到RabbitMQ服务器，并且服务器对消息进行了处理（无论是接受还是拒绝），都会调用实例的<code>confirm</code>方法。</p>
</li>
</ul>
</li>
<li><p><code>CorrelationData</code>  对象是在发送消息时由消息生产者创建并传递的</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCallBack</span> <span class="keyword">implements</span> <span class="title class_">RabbitTemplate</span>.ConfirmCallback &#123;</span><br><span class="line">    <span class="comment">// 注入</span></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类内部接口, 容器内也要有内部接口的实例</span></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        rabbitTemplate.setConfirmCallback(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交换机确认回调方法</span></span><br><span class="line"><span class="comment">     * 发消息 交换机接收到了 回调</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> correlationData 保存回调消息的 ID 及相关信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ack             交换机收到消息 =&gt; true, 没收到 =&gt; false</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cause           成功没有原因 null, 失败就是失败的原因</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">confirm</span><span class="params">(CorrelationData correlationData, <span class="type">boolean</span> ack, String cause)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> correlationData != <span class="literal">null</span> ? correlationData.getId() : <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (ack) &#123;  <span class="comment">// 成功</span></span><br><span class="line">            log.info(<span class="string">&quot;交换机已经收到 id 为:&#123;&#125;的消息&quot;</span>, id);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 失败</span></span><br><span class="line">            log.info(<span class="string">&quot;交换机还未收到 id 为:&#123;&#125;消息,由于原因:&#123;&#125;&quot;</span>, id, cause);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="8-1-5-消息消费者"><a href="#8-1-5-消息消费者" class="headerlink" title="8.1.5 消息消费者"></a>8.1.5 消息消费者</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer</span> &#123;</span><br><span class="line">    <span class="meta">@RabbitListener(queues = ConfirmConfig.CONFIRM_QUEUE_NAME)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveConfirmMsg</span><span class="params">(Message message)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody());</span><br><span class="line">        log.info(<span class="string">&quot;接受到队列 confirm.queue 消息: &#123;&#125;&quot;</span>, msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="8-1-6-测试"><a href="#8-1-6-测试" class="headerlink" title="8.1.6 测试"></a>8.1.6 测试</h4><ul>
<li><code>http://localhost:8080/confirm/sendMsg?msg=hhh</code></li>
</ul>
<p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/image-20240412135800282.png" alt="image-20240412135800282"></p>
<ul>
<li><strong>考虑到交换机接收不到消息</strong>的情况，测试下<ul>
<li>在生产者代码里修改交换机的名字为不存在的交换机，然后发送消息</li>
<li>可以看到会回显失败和失败的原因</li>
</ul>
</li>
</ul>
<p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/image-20240412141332905.png" alt="image-20240412141332905"></p>
<ul>
<li><strong>考虑到队列接收不到消息</strong>的情况，测试下<ul>
<li>在生产者代码里增加一个绑定键为错误的消息进行发送</li>
<li>可以看到<strong>接收不到失败的回调</strong>，消费者(队列)只收到了一个消息，另一个没收到，但是它也没有应答，也没有确认，因为底层默认把<strong>消息丢失</strong>了</li>
<li>具体解决看 8.2</li>
</ul>
</li>
</ul>
<p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/image-20240412141703506.png" alt="image-20240412141703506"></p>
<h3 id="8-2-回退消息"><a href="#8-2-回退消息" class="headerlink" title="8.2 回退消息"></a>8.2 回退消息</h3><p>在 RabbitMQ 中，当<strong>消息无法被路由到任何队列时（即没有匹配的绑定键）</strong>，默认情况下，这条消息会被交换机丢弃，而生产者不会得到任何通知。这种情况可能会导致数据丢失，特别是在生产者假设消息已成功发送的场景下</p>
<h4 id="8-2-1-Mandatory-参数"><a href="#8-2-1-Mandatory-参数" class="headerlink" title="8.2.1 Mandatory 参数"></a>8.2.1 Mandatory 参数</h4><p>当设置了<code>mandatory</code>参数后，如果消息在到达交换机后无法路由到任何队列，<strong>交换机不会静默丢弃这条消息。相反，消息会被返回给生产者</strong>。这个过程通常称为消息回退</p>
<h4 id="8-2-2-配置文件"><a href="#8-2-2-配置文件" class="headerlink" title="8.2.2 配置文件"></a>8.2.2 配置文件</h4><ul>
<li>在配置文件 yaml 里<strong>开启发布退回的配置</strong>：<ul>
<li><code>publisher-returns: true</code> 在Spring Boot配置中确实起到了类似AMQP的<code>mandatory</code>标志的作用</li>
<li>确保配置了<code>ReturnCallback</code>回调接口来处理退回的消息</li>
</ul>
</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">publisher-returns:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h4 id="8-2-3-回调接口"><a href="#8-2-3-回调接口" class="headerlink" title="8.2.3 回调接口"></a>8.2.3 回调接口</h4><ul>
<li>在 8.1.5 的回调接口代码上添加回退接口的实现：<code>RabbitTemplate.ReturnsCallback</code><ul>
<li>注意也要注入改接口</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">    rabbitTemplate.setConfirmCallback(<span class="built_in">this</span>);</span><br><span class="line">    rabbitTemplate.setReturnsCallback(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当消息无法路由到任何队列时调用</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> returned 封装了退回消息的详细信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">returnedMessage</span><span class="params">(ReturnedMessage returned)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(returned.getMessage().getBody());</span><br><span class="line"></span><br><span class="line">    log.error(<span class="string">&quot;消息 &#123;&#125; 被交换机 &#123;&#125; 退回, 退回原因: &#123;&#125;, 路由 key: &#123;&#125;&quot;</span>,</span><br><span class="line">              message,</span><br><span class="line">              returned.getExchange(),</span><br><span class="line">              returned.getReplyText(),</span><br><span class="line">              returned.getRoutingKey());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="8-2-4-测试"><a href="#8-2-4-测试" class="headerlink" title="8.2.4 测试"></a>8.2.4 测试</h4><ul>
<li>可以看到消息被回退了，还有回退的原因，保障即使消息发不到队列，消息也不丢失</li>
</ul>
<p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/image-20240412143809373.png" alt="image-20240412143809373"></p>
<h3 id="8-3-备份交换机"><a href="#8-3-备份交换机" class="headerlink" title="8.3 备份交换机"></a>8.3 备份交换机</h3><blockquote>
<p>前面在设置死信队列的部分提到可以为队列设置死信交换机来存储那些处理失败的消息，可是这些<strong>不可路由消息根本没有机会进入到队列，因此无法使用死信队列来保存消息</strong></p>
</blockquote>
<p><strong>备份交换机</strong>可以理解为某个主交换机的“备胎”。当一条消息发送到主交换机，但找不到任何合适的队列匹配时（即消息无法路由），这条消息将会被发送到配置的备份交换机。这样的机制确保消息在无法正常路由时不会被丢弃，而是有另一条路径可以走。</p>
<ul>
<li><p><strong>使用场景</strong>：</p>
<ul>
<li><p><strong>错误处理和日志记录</strong>：通过备份交换机，无法路由的消息可以被统一收集和记录，用于后续的错误处理或者生成警报。</p>
</li>
<li><p><strong>系统可靠性增强</strong>：在高可靠性需求的系统中，备份交换机提供了一个简单的方法来保证消息至少在某个地方被处理，即使它们无法被正常的业务逻辑处理。</p>
</li>
</ul>
</li>
<li><p>备份交换机通常设置为<code>Fanout</code>类型，这是因为<code>Fanout</code>交换机会将接收到的所有消息广播到所有绑定的队列，确保无法路由的消息不会丢失。下面是如何配置备份交换机的步骤：</p>
<ul>
<li><p><strong>声明备份交换机</strong>：首先，需要声明一个<code>Fanout</code>类型的备份交换机。</p>
</li>
<li><p><strong>配置主交换机</strong>：在声明主交换机时，设置一个额外的参数<code>alternate-exchange</code>，指向备份交换机。</p>
</li>
<li><p><strong>绑定队列</strong>：至少需要为备份交换机绑定一个队列，以确保从备份交换机接收消息。</p>
</li>
</ul>
</li>
</ul>
<h4 id="8-3-1-示例"><a href="#8-3-1-示例" class="headerlink" title="8.3.1 示例"></a>8.3.1 示例</h4><ul>
<li>增加备份交换机、备份队列和报警队列<ul>
<li>备份交换机设置为扇出类型，会广播消息到所有绑定的队列，可以实现备份和报警的功能</li>
</ul>
</li>
</ul>
<p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/image-20240412154643543.png" alt="image-20240412154643543"></p>
<h4 id="8-3-2-修改配置类"><a href="#8-3-2-修改配置类" class="headerlink" title="8.3.2 修改配置类"></a>8.3.2 修改配置类</h4><ul>
<li><strong>设置原先的确认交换机的备份交换机</strong></li>
<li><strong>增加扇出类型的备份交换机</strong>，并分别和备份队列以及报警队列进行绑定</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明直接交换机, 并声明它的备份交换机</span></span><br><span class="line"><span class="meta">@Bean(&quot;confirmExchange&quot;)</span></span><br><span class="line"><span class="keyword">public</span> DirectExchange <span class="title function_">confirmExchange</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ExchangeBuilder.directExchange(CONFIRM_EXCHANGE_NAME)</span><br><span class="line">        .durable(<span class="literal">true</span>)</span><br><span class="line">        .withArgument(<span class="string">&quot;alternate-exchange&quot;</span>, BACKUP_EXCHANGE_NAME)</span><br><span class="line">        .build();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 备份交换机-扇出类型的</span></span><br><span class="line"><span class="meta">@Bean(&quot;backupExchange&quot;)</span></span><br><span class="line"><span class="keyword">public</span> FanoutExchange <span class="title function_">backupExchange</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FanoutExchange</span>(BACKUP_EXCHANGE_NAME);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 备份队列</span></span><br><span class="line"><span class="meta">@Bean(&quot;backupQueue&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Queue <span class="title function_">backupQueue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> QueueBuilder.durable(BACKUP_QUEUE_NAME).build();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 备份队列</span></span><br><span class="line"><span class="meta">@Bean(&quot;warningQueue&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Queue <span class="title function_">warningQueue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> QueueBuilder.durable(WARNING_QUEUE_NAME).build();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 绑定</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Binding <span class="title function_">backupQueueBindingBackExchange</span><span class="params">(<span class="meta">@Qualifier(&quot;backupQueue&quot;)</span> Queue backupQueue,</span></span><br><span class="line"><span class="params">                                              <span class="meta">@Qualifier(&quot;backupExchange&quot;)</span> FanoutExchange backupExchange)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> BindingBuilder.bind(backupQueue).to(backupExchange);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Binding <span class="title function_">warningQueueBindingBackExchange</span><span class="params">(<span class="meta">@Qualifier(&quot;warningQueue&quot;)</span> Queue warningQueue,</span></span><br><span class="line"><span class="params">                                               <span class="meta">@Qualifier(&quot;backupExchange&quot;)</span> FanoutExchange backupExchange)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> BindingBuilder.bind(warningQueue).to(backupExchange);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="8-3-3-报警消费者"><a href="#8-3-3-报警消费者" class="headerlink" title="8.3.3 报警消费者"></a>8.3.3 报警消费者</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WarningConsumer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(queues = ConfirmConfig.WARNING_QUEUE_NAME)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveWarningMsg</span><span class="params">(Message message)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody());</span><br><span class="line">        log.error(<span class="string">&quot;报警发现不可路由消息：&#123;&#125;&quot;</span>, msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="8-3-4-测试"><a href="#8-3-4-测试" class="headerlink" title="8.3.4 测试"></a>8.3.4 测试</h4><ul>
<li>先在 web 界面删除之前的确认交换机，因为我们修改了其绑定属性，不然会报错</li>
</ul>
<p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/image-20240412161545389.png" alt="image-20240412161545389"></p>
<ul>
<li>从结果也可以说明，在我们<strong>同时设置了回退消息和备份交换机的两种机制下，备份交换机的优先级更高些</strong></li>
</ul>
<h2 id="9-其他知识点"><a href="#9-其他知识点" class="headerlink" title="9. 其他知识点"></a>9. 其他知识点</h2><h3 id="9-1-幂等性"><a href="#9-1-幂等性" class="headerlink" title="9.1 幂等性"></a>9.1 幂等性</h3><h4 id="9-1-1-概念"><a href="#9-1-1-概念" class="headerlink" title="9.1.1 概念"></a>9.1.1 概念</h4><p>幂等性意味着<strong>执行多次和执行一次的效果完全相同</strong>。在业务操作如支付中，用户可能因为网络延迟等问题多次点击支付按钮，导致多次扣款。确保操作的幂等性可以防止这种情况，即使操作多次执行，也只有一次有效果生效。</p>
<h4 id="9-1-2-消息重复消费"><a href="#9-1-2-消息重复消费" class="headerlink" title="9.1.2 消息重复消费"></a>9.1.2 消息重复消费</h4><p>消费者在消费 MQ 中的消息时，MQ 已把消息发送给消费者，消费者在给 MQ 返回 ack 时网络中断，故 MQ 未收到确认信息，该条消息会重新发给其他的消费者，或者在网络重连后再次发送给该消费者，但实际上该消费者已成功消费了该条消息，造成消费者消费了重复的消息。</p>
<h4 id="9-1-3-解决思路"><a href="#9-1-3-解决思路" class="headerlink" title="9.1.3 解决思路"></a>9.1.3 解决思路</h4><p>解决消息队列中的幂等性问题通常涉及到<strong>确保每条消息只被处理一次，即使它被多次接收</strong>。实现这一点的方法包括：</p>
<ul>
<li><strong>使用全局唯一ID</strong>：每条消息都有一个全局唯一标识，消费者处理消息前先检查该消息ID是否已被处理。</li>
<li><strong>时间戳、UUID或业务ID</strong>：使用这些唯一标识来标记每个消息或事务。</li>
</ul>
<h4 id="9-1-4-消费端的幂等性保障"><a href="#9-1-4-消费端的幂等性保障" class="headerlink" title="9.1.4 消费端的幂等性保障"></a>9.1.4 消费端的幂等性保障</h4><p>保障消息消费端的幂等性是通过确保每条消息只触发一次业务处理逻辑实现的。主流方法包括：</p>
<ul>
<li><strong>唯一ID + 指纹码机制</strong>：结合消息内容或特定字段（如时间戳、用户ID等）生成一个指纹码，通过数据库主键去重或查询来防止重复处理。<ul>
<li>指纹码通常是根据消息内容或业务场景特征生成的一个唯一标识符。这个机制的实现通常依赖于数据库的能力来快速检查和插入这些唯一标识，确保操作的原子性和唯一性。这种方法的优点是实现简单，缺点是在高并发场景下可能会遇到数据库性能瓶颈。</li>
</ul>
</li>
<li><strong>数据库事务和锁</strong>：利用数据库的事务和锁机制来确保操作只被成功执行一次。 &#x3D;&#x3D;&gt; 推荐<ul>
<li><strong>Redis的<code>SETNX</code>命令（</strong>set if not exists）提供了一个天然的<strong>原子操作，可以用来实现幂等性</strong>。这个命令只有在键不存在时才设置键的值，如果键已存在，命令不做任何操作。这样，可以利用Redis来记录每个消息或操作的唯一标识，并确保重复的消息或操作不会被处理。</li>
</ul>
</li>
</ul>
<h3 id="9-2-优先级队列"><a href="#9-2-优先级队列" class="headerlink" title="9.2 优先级队列"></a>9.2 优先级队列</h3><h4 id="9-2-1-使用场景"><a href="#9-2-1-使用场景" class="headerlink" title="9.2.1 使用场景"></a>9.2.1 使用场景</h4><ul>
<li><p><strong>场景</strong>：</p>
<ul>
<li><p>在电商平台中，例如天猫，订单支付提醒功能，即当用户在预定时间内未完成支付时，系统会自动发送提醒短信。</p>
</li>
<li><p>对于不同级别的商家，如苹果或小米（被认为是大客户），他们的订单应当被优先处理，因为这些客户为平台带来较高的利润。</p>
</li>
</ul>
</li>
<li><p><strong>问题</strong>：传统使用Redis实现的后端系统通过List结构支持的是基本的队列功能，无法处理复杂的优先级逻辑。当订单量大增时，需要一种机制来区分处理订单的优先级。</p>
</li>
<li><p><strong>解决方案</strong>：使用RabbitMQ的优先级队列功能来优化系统。这允许系统根据客户的重要性赋予订单不同的优先级，从而确保重要客户的订单可以得到更快的处理。</p>
</li>
</ul>
<h4 id="9-2-2-如何添加优先级"><a href="#9-2-2-如何添加优先级" class="headerlink" title="9.2.2 如何添加优先级"></a>9.2.2 如何添加优先级</h4><ul>
<li><p><strong>设置队列的最大优先级 最大可以设置到255官网推荐 1-10 如果设置太高比较吃内存和 CPU</strong></p>
</li>
<li><p>要让队列实现优先级有如下步骤：</p>
<ul>
<li><p>队列需要设置为优先级队列，消息需要设置消息的优先级</p>
</li>
<li><p><strong>消费者需要等待消息已经发送到队列中才去消费，因为这样才有机会对消息进行排序</strong></p>
</li>
</ul>
</li>
<li><p><strong>两种方式添加队列的优先级</strong>：</p>
<ul>
<li><strong>控制台页面添加</strong>：</li>
</ul>
<p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/image-20240412184641755.png" alt="image-20240412184641755"></p>
<ul>
<li><strong>代码方式添加</strong>：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Object&gt; params = <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">params.put(<span class="string">&quot;x-max-priority&quot;</span>, <span class="number">10</span>);</span><br><span class="line">channel.queueDeclare(<span class="string">&quot;hello&quot;</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, params);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>消息设置优先级</strong>：</p>
<ul>
<li>注意消息的优先级数值需要在队列设置的优先级数值范围内，不能超过</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AMQP.<span class="type">BasicProperties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> </span><br><span class="line">    <span class="title class_">AMQP</span>.BasicProperties().builder().priority(<span class="number">5</span>).build();</span><br></pre></td></tr></table></figure>

<h4 id="9-2-3-实战"><a href="#9-2-3-实战" class="headerlink" title="9.2.3 实战"></a>9.2.3 实战</h4><ul>
<li>消息生产者：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Producer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME=<span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtils.getChannel();) &#123;</span><br><span class="line">            <span class="comment">// 给消息赋予一个 priority 属性</span></span><br><span class="line">            AMQP.<span class="type">BasicProperties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> </span><br><span class="line">                <span class="title class_">AMQP</span>.BasicProperties().builder().priority(<span class="number">5</span>).build();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;<span class="number">11</span>; i++) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;info&quot;</span>+i;</span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">5</span>)&#123;</span><br><span class="line">                    channel.basicPublish(<span class="string">&quot;&quot;</span>, QUEUE_NAME, properties, message.getBytes());</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    channel.basicPublish(<span class="string">&quot;&quot;</span>, QUEUE_NAME, <span class="literal">null</span>, message.getBytes());</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;发送消息完成:&quot;</span> + message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>消息消费者</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME=<span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtils.getChannel();</span><br><span class="line">        <span class="comment">//设置队列的最大优先级 最大可以设置到 255 官网推荐 1-10 如果设置太高比较吃内存和 CPU</span></span><br><span class="line">        Map&lt;String, Object&gt; params = <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        params.put(<span class="string">&quot;x-max-priority&quot;</span>, <span class="number">10</span>);</span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, params);</span><br><span class="line">        System.out.println(<span class="string">&quot;消费者启动等待消费......&quot;</span>);</span><br><span class="line">        DeliverCallback deliverCallback=(consumerTag, delivery)-&gt;&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">receivedMessage</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody());</span><br><span class="line">            System.out.println(<span class="string">&quot;接收到消息:&quot;</span>+receivedMessage);</span><br><span class="line">        &#125;;</span><br><span class="line">        channel.basicConsume(QUEUE_NAME,<span class="literal">true</span>,deliverCallback,(consumerTag)-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;消费者无法消费消息时调用，如队列被删除&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-3-惰性队列"><a href="#9-3-惰性队列" class="headerlink" title="9.3 惰性队列"></a>9.3 惰性队列</h3><h4 id="9-3-1-使用场景"><a href="#9-3-1-使用场景" class="headerlink" title="9.3.1 使用场景"></a>9.3.1 使用场景</h4><blockquote>
<p>默认情况 &#x3D;&#x3D;&gt; 消息保存在<strong>内存</strong></p>
<p><strong>惰性队列 &#x3D;&#x3D;&gt; 消息保存在磁盘</strong></p>
</blockquote>
<ul>
<li>惰性队列的设计旨在支持长队列的管理，<strong>允许存储大量消息而不对系统性能造成显著影响</strong><ul>
<li>当消费者由于各种各样的原因(比如消费者下线、宕机亦或者是由于维护而关闭等)而致使长时间内不能消费消息造成堆积时，惰性队列就很有必要了</li>
</ul>
</li>
<li><strong>问题解决</strong>：<ul>
<li>在默认队列行为中，RabbitMQ尽可能将消息保留在内存中，以便快速传递给消费者。然而，这种模式在消息量大时会导致内存压力增大，系统可能需要执行耗时的内存到磁盘的数据交换操作，进而影响队列性能。</li>
<li>惰性队列通过将消息直接存储到磁盘来解决这一问题，<strong>只有当消息需要被消费时，才加载到内存中。这极大地减少了内存的使用，使得RabbitMQ能够处理更长的队列</strong>。</li>
</ul>
</li>
</ul>
<h4 id="9-3-2-两种模式"><a href="#9-3-2-两种模式" class="headerlink" title="9.3.2 两种模式"></a>9.3.2 两种模式</h4><ul>
<li><p>**默认模式 <code>default</code>**：RabbitMQ的传统行为，消息尽可能保留在内存中，以便快速处理。适用于消息量不大，或需要极速处理的场景。</p>
</li>
<li><p>**惰性模式 <code>lazy</code>**：消息直接写入磁盘，仅在需要时加载到内存中，极大减轻了内存的压力，适用于处理大量或长队列的消息。</p>
</li>
<li><p><strong>设置方式</strong>：</p>
<ul>
<li><p>可以在队列声明时通过 <code>x-queue-mode</code> 参数设置，如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Object&gt; args = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">args.put(<span class="string">&quot;x-queue-mode&quot;</span>, <span class="string">&quot;lazy&quot;</span>);</span><br><span class="line">channel.queueDeclare(<span class="string">&quot;myqueue&quot;</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, args);</span><br></pre></td></tr></table></figure>
</li>
<li><p>也可以通过Policy（策略）设置，<strong>策略设置具有比声明时更高的优先级</strong></p>
</li>
<li><p>已存在的队列需要先删除后再以新模式重新声明</p>
</li>
</ul>
</li>
</ul>
<p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/image-20240412190534258.png" alt="image-20240412190534258"></p>
<ul>
<li>惰性队列大幅减少了内存使用，从而降低了因内存不足而导致的性能问题。这使得RabbitMQ服务器能够在资源有限的环境下更加稳定地运行，尤其<strong>适合消息生产速度远大于消费速度的场景</strong></li>
</ul>
<h2 id="10-RabbitMQ-集群"><a href="#10-RabbitMQ-集群" class="headerlink" title="10. RabbitMQ 集群"></a>10. RabbitMQ 集群</h2><h3 id="10-1-clustering"><a href="#10-1-clustering" class="headerlink" title="10.1 clustering"></a>10.1 clustering</h3><p><strong>背景</strong>：单机RabbitMQ服务器在面对内存崩溃、电力故障或硬件故障等问题时容易出现服务中断，这在<strong>高可用性</strong>要求的生产环境中是不可接受的。</p>
<p><strong>需求提升</strong>：随着业务规模的扩大，如需处理每秒达10万条消息的场景，单台服务器的处理能力明显不足，且高性能服务器成本过高。</p>
<p><strong>解决方案</strong>：构建RabbitMQ集群，分散负载和增强冗余，以提高系统的可靠性和消息吞吐量。</p>
<h3 id="10-2-镜像队列"><a href="#10-2-镜像队列" class="headerlink" title="10.2 镜像队列"></a>10.2 镜像队列</h3><p><strong>问题</strong>：单个Broker节点的故障可以导致服务不可用和消息丢失，尽管消息持久化到磁盘可以减少数据丢失，但不足以处理节点故障引起的问题。</p>
<p><strong>解决方案</strong>：通过使用镜像队列，<strong>将队列的副本存储在集群的其他节点上，确保主节点故障时可以无缝切换到镜像节点。</strong></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://tangsmallrong.github.io">thr</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://tangsmallrong.github.io/2024/04/12/RabbitMQ%E5%85%A5%E9%97%A8/">https://tangsmallrong.github.io/2024/04/12/RabbitMQ%E5%85%A5%E9%97%A8/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://tangsmallrong.github.io" target="_blank">thr's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/RabbitMQ/">RabbitMQ</a></div><div class="post_share"></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/05/01/Java%E9%9B%86%E5%90%88/" title="Java 集合"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Java 集合</div></div></a></div><div class="next-post pull-right"><a href="/2023/11/18/Awk/" title="awk 编程"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">awk 编程</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#RabbitMQ"><span class="toc-text">RabbitMQ</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="toc-text">1. 消息队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-MQ-%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5"><span class="toc-text">1.1 MQ 相关概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-1-%E4%BB%80%E4%B9%88%E6%98%AF-MQ"><span class="toc-text">1.1.1 什么是 MQ</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-2-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8-MQ"><span class="toc-text">1.1.2 为什么要用 MQ</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-3-MQ-%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-text">1.1.3 MQ 的分类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-4-MQ-%E7%9A%84%E9%80%89%E6%8B%A9"><span class="toc-text">1.1.4 MQ 的选择</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-RabbitMQ"><span class="toc-text">1.2 RabbitMQ</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-1-%E5%9B%9B%E5%A4%A7%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5"><span class="toc-text">1.2.1 四大核心概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-3-RabbitMQ-%E6%A0%B8%E5%BF%83%E9%83%A8%E5%88%86"><span class="toc-text">1.2.3 RabbitMQ 核心部分</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-3-%E5%90%84%E4%B8%AA%E5%90%8D%E8%AF%8D%E4%BB%8B%E7%BB%8D"><span class="toc-text">1.2.3 各个名词介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-4-%E5%AE%89%E8%A3%85"><span class="toc-text">1.2.4 安装</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-5-%E6%B7%BB%E5%8A%A0%E7%94%A8%E6%88%B7%E5%B9%B6%E8%AE%BE%E7%BD%AE%E6%9D%83%E9%99%90"><span class="toc-text">1.2.5 添加用户并设置权限</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Hello-World"><span class="toc-text">2. Hello World</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E5%88%9B%E5%BB%BA%E5%B7%A5%E7%A8%8B%E5%B9%B6%E6%B7%BB%E5%8A%A0%E4%BE%9D%E8%B5%96"><span class="toc-text">2.1 创建工程并添加依赖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E6%B6%88%E6%81%AF%E7%94%9F%E4%BA%A7%E8%80%85"><span class="toc-text">2.2 消息生产者</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E6%B6%88%E6%81%AF%E6%B6%88%E8%B4%B9%E8%80%85"><span class="toc-text">2.3 消息消费者</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Work-Queues"><span class="toc-text">3. Work Queues</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E8%BD%AE%E8%AF%A2%E5%88%86%E5%8F%91%E6%B6%88%E6%81%AF"><span class="toc-text">3.1 轮询分发消息</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-1-%E6%8A%BD%E5%8F%96%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-text">3.1.1 抽取工具类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-2-%E5%90%AF%E5%8A%A8%E4%B8%A4%E4%B8%AA%E5%B7%A5%E4%BD%9C%E8%BF%9B%E7%A8%8B"><span class="toc-text">3.1.2 启动两个工作进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-3-%E5%90%AF%E5%8A%A8%E4%B8%80%E4%B8%AA%E5%8F%91%E9%80%81%E8%BF%9B%E7%A8%8B"><span class="toc-text">3.1.3 启动一个发送进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-4-%E7%BB%93%E6%9E%9C"><span class="toc-text">3.1.4 结果</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E6%B6%88%E6%81%AF%E5%BA%94%E7%AD%94"><span class="toc-text">3.2 消息应答</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-1-%E6%A6%82%E5%BF%B5"><span class="toc-text">3.2.1 概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-2-%E8%87%AA%E5%8A%A8%E5%BA%94%E7%AD%94"><span class="toc-text">3.2.2 自动应答</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-3-%E6%B6%88%E6%81%AF%E5%BA%94%E7%AD%94%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">3.2.3 消息应答的方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-4-Multiple-%E7%9A%84%E8%A7%A3%E9%87%8A"><span class="toc-text">3.2.4 Multiple 的解释</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-5-%E6%B6%88%E6%81%AF%E8%87%AA%E5%8A%A8%E9%87%8D%E6%96%B0%E5%85%A5%E9%98%9F"><span class="toc-text">3.2.5 消息自动重新入队</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-6-%E6%B6%88%E6%81%AF%E6%89%8B%E5%8A%A8%E5%BA%94%E7%AD%94%E4%BB%A3%E7%A0%81"><span class="toc-text">3.2.6 消息手动应答代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-7-%E6%89%8B%E5%8A%A8%E5%BA%94%E7%AD%94%E6%95%88%E6%9E%9C%E6%BC%94%E7%A4%BA"><span class="toc-text">3.2.7 手动应答效果演示</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-RabbitMQ-%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-text">3.3 RabbitMQ 持久化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-1-%E6%A6%82%E5%BF%B5"><span class="toc-text">3.3.1 概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-2-%E9%98%9F%E5%88%97%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-text">3.3.2 队列如何实现持久化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-3-%E6%B6%88%E6%81%AF%E5%AE%9E%E7%8E%B0%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-text">3.3.3 消息实现持久化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-4-%E4%B8%8D%E5%85%AC%E5%B9%B3%E5%88%86%E5%8F%91"><span class="toc-text">3.3.4 不公平分发</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-5-%E9%A2%84%E5%8F%96%E5%80%BC"><span class="toc-text">3.3.5 预取值</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%8F%91%E5%B8%83%E7%A1%AE%E8%AE%A4"><span class="toc-text">4. 发布确认</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E5%8F%91%E5%B8%83%E7%A1%AE%E8%AE%A4%E5%8E%9F%E7%90%86"><span class="toc-text">4.1 发布确认原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E5%8F%91%E5%B8%83%E7%A1%AE%E8%AE%A4%E7%AD%96%E7%95%A5"><span class="toc-text">4.2 发布确认策略</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-1-%E5%BC%80%E5%90%AF%E5%8F%91%E5%B8%83%E7%A1%AE%E8%AE%A4%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">4.2.1 开启发布确认的方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-2-%E5%8D%95%E4%B8%AA%E7%A1%AE%E8%AE%A4%E5%8F%91%E5%B8%83"><span class="toc-text">4.2.2 单个确认发布</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-3-%E6%89%B9%E9%87%8F%E7%A1%AE%E8%AE%A4%E5%8F%91%E5%B8%83"><span class="toc-text">4.2.3 批量确认发布</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-4-%E5%BC%82%E6%AD%A5%E7%A1%AE%E8%AE%A4%E5%8F%91%E5%B8%83"><span class="toc-text">4.2.4 异步确认发布</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-5-%E4%BB%A5%E4%B8%8A-3-%E7%A7%8D%E5%8F%91%E5%B8%83%E7%A1%AE%E8%AE%A4%E9%80%9F%E5%BA%A6%E5%AF%B9%E6%AF%94"><span class="toc-text">4.2.5 以上 3 种发布确认速度对比</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E4%BA%A4%E6%8D%A2%E6%9C%BA"><span class="toc-text">5. 交换机</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-Exchanges"><span class="toc-text">5.1 Exchanges</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-1-%E6%A6%82%E5%BF%B5"><span class="toc-text">5.1.1 概念</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-%E4%B8%B4%E6%97%B6%E9%98%9F%E5%88%97"><span class="toc-text">5.2 临时队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-%E7%BB%91%E5%AE%9A"><span class="toc-text">5.3 绑定</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-Fanout"><span class="toc-text">5.4 Fanout</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5-Direct-exchange"><span class="toc-text">5.5 Direct exchange</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-6-Topics"><span class="toc-text">5.6 Topics</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-6-1-%E4%B8%BB%E9%A2%98%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%9A%84%E5%BC%95%E5%85%A5"><span class="toc-text">5.6.1 主题交换机的引入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-6-2-Topic-%E5%8C%B9%E9%85%8D%E6%A1%88%E4%BE%8B"><span class="toc-text">5.6.2 Topic 匹配案例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-6-3-%E4%BB%A3%E7%A0%81%E5%AE%9E%E6%88%98"><span class="toc-text">5.6.3 代码实战</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E6%AD%BB%E4%BF%A1%E9%98%9F%E5%88%97"><span class="toc-text">6. 死信队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-%E6%AD%BB%E4%BF%A1%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E6%9D%A5%E6%BA%90"><span class="toc-text">6.1 死信的概念和来源</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-%E6%AD%BB%E4%BF%A1%E5%AE%9E%E6%88%98"><span class="toc-text">6.2 死信实战</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-1-%E6%B6%88%E6%81%AF-TTL-%E8%BF%87%E6%9C%9F"><span class="toc-text">6.2.1 消息 TTL 过期</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-2-%E9%98%9F%E5%88%97%E8%BE%BE%E5%88%B0%E6%9C%80%E5%A4%A7%E9%95%BF%E5%BA%A6"><span class="toc-text">6.2.2 队列达到最大长度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-3-%E6%B6%88%E6%81%AF%E8%A2%AB%E6%8B%92"><span class="toc-text">6.2.3 消息被拒</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97"><span class="toc-text">7. 延迟队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">7.1 延迟队列的概念和使用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-%E6%95%B4%E5%90%88-SpringBoot"><span class="toc-text">7.2 整合 SpringBoot</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-1-%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE"><span class="toc-text">7.2.1 创建项目</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-2-RabbitMQ-%E4%BE%9D%E8%B5%96"><span class="toc-text">7.2.2 RabbitMQ 依赖</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-3-%E4%BF%AE%E6%94%B9%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-text">7.2.3 修改配置文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-4-%E6%B7%BB%E5%8A%A0-Swagger-%E9%85%8D%E7%BD%AE%E7%B1%BB"><span class="toc-text">7.2.4 添加 Swagger 配置类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-RabbitMQ-%E4%B8%AD%E7%9A%84-TTL"><span class="toc-text">7.3 RabbitMQ 中的 TTL</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4-%E9%98%9F%E5%88%97-TTL"><span class="toc-text">7.4 队列 TTL</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-4-1-%E6%A1%88%E4%BE%8B"><span class="toc-text">7.4.1 案例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-4-2-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%B1%BB%E4%BB%A3%E7%A0%81"><span class="toc-text">7.4.2 配置文件类代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-4-3-%E6%B6%88%E6%81%AF%E7%94%9F%E4%BA%A7%E8%80%85%E4%BB%A3%E7%A0%81"><span class="toc-text">7.4.3 消息生产者代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-4-4-%E6%B6%88%E6%81%AF%E6%B6%88%E8%B4%B9%E8%80%85%E4%BB%A3%E7%A0%81"><span class="toc-text">7.4.4 消息消费者代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-4-5-%E5%90%AF%E5%8A%A8%E6%B5%8B%E8%AF%95"><span class="toc-text">7.4.5 启动测试</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-5-%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97%E4%BC%98%E5%8C%96"><span class="toc-text">7.5 延迟队列优化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-5-1-%E4%BC%98%E5%8C%96%E6%A1%88%E4%BE%8B"><span class="toc-text">7.5.1 优化案例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-5-2-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%B1%BB%E4%BB%A3%E7%A0%81"><span class="toc-text">7.5.2 配置文件类代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-5-3-%E6%B6%88%E6%81%AF%E7%94%9F%E4%BA%A7%E8%80%85%E4%BB%A3%E7%A0%81"><span class="toc-text">7.5.3 消息生产者代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-5-4-%E5%90%AF%E5%8A%A8%E6%B5%8B%E8%AF%95"><span class="toc-text">7.5.4 启动测试</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-5-6-%E5%AD%98%E5%9C%A8%E9%97%AE%E9%A2%98-%E5%9F%BA%E4%BA%8E%E6%AD%BB%E4%BF%A1%E7%9A%84%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97"><span class="toc-text">7.5.6 存在问题(基于死信的延迟队列)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-6-RabbitMQ-%E6%8F%92%E4%BB%B6%E5%AE%9E%E7%8E%B0%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97"><span class="toc-text">7.6 RabbitMQ 插件实现延迟队列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-6-1-%E5%AE%89%E8%A3%85%E5%BB%B6%E6%97%B6%E9%98%9F%E5%88%97%E6%8F%92%E4%BB%B6"><span class="toc-text">7.6.1 安装延时队列插件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-6-2-%E6%A1%88%E4%BE%8B"><span class="toc-text">7.6.2 案例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-6-3-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%B1%BB%E4%BB%A3%E7%A0%81"><span class="toc-text">7.6.3 配置文件类代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-6-4-%E6%B6%88%E6%81%AF%E7%94%9F%E4%BA%A7%E8%80%85%E4%BB%A3%E7%A0%81"><span class="toc-text">7.6.4 消息生产者代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-6-5-%E6%B6%88%E6%81%AF%E6%B6%88%E8%B4%B9%E8%80%85%E4%BB%A3%E7%A0%81"><span class="toc-text">7.6.5 消息消费者代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-6-6-%E6%B5%8B%E8%AF%95"><span class="toc-text">7.6.6 测试</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-7-%E6%80%BB%E7%BB%93"><span class="toc-text">7.7 总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E5%8F%91%E5%B8%83%E7%A1%AE%E8%AE%A4%E9%AB%98%E7%BA%A7"><span class="toc-text">8. 发布确认高级</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-%E5%8F%91%E5%B8%83%E7%A1%AE%E8%AE%A4-SpringBoot-%E7%89%88%E6%9C%AC"><span class="toc-text">8.1 发布确认 SpringBoot 版本</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-1-1-%E7%A1%AE%E8%AE%A4%E6%9C%BA%E5%88%B6%E6%96%B9%E6%A1%88"><span class="toc-text">8.1.1 确认机制方案</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-1-2-%E7%A4%BA%E4%BE%8B"><span class="toc-text">8.1.2 示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-1-3-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%92%8C%E9%85%8D%E7%BD%AE%E7%B1%BB"><span class="toc-text">8.1.3 配置文件和配置类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-1-4-%E6%B6%88%E6%81%AF%E7%94%9F%E4%BA%A7%E8%80%85"><span class="toc-text">8.1.4 消息生产者</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-1-5-%E5%9B%9E%E8%B0%83%E6%8E%A5%E5%8F%A3"><span class="toc-text">8.1.5 回调接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-1-5-%E6%B6%88%E6%81%AF%E6%B6%88%E8%B4%B9%E8%80%85"><span class="toc-text">8.1.5 消息消费者</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-1-6-%E6%B5%8B%E8%AF%95"><span class="toc-text">8.1.6 测试</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-%E5%9B%9E%E9%80%80%E6%B6%88%E6%81%AF"><span class="toc-text">8.2 回退消息</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2-1-Mandatory-%E5%8F%82%E6%95%B0"><span class="toc-text">8.2.1 Mandatory 参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2-2-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-text">8.2.2 配置文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2-3-%E5%9B%9E%E8%B0%83%E6%8E%A5%E5%8F%A3"><span class="toc-text">8.2.3 回调接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2-4-%E6%B5%8B%E8%AF%95"><span class="toc-text">8.2.4 测试</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-%E5%A4%87%E4%BB%BD%E4%BA%A4%E6%8D%A2%E6%9C%BA"><span class="toc-text">8.3 备份交换机</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-3-1-%E7%A4%BA%E4%BE%8B"><span class="toc-text">8.3.1 示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-3-2-%E4%BF%AE%E6%94%B9%E9%85%8D%E7%BD%AE%E7%B1%BB"><span class="toc-text">8.3.2 修改配置类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-3-3-%E6%8A%A5%E8%AD%A6%E6%B6%88%E8%B4%B9%E8%80%85"><span class="toc-text">8.3.3 报警消费者</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-3-4-%E6%B5%8B%E8%AF%95"><span class="toc-text">8.3.4 测试</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E5%85%B6%E4%BB%96%E7%9F%A5%E8%AF%86%E7%82%B9"><span class="toc-text">9. 其他知识点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-1-%E5%B9%82%E7%AD%89%E6%80%A7"><span class="toc-text">9.1 幂等性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#9-1-1-%E6%A6%82%E5%BF%B5"><span class="toc-text">9.1.1 概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-1-2-%E6%B6%88%E6%81%AF%E9%87%8D%E5%A4%8D%E6%B6%88%E8%B4%B9"><span class="toc-text">9.1.2 消息重复消费</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-1-3-%E8%A7%A3%E5%86%B3%E6%80%9D%E8%B7%AF"><span class="toc-text">9.1.3 解决思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-1-4-%E6%B6%88%E8%B4%B9%E7%AB%AF%E7%9A%84%E5%B9%82%E7%AD%89%E6%80%A7%E4%BF%9D%E9%9A%9C"><span class="toc-text">9.1.4 消费端的幂等性保障</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97"><span class="toc-text">9.2 优先级队列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#9-2-1-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">9.2.1 使用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-2-2-%E5%A6%82%E4%BD%95%E6%B7%BB%E5%8A%A0%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-text">9.2.2 如何添加优先级</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-2-3-%E5%AE%9E%E6%88%98"><span class="toc-text">9.2.3 实战</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-3-%E6%83%B0%E6%80%A7%E9%98%9F%E5%88%97"><span class="toc-text">9.3 惰性队列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#9-3-1-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">9.3.1 使用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-3-2-%E4%B8%A4%E7%A7%8D%E6%A8%A1%E5%BC%8F"><span class="toc-text">9.3.2 两种模式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-RabbitMQ-%E9%9B%86%E7%BE%A4"><span class="toc-text">10. RabbitMQ 集群</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#10-1-clustering"><span class="toc-text">10.1 clustering</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-2-%E9%95%9C%E5%83%8F%E9%98%9F%E5%88%97"><span class="toc-text">10.2 镜像队列</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By thr</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>