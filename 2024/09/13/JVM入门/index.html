<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>JVM 入门 | thr's blog</title><meta name="author" content="thr"><meta name="copyright" content="thr"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="JVM 学习视频： 黑马程序员JVM完整教程，Java虚拟机快速入门，全程干货不拖沓_哔哩哔哩_bilibili G1与zgc垃圾回收器剖析_哔哩哔哩_bilibili  1. 概述 什么是 JVM？ 定义：java virtual machine 也就是 java 程序(准确说是 java 二进制字节码)的运行环境 java 程序源代码经过 javac 编译成 class 字节码，字节码再通过">
<meta property="og:type" content="article">
<meta property="og:title" content="JVM 入门">
<meta property="og:url" content="https://tangsmallrong.github.io/2024/09/13/JVM%E5%85%A5%E9%97%A8/index.html">
<meta property="og:site_name" content="thr&#39;s blog">
<meta property="og:description" content="JVM 学习视频： 黑马程序员JVM完整教程，Java虚拟机快速入门，全程干货不拖沓_哔哩哔哩_bilibili G1与zgc垃圾回收器剖析_哔哩哔哩_bilibili  1. 概述 什么是 JVM？ 定义：java virtual machine 也就是 java 程序(准确说是 java 二进制字节码)的运行环境 java 程序源代码经过 javac 编译成 class 字节码，字节码再通过">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://tangsmallrong.github.io/img/avatar.jpg">
<meta property="article:published_time" content="2024-09-13T11:55:30.000Z">
<meta property="article:modified_time" content="2024-09-13T12:06:39.627Z">
<meta property="article:author" content="thr">
<meta property="article:tag" content="JVM">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://tangsmallrong.github.io/img/avatar.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://tangsmallrong.github.io/2024/09/13/JVM%E5%85%A5%E9%97%A8/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: thr","link":"链接: ","source":"来源: thr's blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'JVM 入门',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-09-13 20:06:39'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.0.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/./img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">13</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">12</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="thr's blog"><span class="site-name">thr's blog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">JVM 入门</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-09-13T11:55:30.000Z" title="发表于 2024-09-13 19:55:30">2024-09-13</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-09-13T12:06:39.627Z" title="更新于 2024-09-13 20:06:39">2024-09-13</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/">Java</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">20.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>64分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="JVM 入门"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><blockquote>
<p>学习视频：</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1yE411Z7AP/?spm_id_from=333.337.search-card.all.click&vd_source=320ecdd8d14979567afe9d21045ad392">黑马程序员JVM完整教程，Java虚拟机快速入门，全程干货不拖沓_哔哩哔哩_bilibili</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1sp4y1Y7ap?p=8&vd_source=ce97d263f08af76fc25ff49de530fe92">G1与zgc垃圾回收器剖析_哔哩哔哩_bilibili</a></p>
</blockquote>
<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><ul>
<li><strong>什么是 JVM？</strong><ul>
<li><strong>定义</strong>：java virtual machine 也就是 java 程序(准确说是 java 二进制字节码)的运行环境<ul>
<li>java 程序源代码经过 <code>javac</code> 编译成 class 字节码，字节码再通过 <code>java</code> 程序加载到虚拟机里即可运行</li>
</ul>
</li>
<li><strong>好处</strong>：<ul>
<li>一次编写，到处运行(跨平台是在jvm层面实现的,屏蔽了字节码和底层操作系统的差异,对外提供了一致的运行环境)</li>
<li>自动内存管理，垃圾回收功能(c和c++没有)</li>
<li>数组下标越界检查(c和c++没有)</li>
<li>多态是面向对象的基石(jvm内部使用虚方法表实现多态)</li>
</ul>
</li>
<li><strong>jdk &amp; jre &amp; jvm</strong><ul>
<li>jvm+基础类库 &#x3D;&gt; jre+编译工具 &#x3D;&gt; jdk</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JVM%E5%85%A5%E9%97%A8.assets/image-20240913162126431.png" alt="image-20240913162126431"></p>
<ul>
<li><p>jvm 只是一套规范，之后的笔记以 HotSpot 虚拟机为例</p>
</li>
<li><p><strong>jvm 的主要组成</strong></p>
</li>
<li><p>类加载系统</p>
</li>
<li><p>内存结构(运行时数据区域)</p>
</li>
<li><p>执行引擎</p>
</li>
<li><p>本地接口</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JVM%E5%85%A5%E9%97%A8.assets/image-20240913162159914.png" alt="image-20240913162159914"></p>
<h2 id="2-内存结构"><a href="#2-内存结构" class="headerlink" title="2. 内存结构"></a>2. 内存结构</h2><h3 id="2-1-程序计数器-PC"><a href="#2-1-程序计数器-PC" class="headerlink" title="2.1 程序计数器(PC)"></a>2.1 程序计数器(PC)</h3><ul>
<li><strong>代码执行流程</strong>：<ul>
<li>java 代码被编译为二进制字节码(jvm指令[在不同平台下一样,跨平台])</li>
<li>解释器将其解释为机器码(过程中<strong>解释器根据指令的类型和执行结果更新程序计数器的值</strong>,使其指向下一条要执行的字节码指令)</li>
<li>cpu 执行机器码</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JVM%E5%85%A5%E9%97%A8.assets/image-20240913164747410.png" alt="image-20240913164747410"></p>
<ul>
<li><strong>作用</strong>：<ul>
<li>记住下一条jvm指令的执行地址，保证程序执行的有序性</li>
<li>多线程环境下，程序计数器也会记住当前线程上次执行结束的位置，当再抢夺到cpu时间片的时候会接着上次执行的位置继续执行</li>
</ul>
</li>
<li>物理上实现程序计数器是通过”寄存器”来实现(快)，因为读取指令内存地址很频繁</li>
<li><strong>特点</strong>：<ul>
<li>线程私有</li>
<li>唯一一个不会存在内存溢出的内存结构</li>
</ul>
</li>
</ul>
<h3 id="2-2-虚拟机栈"><a href="#2-2-虚拟机栈" class="headerlink" title="2.2 虚拟机栈"></a>2.2 虚拟机栈</h3><ul>
<li><p>每个线程运行时所需要的内存，<strong>线程私有</strong></p>
</li>
<li><p>每个栈由多个栈帧组成，对应着每个方法运行时需要的内存(参数、局部变量、返回地址)</p>
</li>
<li><p>每个线程只能有一个活动栈帧，对应着正在执行的那个方法(栈顶的栈帧)</p>
</li>
<li><p>可以在idea调试的时候查看左下角的栈帧</p>
</li>
<li><p><strong>问题辨析</strong>：</p>
<ul>
<li><p>垃圾回收不涉及栈内存(一次次方法调用产生的栈帧内存,其在每次方法调用后都会被自动弹出栈,不用垃圾回收来管理)</p>
</li>
<li><p>jvm 可以通过 <code>-Xss</code> 参数设置栈内存(linux默认1024KB)，并不是越大越好(虽然越大可以支持更多的递归调用)，但其会增加每个线程占用内存，会使可执行的线程数变少(因为物理内存大小固定)</p>
</li>
<li><p>方法内的局部变量是否线程安全要看局部变量有没有逃离方法的作用范围，若没有则为线程私有&#x3D;&gt;安全，否则如果局部变量引用了对象(方法的参数是一个对象)，并逃离了方法的作用范围(比如将局部变量返回)，需要考虑线程安全</p>
</li>
</ul>
</li>
<li><p><strong>虚拟机栈的内存溢出问题</strong>：两种情况，java 会抛出 <strong>StackOverflowError 异常</strong></p>
<ul>
<li>栈帧过多(如递归调用没有设置正确的终止条件)</li>
<li>栈帧过大</li>
<li>调用第三方库也可能出现栈溢出(如使用 JSON 库进行序列化或反序列化时，若实体类的属性之间存在循环引用则可能导致栈溢出等问题) &#x3D;&gt; 若场景不可避免,可以使用注解啥的忽略某个字段</li>
</ul>
</li>
<li><p><strong>线程诊断相关问题</strong>：</p>
<ul>
<li>cpu 占用过多<ul>
<li><code>top</code>：实时查看系统中各个进程的资源使用情况</li>
<li><code>ps -H -eo pid,tid,%cpu | grep &lt;PID&gt;</code>：查看具体进程的线程资源使用情况</li>
<li><code>printf &quot;%x\n&quot; &lt;TID&gt;</code>：将 TID 转换为十六进制格式</li>
<li><code>jps</code>：列出所有 Java 进程</li>
<li><code>jstack &lt;PID&gt; &gt; thread_dump.txt</code>：获取指定 Java 进程的线程 dump,再根据TID的十六进制格式进行定位</li>
</ul>
</li>
<li>程序运行很长时间没有结果<ul>
<li>可能是死锁问题，使用 <code>jstack &lt;pID&gt;</code> 查看末尾会输出类似 <code>Found one Java level deadlock</code> 语句</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2-3-本地方法栈"><a href="#2-3-本地方法栈" class="headerlink" title="2.3 本地方法栈"></a>2.3 本地方法栈</h3><ul>
<li>本地(native)方法是用非 Java 语言(如 C 或 C++)编写的代码</li>
<li>本地方法栈：在 java 虚拟机<strong>调用一些本地方法时为其提供内存空间，线程私有</strong></li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JVM%E5%85%A5%E9%97%A8.assets/image-20240913165029364.png" alt="image-20240913165029364"></p>
<h3 id="2-4-堆"><a href="#2-4-堆" class="headerlink" title="2.4 堆"></a>2.4 堆</h3><ul>
<li><p><strong>特点</strong>（通过 new 关键字，创建对象都会使用堆内存）</p>
<ul>
<li>程序计数器 虚拟机栈 本地方法栈都是线程私有的，堆是线程共享的，需要考虑线程安全的问题</li>
<li>有垃圾回收机制</li>
</ul>
</li>
<li><p><strong>堆内存溢出问题</strong>：抛出 OutofMemoryError 异常</p>
<ul>
<li>可以通过参数指定堆内存大小：（有时候运行时间短不容易发现堆内存溢出问题,设置小些可以方便暴露问题）<ul>
<li>堆的最小值：-Xms 如-Xms2m</li>
<li>堆的最大值：-Xmx 如-Xmx8m</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>堆内存诊断</strong>：</p>
<ul>
<li><code>jps</code> 查找 java 进程 PID</li>
<li><code>jmap -heap &lt;PID&gt;</code> 查看 java 进程的堆内存使用情况 &#x3D;&gt; 只能查询当前时刻</li>
<li><code>jconsole</code> 可连续检测，图形化界面，多功能</li>
<li>案例：垃圾回收后，内存占用仍然很高<ul>
<li>使用 JVisualVM 来监控 java 程序 &#x3D;&gt; 也是图形化界面，有个 dump 功能可以抓取堆的当前快照，分析堆转储文件里对内存占用大的对象</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2-5-方法区"><a href="#2-5-方法区" class="headerlink" title="2.5 方法区"></a>2.5 方法区</h3><ul>
<li><strong>线程共享</strong>，存储所有类和常量的元数据信息，如类加载信息、运行时常量池、字符串常量池(JDK7 开始，字符串常量池被移到了 Java 堆中)</li>
<li>在虚拟机启动时创建，逻辑上是堆的组成部分(具体实现不一样,规范上不强制位置)<ul>
<li>如 Oracle 的 HotSpot，1.8以前方法区的实现叫做”永久代”(PermGen)，使用堆的一部分内存作为方法区</li>
<li>1.8以后，移除了”永久代”，换了一种实现叫”元空间”(Metaspace)，用的是本地的内存，也就是操作系统的内存</li>
<li>方法区都是一种规范，”永久代”和”元空间”都是它的一种实现</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JVM%E5%85%A5%E9%97%A8.assets/image-20240913170458211.png" alt="image-20240913170458211"></p>
<ul>
<li><p><strong>方法区的内存溢出问题</strong>：</p>
<ul>
<li>1.8 以前会导致永久代内存溢出</li>
<li>1.8 以后会导致元空间内存溢出</li>
<li>1.8 以后用的元空间(使用系统内存),一般不容易溢出</li>
<li><code>-XX:MaxMetaspaceSize=&lt;size&gt;</code> 设置元空间最大大小</li>
<li>实际场景中动态产生并加载类的情况很多，如 spring(使用 CGLIB 或 Java 动态代理生成 AOP 代理类) 和 mybatis(使用 Java 动态代理生成映射器接口的实现类) 等代理对象<ul>
<li>在这些动态生成类的过程中，类的加载和卸载频繁，加上框架所创建的类通常都不是轻量级类，这些类的元数据需要存储在方法区（永久代或元空间）中</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>方法区中的一个组成部分：运行时常量池</strong></p>
<ul>
<li><strong>常量池</strong>：在编译时生成，存在于 <code>.class</code> 文件中<ul>
<li>反编译 target 目录下的 <code>.class</code> 文件(命令:<code>javap -v Hello.class</code>) ，该文件包括<ul>
<li>类基本信息</li>
<li>该类的常量池信息</li>
<li>类方法定义(包含JVM指令)</li>
</ul>
</li>
<li>常量池中包括编译时生成的各种字面量(如字符串常量、数值常量)和符号引用(如类名、方法名、字段名等)，作用是给JVM指令提供一些常量符号，保证虚拟机指令能够成功执行</li>
</ul>
</li>
<li><strong>运行时常量池</strong>：<ul>
<li>类加载时，<code>.class</code> 文件中的常量池内容会被加载到运行时常量池中</li>
<li>并在类加载(加载、链接[验证,准备,解析]、初始化) 的解析阶段，将class常量池中的原先的”符号引用”解析为”直接引用”</li>
<li>运行时常量池不仅包含编译时的常量池内容，还可以动态扩展，可能在运行阶段加入新的常量</li>
</ul>
</li>
<li><strong>运行时常量池的一部分：字符串常量池</strong><ul>
<li><code>StringTable</code> 是 JVM 内部用于实现字符串常量池的数据结构，底层是哈希表(固定大小的哈希表，带有开放地址法来处理哈希冲突)</li>
<li>在类加载过程中，编译后的 <code>.class</code> 文件中的常量池内容被加载到运行时常量池中，字符串字面量在这个阶段被加载到字符串常量池中 &#x3D;&gt; <code>s3 = &quot;ab&quot;</code></li>
<li><strong>Java 8 及之前</strong>：编译器将使用 <code>+</code> 操作符的字符串拼接(语法糖)优化为 <code>StringBuilder</code> 的拼接，如<code>new StringBuilder().append(&quot;a&quot;).qppend(&quot;b&quot;).toString()</code>  &#x3D;&#x3D;&gt; <code>s4 = s1 + s2</code> 存放在堆里</li>
<li><strong>Java 9 及之后</strong>：引入 <code>invokedynamic</code> 指令来实现字符串拼接，允许 JVM 在运行时选择最优的拼接方式</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringConcatExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;b&quot;</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;        <span class="comment">// 字面量形式</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> s1 + s2;     <span class="comment">// 变量拼接</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span> + <span class="string">&quot;b&quot;</span>;   <span class="comment">// 常量拼接</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 比较引用</span></span><br><span class="line">        System.out.println(s3 == s4); <span class="comment">// false</span></span><br><span class="line">        System.out.println(s3 == s5); <span class="comment">// true</span></span><br><span class="line">        System.out.println(s4 == s5); <span class="comment">// false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>字符串延迟加载</strong>：</p>
<ul>
<li>在 Java 编译过程中，所有字符串字面量确实被存储在 <code>.class</code> 文件的常量池中。但这并不意味着它们会在类加载时立即全部被加入到运行时字符串常量池中去</li>
<li><strong>字符串字面量在被首次使用时</strong>，会被放入字符串常量池</li>
<li>JVM 使用<strong>懒加载（lazy loading）技术</strong>，按需加载和管理字符串对象，以减少不必要的内存占用</li>
</ul>
</li>
<li><p><strong>intern 方法</strong>（串池存放对象还是引用有争议，先按着视频里的来）</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/lotusPlant/article/details/125804308">https://blog.csdn.net/lotusPlant/article/details/125804308</a></p>
</blockquote>
<ul>
<li>针对 JDK1.8，intern() 方法的工作机制是尝试将字符串对象放入串池，如果有则不放，如果没有则放，并把串池中的对象返回</li>
<li>针对 JDK1.6，intern() 方法尝试将字符串对象放入串池，如果有则不放，如果没有则把对象复制一份放入串池，并把串池中的对象返回</li>
</ul>
</li>
<li><p><strong>StringTable 的位置</strong></p>
<ul>
<li>JDK1.6 StringTable 在永久代中，1.8 StringTable 在堆中，主要是为了优化垃圾回收效率，减少 <code>OutOfMemoryError</code> 的风险</li>
<li>永久代的大小是固定的，字符串常量池在 JDK 1.6 中容易导致 <code>OutOfMemoryError</code></li>
<li>规则：<strong>当 GC（垃圾回收）耗时超过 98% 且仅回收不到 2% 的堆内存时，会抛出 <code>OutOfMemoryError</code> 异常</strong>。<ul>
<li>这一规则是 JVM 为了避免系统陷入“GC回收但效果很差”的恶性循环而设计的</li>
<li>如果垃圾回收的效率非常低，即 GC 几乎占用了大部分的 CPU 时间，但实际上回收的内存却很少，那么 JVM 会认为当前的内存配置已经无法支持正常运行，因此抛出 <code>OutOfMemoryError</code></li>
</ul>
</li>
<li><code>-XX:MaxPermSize</code>：设置永久代的最大大小</li>
<li><code>-Xmx8m</code>：设置堆的最大内存</li>
</ul>
</li>
<li><p><strong>StringTable 垃圾回收</strong></p>
<ul>
<li><code>-Xmx10m</code> 指定堆内存大小</li>
<li><code>-XX:+PrintStringTableStatistics</code> 打印字符串常量池信息</li>
<li><code>-XX:+PrintGCDetails</code></li>
<li><code>-verbose:gc</code> 打印 gc 的次数，耗费时间等信息</li>
</ul>
</li>
<li><p><strong>StringTable 性能调优</strong></p>
</li>
<li><p>StringTable 底层是固定大小的哈希表(数组+链表)，如果数组长度较长，相当于存放的元素就会比较分散，哈希冲突的概率会小一些，查找的速度也会更快</p>
</li>
<li><p>所以如果系统里字符串常量非常多的话，可以设置桶的个数多一些，如：<code>-XX:StringTablesize=101010</code></p>
</li>
</ul>
<h3 id="2-6-操作系统的内存-直接内存"><a href="#2-6-操作系统的内存-直接内存" class="headerlink" title="2.6 操作系统的内存-直接内存"></a>2.6 操作系统的内存-直接内存</h3><ul>
<li><strong>特点</strong>：<ul>
<li>常见于 NIO 操作时，用于数据缓冲区</li>
<li>分配回收成本较高，但读写性能高</li>
<li>不受 JVM 内存回收管理</li>
</ul>
</li>
<li>直接内存也会有内存溢出的问题，其底层的分配和释放直接内存的原理：<ul>
<li><strong>底层使用 unsafe 对象来管理</strong><ul>
<li><code>base = unsafe.allocateMemory(size);</code></li>
<li><code>unsafe.freeMemory(address);</code></li>
</ul>
</li>
<li>Cleaner 继承虚引用类型，会将 unsafe 分配的直接内存地址与一个虚引用关联起来，并监控这个引用，当直接内存对象不再被使用时，虚引用会被添加到引用队列中，通知 Cleaner 需要执行清理操作</li>
<li>Cleaner 的清理线程会从引用队列中取出这个虚引用，并调用其 run() 方法(其内部调用unsafe的freeMemory方法来释放内存)</li>
</ul>
</li>
<li>JVM 调优有个参数 <code>-XX:+DisableExplicitGC</code>，用于防止手动用 <code>System.gc()</code> 释放内存，但是该参数可能会对直接内存的垃圾回收造成影响 &#x3D;&gt; 解决办法是对于直接内存回收直接使用底层的 <code>unsafe.freeMemory()</code></li>
</ul>
<h2 id="3-垃圾回收"><a href="#3-垃圾回收" class="headerlink" title="3. 垃圾回收"></a>3. 垃圾回收</h2><h3 id="3-1-判断对象是否可以回收"><a href="#3-1-判断对象是否可以回收" class="headerlink" title="3.1 判断对象是否可以回收"></a>3.1 判断对象是否可以回收</h3><ul>
<li><p>两种算法：引用计数、可达性分析(JVM使用的)</p>
</li>
<li><p><strong>引用计数</strong>：每个对象都维护一个引用计数器，用来记录有多少个引用指向该对象</p>
<ul>
<li>当对象被一个变量引用时+1，计数为0时说明可以被销毁</li>
<li>缺点是<strong>无法处理循环引用</strong>，如果两个对象相互引用，但没有其他对象引用它们</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JVM%E5%85%A5%E9%97%A8.assets/image-20240913170900311.png" alt="image-20240913170900311"></p>
</li>
<li><p><strong>可达性分析</strong>：看是否被根对象直接或间接的引用，不是则可以被回收</p>
</li>
<li><p><strong>补充</strong>：内存泄漏是指程序在运行过程中分配了内存，但这些内存由于某些原因没有被释放或回收，从而导致内存资源逐渐被耗尽</p>
<ul>
<li>未被释放的内存：程序动态分配了一块内存，但在不再需要这块内存时，没有显式或隐式地释放它</li>
<li>不可达但未被回收：在垃圾回收机制的语言中（如 Java），即使对象已经不可达（即没有任何引用指向它），但如果垃圾回收器没有及时或无法识别并回收这些内存，就会造成内存泄漏</li>
<li>持续的无用占用：虽然内存泄漏的内存仍然被分配和占用，但它已经对程序没有任何作用，这些内存无法再被程序利用，从而浪费了资源</li>
</ul>
</li>
</ul>
<h3 id="3-2-JVM-五种引用"><a href="#3-2-JVM-五种引用" class="headerlink" title="3.2 JVM 五种引用"></a>3.2 JVM 五种引用</h3><blockquote>
<p>参考：<a target="_blank" rel="noopener" href="https://juejin.cn/post/7131175540874018830">https://juejin.cn/post/7131175540874018830</a></p>
</blockquote>
<ul>
<li><p><strong>强、软、弱、虚、终结器</strong></p>
<ul>
<li><p><strong>强引用</strong>：平时用的都是强引用(如new出来的对象被赋值给了某个变量,那么这个变量就强引用该对象)，特点就是只要能够沿着GC Root的引用链找到它,就不会被回收</p>
</li>
<li><p><strong>软引用</strong>：用 SoftReference 类实现，在没有强引用引用它的前提下，当垃圾回收且内存不足时会被回收掉</p>
</li>
<li><p><strong>弱引用</strong>：用 WeakReference 类实现，在没有强引用引用它的前提下，当垃圾回收时就会被回收掉</p>
</li>
<li><p><strong>虚引用</strong>：主要配置 ByteBuffer 使用(有关直接内存的释放&#x3D;&gt;因为直接内存不受JVM垃圾回收的管理)，当ByteBuffer对象没有强引用时，JVM 会将其内部关联的 Cleaner 对象(虚引用)放入引用队列中，系统中有一个专门的线程定期检查这个队列，一旦发现 Cleaner 对象，便会调用其 <code>clean</code> 方法，该方法内部会通过 <code>unsafe</code> 类的 <code>freeMemory</code> 方法来释放直接内存，从而避免内存泄漏</p>
</li>
<li><p><strong>终结器引用</strong>：Object 父类中的 finalize 方法(不推荐使用)，当对象被垃圾回收时，如果该对象重写了 finalize 方法，JVM 会生成一个与该对象关联的 终结器引用，并将这个 终结器引用 放入 终结器队列，JVM 会通过一个低优先级的后台线程调用队列中引用关联的对象的 finalize 方法，如果对象再次可达，它就会被自救，避免被回收</p>
</li>
</ul>
</li>
<li><p>软引用和弱引用也可以配合”引用队列”来使用,也可以不配合，<strong>虚引用和终结器引用必须配合引用队列使用</strong></p>
</li>
<li><p><code>[软引用][弱引用][虚引用][终结器引用]</code>本身都是对象，当这些对象引用的对象被回收后，它们就可以放到”引用队列”中去方便后续处理(如遍历队列释放内存它们占用的内存)</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JVM%E5%85%A5%E9%97%A8.assets/image-20240913171009096.png" alt="image-20240913171009096"></p>
<ul>
<li><strong>软引用的应用</strong>：针对内存敏感的资源(如图片等)，可以使用软引用引用，在内存紧张时，将该占有的内存释放掉，以后要使用到时再读取一遍</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JVM%E5%85%A5%E9%97%A8.assets/image-20240913171439542.png" alt="image-20240913171439542"></p>
<ul>
<li><strong>软引用和引用队列 (弱引用类似)</strong><ul>
<li>软引用引用的对象在内存紧张时被回收，但软引用对象本身也是占用内存的 &#x3D;&gt; 需要使用引用队列来清理</li>
<li>在创建软引用对象的时候，将[引用队列]作为参数传入，当软引用所关联的对象被回收时，软引用自己会加入到队列中</li>
<li>编写代码去轮询或检查这个引用队列，确定哪些软引用对象已经失效，并根据业务逻辑执行清理操作（如从缓存中移除条目或释放其他相关资源）</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JVM%E5%85%A5%E9%97%A8.assets/image-20240913171509781.png" alt="image-20240913171509781"></p>
<ul>
<li><p><strong>补充</strong>：</p>
<ul>
<li><strong>直接内存回收的具体工作流程(涉及虚引用)：</strong><ul>
<li><strong>ByteBuffer 分配直接内存</strong>：当创建一个直接内存 ByteBuffer 时，底层会通过 JNI (Java Native Interface) 调用操作系统分配一块直接内存，并使用 ByteBuffer 对象对其进行封装</li>
<li><strong>Cleaner 对象</strong>：ByteBuffer 内部通常会关联一个 Cleaner 对象，Cleaner 是一个虚引用，它注册了一个清理任务，该任务定义了如何在 ByteBuffer 被垃圾回收时释放对应的直接内存</li>
<li><strong>虚引用的使用</strong>：Cleaner 继承自 PhantomReference，当 ByteBuffer 对象没有强引用（即它不再被任何其他对象引用）时 JVM 的垃圾回收器会将 Cleaner 对象放入到一个引用队列（ReferenceQueue）中</li>
<li><strong>清理任务的执行</strong>：系统中有一个专门的线程（通常是 ReferenceHandler 线程）负责定期检查这个引用队列<br> 当 Cleaner 对象被放入队列中时，ReferenceHandler 线程会调用 Cleaner 中的清理任务。这个清理任务通常会调用 Unsafe 类的 freeMemory 方法来释放分配的直接内存，从而避免内存泄漏</li>
<li><strong>防止直接内存泄漏</strong>：通过这种机制，即使 ByteBuffer 对象被垃圾回收了，系统仍然能够确保其对应的直接内存被安全释放，防止内存泄漏</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">总结：虚引用主要配合 ByteBuffer 使用(有关直接内存的释放=&gt;因为直接内存不受JVM垃圾回收的管理)，当ByteBuffer对象没有强引用时，JVM 会将其内部关联的 Cleaner 对象(虚引用)放入引用队列中，系统中有一个专门的线程定期检查这个队列，一旦发现 Cleaner 对象，便会调用其 `clean` 方法，该方法内部会通过 `unsafe` 类的 `freeMemory` 方法来释放直接内存，从而避免内存泄漏。</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>虚引用在直接内存管理中的作用</strong>：<ul>
<li>虚引用通过 Cleaner 机制确保 ByteBuffer 在被垃圾回收时，其对应的直接内存也能够被安全释放</li>
<li>这是因为 JVM 不会自动管理直接内存的回收，必须通过这种机制来避免内存泄漏</li>
</ul>
</li>
<li><strong>终结器引用</strong>：<ul>
<li>终结器引用和 finalize 方法是 Java 对象生命周期管理中的一个机制，主要用于在对象被垃圾回收之前执行一些清理操作</li>
<li>然而，由于性能和可靠性问题，finalize 方法已经被认为是不推荐使用的，并且在现代 Java 开发中基本上被废弃了。不推荐的原因：<ul>
<li>finalize 方法工作效率低</li>
<li>处理引用队列的线程优先级低，执行机会少，可能对象占用内存迟迟不被释放</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="3-3-垃圾回收算法"><a href="#3-3-垃圾回收算法" class="headerlink" title="3.3 垃圾回收算法"></a>3.3 垃圾回收算法</h3><ul>
<li><strong>标记清除</strong>（两个阶段）<ul>
<li>对没有被 GC root 直接或间接引用的对象进行标记，然后将其所占用的空间进行释放(将起始结束地址记录在空闲表里)<ul>
<li><strong>标记阶段</strong>：通过引用链从 GC Roots 开始遍历所有可达的对象</li>
<li><strong>清除阶段</strong>：JVM 开始遍历整个堆内存区域，发现没有标记的对象则将其视为垃圾对象并释放其占用的内存（这里的释放是指标记未被使用的内存块的起始地址和结束地址，将这些空闲内存记录到一个“空闲列表”中以便后续内存分配时可以使用这些空闲内存）</li>
</ul>
</li>
<li><strong>优点：速度快；缺点：内存碎片</strong></li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JVM%E5%85%A5%E9%97%A8.assets/image-20240913172418578.png" alt="image-20240913172418578"></p>
<ul>
<li><strong>标记整理</strong> <ul>
<li>标记阶段都类似，整理阶段垃圾回收器会扫描整个堆内存区域，将所有标记为存活的对象移动到堆的一个连续区域(通常是内存的起始端)，然后更新所有相关的引用，确保引用指向的是对象的新地址</li>
<li><strong>优点：解决内存碎片问题，提高内存的利用率；缺点：时间长，耗性能(涉及对象的移动)</strong></li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JVM%E5%85%A5%E9%97%A8.assets/image-20240913172439486.png" alt="image-20240913172439486"></p>
<ul>
<li><strong>标记复制</strong><ul>
<li>内存空间被划分为两个大小相等的区域，假设为 From 和 To 区域。开始时，所有对象都分配在 From 中，To 空闲</li>
<li>当标记阶段完成后，垃圾回收器会<strong>将所有存活的对象从 From&#x2F;伊甸园 复制到 To 中，并进行寿命+1操作，然后交换 From 和 To</strong></li>
<li>适合年轻代，存活对象较少，复制的成本相对较低</li>
<li><strong>缺点：会占用双份的内存</strong></li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JVM%E5%85%A5%E9%97%A8.assets/image-20240913172518307.png" alt="image-20240913172518307"></p>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JVM%E5%85%A5%E9%97%A8.assets/image-20240913172526797.png" alt="image-20240913172526797"></p>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JVM%E5%85%A5%E9%97%A8.assets/image-20240913172535385.png" alt="image-20240913172535385"></p>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JVM%E5%85%A5%E9%97%A8.assets/image-20240913172542893.png" alt="image-20240913172542893"></p>
<ul>
<li><strong>总结</strong>：JVM 中这三种算法垃圾回收算法都是结合着一起使用，不会只使用一种</li>
</ul>
<h3 id="3-4-分代垃圾回收"><a href="#3-4-分代垃圾回收" class="headerlink" title="3.4 分代垃圾回收"></a>3.4 分代垃圾回收</h3><ul>
<li><strong>分代垃圾回收</strong><ul>
<li>JVM 协同三种算法进行垃圾回收的具体实现就是分代的垃圾回收机制，将<strong>堆内存分为老年代和新生代(包括伊甸园、幸存区from、幸存区to)</strong></li>
<li>长时间使用的放在老年代(回收频率低)，有些用的时间短的放在新生代(回收频率高)</li>
</ul>
</li>
<li><strong>分代垃圾回收的工作机制</strong><ul>
<li>创建的新对象默认会放在伊甸园，如果伊甸园放不下就会触发一次垃圾回收(新生代的垃圾回收一般被称为”Minor GC”)，然后根据可达性分析算法进行标记，执行标记复制算法，将伊甸园和from区中存活的对象复制到to区中，并将其寿命+1，然后回收伊甸园的对象，交换 from 和 to 的指针引用的指向，当幸存区的对象寿命超过了阈值(15)，晋升到老年代</li>
<li>如果新来的对象在伊甸园&#x2F;幸存区&#x2F;老年代都放不下，就会触发 “Full GC”</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JVM%E5%85%A5%E9%97%A8.assets/image-20240913172632578.png" alt="image-20240913172632578"></p>
<ul>
<li><p><strong>总结分代垃圾回收</strong></p>
<ul>
<li>对象首先分配在伊甸园区</li>
<li>新生代空间不足时触发 Minor GC，使用标记复制算法将伊甸园和from区存活的对象复制到to区，存活的对象年龄+1并且交换 from 和 to 指针</li>
<li>Minor GC 会引发 **stop the word(STW)**，暂停其他用户线程(因为回收过程中可能会导致对象地址的改变)，minor gc 暂停时间并不长(新生代大部分都是被回收，复制的存活的不多)</li>
<li>当对象寿命超过阈值时(最大15&#x3D;&gt;保存在对象的对象头中[4bit最大就是1111也就是15]&#x3D;&gt;不同垃圾回收器也不一样,也不一定到阈值了才晋升,可能空间不够了也晋升)，会晋升至老年代</li>
<li>当老年代空间不足，会先尝试触发 minor gc，如果之后空间仍然不足则触发 full gc，STW 时间更长，如果空间还是不够 &#x3D;&gt; out of memory error</li>
</ul>
</li>
<li><p><strong>案例演示垃圾回收过程</strong>：</p>
<ul>
<li>添加 <code>-XX:+PrintGCDetails -verbose:gc</code> 的参数可以查看垃圾回收的详细日志记录</li>
</ul>
<blockquote>
<p>新生代 10M &#x3D;&gt; 伊甸园:from:to &#x3D; 8:1:1<br>老年代 10M<br>图中的 total 没有算上 to 区的大小(因为 to 区要空着)</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JVM%E5%85%A5%E9%97%A8.assets/image-20240913172757606.png" alt="image-20240913172757606"></p>
<ul>
<li><strong>大对象如果一开始新生代都放不下，会先尝试直接放到老年代</strong>，如果还放不下，会触发 minor gc 和 full gc，还是不行就 OutOfMemoryError</li>
<li>java中某一个线程内发生了内存溢出异常，并不会导致整个java进程的结束</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JVM%E5%85%A5%E9%97%A8.assets/image-20240913173353913.png" alt="image-20240913173353913"></p>
<h3 id="3-5-垃圾回收器"><a href="#3-5-垃圾回收器" class="headerlink" title="3.5 垃圾回收器"></a>3.5 垃圾回收器</h3><blockquote>
<p>这块黑马视频讲的不太容易懂，参考下尚硅谷的 P176-185</p>
<p>同时参考下 <strong>书《深入理解Java虚拟机：JVM高级特性与最佳实践（第3版）》——周志明</strong></p>
</blockquote>
<ul>
<li><p><strong>垃圾回收器</strong></p>
<ul>
<li><p><strong>垃圾回收算法是方法论，垃圾回收器则是方法论的实践者</strong>；不同的垃圾回收器负责不同的区域，并采取不同的垃圾回收算法</p>
</li>
<li><p><strong>分类</strong>：</p>
<ul>
<li><strong>串行</strong>(单线程,适用于堆内存较小的)</li>
<li><strong>吞吐量优先</strong>(多线程,允许较长时间的 STW 事件以减少总的垃圾回收次数,进而减少垃圾回收的总时间)</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JVM%E5%85%A5%E9%97%A8.assets/image-20240913173529054.png" alt="image-20240913173529054"></p>
<ul>
<li><strong>响应时间优先</strong>(多线程,单次STW的时间最短,但可能会更频繁地触发垃圾回收,适用于延迟敏感的应用)</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JVM%E5%85%A5%E9%97%A8.assets/image-20240911140502885.png" alt="image-20240911140502885"></p>
<ul>
<li><strong>串行垃圾回收器 Serial</strong> <ul>
<li>开启参数：<code>-XX:+UseSerialGC=Serial+SerialOld</code></li>
<li>分为两个部分，Serial 工作在<strong>新生代(采用复制算法)<strong>，SerialOld 工作在</strong>老年代(采用标记整理算法)</strong></li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JVM%E5%85%A5%E9%97%A8.assets/image-20240913173404353.png" alt="image-20240913173404353"></p>
<ul>
<li><strong>并行的垃圾回收器-吞吐量优先 Parallel</strong> （Java8默认的 PS[新生代] 和 PO[老年代]）<ul>
<li>开启参数(1.8默认开启)：<code>-XX:+UseParallelGC</code>或<code>-XX:+UseParallelOldGC</code>（前者新生代后者老年代,开启一个另一个就连带开启，算法也是<strong>新生代复制，老年代标记整理</strong>）</li>
<li>控制线程数(默认开启,和CPU核数相关)：<code>-XX:ParallelGCThreads=n</code></li>
<li>目标是达到可控制的吞吐量，还可以通过设置参数达到自适应的条件策略，适合后台运算不需要太多交互的任务</li>
<li>并行垃圾回收 指的是垃圾回收器使用多个线程来执行垃圾回收工作，但在执行垃圾回收时，会完全暂停应用程序的所有线程(STW)</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JVM%E5%85%A5%E9%97%A8.assets/image-20240913173412117.png" alt="image-20240913173412117"></p>
<ul>
<li><p><strong>并发的垃圾回收器-响应时间优先（CMS）</strong></p>
<ul>
<li>开启参数：<code>-XX:UseConcMarkSweepGC</code></li>
<li>应用线程执行的同时，并发地(即在同一时间段内)执行部分垃圾回收工作，避免长时间的 STW 事件，适合对响应时间敏感的应用</li>
<li>使用的是<strong>标记清除算法</strong>，过程是：<ul>
<li><strong>初始标记</strong>(只标记GC Roots直接关联的对象,速度快)</li>
<li><strong>并发标记</strong>(遍历整个对象图,耗时长,但并发)，会产生浮动垃圾&#x2F;错标的情况<ul>
<li><strong>浮动垃圾</strong>：并发标记时标记对象是存活的，但因为用户线程的影响变为了垃圾对象</li>
<li><strong>错标</strong>：并发标记时标记对象是垃圾对象，但因为用户线程的影响变为了非垃圾对象</li>
<li>浮动垃圾无所谓，在下次垃圾回收的时候会把该垃圾回收即可；但是**”错标”会导致要使用的对象被回收了，所以接下来的”重新标记”阶段就是解决”错标”的问题！！**</li>
</ul>
</li>
<li><strong>重新标记</strong>(修正并发标记期间由于用户线程继续运作导致标记变动的记录)</li>
<li><strong>并发清理</strong>(用的清除,也是并发)</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JVM%E5%85%A5%E9%97%A8.assets/image-20240913173445561.png" alt="image-20240913173445561"></p>
<ul>
<li><strong>在初始标记和重新标记的时候会发生短暂的STW</strong></li>
<li>当 CMS 运行时，如果老年代内存不足且预留的空间不够分配新对象会导致并发失败，会先冻结用户线程,然后启动Serial Old来收集老年代</li>
<li><strong>缺点</strong>：产生内存碎片(导致提前触发full gc)、无法处理浮动垃圾(并发标记阶段用户线程又产生新的垃圾对象,CMS无法进行标记,这些对象就无法被及时回收)  &#x3D;&gt; JDK9废弃了</li>
</ul>
</li>
<li><p><strong>G1 垃圾回收器</strong>  </p>
<ul>
<li>JDK9 之后默认的垃圾回收器</li>
<li>将堆内存进行分区，优先回收垃圾最多的区间(Region)</li>
<li>优势：**兼具并行(多个GC线程同时工作)和并发(拥有与应用程序交替执行的能力)**；也是分代的(但空间上不要求连续,内存的回收以region为单位)；region之间是复制算法(但整体上看是标记整理,可以避免内存碎片)，大内存上有优势(内存小的时候和 CMS 差不多)</li>
<li>伊甸园空间耗尽则触发年轻代垃圾回收</li>
<li><strong>工作流程</strong>：<ul>
<li>**初始标记(STW)**：短暂停顿，标记 GC Roots 能直接关联到的对象</li>
<li>**并发标记(不会STW)**：与用户线程并发运行，可达性分析递归扫描堆中对象图，找出要回收的对象(通过写屏障的技术记录下会发生错标的对象)</li>
<li>**最终标记(STW)**：解决发生的错标问题，通过原始快照的算法解决，重新扫描被记录下来的灰色对象</li>
<li>**混合回收(STW-标记整理算法)**：<ul>
<li>根据G1跟踪生成的对于不同区的优先级列表，优先选择回收价值大的区</li>
<li>基于用户设定的 <strong>最大停顿时间(默认 200 毫秒)</strong> 生成回收计划，回收多个 Region，组成一个 <strong>回收集</strong></li>
<li>存活对象会被 <strong>复制到空闲的 Region</strong> 中，而旧的 Region 将被完全清空，因为涉及对象的移动，这一步需要 <strong>STW</strong></li>
</ul>
</li>
</ul>
<p>	</p>
</li>
<li><strong>与 CMS 比较</strong>：<ul>
<li><strong>回收算法</strong>：CMS 是 <strong>标记-清除</strong>，会产生内存碎片；G1 是 <strong>标记-整理</strong>，会进行内存压缩，避免碎片化，有利于程序长时间运行，在程序为大对象分配内存时不容易因无法找到连续内存空间而提前触发下一次收集</li>
<li><strong>内存占用</strong>：虽然G1和CMS都使用卡表来处理跨代引用，但G1的卡表实现更为复杂，而且堆中每个Region，都必须有一份卡表，这导致G1的记忆集（和其他内存消耗）可能会占整个堆容量的20%乃至更多的内存空间</li>
<li><strong>停顿时间</strong>：G1 支持用户设定最大停顿时间，具有更高的预测性，而 CMS 在老年代满时可能引发长时间的 Full GC</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="3-6-GC-相关参数"><a href="#3-6-GC-相关参数" class="headerlink" title="3.6 GC 相关参数"></a>3.6 GC 相关参数</h3><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JVM%E5%85%A5%E9%97%A8.assets/image-20240913173627895.png" alt="image-20240913173627895"></p>
<h3 id="补充：算法细节"><a href="#补充：算法细节" class="headerlink" title="补充：算法细节"></a>补充：算法细节</h3><h4 id="记忆集和卡表"><a href="#记忆集和卡表" class="headerlink" title="记忆集和卡表"></a>记忆集和卡表</h4><ul>
<li><strong>记忆集</strong>：一种用于记录从非收集区域指向收集区域的指针集合的抽象数据结构，用于记录跨代引用，减少 GC Roots 扫描范围</li>
<li><strong>卡表</strong>：是记忆集的一种实现形式，通过维护卡表记录内存区域的跨代引用情况<ul>
<li>在新生代上建立一个记忆集(Remembered Set)，把老年代划分成若干小块，标识出老年代的哪一块内存会存在跨代引用，如果当前某个card引用了新生代中的某对象，则这个card被称为脏card</li>
<li><strong>卡表元素何时变脏？</strong>&#x3D;&gt; 有其他分代区域中对象引用了本区域对象时，其对应的卡表元素就应该变脏，变脏时间点原则上应该发生在引用类型字段赋值的那一刻<ul>
<li>CMS中因为只需要维护一份卡表(老年代和新生代的引用问题),所以卡表的维护是同步的方式</li>
<li>G1中每一份region都需要持有一个Remembered Set(记忆集),卡表的维护较为繁琐，所以采取异步的方式(不会立即更新,会将脏卡的指令放到一个dirty card队列之中，将来由一个线程完成脏card的更新操作)</li>
</ul>
</li>
<li><strong>卡表元素如何变脏？</strong>&#x3D;&gt; HotSpot虚拟机里是通过写屏障（Write Barrier）技术维护卡表状态的</li>
</ul>
</li>
<li><strong>跨代引用问题</strong>：<ul>
<li><strong>分代垃圾回收</strong><ul>
<li>新生代对象可能被老年代对象引用，GC 在收集新生代时为了少量的跨代引用去扫描整个老年代并不划算</li>
<li>使用记忆集和卡表，在发生Minor GC时，只有包含了跨代引用的小块内存里的对象才会被加入到GCRoots进行扫描。避免了minor GC时需要对老年代全扫描一遍的低效</li>
</ul>
</li>
<li><strong>分区垃圾回收</strong>：<ul>
<li>将堆划分为多个大小相等的 <strong>Region</strong>，每个 Region 都有自己的记忆集，用于记录跨区域的引用，机制与分代垃圾回收相似</li>
<li>占用内存消耗更大</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="写屏障"><a href="#写屏障" class="headerlink" title="写屏障"></a>写屏障</h4><ul>
<li><p><strong>HotSpot 中通过”写屏障”的技术维护了卡表的更新状态</strong></p>
</li>
<li><p>写屏障可以看作<strong>在虚拟机层面对 “引用类型字段赋值” 这个动作的AOP切面，在引用对象赋值时会产生一个环绕（Around）通知</strong>，供程序执行额外的动作，也就是说赋值的前后都在写屏障的覆盖范畴内</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JVM%E5%85%A5%E9%97%A8.assets/image-20240911194844290.png" alt="image-20240911194844290"></p>
<ul>
<li>应用写屏障后，虚拟机就会为所有赋值操作生成相应的指令，一旦收集器在写屏障中增加了更新卡表操作，无论更新的是不是老年代对新生代对象的引用，每次只要对引用进行更新，就会产生额外的开销，不过这个开销与Minor GC时扫描整个老年代的代价相比还是低得多的</li>
<li><strong>应用</strong>：<ul>
<li>对卡表的状态的维护</li>
<li>在 <strong>并发标记阶段</strong> 记录根对象的引用变化(配合satb_mark_queue队列)，解决并发标记阶段的错标问题</li>
</ul>
</li>
</ul>
<h4 id="三色标记"><a href="#三色标记" class="headerlink" title="三色标记"></a>三色标记</h4><ul>
<li>想解决或者降低用户线程的停顿，就要先搞清楚为什么必须在一个能保障一致性的快照上才能进行对象图的遍历？</li>
<li>引入三色标记作为工具来辅助推导，把遍历对象图过程中遇到的对象，按照“是否访问过”这个条件标记成以下三种颜色：<ul>
<li>**黑色(不该被回收的对象)**：表示对象已经被垃圾收集器访问过，且这个对象的所有引用都已经扫描过。黑色的对象代表已经扫描过，它是安全存活的</li>
<li>**灰色(在该对象中找垃圾)**：表示对象已经被垃圾收集器访问过，但这个对象上至少存在一个引用还没有被扫描过</li>
<li>**白色(需要被回收的垃圾)**：表示对象尚未被垃圾收集器访问过，即代表不可达</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JVM%E5%85%A5%E9%97%A8.assets/image-20240911195722993.png" alt="image-20240911195722993"></p>
<ul>
<li><strong>对象消失问题</strong>：在并发标记过程中，用户线程可能会修改对象的引用关系，比如：<ul>
<li><strong>新增引用</strong>：原本被标记为黑色（安全存活）的对象突然引用了一个白色对象（还没被标记的对象）</li>
<li><strong>删除引用</strong>：灰色对象（正在扫描）突然不再引用某个白色对象</li>
<li>这些变化可能会导致垃圾回收器的标记过程出错，如：未标记的白色对象被错误回收，或者丢失了对已存在引用的对象的追踪</li>
</ul>
</li>
<li><strong>CMS和G1解决错标问题采用了三色标记法来辅助完成对对象状态的标记</strong>，解决并发标记时“对象消失问题”的两种方式：增量更新和原始快照 &#x3D;&gt; 都是通过写屏障实现的，在HotSpot虚拟机中，如CMS是基于增量更新来做并发标记的，G1、Shenandoah 则是用原始快照来实现<ul>
<li><strong>增量更新</strong>：在并发标记时，跟踪并标记新创建的引用。当用户线程修改对象引用时，系统会通过写屏障记录这些变化，确保在垃圾回收时不遗漏任何引用<ul>
<li>解决的是 <strong>黑色对象新增引用</strong> 导致的“错标”问题，通过写屏障记录新引用的白色对象，确保这些对象不会被错误地回收</li>
</ul>
</li>
<li><strong>原始快照</strong>：保持并发标记开始时的对象引用状态，即即使用户线程修改了引用，垃圾回收器仍然按照开始时的引用状态来标记。这种方式减少了对新引用的依赖，避免标记遗漏<ul>
<li>解决的是 <strong>灰色对象删除引用</strong> 导致的“错标”问题，通过写屏障保留最初的引用关系，确保原本引用的白色对象不会被漏标</li>
</ul>
</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th><strong>增量更新（CMS）</strong></th>
<th><strong>原始快照（G1）</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>关注新增引用</strong>：特别是黑色对象新增对白色对象的引用，需要重新扫描这些引用。</td>
<td><strong>关注删除引用</strong>：即使灰色对象删除了对某些白色对象的引用，依然按照原始快照继续标记。</td>
</tr>
<tr>
<td><strong>例子</strong>：黑色对象 A 新增了对白色对象 B 的引用，需要确保 B 不被误回收。</td>
<td><strong>例子</strong>：灰色对象 C 删除了对白色对象 D 的引用，D 仍然会被标记为存活对象。</td>
</tr>
<tr>
<td><strong>写屏障记录引用更新</strong>：跟踪对象引用新增的变化，确保垃圾回收不遗漏这些新增的白色对象。</td>
<td><strong>写屏障记录原始引用</strong>：即使引用关系发生变化，仍然按照并发标记开始时的快照继续标记。</td>
</tr>
<tr>
<td>主要避免因为 <strong>引用新增</strong> 导致对象漏标。</td>
<td>主要避免因为 <strong>引用删除</strong> 导致对象漏标。</td>
</tr>
</tbody></table>
<h2 id="4-垃圾回收调优"><a href="#4-垃圾回收调优" class="headerlink" title="4. 垃圾回收调优"></a>4. 垃圾回收调优</h2><blockquote>
<p>调优和应用、环境有关，因地制宜</p>
</blockquote>
<h3 id="4-1-GC-调优"><a href="#4-1-GC-调优" class="headerlink" title="4.1 GC 调优"></a>4.1 GC 调优</h3><ul>
<li><p><strong>调优领域</strong></p>
<ul>
<li><p>内存</p>
</li>
<li><p>锁竞争</p>
</li>
<li><p>cpu 占用</p>
</li>
<li><p>io</p>
</li>
</ul>
</li>
<li><p><strong>确定目标</strong></p>
<ul>
<li>低延迟(CMS，G1，ZGC)还是高吞吐(PS和PO)？</li>
</ul>
</li>
<li><p><strong>最快的GC是不发生GC</strong>，考虑思考几个问题</p>
<ul>
<li>是否加载太多数据到内存</li>
<li>数据表示是否太臃肿</li>
<li>是否存在内存泄漏，尝试用软弱引用或者考虑第三方缓存实现？</li>
</ul>
</li>
</ul>
<h3 id="4-2-新生代调优"><a href="#4-2-新生代调优" class="headerlink" title="4.2 新生代调优"></a>4.2 新生代调优</h3><blockquote>
<p>内存调优的点</p>
<ul>
<li>先检查代码由于自身问题可以优化的点</li>
<li>再进行内存调优，优先从新生代中调优…</li>
</ul>
</blockquote>
<ul>
<li><p><strong>新生代特点</strong>：</p>
<ul>
<li>所有new操作的内存分配非常廉价 &#x3D;&gt; 创建对象效率高<ul>
<li>**TLAB(thread-local allocation buffer)**：加速 <strong>对象分配</strong>，避免多线程之间对共享内存区域(Eden 区)的竞争和锁定开销<ul>
<li>每一个线程都会在伊甸园中给它分配一个私有的区域 TLAB</li>
<li>每次new一个对象，会检查TLAB缓冲区中有没有足够的空间来分配对象，如果有，会优先在这个区域里面进行对象内存分配，否则 JVM 会重新分配一个新的 TLAB 或者从 Eden 区的共享部分为对象分配内存</li>
<li>对象分配也会有线程安全问题，TLAB作用就是让每个线程用自己私有的这块伊甸园内存来进行对象分配</li>
</ul>
</li>
</ul>
</li>
<li>死亡对象回收代价是零 &#x3D;&gt; 复制算法</li>
<li>大部分对象用过即死</li>
<li>minor gc 时间远低于 full gc</li>
</ul>
</li>
<li><p>新生代空间太小会导致多次的 minor gc(多次的 STW)，太大会导致老年代空间小，容易触发 full gc(更长的 STW)，oracle 推荐新生代空间占堆的 25%-50% 之间</p>
</li>
<li><p>幸存区大到要能保留【当前活跃对象+需要晋升的对象】</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JVM%E5%85%A5%E9%97%A8.assets/image-20240912092019491.png" alt="image-20240912092019491"></p>
<h3 id="4-3-老年代调优"><a href="#4-3-老年代调优" class="headerlink" title="4.3 老年代调优"></a>4.3 老年代调优</h3><ul>
<li>以 CMS 为例，老年代内存越大越好(避免CMS的产生的浮动垃圾过多而导致的并发失败)<ul>
<li>先尝试不调老年代，再尝试新生代，除非还是有很多 full gc</li>
</ul>
</li>
</ul>
<h2 id="5-类加载和字节码技术"><a href="#5-类加载和字节码技术" class="headerlink" title="5. 类加载和字节码技术"></a>5. 类加载和字节码技术</h2><ul>
<li>在类加载器加载class文件到JVM虚拟机中，虚拟机中执行引擎的解释器会对jvm指令解释，解释阶段也会对一些代码进行”即使编译处理”，就是在虚拟机中是”解释+编译”</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JVM%E5%85%A5%E9%97%A8.assets/image-20240912092746712.png" alt="image-20240912092746712"></p>
<h3 id="5-1-类文件结构"><a href="#5-1-类文件结构" class="headerlink" title="5.1 类文件结构"></a>5.1 类文件结构</h3><blockquote>
<p>执行 <code>javac -parameters -d . HelloWorld.java</code> 编译java类</p>
<p>得到 class 文件，<code>od -t xC HelloWorld.class</code></p>
</blockquote>
<ul>
<li><strong>规范</strong>：魔数(前4个字节)、Class文件版本、常量池信息、访问标志、类索引,父类索引,接口索引集合、字段表集合、方法表集合、属性表集合</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JVM%E5%85%A5%E9%97%A8.assets/image-20240912092939463.png" alt="image-20240912092939463"></p>
<ul>
<li><strong>魔数</strong>：0-3字节，表示它是否是合法的 class 类型文件，java 的类的魔数：<code>ca fe ba be</code></li>
<li><strong>版本</strong>：4-7字节，表示类的版本，小版本和主版本各占俩字节，主要是后者，34(16进制)&#x3D;&gt;56 代表 JDK8</li>
<li><strong>常量池</strong>：8-9字节，表示常量池有几项，从1开始记录，如 <code>00 23</code> 表示十进制的 <code>35</code>，故有 <code>#1-#34</code> 共 34 项，后续就是这 34 项，(1个字节代表方法信息，后几个字节代表引用了常量池中的第几项来获得该方法的所属类和方法名)</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JVM%E5%85%A5%E9%97%A8.assets/image-20240912094143058.png" alt="image-20240912094143058"></p>
<h3 id="5-2-反编译-class-文件"><a href="#5-2-反编译-class-文件" class="headerlink" title="5.2 反编译 class 文件"></a>5.2 反编译 class 文件</h3><blockquote>
<p>使用 javap 工具反编译 class 文件</p>
</blockquote>
<ul>
<li>使用方式：<code>javap -v HelloWorld.class</code> （<code>-v</code> 表示输出类文件的详细信息）</li>
<li><strong>分析运行流程</strong>：<ul>
<li>**常量池载入运行时常量池(方法区的一部分)**：将class文件常量池中的信息载入方法区中的运行时常量池，并在解析阶段将符号引用转换为直接引用</li>
<li><strong>方法字节码载入方法区</strong>：小的数字和字节码指令存一起，超过 short 范围的数字存入常量池</li>
<li><strong>main 线程运行，分配栈帧内存</strong>：<code>.class</code> 文件中的 <code>stack</code> 和 <code>locals</code> 值代表了 <strong>方法的栈帧</strong> 中的 <strong>最大操作数栈深度</strong> 和 <strong>局部变量表的大小</strong>。这些信息由编译器在编译时确定(编译器基于方法的代码分析得出)，并在运行时用于分配栈帧资源</li>
<li><strong>执行引擎开始执行字节码</strong></li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JVM%E5%85%A5%E9%97%A8.assets/image-20240912100420482.png" alt="image-20240912100420482"></p>
<h3 id="5-3-构造方法"><a href="#5-3-构造方法" class="headerlink" title="5.3 构造方法"></a>5.3 构造方法</h3><ul>
<li><p><strong>字节码指令 <code>&lt;cinit&gt;()V</code></strong> </p>
<ul>
<li><strong>类构造器方法</strong>，用于初始化类变量和执行静态代码块</li>
<li><code>&lt;cinit&gt;()V</code> 方法会在类加载的初始化阶段被调用</li>
<li>编译器会按照从上至下的顺序，收集所有 static 静态代码块和静态成员复制的代码，合并成一个特殊的方法 <code>&lt;cinit&gt;()V</code></li>
<li>方法是类级别的，只执行一次，当类被首次使用时触发（如首次创建实例、访问静态字段、调用静态方法等）</li>
</ul>
</li>
<li><p><strong>字节码指令 <code>&lt;init&gt;()V</code></strong></p>
<ul>
<li><strong>对象构造器方法</strong>，通常是你在 Java 代码中定义的构造函数，以及任何实例初始化代码块（非静态代码块）和字段初始化表达式（确保了每个对象构造时其字段按照程序员的意图被正确初始化）</li>
<li>每次创建类的新实例时，<code>&lt;init&gt;()V</code> 方法都会被调用</li>
<li>编译器会按照从上至下的顺序，收集所有 {} 代码块和成员变量赋值的代码，形成新的构造方法，但原始构造方法内的代码总是在最后</li>
<li>方法是对象级别的，每创建一个实例就会调用一次</li>
</ul>
</li>
<li><p><strong>举例</strong>：</p>
<ul>
<li><strong>类初始化阶段（只一次）</strong><ul>
<li><code>staticValue = 10;</code></li>
<li><code>staticValue = 20;</code> (静态代码块)</li>
</ul>
</li>
<li><strong>每次实例化时</strong><ul>
<li><code>instanceValue = 100;</code> (实例变量初始化)</li>
<li><code>instanceValue = 200;</code> (实例初始化块)</li>
<li><code>instanceValue = 300;</code> (构造器)</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">staticValue</span> <span class="operator">=</span> <span class="number">10</span>;    <span class="comment">// 静态变量初始化</span></span><br><span class="line">    <span class="keyword">static</span> &#123;                        <span class="comment">// 静态初始化块</span></span><br><span class="line">        staticValue = <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="variable">instanceValue</span> <span class="operator">=</span> <span class="number">100</span>;        <span class="comment">// 实例变量初始化</span></span><br><span class="line">    &#123;                               <span class="comment">// 实例初始化块</span></span><br><span class="line">        instanceValue = <span class="number">200</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyClass</span><span class="params">()</span> &#123;              <span class="comment">// 构造器</span></span><br><span class="line">        instanceValue = <span class="number">300</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-4-字节码指令解释"><a href="#5-4-字节码指令解释" class="headerlink" title="5.4 字节码指令解释"></a>5.4 字节码指令解释</h3><ul>
<li><p><code>istore</code>：将栈顶 int 类型的值弹出，并存储到局部变量表中的指定索引位置</p>
<ul>
<li><strong>使用场景</strong>：在方法执行中，对于基本类型的局部变量赋值操作，如将计算结果保存到一个局部变量中</li>
</ul>
</li>
<li><p><code>astore</code>：将栈顶引用类型的值弹出，并存储到局部变量表中的指定索引位置</p>
<ul>
<li>用于对象和数组类型的局部变量赋值，例如将一个对象引用存储到局部变量中</li>
</ul>
</li>
<li><p><code>aload</code>：从局部变量表中加载一个引用类型的值到操作数栈顶</p>
<ul>
<li><strong>使用场景</strong>：在需要使用局部变量表中的对象或数组时，如访问对象的成员或调用方法前</li>
</ul>
</li>
<li><p><code>bipush</code>：将一个 byte 类型的立即数（即直接指定的数值）压入至栈顶</p>
<ul>
<li><strong>使用场景</strong>：通常用于小范围的整数值赋值，如循环计数器的初始化。因为 <code>bipush</code> 可以直接将一个小整数（-128 到 127）推送到栈顶，常用于需要小整数的场景</li>
</ul>
</li>
</ul>
<h3 id="5-5-方法调用和多态原理"><a href="#5-5-方法调用和多态原理" class="headerlink" title="5.5 方法调用和多态原理"></a>5.5 方法调用和多态原理</h3><ul>
<li><p><strong>私有方法和 <code>final</code> 方法</strong> 使用 <code>invokespecial</code> 进行调用，因为它们在编译时已经确定，采用静态绑定</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">0</span>: <span class="keyword">new</span>           #<span class="number">3</span> <span class="comment">// class MyClass</span></span><br><span class="line"> <span class="number">3</span>: dup</span><br><span class="line"> <span class="number">4</span>: invokespecial #<span class="number">1</span> <span class="comment">// Method MyClass.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line"> <span class="number">7</span>: aload_1</span><br><span class="line"> <span class="number">8</span>: invokespecial #<span class="number">2</span> <span class="comment">// Method MyClass.privateMethod:()V</span></span><br><span class="line"><span class="number">11</span>: <span class="keyword">return</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>公共方法</strong> 使用 <code>invokevirtual</code> 进行调用，采用动态绑定，支持多态，运行时根据实际类型决定调用的具体实现</p>
<ul>
<li><strong>多态原理</strong>：每个类都有一个虚方法表 <code>vtable</code>，存储在类结构中，包含了指向类中所有虚方法的直接引用(虚方法是那些可能会被子类重写的方法)；<strong>虚方法表</strong> 通常是在类加载的 <strong>链接阶段</strong> (解析之后)生成的；类似 C++ 使用虚函数表来实现多态</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JVM%E5%85%A5%E9%97%A8.assets/image-20240912111357605.png" alt="image-20240912111357605"></p>
</li>
<li><p><strong>静态方法</strong> 使用 <code>invokestatic</code>，因为它不依赖对象实例，属于类级别的调用。使用对象调用静态方法时，JVM 需要先加载对象引用，会多出两条不必要的指令，因此推荐使用 <strong>类名</strong> 调用静态方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对象引用调用静态方法（不推荐）</span></span><br><span class="line"><span class="number">0</span>: <span class="keyword">new</span>           #<span class="number">3</span> <span class="comment">// class MyClass</span></span><br><span class="line"><span class="number">3</span>: dup</span><br><span class="line"><span class="number">4</span>: invokespecial #<span class="number">1</span> <span class="comment">// Method MyClass.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 两条多余指令</span></span><br><span class="line"><span class="number">7</span>: aload_1        <span class="comment">// 加载对象引用</span></span><br><span class="line"><span class="number">8</span>: pop            <span class="comment">// 弹出对象引用，因为静态方法不需要它</span></span><br><span class="line"></span><br><span class="line"><span class="number">9</span>: invokestatic   #<span class="number">2</span> <span class="comment">// Method MyClass.staticMethod:()V</span></span><br><span class="line"><span class="number">12</span>: <span class="keyword">return</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="5-6-异常处理"><a href="#5-6-异常处理" class="headerlink" title="5.6 异常处理"></a>5.6 异常处理</h3><ul>
<li><p><strong>异常表</strong>：当Java代码中包含<code>try-catch</code>结构时，编译器会在字节码中生成一个异常表。这个表里面记录了：</p>
<ul>
<li>哪些区域的代码是<code>try</code>块（哪行开始，哪行结束）</li>
<li>如果在这些区域中抛出异常，应该跳转到哪个位置去处理这个异常</li>
<li>每种异常类型对应的处理代码在哪里</li>
</ul>
</li>
<li><p><strong>多个 catch 块</strong>：当一个<code>try</code>块后面跟着多个<code>catch</code>块时：</p>
<ul>
<li>如果异常发生，JVM会查看异常表，找到第一个匹配的<code>catch</code>块，然后跳转到那里去执行</li>
<li>这些<code>catch</code>块通常会共用一些局部变量槽位。比如，多个<code>catch</code>块可能都会有一个用来存储异常信息的局部变量。这是一种内存优化手段，避免为每个<code>catch</code>块分配新的存储空间</li>
</ul>
</li>
<li><p><strong>multi-catch</strong>：在 Java 7 及以上版本，可以使用一个 catch 块捕获多种类型的异常，如<code> catch (IOException | SQLException ex)</code></p>
</li>
<li><p><strong>finally 块</strong>：确保无论 try 块是否抛出异常，finally 块中的代码都会被执行</p>
<ul>
<li><strong>实现原理</strong>：在字节码中，<code>finally</code> 块的代码被<strong>复制</strong>到每个可能的退出路径上(确保了无论是<code>try</code>块、<code>catch</code>块正常返回还是抛出异常，<code>finally</code> 块的代码都会被执行)。具体来说，<code>finally</code> 块的代码被复制了<strong>三份</strong>：<ul>
<li>一份在 <code>try</code> 块<strong>正常执行完毕</strong>后执行</li>
<li>一份在 <code>catch</code> 块处理完异常后执行</li>
<li>一份在 <code>catch</code> 处理不到的剩余异常（<code>any</code> 类型）时执行</li>
</ul>
</li>
<li><strong>注意</strong>：<ul>
<li>**不要在<code>finally</code>块中使用<code>return</code>**：方法会在执行 <code>finally</code> 块的 <code>return</code> 之后直接返回，而抛出的异常会被忽略掉(控制台不会看到异常抛出)</li>
<li><strong><code>finally</code>中的变量赋值不影响返回值</strong>：如果在<code>try</code>块中有一个<code>return</code>语句，而<code>finally</code>块中修改了该返回值，这个修改不会影响方法的实际返回值。因为执行时先把返回结果暂存，等finally执行完了再把暂存结果返回(恢复到栈顶)，所以最后返回的还是 try 块执行时已经存储的值，不影响返回结果</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="5-7-synchronized"><a href="#5-7-synchronized" class="headerlink" title="5.7 synchronized"></a>5.7 synchronized</h3><blockquote>
<p>从字节码的角度分析 synchronized 代码块</p>
<p>方法级别的 synchronized 不会体现在字节码中</p>
<p>这里是对象级别的 synchronized</p>
</blockquote>
<ul>
<li><p>先 new 对象，并复制(dup指令)了一份该对象的引用</p>
<ul>
<li>一份用于调用构造方法(会消耗一个引用)，一份存储到局部变量表中</li>
</ul>
</li>
<li><p>new 对象后将锁对象的引用加载到操作数栈顶</p>
<ul>
<li>再次复制一份该对象的引用，一个给加锁指令 monitorenter 用，一个给解锁指令 monitorexit 用</li>
</ul>
</li>
<li><p>加锁之后，当代码块中代码执行完毕，如果没有异常，则再执行monitorexit 来给对象解锁；如果代码块中出现了异常，会通过”异常表”也会进行解锁</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JVM%E5%85%A5%E9%97%A8.assets/image-20240912140006491.png" alt="image-20240912140006491"></p>
<h3 id="5-8-语法糖"><a href="#5-8-语法糖" class="headerlink" title="5.8 语法糖"></a>5.8 语法糖</h3><blockquote>
<p>语法糖：java 编译器将源码 .java 文件编译为 .class 字节码的过程中自动生成和转换的代码，目的是减轻程序员编码负担</p>
</blockquote>
<ul>
<li><strong>默认构造器</strong>：若本身代码没实现构造器，编译后默认生成的构造方法里调用 super() 的无参构造方法</li>
<li><strong>自动拆装箱</strong>：JDK5 后 java 的基本类型和包装类型的自动转换</li>
<li><strong>泛型集合取值</strong>：JDK5 后的泛型，java 在编译泛型代码会有<strong>泛型擦除</strong>的动作，即泛型信息在编译为字节码后就丢失了，实际的类型都当作了 Object 类型处理<ul>
<li>泛型是为了编译期间的类型检查，泛型擦除是为了便于字节码处理(方便向下兼容)</li>
<li>通过反射只可以拿到方法返回值和方法参数上的泛型信息，其他地方的泛型信息都会被”泛型擦除”</li>
</ul>
</li>
<li><strong>可变参数</strong>：如编译器会在编译期间把参数从 <code>String... args</code> 变为 <code>String[] args</code></li>
<li><strong>foreach 循环</strong>：如果遍历数组，会被编译器转换为 for 循环；如果遍历集合，会被转换成对迭代器的调用</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JVM%E5%85%A5%E9%97%A8.assets/image-20240912145244637.png" alt="image-20240912145244637"></p>
<ul>
<li><p><strong>switch</strong>：JDK7 开始 switch 可以作用于字符串和枚举类</p>
<ul>
<li><p>对 String 的支持，转换后的代码：</p>
<ul>
<li>执行了两遍 switch，第一遍根据字符串的 hashCode 和 equals 将字符串转换为相应 byte 类型，第二遍利用 byte 进行 switch 判断比较</li>
<li>先比较 hashCode 是为了提高比较效率，再比较 equals 是为了防止哈希冲突（因为hashCode相等不代表两个对象相同）</li>
</ul>
</li>
<li><p>对 enum 的支持，转换后的代码：</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JVM%E5%85%A5%E9%97%A8.assets/image-20240912150334768.png" alt="image-20240912150334768"></p>
</li>
<li><p><strong>枚举类</strong>：</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JVM%E5%85%A5%E9%97%A8.assets/image-20240912150506659.png" alt="image-20240912150506659"></p>
<ul>
<li><p><strong>try-with-resources</strong>：JDK7 引入的用于简化资源的关闭，省略 finally 块，前提是资源对象需要实现 <code>AutoCloseable</code> 接口</p>
<ul>
<li>代码示例</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JVM%E5%85%A5%E9%97%A8.assets/image-20240912151100950.png" alt="image-20240912151100950"></p>
<ul>
<li>转换后：不管是自己代码的异常还是关闭资源的异常，只要有就都会抛出</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JVM%E5%85%A5%E9%97%A8.assets/image-20240912151206091.png" alt="image-20240912151206091"></p>
</li>
<li><p><strong>方法重写时的桥接方法</strong>：方法重写时对返回值分两种情况</p>
<ul>
<li>父子类返回值类型一致</li>
<li>子类返回值可以是父类返回值的子类</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JVM%E5%85%A5%E9%97%A8.assets/image-20240912152318986.png" alt="image-20240912152318986"></p>
<ul>
<li><strong>匿名内部类</strong>：编译时额外生成了一个类，如果匿名内部类引用了局部变量，那么编译时生成的类里会新增一个属性，通过构造方法参数传入<ul>
<li>所以语法上匿名内部类引用局部变量时，局部变量必须是 final 的，因为底层内部类里的属性没有机会跟着一起变动，保证一致性</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JVM%E5%85%A5%E9%97%A8.assets/image-20240912152813205.png" alt="image-20240912152813205"></p>
<h2 id="6-类加载阶段"><a href="#6-类加载阶段" class="headerlink" title="6. 类加载阶段"></a>6. 类加载阶段</h2><blockquote>
<p>加载、链接、初始化</p>
</blockquote>
<h3 id="6-1-加载"><a href="#6-1-加载" class="headerlink" title="6.1 加载"></a>6.1 加载</h3><blockquote>
<p>方法区中的二进制字节码元数据(c++中一个数据结构,用来描述java类的)  和  堆中class类对象xxx.class</p>
</blockquote>
<ul>
<li>java 类编译成 class 字节码后，想要运行，需要通过 <strong>类加载器 把类的字节码加载到方法区中</strong>(底层用的 C++ 的 instanceKlass 描述 Java 类)<ul>
<li>instanceKlass 存储在方法区(1.8后也就是在元空间)，其包含的属性包括 <code>_java_mirror</code> 和类的一些其他信息 </li>
<li><code>_java_mirror</code> 是 Java 的类镜像(相当于桥梁，java 只能通过这个镜像来访问类的一些信息 &#x3D;&gt; 存储在堆中)，其实就是堆中的 Class类对象，如对于 String 类来说，<code>_java_mirror</code> 就是 <code>String.class</code></li>
<li>可以理解为 <strong>堆中的class对象是方法区中该类二进制字节码元数据的镜像</strong></li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JVM%E5%85%A5%E9%97%A8.assets/image-20240912154518799.png" alt="image-20240912154518799"></p>
<ul>
<li>如果这个类还有父类没有加载，会先加载父类</li>
<li>加载和链接可能是交替运行的</li>
</ul>
<h3 id="6-2-链接"><a href="#6-2-链接" class="headerlink" title="6.2 链接"></a>6.2 链接</h3><blockquote>
<p>验证、准备、解析</p>
</blockquote>
<ul>
<li><strong>验证</strong>：验证类是否符合 JVM 字节码规范 和 安全性检查(是否会对jvm虚拟机造成伤害)，比如魔数啥的是否正确</li>
<li><strong>准备</strong>：为静态变量开辟内存空间并设置默认值<ul>
<li>JDK8 后静态变量和class类对象(java_mirror)存储在一起，都是存储在堆中（JDK8 之前存储在方法区中的二进制元数据instanceKlass中）</li>
<li>静态变量分配空间和复制是两个步骤，分配空间在准备阶段完成，赋值在初始化阶段完成，但<ul>
<li>如果静态变量是 final 的基本类型以及字符串常量，那么编译阶段值就确定了，赋值就在准备阶段完成</li>
<li>如果静态变量是 final 的引用类型(new 出来的)或者包装类型，那么赋值还是推迟到初始化阶段完成</li>
</ul>
</li>
</ul>
</li>
<li><strong>解析</strong>：将运行时常量池中符号引用解析为直接引用(能确切知道类&#x2F;方法&#x2F;属性在内存中的位置)</li>
</ul>
<h3 id="6-3-初始化"><a href="#6-3-初始化" class="headerlink" title="6.3 初始化"></a>6.3 初始化</h3><blockquote>
<p>执行 clinit() 方法的过程，会将自己给静态变量赋值语句和静态代码块拼接起来组成 clinit() 方法</p>
<p> <code>&lt;clinit&gt;()</code> 代表 “class initialization method”，即类初始化方法</p>
</blockquote>
<ul>
<li><strong>触发的时机</strong>：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JVM%E5%85%A5%E9%97%A8.assets/image-20240912161444041.png" alt="image-20240912161444041"></p>
<ul>
<li><strong>类加载阶段的前两个阶段是会执行的，但是初始化阶段并不一定会被执行</strong><ul>
<li>当 JVM 开始加载某个类时，<strong>加载</strong> 和 <strong>链接</strong> 阶段会自动进行，这些是类加载过程的必要步骤</li>
<li><strong>初始化</strong> 阶段只有在<strong>类被主动使用</strong>时才会触发。如果一个类被加载到 JVM，但从未主动使用，那么类的初始化阶段（包括静态变量的赋值和静态代码块的执行）可能永远不会发生，JVM 规范中定义了<strong>类的主动使用</strong>场景，例如：<ul>
<li>创建类的实例</li>
<li>访问类的静态字段（非常量静态字段）</li>
<li>调用类的静态方法</li>
<li>反射使用这个类</li>
<li>子类初始化时会初始化父类</li>
</ul>
</li>
</ul>
</li>
<li><strong>练习-利用静态内部类的初始化机制实现懒汉式的单例模式</strong>：(线程安全)<ul>
<li>**<code>main</code> 方法调用 <code>getInstance()</code>**：在 <code>main</code> 方法中调用 <code>Singleton.getInstance()</code> 时，JVM 开始查找 <code>Singleton</code> 类中的静态方法 <code>getInstance()</code></li>
<li><strong>类的初始化触发</strong>：<ul>
<li>因为访问了 <code>Singleton</code> 类的静态方法（<code>getInstance()</code>），这会触发 <strong><code>Singleton</code> 类的加载和初始化</strong></li>
<li>但此时，<strong>静态内部类 <code>SingletonHolder</code> 还没有被加载</strong>，因为 <code>SingletonHolder</code> 只会在首次使用时才被加载（即懒加载）</li>
</ul>
</li>
<li><strong>调用 <code>getInstance()</code></strong> 方法：<ul>
<li><code>getInstance()</code> 方法返回的是 <code>SingletonHolder.INSTANCE</code>，这就触发了 <strong><code>SingletonHolder</code> 静态内部类的加载和初始化</strong></li>
</ul>
</li>
<li><strong>加载 <code>SingletonHolder</code> 类</strong>：<ul>
<li>在 <code>SingletonHolder</code> 被加载时，它的静态成员 <code>INSTANCE</code>（<code>Singleton</code> 类的唯一实例）会被初始化。这是单例实例创建的时刻</li>
<li>JVM 会自动执行 <code>SingletonHolder</code> 类中的静态代码块或静态成员初始化，因此 <strong><code>INSTANCE</code> 会被创建</strong></li>
</ul>
</li>
<li><strong>返回单例实例</strong>：<ul>
<li>现在，<code>getInstance()</code> 方法返回 <code>SingletonHolder.INSTANCE</code>，这就是 <code>Singleton</code> 类的唯一实例</li>
<li>因为静态成员 <code>INSTANCE</code> 是在 <code>SingletonHolder</code> 被加载时创建的，并且只会初始化一次，所以无论你调用 <code>getInstance()</code> 多少次，返回的都是同一个实例</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JVM%E5%85%A5%E9%97%A8.assets/image-20240912171116449.png" alt="image-20240912171116449"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">// 私有构造函数，防止外部实例化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态内部类负责持有 Singleton 的唯一实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonHolder</span> &#123;</span><br><span class="line">        <span class="comment">// 在内部类被加载和初始化时，创建单例实例</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 公共静态方法，供外界获取单例实例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主函数，演示单例模式的调用</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取 Singleton 的实例</span></span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">instance1</span> <span class="operator">=</span> Singleton.getInstance();</span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">instance2</span> <span class="operator">=</span> Singleton.getInstance();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查两次获取的是否为同一个实例</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Instance 1 hash: &quot;</span> + instance1.hashCode());</span><br><span class="line">        System.out.println(<span class="string">&quot;Instance 2 hash: &quot;</span> + instance2.hashCode());</span><br><span class="line">        System.out.println(<span class="string">&quot;Same instance? &quot;</span> + (instance1 == instance2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>JVM 内部是如何保证一个类的静态代码块只会被执行一次？并且每个类只有一次？</strong><ul>
<li>类加载过程中的初始化阶段是执行 <code>clinit()</code> 方法的过程</li>
<li><strong><code>&lt;clinit&gt;()</code> 方法</strong>：静态变量初始化和静态代码块会被编译器合并成一个特殊的类初始化方法 <code>&lt;clinit&gt;()</code>，这个方法会在类加载的<strong>初始化阶段</strong>执行，并且只会被调用一次</li>
<li>当多个线程同时访问一个类的静态成员时，只有<strong>第一个访问该类的线程</strong>会触发类的加载和初始化，其他线程会被阻塞，等待初始化完成。JVM 在初始化类时对类加载过程进行加锁控制，以确保静态初始化代码（即 <code>&lt;clinit&gt;()</code> 方法）在多线程环境下的<strong>安全性</strong></li>
</ul>
</li>
</ul>
<h2 id="7-类加载器"><a href="#7-类加载器" class="headerlink" title="7. 类加载器"></a>7. 类加载器</h2><h3 id="7-1-概述"><a href="#7-1-概述" class="headerlink" title="7.1 概述"></a>7.1 概述</h3><ul>
<li><strong>向上委托，向下加载</strong>（先由下向上询问，再自上而下加载）</li>
<li><strong>父级加载器并不是父类加载器，并没有继承关系！！</strong></li>
<li>对于一个<strong>普通类的加载过程</strong>：<ul>
<li>先会自下而上去询问父级加载器是否加载过，加载过就终止，没有加载过就一直往父级询问</li>
<li>然后加载的时候自上而下的先寻找自己负责加载的目录下有没有该类，有该类的直接加载，没有就会让子加载器自己加载，从而保证类加载的安全性和类的唯一性</li>
</ul>
</li>
</ul>
<blockquote>
<p>启动类加载器、扩展类加载器、应用程序类加载器、自定义类加载器</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JVM%E5%85%A5%E9%97%A8.assets/image-20240912183244471.png" alt="image-20240912183244471"></p>
<ul>
<li><p><strong>启动类加载器</strong></p>
<ul>
<li><p>可以携带一些虚拟机启动参数设置”启动类加载器”来加载指定的类</p>
</li>
<li><p>获取加载当前class类对象的类加载器：<code>Class.forName(&quot;xxx.xx...&quot;).getClassLoader();</code></p>
</li>
<li><p>启动类加载器无法通过 java 代码直接获得，打印获得到的是null，因为这个加载器是由 c++ 写的</p>
</li>
</ul>
</li>
<li><p><strong>扩展类加载器</strong></p>
<ul>
<li>当你想让扩展类加载器加载一个类的时候，把该类打成jar包,然后放到 <code>Java_HOME/jre/lib/ext</code> 目录下</li>
<li>扩展类加载器就会加载这个目录下的jar包类，这样就轮不到应用程序类加载器来加载了</li>
</ul>
</li>
</ul>
<h3 id="7-2-双亲委派模式"><a href="#7-2-双亲委派模式" class="headerlink" title="7.2 双亲委派模式"></a>7.2 双亲委派模式</h3><ul>
<li>双亲委派指的是调用类加载器的 <code>loadClass</code> 方法时<strong>查找类的规则</strong></li>
<li><strong>源码分析</strong>：<ul>
<li><code>loadclass()</code>：<ul>
<li>当某个类加载器收到类加载请求时，它首先不会自己去加载，而是将请求委托给父加载器的 <code>loadClass()</code> 方法</li>
<li>递归调用父级加载的loadClass()方法来委托父级来进行加载</li>
</ul>
</li>
<li><code>findclass()</code>：如果父加载器找不到类，当前的类加载器会调用自己的 <code>findClass()</code> 方法，尝试加载这个类</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JVM%E5%85%A5%E9%97%A8.assets/image-20240912190620066.png" alt="image-20240912190620066"></p>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JVM%E5%85%A5%E9%97%A8.assets/image-20240912190637001.png" alt="image-20240912190637001"></p>
<ul>
<li><strong>好处</strong>：<ul>
<li><strong>安全性</strong>：防止自定义类加载器加载与核心类库同名的类，防止类篡改。例如，你不能通过自定义类加载器去加载一个伪造的 <code>java.lang.String</code> 类</li>
<li><strong>避免重复加载</strong>：通过委派机制，每个类只会被加载一次。如果类已经被某个父级加载器加载，子加载器就不再重新加载同一个类，避免了类的重复加载</li>
</ul>
</li>
</ul>
<h3 id="7-3-线程上下文类加载器"><a href="#7-3-线程上下文类加载器" class="headerlink" title="7.3 线程上下文类加载器"></a>7.3 线程上下文类加载器</h3><ul>
<li><p><strong>SPI（Service Provider Interface）</strong></p>
<ul>
<li><p><strong>目的</strong>：允许第三方提供类和接口的具体实现，这些实现可以在运行时被替换或添加，提供了极高的可扩展性</p>
</li>
<li><p><strong>工作原理</strong>：</p>
<ul>
<li><strong>定义服务接口</strong>：首先定义一个服务接口，这是服务提供者和服务消费者共同遵守的合同</li>
<li><strong>服务提供者实现接口</strong>：服务提供者根据定义好的接口实现具体的服务</li>
<li><strong>注册服务实现</strong>：服务提供者在自己的 JAR 文件中通过配置文件声明服务实现。这个配置文件通常位于 <code>META-INF/services</code> 目录下，并以服务接口的全限定类名命名。文件内容包含实现该服务接口的具体类的全限定名</li>
<li><strong>服务加载</strong>：使用 <code>ServiceLoader</code> 类，应用程序可以加载这些服务。<code>ServiceLoader</code> 读取配置文件，然后使用当前线程的上下文类加载器加载这些实现类</li>
</ul>
</li>
<li><p><strong>举例说明</strong>：</p>
<ul>
<li>在 JDBC 的案例中，服务接口是 <code>java.sql.Driver</code>。这是 Java 提供的一个接口，所有的 JDBC 驱动都必须实现这个接口，以便能被 <code>java.sql.DriverManager</code> 管理和使用</li>
<li>每个 JDBC 驱动的 JAR 文件中，会包含一个特定的配置文件，位于 <code>META-INF/services</code> 目录下。对于 <code>java.sql.Driver</code> 接口，配置文件的名称会是：<code>META-INF/services/java.sql.Driver</code></li>
<li>这个文件内部会列出实现了 <code>java.sql.Driver</code> 授课的具体类的全限定名。例如，如果你有一个 MySQL 数据库驱动的 JAR，文件内容可能会是：<code>com.mysql.cj.jdbc.Driver</code></li>
<li>当应用程序启动时，或者当你需要连接到数据库时，<code>DriverManager</code> 会尝试加载这些驱动。它会使用 <code>ServiceLoader</code> 来查找和加载所有可用的 JDBC 驱动程序</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ServiceLoader&lt;Driver&gt; loader = ServiceLoader.load(Driver.class);</span><br><span class="line"><span class="keyword">for</span> (Driver driver : loader) &#123;</span><br><span class="line">    <span class="comment">// 这里可以访问到每个加载的驱动实例</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Loaded driver: &quot;</span> + driver.getClass().getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>当每个驱动类被 <code>ServiceLoader</code> 加载时，通常在它们的静态初始化块中，它们会自动将自己注册到 <code>DriverManager</code> 中。这通常是通过调用 <code>DriverManager.registerDriver()</code> 方法实现的</p>
</li>
<li><p>一旦驱动程序注册，你就可以通过 <code>DriverManager</code> 来获取数据库连接了：<code>Connection conn = DriverManager.getConnection(&quot;jdbc:mysql://example.com:3306/mydb&quot;, &quot;user&quot;, &quot;password&quot;);</code></p>
</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JVM%E5%85%A5%E9%97%A8.assets/image-20240912192208389.png" alt="image-20240912192208389"></p>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JVM%E5%85%A5%E9%97%A8.assets/image-20240912192214896.png" alt="image-20240912192214896"></p>
<ul>
<li><strong>以 JDBC 驱动程序加载为例</strong>：<ul>
<li><code>java.sql.DriverManager</code> 类负责管理数据库驱动程序的注册和连接，本身是由启动类加载器加载的，因为<code>java.sql</code> 包是 JDK 的标准 API 的一部分，位于 <code>rt.jar</code> 之中，这是 Java 的核心类库。因此，**<code>java.sql.DriverManager</code> 和其他 JDBC 核心接口位于启动类加载器的加载路径下**</li>
<li>但是 jdbc 的<strong>驱动是各个厂商来实现的，不在启动类加载路径下，启动类无法加载，而驱动管理需要用到这些驱动</strong></li>
<li>只能<strong>打破双亲委派，启动类直接请求启动类加载器去classpath下加载驱动</strong>（正常是向上委托，这个反过来了），而打破双亲委派的就是这个线程上下文类加载器</li>
</ul>
</li>
<li><strong>线程上下文类加载器的作用</strong>：<ul>
<li><strong>注册驱动</strong>：线程上下文类加载器用于在运行时加载外部驱动程序，这些驱动程序通常不是由 Java 系统类加载器加载的，因为它们不位于 Java 核心库的路径中</li>
<li>在java.sql.DriverManager被类加载(启动类加载器)的时候，该类的静态代码块中成对驱动的加载，但对驱动的加载并不是通过启动类加载器，而是利用java的SPI机制，先<strong>获取线程上下文类加载器，该加载器默认为应用程序加载器，然后<code>ServiceLoader.load()</code> 方法中会通过线程上下文类加载器来进行对驱动的加载</strong></li>
</ul>
</li>
<li>SPI 主要是为了解耦，允许服务接口的实现在运行时被动态加载和替换，而不需要修改原有的代码，使得应用程序可以插拔不同的服务实现 &#x3D;&gt; <strong>【面向接口编程+解耦】思想</strong></li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JVM%E5%85%A5%E9%97%A8.assets/image-20240912201119134.png" alt="image-20240912201119134"></p>
<h3 id="7-4-自定义类加载器"><a href="#7-4-自定义类加载器" class="headerlink" title="7.4 自定义类加载器"></a>7.4 自定义类加载器</h3><ul>
<li><strong>什么时候需要自定义类加载器</strong>：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JVM%E5%85%A5%E9%97%A8.assets/image-20240912202936863.png" alt="image-20240912202936863"></p>
<ul>
<li><strong>步骤</strong>：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JVM%E5%85%A5%E9%97%A8.assets/image-20240912203028421.png" alt="image-20240912203028421"></p>
<ul>
<li><strong>在 Java 中，类的唯一性由其全限定名（即包名和类名的组合）和加载它的类加载器共同决定</strong><ul>
<li>如果包名类名一样，但是类加载器对象不一样，就会被认为是不同的类，会被加载两次，是隔离的</li>
</ul>
</li>
</ul>
<h2 id="8-运行期优化"><a href="#8-运行期优化" class="headerlink" title="8. 运行期优化"></a>8. 运行期优化</h2><h3 id="8-1-逃逸分析"><a href="#8-1-逃逸分析" class="headerlink" title="8.1 逃逸分析"></a>8.1 逃逸分析</h3><blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/Herishwater/article/details/123780967">JVM系列之：关于逃逸分析的学习_cannot use jvmci compiler: no jvmci compiler found-CSDN博客</a></p>
<p>[逃逸分析]属于C2即时编译器优化手段的一种</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JVM%E5%85%A5%E9%97%A8.assets/image-20240913084340242.png" alt="image-20240913084340242"></p>
<ul>
<li><strong>原因分析</strong>：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JVM%E5%85%A5%E9%97%A8.assets/image-20240913084543858.png" alt="image-20240913084543858"></p>
<ul>
<li><strong>解释器和即时编译器(JIT-Just In Time Compiler)的区别</strong>：<ul>
<li>解释器每次遇到字节码都会一个字节一个字节解释成为机器码，下次遇到相同的字节码，还会解释执行</li>
<li>即时编译器会识别一些热点代码(字节码)，会将这些字节码编译为机器码并存入Code Cache，下次遇到相同代码，直接执行，无需再编译</li>
<li>解释器是将字节码解释为针对所有平台都通用的机器码</li>
<li>JIT 会根据平台类型，生成平台特定的机器码</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>编译器</strong>：在程序执行之前，将源代码一次性编译成字节码或机器码</p>
<p><strong>即时编译器（JIT 编译器）</strong>：在程序运行期间，将热点字节码编译为机器码，以提升运行时性能</p>
</blockquote>
<ul>
<li><strong>C1即时编译器和C2即时编译器优化程度不同</strong>：<ul>
<li><strong>[逃逸分析]是在C2即时编译器中做的优化！</strong></li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JVM%E5%85%A5%E9%97%A8.assets/image-20240913085229194.png" alt="image-20240913085229194"></p>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JVM%E5%85%A5%E9%97%A8.assets/image-20240913085248935.png" alt="image-20240913085248935"></p>
<ul>
<li><p><strong>逃逸分析(Escape Analysis)</strong> 并不是直接的优化手段，而是通过动态分析对象的作用域为其它优化手段提供依据的分析技术，用来分析一个对象的作用范围，判断该对象是否会<strong>逃逸</strong>出当前的作用域(如方法或线程)</p>
<ul>
<li>根据逃逸分析的结果，JVM 可以对对象的分配和垃圾回收进行优化，主要有以下几种典型的优化策略：<ul>
<li><strong>栈上分配</strong>：通常，Java 中的对象是在堆上分配内存的，但是如果通过逃逸分析确定对象没有逃逸出当前方法，那么 JVM 可以将对象直接分配在栈上而不是堆上。栈上的内存分配和回收比堆内存更快，也不需要垃圾回收的参与</li>
<li><strong>标量替换</strong>：如果逃逸分析表明对象可以完全分解成一组标量(如对象的属性)，并且这些标量可以在栈上分配，JVM 可以将对象分解为多个基本数据类型，而不需要真正创建对象。这种方式进一步减少了对象的分配和垃圾回收压力</li>
<li>**同步省略(锁消除)**：如果逃逸分析表明某个对象不会被其他线程访问，JVM 可以去掉不必要的同步代码。比如，在单线程方法中，如果对象只在当前线程中使用，JVM 可以认为不需要对该对象加锁，从而消除同步开销</li>
</ul>
</li>
<li>事实上，逃逸分析的结果更多被用于将新建对象操作转换成栈上分配或者标量替换</li>
</ul>
</li>
<li><p><strong>HotSpot JVM</strong> 并未真正实现 <strong>栈上分配</strong>，而是使用了 <strong>标量替换</strong></p>
<ul>
<li><strong>标量</strong>：不可再分割的基本数据类型，如 <code>int</code>、<code>float</code>、<code>boolean</code> 等</li>
<li><strong>聚合量</strong>：可以分割的数据结构，比如对象。一个对象由多个标量组成，比如一个 <code>Point</code> 对象有 <code>x</code> 和 <code>y</code> 两个 <code>int</code> 字段</li>
<li><strong>标量替换的原理</strong>：<ul>
<li>标量替换可以将原先对对象字段(聚合量)的访问,替换代替成为对一些局部变量(标量)的访问，就是将聚合量分解成为一个个标量，减少对象创建和垃圾回收的负担，提高了程序的执行效率</li>
<li>例如，如果你创建了一个 <code>Point</code> 对象，并且该对象没有逃逸，JVM 可以将 <code>Point</code> 的 <code>x</code> 和 <code>y</code> 字段作为局部变量直接在栈中存储，而无需真正创建 <code>Point</code> 对象</li>
</ul>
</li>
<li>默认情况下，<strong>标量替换</strong>是开启的，但你可以通过 JVM 参数（如 <code>-XX:-EliminateAllocations</code>）来禁用它</li>
</ul>
</li>
<li><p><strong>对象的内存分配策略</strong>：</p>
<ul>
<li><strong>优先在堆的伊甸园区分配</strong>：小对象通常会在堆的年轻代中（Eden 区）分配内存。这是默认的分配区域</li>
<li><strong>TLAB（Thread-Local Allocation Buffer）分配</strong>：如果开启了 TLAB（线程本地分配缓冲区），每个线程会有一个私有的小块内存（来自 Eden 区），用来加速对象的分配。这样可以减少多线程环境下的同步开销</li>
<li><strong>大对象直接分配到老年代</strong>：如果对象很大（通常是长数组或大数据结构），它会直接分配到堆的老年代，以避免年轻代垃圾回收的频繁触发</li>
<li><strong>逃逸分析和栈上分配</strong>：如果 JIT 编译器通过逃逸分析确定对象不会逃逸（即对象的生命周期局限于一个方法内），则理论上该对象可以直接分配在栈上，这样对象在方法结束时内存就会自动释放，无需依赖垃圾回收。不过在 HotSpot JVM 中，这种栈上分配通常通过标量替换的方式实现</li>
</ul>
</li>
</ul>
<h3 id="8-2-方法内联"><a href="#8-2-方法内联" class="headerlink" title="8.2 方法内联"></a>8.2 方法内联</h3><blockquote>
<p>[方法内联]也属于即时编译器优化手段的一种</p>
</blockquote>
<ul>
<li>内联就是把方法内代码拷贝粘贴到调用者的位置</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JVM%E5%85%A5%E9%97%A8.assets/image-20240913091234098.png" alt="image-20240913091234098"></p>
<ul>
<li><strong>代码示例</strong>：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JVM%E5%85%A5%E9%97%A8.assets/image-20240913091351334.png" alt="image-20240913091351334"></p>
<h3 id="8-3-字段优化"><a href="#8-3-字段优化" class="headerlink" title="8.3 字段优化"></a>8.3 字段优化</h3><ul>
<li>字段优化：主要是针对”成员变量”和”静态变量”读写操作的优化</li>
<li><strong>开启方法内联的情况下(默认开启)，会结合字段优化来优化</strong>：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JVM%E5%85%A5%E9%97%A8.assets/image-20240913093112752.png" alt="image-20240913093112752"></p>
<ul>
<li>**也可自己手动优化或编译器优化(foreach语法糖)**：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JVM%E5%85%A5%E9%97%A8.assets/image-20240913093313836.png" alt="image-20240913093313836"></p>
<ul>
<li><p><strong>补充</strong>：<strong>JMH（Java Microbenchmark Harness）</strong> 是一个专门用于 Java 语言的基准测试框架，用来准确地测量 Java 代码性能</p>
<ul>
<li><p><strong>关键注解</strong></p>
<ul>
<li><p>**<code>@Benchmark</code>**：标记基准测试方法。JMH 会运行这个方法多次，并统计其执行时间</p>
</li>
<li><p>**<code>@BenchmarkMode</code>**：指定测试模式，如吞吐量、平均时间、单次执行时间等</p>
</li>
<li><p>**<code>@OutputTimeUnit</code>**：指定测试结果的输出时间单位，如秒、毫秒、纳秒等</p>
</li>
<li><p>**<code>@State</code>**：指定基准测试的状态范围，可以是线程级、进程级等，确保对象在基准测试中的状态</p>
</li>
<li><p>**<code>@Warmup</code>**：指定预热的轮数和时间，帮助 JIT 编译器优化代码</p>
</li>
</ul>
</li>
<li><p><strong>JMH 是 Java 的微基准测试框架</strong>，用于测量方法、代码段等小粒度代码的性能，添加依赖编写测试代码即可</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.openjdk.jmh.annotations.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="meta">@BenchmarkMode(Mode.AverageTime)</span> <span class="comment">// 使用平均时间模式</span></span><br><span class="line"><span class="meta">@OutputTimeUnit(TimeUnit.MILLISECONDS)</span> <span class="comment">// 输出结果以毫秒为单位</span></span><br><span class="line"><span class="meta">@State(Scope.Thread)</span> <span class="comment">// 定义测试状态为每个线程独立</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBenchmark</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 基准测试方法</span></span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        calculate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 要测试的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">calculate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-4-反射优化"><a href="#8-4-反射优化" class="headerlink" title="8.4 反射优化"></a>8.4 反射优化</h3><ul>
<li>反射调用的性能相对较低，因为它需要通过 <code>Method.invoke()</code> 进行间接调用，涉及到安全检查和参数处理等<ul>
<li>为了提高反射调用的性能，JVM 会采用一种 “膨胀” 机制：当某个反射调用非常频繁时，JVM 会将它优化为一种更高效的直接调用形式，从而减少反射调用的开销</li>
<li>具体来说，<strong>膨胀</strong>就是指将原本使用通用的反射调用路径（<code>Method.invoke()</code>）的操作，转换为更高效的字节码路径，类似于直接调用的方法。JVM 通过这种方式来加速频繁的反射调用</li>
</ul>
</li>
<li>**膨胀阈值(Inflation Threshold)**：是控制 “膨胀” 机制何时触发的关键参数。也就是说，当反射调用的次数达到一定的阈值后，JVM 就会触发膨胀机制，将反射调用转化为更高效的直接调用<ul>
<li>在 <code>ReflectionFactory</code> 源码的实现中，这个膨胀阈值默认值是 <strong>15</strong>，表示当某个反射方法被调用 15 次之后，JVM 就会对该方法进行膨胀，将其优化为直接调用路径</li>
<li>如果反射调用次数<strong>低于 15 次</strong>，JVM 使用 <code>NativeMethodAccessorImpl</code> 处理反射调用，它是<strong>基于本地方法的实现</strong>，适合处理少量调用</li>
<li><strong>膨胀发生</strong>：当反射调用次数超过膨胀阈值（15 次）后，<code>MethodAccessor</code> 会被替换为一个更高效的实现，称为 <code>GeneratedMethodAccessor</code>，它是通过字节码生成直接调用路径的方法</li>
</ul>
</li>
</ul>
<h2 id="9-JMM-Java-内存模型"><a href="#9-JMM-Java-内存模型" class="headerlink" title="9. JMM-Java 内存模型"></a>9. JMM-Java 内存模型</h2><blockquote>
<p>可以配合 黑马 的并发编程视频学习，这里快速过下</p>
</blockquote>
<ul>
<li>JMM 规定了在<strong>多线程下对共享数据的读写时对数据的原子性、有序性、可见性的规则和保障</strong></li>
</ul>
<h3 id="9-1-原子性"><a href="#9-1-原子性" class="headerlink" title="9.1 原子性"></a>9.1 原子性</h3><ul>
<li>例如：Java 中对静态变量的自增、自减不是原子操作，有可能被 CPU 交错执行</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JVM%E5%85%A5%E9%97%A8.assets/image-20240913095254956.png" alt="image-20240913095254956"></p>
<ul>
<li><p><strong>从 JMM 角度分析</strong>：对静态变量的自增、自减需要再主内存和线程内存(工作内存)中进行数据交换</p>
<ul>
<li>共享的变量信息是放在主内存中的，线程是在工作内存中</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JVM%E5%85%A5%E9%97%A8.assets/image-20240913095415931.png" alt="image-20240913095415931"></p>
<ul>
<li>多线程情况下(轮流使用CPU)指令交错产生的问题</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JVM%E5%85%A5%E9%97%A8.assets/image-20240913095659878.png" alt="image-20240913095659878"></p>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JVM%E5%85%A5%E9%97%A8.assets/image-20240913095707201.png" alt="image-20240913095707201"></p>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JVM%E5%85%A5%E9%97%A8.assets/image-20240913095756344.png" alt="image-20240913095756344"></p>
</li>
<li><p><strong>问题解决</strong>：java中通过synchronized来保证了原子性</p>
</li>
</ul>
<h3 id="9-2-可见性"><a href="#9-2-可见性" class="headerlink" title="9.2 可见性"></a>9.2 可见性</h3><ul>
<li><strong>举例</strong>：main 线程对 run 变量的修改对 t 线程不可见，导致了 t 线程无法停止</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JVM%E5%85%A5%E9%97%A8.assets/image-20240913100118675.png" alt="image-20240913100118675"></p>
<ul>
<li><strong>原因分析</strong>：t 线程频繁的读取 boolean 这个变量，然后即时编译器就会视为热点代码，将boolean的值缓存到高速缓存中，所以 t 线程每次读取都是从自己的工作内存中读取，主内存中改了值，其实 t 线程是感知不到的</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JVM%E5%85%A5%E9%97%A8.assets/image-20240913100422046.png" alt="image-20240913100422046"></p>
<ul>
<li><p><strong>解决方法</strong>：</p>
<ul>
<li><p>使用 <code>volatile</code> 关键字修饰变量</p>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JVM%E5%85%A5%E9%97%A8.assets/image-20240913100604050.png" alt="image-20240913100604050"></p>
<ul>
<li><p>volatile 可以保证可见性和有序性，但是不能保证原子性，它只适用于一个写线程，多个读线程的情况</p>
</li>
<li><p>通过读写屏障保证线程之间的可见性和禁止编译器&#x2F;处理器对指令进行指令重排序</p>
</li>
</ul>
</li>
<li><p>synchronized 既可以保证原子性，也可以保证可见性，但属于重量级的操作，是一种重量级锁，线程的用户态-&gt;内核态的转变，比较重量级操作</p>
</li>
</ul>
</li>
<li><p><strong>注意</strong>：</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JVM%E5%85%A5%E9%97%A8.assets/image-20240913101110351.png" alt="image-20240913101110351"></p>
<h3 id="9-3-有序性"><a href="#9-3-有序性" class="headerlink" title="9.3 有序性"></a>9.3 有序性</h3><ul>
<li><p><strong>指令重排</strong>是指编译器和 CPU 在不改变单线程语义的前提下，出于性能优化的目的，可以对指令的执行顺序进行调整。指令重排可以提高程序的执行效率，但在多<strong>线程环境下，它可能会导致并发问题</strong></p>
</li>
<li><p>在多线程环境下，指令重排可能导致线程之间的数据可见性问题，举例：<strong>双重检查锁定的单例模式</strong>  &#x3D;&gt; <strong>变量需要加volatile</strong>，否则会指令重排造成问题，使得返回的对象不完整</p>
<ul>
<li><code>instance = new Singleton()</code> 实际上它可能会被分解为以下三个步骤：<ul>
<li>分配内存给 <code>Singleton</code> 对象</li>
<li>调用 <code>Singleton</code> 的构造方法</li>
<li>将分配的内存地址赋值给 <code>instance</code></li>
</ul>
</li>
<li>由于指令重排的存在，步骤 2 和步骤 3 可能会被重排，可能会出现 <code>instance</code> 已经指向了分配的内存（步骤 3 已经执行），但对象还没有完全初始化（步骤 2 尚未执行完毕）。导致另一个线程在未完全初始化的情况下获取了 <code>instance</code>，从而导致程序异常</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();  <span class="comment">// 指令重排可能发生在这里</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JVM%E5%85%A5%E9%97%A8.assets/image-20240913123834849.png" alt="image-20240913123834849"></p>
<h3 id="9-4-happens-before-规则"><a href="#9-4-happens-before-规则" class="headerlink" title="9.4 happens-before 规则"></a>9.4 happens-before 规则</h3><ul>
<li>happens-before 规则描述了哪些写操作可以对其他线程的读操作可见，是保证可见性与有序性的一套规则：<ul>
<li>简单地说，如果一个操作 A <strong>happens-before</strong> 另一个操作 B，那么 A 的结果对 B 可见，A 的操作完成后，B 才会开始</li>
<li>这里的变量都是共享变量，也就是成员变量或静态变量</li>
</ul>
</li>
<li><strong>总结</strong>：并不是指代码在物理上的执行顺序，而是确保逻辑上的操作顺序<ul>
<li><strong>程序顺序</strong>：同一线程中，前面的操作 <strong>happens-before</strong> 后面的操作</li>
<li><strong>锁规则</strong>：解锁 <strong>happens-before</strong> 后续的加锁</li>
<li><strong>volatile 规则</strong>：<code>volatile</code> 写操作 <strong>happens-before</strong> 读操作</li>
<li><strong>线程启动</strong>：<code>start()</code> <strong>happens-before</strong> 子线程开始运行</li>
<li><strong>线程终止</strong>：线程结束 <strong>happens-before</strong> 其他线程检测到它结束（如 <code>join()</code>）</li>
<li><strong>中断规则</strong>：<code>interrupt()</code> <strong>happens-before</strong> 中断状态的检测</li>
<li><strong>终结规则</strong>：对象的构造 <strong>happens-before</strong> <code>finalize()</code> 方法</li>
<li><strong>传递性</strong>：A <strong>happens-before</strong> B 且 B <strong>happens-before</strong> C，那么 A <strong>happens-before</strong> C</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JVM%E5%85%A5%E9%97%A8.assets/image-20240913140702468.png" alt="image-20240913140702468"></p>
<h2 id="10-CAS"><a href="#10-CAS" class="headerlink" title="10. CAS"></a>10. CAS</h2><ul>
<li>CAS(Compare-and-Swap) 是配合 volatile 使用的一项技术，体现的是一种乐观锁的思想，是一种无锁并发技术<ul>
<li>获取”主内存中值时”，<strong>为了保证变量的可见性，需要使用volatile来修饰</strong>！集合CAS和volatile可以实现无锁并发！</li>
<li>CAS <strong>适用场景：竞争不激烈，多核CPU的情况下</strong><ul>
<li>因为等待的线程并不是进行进入阻塞状态，而是一种在尝试尝试 &#x3D;&gt; 效率提升的原因之一(在低竞争时效率比synchronized高)</li>
<li>但其他线程也需要占用CPU资源，如果竞争激烈，会影响效率</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JVM%E5%85%A5%E9%97%A8.assets/image-20240913125937970.png" alt="image-20240913125937970"></p>
<ul>
<li><strong>CAS 操作底层依赖于一个 Unsafe 类直接调用操作系统底层的 CAS 指令</strong><ul>
<li>CAS 在操作系统中就是一条指令，所以是原子性的</li>
</ul>
</li>
<li><strong>原子操作类</strong>：<ul>
<li>java中的悲观锁：synchronized</li>
<li>java中的乐观锁：CAS</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JVM%E5%85%A5%E9%97%A8.assets/image-20240913131020822.png" alt="image-20240913131020822"></p>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JVM%E5%85%A5%E9%97%A8.assets/image-20240913131209281.png" alt="image-20240913131209281"></p>
<h2 id="11-Synchronized-优化"><a href="#11-Synchronized-优化" class="headerlink" title="11. Synchronized 优化"></a>11. Synchronized 优化</h2><blockquote>
<p><code>synchronized</code> 的传统实现是一种重量级锁，性能相对较低，尤其是在频繁竞争和上下文切换时。为了解决性能问题，Java 虚拟机（JVM）引入了一系列<strong>锁优化机制</strong>，包括<strong>偏向锁</strong>、<strong>轻量级锁</strong>、<strong>重量级锁</strong></p>
<p>注意锁只能升级不能降级！</p>
</blockquote>
<ul>
<li><strong>对象头</strong>：Java 对象头主要分为两部分<ul>
<li><strong>Mark Word</strong>：存储对象的状态信息（如锁信息、GC 信息等）</li>
<li><strong>Class Pointer</strong>：指向该对象所属类的元数据（Class 元数据）</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JVM%E5%85%A5%E9%97%A8.assets/image-20240913131316057.png" alt="image-20240913131316057"></p>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JVM%E5%85%A5%E9%97%A8.assets/image-20240913141301268.png" alt="image-20240913141301268"></p>
<ul>
<li><p><strong>锁状态</strong>：对象头的Mark Word中”锁标志位”分别对应四种锁状态</p>
<ul>
<li>无锁</li>
<li>偏向锁</li>
<li>轻量级锁</li>
<li>重量级锁</li>
</ul>
</li>
<li><p><strong>轻量级锁</strong></p>
<ul>
<li>采用了 <strong>CAS（Compare-And-Swap）操作</strong> 来尝试获取锁，而不直接进入重量级锁状态</li>
<li><strong>适用场景</strong>：适合线程竞争不激烈（锁持有时间短）的场景，轻量级锁可以通过自旋来减少线程上下文切换的开销</li>
<li>当一个线程持有轻量级锁时，另一个线程尝试获取该锁。如果失败，会进行自旋。自旋一定次数后，如果仍然无法获取锁，轻量级锁会升级为重量级锁，则轻量级锁会升级为重量级锁（锁膨胀）</li>
</ul>
</li>
<li><p><strong>重量级锁</strong></p>
<ul>
<li>当锁升级为重量级锁时，JVM 会采用操作系统级的线程阻塞机制来进行线程同步。获取锁失败的线程会进入阻塞状态，直到锁释放</li>
<li>重量级锁会导致线程上下文切换，性能较差</li>
<li><strong>适用场景</strong>：适合锁竞争激烈的场景，但由于线程阻塞和唤醒的开销较大，效率较低</li>
</ul>
</li>
<li><p><strong>偏向锁</strong>：偏向锁的设计是为了<strong>消除轻量级锁在单线程无竞争情况下的锁开销</strong>。如果只有一个线程反复获取锁，偏向锁不需要执行 CAS 操作，而是直接让该线程“偏向”该锁</p>
<ul>
<li>JVM 会在锁对象的<strong>对象头（Mark Word）中记录持有偏向锁的线程 ID</strong>，在接下来该线程的加锁和解锁操作中，无需执行 CAS 操作，直接进入临界区</li>
<li>如果另一个线程尝试获取已经偏向某个线程的锁时，偏向锁会被撤销，Java 15 中默认禁用偏向锁，并在后续版本中完全移除，因为偏向锁的撤销过程会带来额外的性能开销，对性能的提升有限</li>
</ul>
</li>
<li><p><strong>其他优化</strong>：</p>
<ul>
<li><strong>减少上锁时间</strong>：尽量缩短锁定临界区的代码块</li>
<li><strong>减少锁粒度</strong>：减少不必要的锁竞争，提高并发性能</li>
<li><strong>锁粗化</strong>：将多个连续的小的锁合并为一个大锁，以避免频繁的加锁和解锁操作，减少锁重入的开销</li>
<li><strong>锁消除</strong>：JVM 在运行时通过逃逸分析判断锁是否有必要存在，如果确定某个锁只在单线程内使用，且不会逃逸到其他线程，则可以消除不必要的锁操作</li>
<li><strong>读写分离</strong>：使用 <strong>读写锁（<code>ReadWriteLock</code>）</strong> 来区分读操作和写操作，允许多个线程同时进行读操作，但写操作依然是互斥的</li>
</ul>
</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://tangsmallrong.github.io">thr</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://tangsmallrong.github.io/2024/09/13/JVM%E5%85%A5%E9%97%A8/">https://tangsmallrong.github.io/2024/09/13/JVM%E5%85%A5%E9%97%A8/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://tangsmallrong.github.io" target="_blank">thr's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JVM/">JVM</a></div><div class="post_share"></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/09/16/Redis%E5%8E%9F%E7%90%86/" title="Redis 原理"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Redis 原理</div></div></a></div><div class="next-post pull-right"><a href="/2024/07/14/Lua%E8%84%9A%E6%9C%AC/" title="Lua 脚本"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Lua 脚本</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#JVM"><span class="toc-text">JVM</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%A6%82%E8%BF%B0"><span class="toc-text">1. 概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84"><span class="toc-text">2. 内存结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8-PC"><span class="toc-text">2.1 程序计数器(PC)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88"><span class="toc-text">2.2 虚拟机栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88"><span class="toc-text">2.3 本地方法栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E5%A0%86"><span class="toc-text">2.4 堆</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-%E6%96%B9%E6%B3%95%E5%8C%BA"><span class="toc-text">2.5 方法区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%86%85%E5%AD%98-%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98"><span class="toc-text">2.6 操作系统的内存-直接内存</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="toc-text">3. 垃圾回收</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E5%9B%9E%E6%94%B6"><span class="toc-text">3.1 判断对象是否可以回收</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-JVM-%E4%BA%94%E7%A7%8D%E5%BC%95%E7%94%A8"><span class="toc-text">3.2 JVM 五种引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95"><span class="toc-text">3.3 垃圾回收算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E5%88%86%E4%BB%A3%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="toc-text">3.4 分代垃圾回收</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="toc-text">3.5 垃圾回收器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-GC-%E7%9B%B8%E5%85%B3%E5%8F%82%E6%95%B0"><span class="toc-text">3.6 GC 相关参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A5%E5%85%85%EF%BC%9A%E7%AE%97%E6%B3%95%E7%BB%86%E8%8A%82"><span class="toc-text">补充：算法细节</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%B0%E5%BF%86%E9%9B%86%E5%92%8C%E5%8D%A1%E8%A1%A8"><span class="toc-text">记忆集和卡表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%99%E5%B1%8F%E9%9A%9C"><span class="toc-text">写屏障</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0"><span class="toc-text">三色标记</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E8%B0%83%E4%BC%98"><span class="toc-text">4. 垃圾回收调优</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-GC-%E8%B0%83%E4%BC%98"><span class="toc-text">4.1 GC 调优</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E6%96%B0%E7%94%9F%E4%BB%A3%E8%B0%83%E4%BC%98"><span class="toc-text">4.2 新生代调优</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E8%80%81%E5%B9%B4%E4%BB%A3%E8%B0%83%E4%BC%98"><span class="toc-text">4.3 老年代调优</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%92%8C%E5%AD%97%E8%8A%82%E7%A0%81%E6%8A%80%E6%9C%AF"><span class="toc-text">5. 类加载和字节码技术</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84"><span class="toc-text">5.1 类文件结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-%E5%8F%8D%E7%BC%96%E8%AF%91-class-%E6%96%87%E4%BB%B6"><span class="toc-text">5.2 反编译 class 文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-text">5.3 构造方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E8%A7%A3%E9%87%8A"><span class="toc-text">5.4 字节码指令解释</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5-%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E5%92%8C%E5%A4%9A%E6%80%81%E5%8E%9F%E7%90%86"><span class="toc-text">5.5 方法调用和多态原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-6-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-text">5.6 异常处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-7-synchronized"><span class="toc-text">5.7 synchronized</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-8-%E8%AF%AD%E6%B3%95%E7%B3%96"><span class="toc-text">5.8 语法糖</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E9%98%B6%E6%AE%B5"><span class="toc-text">6. 类加载阶段</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-%E5%8A%A0%E8%BD%BD"><span class="toc-text">6.1 加载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-%E9%93%BE%E6%8E%A5"><span class="toc-text">6.2 链接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">6.3 初始化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-text">7. 类加载器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-%E6%A6%82%E8%BF%B0"><span class="toc-text">7.1 概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%BC%8F"><span class="toc-text">7.2 双亲委派模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-%E7%BA%BF%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-text">7.3 线程上下文类加载器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-text">7.4 自定义类加载器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E8%BF%90%E8%A1%8C%E6%9C%9F%E4%BC%98%E5%8C%96"><span class="toc-text">8. 运行期优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90"><span class="toc-text">8.1 逃逸分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-%E6%96%B9%E6%B3%95%E5%86%85%E8%81%94"><span class="toc-text">8.2 方法内联</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-%E5%AD%97%E6%AE%B5%E4%BC%98%E5%8C%96"><span class="toc-text">8.3 字段优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-4-%E5%8F%8D%E5%B0%84%E4%BC%98%E5%8C%96"><span class="toc-text">8.4 反射优化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-JMM-Java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="toc-text">9. JMM-Java 内存模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-1-%E5%8E%9F%E5%AD%90%E6%80%A7"><span class="toc-text">9.1 原子性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="toc-text">9.2 可见性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-3-%E6%9C%89%E5%BA%8F%E6%80%A7"><span class="toc-text">9.3 有序性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-4-happens-before-%E8%A7%84%E5%88%99"><span class="toc-text">9.4 happens-before 规则</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-CAS"><span class="toc-text">10. CAS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-Synchronized-%E4%BC%98%E5%8C%96"><span class="toc-text">11. Synchronized 优化</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By thr</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>