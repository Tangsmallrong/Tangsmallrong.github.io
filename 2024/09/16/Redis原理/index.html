<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Redis 原理 | thr's blog</title><meta name="author" content="thr"><meta name="copyright" content="thr"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="Redis 原理篇 原理篇-01.Redis原理篇课程介绍_哔哩哔哩_bilibili  0. 准备 redis 源码：redis 安装包下 src 目录里   1. 数据结构1.1 动态字符串SDS Redis 是基于 C 语言实现的，但没有直接使用 C 语言的字符串(底层是字符数组)，C 语言的字符串存在很多问题：  获取字符串长度需要通过运算(字符串数组以 \0 结尾) 非二进制安全(不能包">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis 原理">
<meta property="og:url" content="https://tangsmallrong.github.io/2024/09/16/Redis%E5%8E%9F%E7%90%86/index.html">
<meta property="og:site_name" content="thr&#39;s blog">
<meta property="og:description" content="Redis 原理篇 原理篇-01.Redis原理篇课程介绍_哔哩哔哩_bilibili  0. 准备 redis 源码：redis 安装包下 src 目录里   1. 数据结构1.1 动态字符串SDS Redis 是基于 C 语言实现的，但没有直接使用 C 语言的字符串(底层是字符数组)，C 语言的字符串存在很多问题：  获取字符串长度需要通过运算(字符串数组以 \0 结尾) 非二进制安全(不能包">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://tangsmallrong.github.io/img/avatar.jpg">
<meta property="article:published_time" content="2024-09-16T01:52:25.000Z">
<meta property="article:modified_time" content="2024-09-16T01:56:55.293Z">
<meta property="article:author" content="thr">
<meta property="article:tag" content="redis">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://tangsmallrong.github.io/img/avatar.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://tangsmallrong.github.io/2024/09/16/Redis%E5%8E%9F%E7%90%86/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: thr","link":"链接: ","source":"来源: thr's blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Redis 原理',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-09-16 09:56:55'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.0.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/./img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">13</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">12</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="thr's blog"><span class="site-name">thr's blog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">Redis 原理</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-09-16T01:52:25.000Z" title="发表于 2024-09-16 09:52:25">2024-09-16</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-09-16T01:56:55.293Z" title="更新于 2024-09-16 09:56:55">2024-09-16</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/DataBase/">DataBase</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">7.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>22分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Redis 原理"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><h1 id="Redis-原理篇"><a href="#Redis-原理篇" class="headerlink" title="Redis 原理篇"></a>Redis 原理篇</h1><blockquote>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1cr4y1671t?p=145">原理篇-01.Redis原理篇课程介绍_哔哩哔哩_bilibili</a></p>
</blockquote>
<h2 id="0-准备"><a href="#0-准备" class="headerlink" title="0. 准备"></a>0. 准备</h2><ul>
<li><strong>redis 源码</strong>：redis 安装包下 src 目录里</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/redis%E5%8E%9F%E7%90%86.assets/image-20240915085521561.png" alt="image-20240915085521561"></p>
<h2 id="1-数据结构"><a href="#1-数据结构" class="headerlink" title="1. 数据结构"></a>1. 数据结构</h2><h3 id="1-1-动态字符串SDS"><a href="#1-1-动态字符串SDS" class="headerlink" title="1.1 动态字符串SDS"></a>1.1 动态字符串SDS</h3><ul>
<li><p><strong>Redis 是基于 C 语言实现的</strong>，但没有直接使用 C 语言的字符串(底层是字符数组)，C 语言的字符串存在很多问题：</p>
<ul>
<li>获取字符串长度需要通过运算(字符串数组以 <code>\0</code> 结尾)</li>
<li>非二进制安全(不能包含特殊字符)</li>
<li>不可修改(拼接字符串要申请内存空间)</li>
</ul>
</li>
<li><p><strong>Redis 创建了一种新的字符串结构，称为简单动态字符串SDS(Simple Dynamic String)</strong></p>
<ul>
<li>SDS 本质是一个结构体，底层字符数组 char[] 由SDS自己管理</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/redis%E5%8E%9F%E7%90%86.assets/image-20240915085945518.png" alt="image-20240915085945518"></p>
<ul>
<li><strong>头</strong>：头中记录当前字符串的长度等信息，便于读取</li>
<li><strong>体</strong>：真实存储字符串的char[]</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/redis%E5%8E%9F%E7%90%86.assets/image-20240915090025742.png" alt="image-20240915090025742"></p>
</li>
<li><p><strong>源码</strong>： <code>sds.h</code> &#x3D;&gt; 支持多种长度字符串</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/redis%E5%8E%9F%E7%90%86.assets/image-20240915085816353.png" alt="image-20240915085816353"></p>
<ul>
<li><strong>SDS 支持动态扩容</strong>：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/redis%E5%8E%9F%E7%90%86.assets/image-20240915090346365.png" alt="image-20240915090346365"></p>
<ul>
<li><p><strong>优点</strong>：</p>
<ul>
<li>二进制安全的：读取数据的时候不是像C中以 <code>/0</code> 为结束标识，而是按照长度，长度是几就读几个</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/redis%E5%8E%9F%E7%90%86.assets/image-20240915090606280.png" alt="image-20240915090606280"></p>
</li>
<li><p>SDS 因为是字节存储，所以也可以存音频，视频等(但不推荐，Redis 是基于内存的，存音频视频浪费空间)</p>
</li>
</ul>
<h3 id="1-2-IntSet"><a href="#1-2-IntSet" class="headerlink" title="1.2 IntSet"></a>1.2 IntSet</h3><ul>
<li>IntSet 是 Redis 中 set 集合的一种实现方式，基于整数数组实现(在C语言上进一步的封装)，具备<strong>长度可变、有序</strong>等特征<ul>
<li>对数组的增删改查都由 IntSet 来维护</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/redis%E5%8E%9F%E7%90%86.assets/image-20240915091241557.png" alt="image-20240915091241557"></p>
<ul>
<li>在这个<strong>数组中，每个元素的大小都是固定的，方便寻址</strong>，将来查找时就可以通过第一个元素的内存地址，再根据距离和一个元素的大小，可以<strong>通过数学表达式直接快速寻址</strong></li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/redis%E5%8E%9F%E7%90%86.assets/image-20240915091548740.png" alt="image-20240915091548740"></p>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/redis%E5%8E%9F%E7%90%86.assets/image-20240915091713524.png" alt="image-20240915091713524"></p>
<ul>
<li><strong>IntSet 升级</strong>：当 encoding 原先的每个数组大小规定为2个字节，但是现在要存储4个字节的元素，这时候就会进行升级操作：<strong>自动升级编码方式(encoding)到合适的大小</strong><ul>
<li>倒序依次将数组元素拷贝到扩容后的正确位置，如元素20，计算下标为2，每个元素变4个字节，2*4&#x3D;8，其起始位置变为8</li>
<li>再把待添加的元素放入数组末尾</li>
<li>最后修改 inset 的 encoding 和 length 的属性值</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/redis%E5%8E%9F%E7%90%86.assets/image-20240915092259125.png" alt="image-20240915092259125"></p>
<ul>
<li><strong>源码</strong>：<code>inset.c</code></li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/redis%E5%8E%9F%E7%90%86.assets/image-20240915093332110.png" alt="image-20240915093332110"></p>
<ul>
<li><strong>总结</strong>：可以看做特殊的整数数组<ul>
<li>底层采用<strong>二分查找</strong>查询</li>
<li>IntSet 就是一个<strong>有序的，元素唯一</strong>的(Set集合)，长度可变的数组，只不过自己实现了升级、扩容等一些动作(具备<strong>类型升级机制,节省内存空间</strong>)</li>
<li><strong>适合于存储一些少量的数据</strong>，因为数据量太多不方便分配一些连续的内存，数组的内存地址都是连续的</li>
</ul>
</li>
</ul>
<h3 id="1-3-Dict"><a href="#1-3-Dict" class="headerlink" title="1.3 Dict"></a>1.3 Dict</h3><ul>
<li>Redis 是键值型数据库，键值的映射关系通过 Dict 实现</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/redis%E5%8E%9F%E7%90%86.assets/image-20240915093718221.png" alt="image-20240915093718221"></p>
<ul>
<li><p><strong>全局哈希表 和 哈希节点关系</strong>：添加时链表使用头插法</p>
<ul>
<li>把一个键分配到哈希表中的某个槽位时，最常用的方式是<strong>取余操作</strong>：<code>index = hash(key) % N;</code></li>
<li>在 Redis 中，哈希表的大小 <code>N</code> 通常是 <strong>2 的幂次方</strong>，可以使用<strong>位运算</strong>（<code>&amp;</code>）来代替取余操作，位运算比除法操作快得多，对于哈希表大小为 <code>2^k</code>，可以通过以下方法计算索引：<code>index = hash(key) &amp; (N - 1);</code></li>
<li>其中 <code>N</code> 是哈希表的大小。因为 <code>N</code> 是 2 的幂次方，<code>N - 1</code> 就是一个<strong>二进制的全 1</strong> 数字，<code>&amp; (N - 1)</code> 的作用是<strong>将哈希值的低 <code>k</code> 位直接截取下来作为索引</strong>，相当于取余操作的结果</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">举例</span></span><br><span class="line">假设一个哈希表大小 N = 16，即 2^4 = 16。现在有一个哈希值 hash(key) = 35，想要确定它应该放在哪个槽位</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">传统取余法：</span></span><br><span class="line">index = 35 % 16;  # 结果是 35 % 16 = 3</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用 &amp; 运算：</span></span><br><span class="line">index = 35 &amp; (16 - 1);  # 16 - 1 = 15，二进制是 1111</span><br><span class="line">index = 35 &amp; 15;  </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">35 的二进制是 100011，15 的二进制是 1111</span> </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">100011 &amp; 1111 = 0011，结果是 3</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">两个结果都是 3，但是 &amp; 运算比 % 更高效</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/redis%E5%8E%9F%E7%90%86.assets/image-20240915094920775.png" alt="image-20240915094920775"></p>
<ul>
<li><strong>字典的结构体</strong>：<ul>
<li>字典中默认有2个全局哈希表</li>
<li>空的哈希表一般是 rehash 时使用 &#x3D;&gt; 因为扩容&#x2F;收缩必定会创建新的哈希表，需要对哈希表中每个key重新计算索引</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/redis%E5%8E%9F%E7%90%86.assets/image-20240915095050285.png" alt="image-20240915095050285"></p>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/redis%E5%8E%9F%E7%90%86.assets/image-20240915095059772.png" alt="image-20240915095059772"></p>
<ul>
<li><p><strong>Dict 的扩容</strong>：每次添加元素，都会检查是否需要扩容</p>
<ul>
<li><strong>触发全局哈希表扩容的时机？</strong>&#x3D;&gt; 负载因子(used&#x2F;size)<ul>
<li>哈希表的负载因子 &gt;&#x3D; 1，且并没有执行bgsave等后台进程(会占用较多CPU,可能会影响rehash的进程)</li>
<li>哈希表的负载因子 &gt; 5</li>
</ul>
</li>
<li><strong>扩容出来的倍数一定是 2^n</strong></li>
</ul>
</li>
<li><p><strong>Dict 的收缩</strong>：每次删除元素，都会检查是否需要收缩</p>
<ul>
<li><strong>触发全局哈希表收缩的时机？</strong><ul>
<li>当负载因子 &lt; 0.1时，会对哈希表进行收缩</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Dict 的 rehash</strong>：扩容&#x2F;收缩 对哈希表中每个key重新计算索引</p>
<ul>
<li>Redis 字典使用**两个哈希表：<code>ht[0]</code> 和 <code>ht[1]</code>**。平时所有的操作都只针对 <code>ht[0]</code> 进行。当哈希表的装载因子超过预设阈值（可以是扩容或缩容触发），<code>rehash</code> 过程就会启动</li>
<li>这个过程包括<strong>将 <code>ht[0]</code> 的内容逐渐迁移到 <code>ht[1]</code> 中，并在迁移完成后，将 <code>ht[1]</code> 变成新的 <code>ht[0]</code>，然后重新分配一个新的 <code>ht[1]</code> 准备下一次的 <code>rehash</code></strong></li>
<li>避免数据量大的情况下一次性rehash可能导致的主线程阻塞，rehash 的过程是分多次、渐进式的，称为 <strong>渐进式rehash</strong></li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/redis%E5%8E%9F%E7%90%86.assets/image-20240915102137011.png" alt="image-20240915102137011"></p>
<ul>
<li><strong>总结</strong>：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/redis%E5%8E%9F%E7%90%86.assets/image-20240915100821429.png" alt="image-20240915100821429"></p>
<h3 id="1-4-ZipList"><a href="#1-4-ZipList" class="headerlink" title="1.4 ZipList"></a>1.4 ZipList</h3><ul>
<li>ZipList 压缩列表是<strong>为了节省内存</strong>而设计的数据结构，内存空间是连续的，可以方便的在任意一端进行压入&#x2F;弹出操作</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/redis%E5%8E%9F%E7%90%86.assets/image-20240915103143995.png" alt="image-20240915103143995"></p>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/redis%E5%8E%9F%E7%90%86.assets/image-20240915103322448.png" alt="image-20240915103322448"></p>
<ul>
<li><strong>ZipListEntry 的结构</strong>：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/redis%E5%8E%9F%E7%90%86.assets/image-20240915104010313.png" alt="image-20240915104010313"></p>
<ul>
<li><strong>ZipList 的连锁更新问题</strong>：增&#x2F;删较大数据时可能会发生(发生概率低)，会频繁产生内存的申请和销毁，涉及内核态的切换，影响性能</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/redis%E5%8E%9F%E7%90%86.assets/image-20240915104951628.png" alt="image-20240915104951628"></p>
<ul>
<li><strong>总结</strong>：Redis 从版本 6.0 开始，将 <code>ZipList</code> 数据结构替换为了 <code>ListPack</code>，仍然是一个紧凑的、序列化的数据结构，用于存储小型列表和哈希集合，但是在内部处理和存储机制上进行了优化，以减少内存碎片和连锁更新的情况</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/redis%E5%8E%9F%E7%90%86.assets/image-20240915105225647.png" alt="image-20240915105225647"></p>
<h3 id="1-5-QuickList"><a href="#1-5-QuickList" class="headerlink" title="1.5 QuickList"></a>1.5 QuickList</h3><ul>
<li><p><strong>ZipList 的问题</strong>：</p>
<ul>
<li>ZipList 必须申请连续内存空间，如果内存占用过多，申<strong>请内存效率很低怎么办？ &#x3D;&gt; 限制 ZipList 的长度和 Entry 大小</strong></li>
<li>如果还是要存储大量数据，<strong>超出 ZipList 上限怎么办？ &#x3D;&gt; 创建多个 ZipList 来分片存储数据，分别去申请独立的连续内存空间</strong></li>
<li><strong>分片后如何进行关联以便查找？ &#x3D;&gt; 链表</strong></li>
</ul>
</li>
<li><p><strong>QuickList 压缩列表</strong>，底层是 LinkedList + ZipList，本质是双端链表，但每个节点都关联了一个 ZipList，<strong>兼具了链表和 ZipList 优点</strong></p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/redis%E5%8E%9F%E7%90%86.assets/image-20240915110417948.png" alt="image-20240915110417948"></p>
<ul>
<li><strong>总结</strong>：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/redis%E5%8E%9F%E7%90%86.assets/image-20240915110841866.png" alt="image-20240915110841866"></p>
<h3 id="1-6-SkipList-重点"><a href="#1-6-SkipList-重点" class="headerlink" title="1.6 SkipList-重点"></a>1.6 SkipList-重点</h3><ul>
<li>ZipList 和 QuickList 查找首尾元素性能高，但是从中间随机查询性能就一般，可以使用 <strong>SkipList 跳表</strong><ul>
<li>通过多级指针提高查询效率，根据socre来做排序，要保证有序性</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/redis%E5%8E%9F%E7%90%86.assets/image-20240915112052997.png" alt="image-20240915112052997"></p>
<ul>
<li><strong>总结</strong>：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/redis%E5%8E%9F%E7%90%86.assets/image-20240915111334655.png" alt="image-20240915111334655"></p>
<h3 id="1-7-RedisObject"><a href="#1-7-RedisObject" class="headerlink" title="1.7 RedisObject"></a>1.7 RedisObject</h3><ul>
<li><strong>SDS(简单动态字符串) 、IntSet(整型数组) Dict(字典[哈希表])、ZipList(压缩列表)、QuickList(双端链表)、SkipList(跳表)</strong><ul>
<li>最终都是作为 value <strong>底层存储的数据结构</strong>，而存在形式又会<strong>被封装为一个 RedisObject (Redis 对象)的类型</strong></li>
<li><code>RedisObject</code> 是 Redis 内部用于管理所有键值对的结构体。每一个键或值都被封装为一个 <code>RedisObject</code><ul>
<li><strong>RedisObject</strong> 是 Redis 中存储数据的基本抽象，每个键或值都由 <code>RedisObject</code> 表示</li>
<li><strong>Type</strong>：<code>RedisObject</code> 的 <code>type</code> 字段标识了该对象的类型（如 <code>String</code>、<code>List</code>、<code>Hash</code> 等）</li>
<li><strong>Encoding</strong>：<code>RedisObject</code> 的 <code>encoding</code> 字段表示该数据类型的具体底层存储方式（如 <code>raw</code>、<code>ziplist</code>、<code>skiplist</code> 等）</li>
<li><strong>Ptr</strong>：实际的数据存储在 <code>RedisObject</code> 的 <code>ptr</code> 字段中，指向的是相应的底层数据结构。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/redis%E5%8E%9F%E7%90%86.assets/image-20240915112759423.png" alt="image-20240915112759423"></p>
<ul>
<li><strong>Redis 的编码方式</strong>：encoding 字段</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/redis%E5%8E%9F%E7%90%86.assets/image-20240915113014955.png" alt="image-20240915113014955"></p>
<ul>
<li><strong>redis会根据存储数据的类型不同，选择不同的编码方式</strong><ul>
<li>每一种 Redis 的高层数据类型，都可能对应不同的底层数据结构</li>
<li>Redis 会根据数据的规模、访问模式等动态选择不同的数据结构来优化性能和内存使用</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/redis%E5%8E%9F%E7%90%86.assets/image-20240915113036006.png" alt="image-20240915113036006"></p>
<ul>
<li><strong>举例</strong>：键值均为字符串</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/redis%E5%8E%9F%E7%90%86.assets/image-20240915113419161.png" alt="image-20240915113419161"></p>
<h3 id="1-8-五种数据类型"><a href="#1-8-五种数据类型" class="headerlink" title="1.8 五种数据类型"></a>1.8 五种数据类型</h3><h4 id="1-8-1-String"><a href="#1-8-1-String" class="headerlink" title="1.8.1 String"></a>1.8.1 String</h4><ul>
<li>String 类型的基本编码方式是 <strong>RAW</strong>，基于SDS(简单动态字符串)实现，存储上限为 512MB，会根据SDS长度来决定采用什么编码方式<ul>
<li>如果存储的 SDS 长度<strong>小于 44 字节</strong>，会使用 <strong>EMBSTR</strong> 编码，其 Object Head 和 SDS 是一段连续空间，申请内存只要调用一次函数，效率更高</li>
<li>如果存储的字符串是<strong>整数值</strong>，并且大小在 LONG_MAX 内，会采用 <strong>INT</strong> 编码，直接将数据保存在 RedisObject 的指针位置</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/redis%E5%8E%9F%E7%90%86.assets/image-20240915114145939.png" alt="image-20240915114145939"></p>
<h4 id="1-8-2-List"><a href="#1-8-2-List" class="headerlink" title="1.8.2 List"></a>1.8.2 List</h4><ul>
<li>Redis 的 List 可以<strong>从首、尾操作列表中的元素</strong>，元素按照插入时的顺序进行存储</li>
<li><strong>数据结构的选择</strong>：<ul>
<li>LinkedList：普通链表，内存占用较高，内存碎片较多</li>
<li>ZipList：压缩列表，内存占用低，存储上限低</li>
<li><strong>QuickList</strong>：快表，底层是 LinkedList + ZipList，内存占用较低，包含多个 ZipList，存储上限高</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/redis%E5%8E%9F%E7%90%86.assets/image-20240915135656785.png" alt="image-20240915135656785"></p>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/redis%E5%8E%9F%E7%90%86.assets/image-20240915140331095.png" alt="image-20240915140331095"></p>
<h4 id="1-8-3-Set"><a href="#1-8-3-Set" class="headerlink" title="1.8.3 Set"></a>1.8.3 Set</h4><ul>
<li><p><strong>Set 是单列集合</strong>：</p>
<ul>
<li>无序</li>
<li>不可重复(可以判断元素是否存在)</li>
<li>可求交集、并集、差集</li>
</ul>
</li>
<li><p><strong>数据结构的选择</strong>：（<strong>对查询元素的效率要求高</strong>）</p>
<ul>
<li>哈希表 ht，也就是 Redis 中的字典 Dict（存key，value统一为null）<ul>
<li>类似 Java 的 HashSet</li>
<li>但是内存占用多</li>
</ul>
</li>
<li>IntSet 整数数组</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/redis%E5%8E%9F%E7%90%86.assets/image-20240915141531984.png" alt="image-20240915141531984"></p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/redis%E5%8E%9F%E7%90%86.assets/image-20240915141558271.png" alt="image-20240915141558271"></p>
<h4 id="1-8-4-ZSet"><a href="#1-8-4-ZSet" class="headerlink" title="1.8.4 ZSet"></a>1.8.4 ZSet</h4><ul>
<li><strong>Zset 也就是 SortedSet，</strong>每个元素都要指定一个 score 值和 member 值（可以看作 member 是键，score 是值）<ul>
<li>可以根据 score 值排序</li>
<li>member 必须唯一</li>
<li>可以根据 member 查询分数</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/redis%E5%8E%9F%E7%90%86.assets/image-20240915143133515.png" alt="image-20240915143133515"></p>
<ul>
<li><strong>数据结构的选择</strong>：满足键值存储，键必须唯一，可排序<ul>
<li>SkipList：可排序，并且可以同时存储score和ele值(member)，但是只能根据 score 进行高效查询</li>
<li>HT（Dict）：可以键值存储，也可以根据 key 找 value，但无法排序</li>
<li><strong>初始化时会判断，初始方案是zipList，最终方案是SkipList + 哈希表</strong></li>
</ul>
</li>
<li><strong>实现方式一</strong>：<strong>SkipList + Dict 跳表+哈希表 &#x3D;&gt; 性能好但太占内存</strong><ul>
<li>利用Dict(哈希表)实现 键唯一 键值存储</li>
<li>利用SkipList(跳表)实现 有序性</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/redis%E5%8E%9F%E7%90%86.assets/image-20240915144547515.png" alt="image-20240915144547515"></p>
<ul>
<li><strong>实现方式二</strong>：<strong>当元素数量不多时采用 ZipList 来存储，节省空间</strong><ul>
<li>需满足以下两个条件<ul>
<li>元素个数不超过 128</li>
<li>元素大小不超过 64 字节</li>
</ul>
</li>
<li>ZipList 实现 Zset 的”键值存储””键唯一””支持有序”通过编码结合业务逻辑来实现</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/redis%E5%8E%9F%E7%90%86.assets/image-20240915144834644.png" alt="image-20240915144834644"></p>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/redis%E5%8E%9F%E7%90%86.assets/image-20240915145512914.png" alt="image-20240915145512914"></p>
<h4 id="1-8-5-Hash"><a href="#1-8-5-Hash" class="headerlink" title="1.8.5 Hash"></a>1.8.5 Hash</h4><ul>
<li>Hash 结构与 ZSet 类似，都是键值存储、需要根据键获取值、键唯一<ul>
<li>区别在于 ZSet 的值是 score(数字)，而Hash对键值类型任意，并且 Hash 不需要排序(所以底层结构参考 ZSet 并删掉和排序相关的跳表即可)</li>
</ul>
</li>
<li>Hash 特点：<ul>
<li>键值存储</li>
<li>键唯一</li>
<li>无序</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/redis%E5%8E%9F%E7%90%86.assets/image-20240915145751685.png" alt="image-20240915145751685"></p>
<ul>
<li><strong>数据结构选择</strong>：<ul>
<li>数据量较少的话，使用ZipList编码</li>
<li>数据量较大时，会采用哈希表HT编码(Dict)</li>
<li>触发条件：<ul>
<li>元素数量超过512</li>
<li>元素大小超过64字节</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/redis%E5%8E%9F%E7%90%86.assets/image-20240915150210995.png" alt="image-20240915150210995"></p>
<h3 id="1-9-总结"><a href="#1-9-总结" class="headerlink" title="1.9 总结"></a>1.9 总结</h3><ul>
<li>时间复杂度<ul>
<li>O(1): 哈希表</li>
<li>O(logN): SkipList</li>
<li>O(n): InteSet ZipList QuickList</li>
<li>注意: ZipList操作列表头部和尾部时的时间复杂度为O(1),头信息中记录了尾偏移量等信息</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/redis%E5%8E%9F%E7%90%86.assets/image-20240915152601331.png" alt="image-20240915152601331"></p>
<h2 id="2-网络模型"><a href="#2-网络模型" class="headerlink" title="2. 网络模型"></a>2. 网络模型</h2><h3 id="2-1-用户空间和内核空间"><a href="#2-1-用户空间和内核空间" class="headerlink" title="2.1 用户空间和内核空间"></a>2.1 用户空间和内核空间</h3><ul>
<li>**用户态 (User Mode)**：<ul>
<li>运行应用程序的环境</li>
<li>只能执行非特权指令，对硬件资源的访问受限</li>
<li>需要执行特权操作（如I&#x2F;O操作、进程管理等）时，必须通过系统调用切换到内核态</li>
</ul>
</li>
<li>**内核态 (Kernel Mode)**：<ul>
<li>操作系统核心运行的模式</li>
<li>可执行特权指令，管理硬件资源和执行系统级操作</li>
<li>提供系统调用接口（System Call Interface），允许用户态程序请求内核执行任务</li>
</ul>
</li>
<li><strong>地址空间</strong>:<ul>
<li>用户空间和内核空间在内存中占据不同的区域，通常内核空间位于高地址，用户空间位于低地址</li>
<li>内核空间直接映射到物理内存，提供高效的内存访问</li>
</ul>
</li>
<li>在操作系统中处理I&#x2F;O操作尤其是文件和网络I&#x2F;O时，涉及多个步骤，每个步骤都有潜在的性能影响，特别是在高负载或大量数据传输时<ul>
<li><strong>用户空间到内核空间的切换</strong>：每次进行系统调用，如读写文件或网络数据时，需要从用户态切换到内核态，这种模式切换涉及保存和加载寄存器，栈的切换等操作，消耗CPU资源</li>
<li><strong>数据复制</strong>：数据需要在用户空间和内核空间之间复制，例如，从用户缓冲区到内核缓冲区（或反之），数据复制会占用CPU周期，并可能导致缓存失效，影响其他进程的性能</li>
<li><strong>等待设备I&#x2F;O</strong>：设备I&#x2F;O通常是操作系统中最慢的操作之一，尤其是磁盘和网络I&#x2F;O；在等待数据从设备加载（如硬盘读取或网络数据接收）期间，进程可能会被阻塞，增加响应时间</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/redis%E5%8E%9F%E7%90%86.assets/image-20240915154051738.png" alt="image-20240915154051738"></p>
<h3 id="2-2-Linux-五种-IO-模型"><a href="#2-2-Linux-五种-IO-模型" class="headerlink" title="2.2 Linux 五种 IO 模型"></a>2.2 Linux 五种 IO 模型</h3><ul>
<li><strong>IO 读取数据</strong>：流程简化为两个主要阶段：<strong>等待数据就绪</strong>和<strong>读取数据</strong></li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/redis%E5%8E%9F%E7%90%86.assets/image-20240915154647998.png" alt="image-20240915154647998"></p>
<h4 id="2-2-1-阻塞-IO"><a href="#2-2-1-阻塞-IO" class="headerlink" title="2.2.1 阻塞 IO"></a>2.2.1 阻塞 IO</h4><ul>
<li><strong>等待数据就绪</strong>和<strong>读取数据</strong>这两个阶段都需要阻塞等待<ul>
<li>系统调用时，应用程序从<strong>用户态</strong>切换到<strong>内核态</strong></li>
<li>如果数据未就绪，系统会让当前线程阻塞，直至数据准备完毕，整个等待过程中线程无法执行其他任务</li>
<li>由于阻塞等待，当前线程会闲置，无法做其他工作，这会导致线程资源浪费</li>
<li>在单线程程序中，I&#x2F;O阻塞会阻止线程处理后续任务，严重影响整体性能</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/redis%E5%8E%9F%E7%90%86.assets/image-20240915155133911.png" alt="image-20240915155133911"></p>
<h4 id="2-2-2-非阻塞-IO"><a href="#2-2-2-非阻塞-IO" class="headerlink" title="2.2.2 非阻塞 IO"></a>2.2.2 非阻塞 IO</h4><ul>
<li><strong>等待数据阶段是非阻塞的，数据拷贝阶段依然阻塞</strong>：<ul>
<li>应用程序发起 I&#x2F;O 操作时，无论数据是否到达或事件是否就绪，系统调用都会<strong>立即返回</strong>，不会阻塞线程<ul>
<li>虽然线程不会被阻塞，但应用程序需要不断向内核询问数据是否就绪，这种循环询问（<strong>轮询</strong>）称为“盲等”</li>
<li>每次轮询都涉及从<strong>用户态</strong>切换到<strong>内核态</strong>，并返回用户态，频繁的态切换增加了系统开销，但大量的态切换和无效的 CPU 占用，导致性能并不理想</li>
</ul>
</li>
<li>当数据准备好后，内核将数据从内核空间拷贝到用户空间，这一过程依然是<strong>阻塞的</strong>，因为数据拷贝时需要保证一致性</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/redis%E5%8E%9F%E7%90%86.assets/image-20240915155710594.png" alt="image-20240915155710594"></p>
<h4 id="2-2-3-IO-多路复用"><a href="#2-2-3-IO-多路复用" class="headerlink" title="2.2.3 IO 多路复用"></a>2.2.3 IO 多路复用</h4><ul>
<li><strong>阻塞 I&#x2F;O</strong> 和 <strong>非阻塞 I&#x2F;O</strong> 在单线程情况下都存在效率问题：<ul>
<li><strong>阻塞 I&#x2F;O</strong>：线程在等待数据到达时被阻塞，不能执行其他任务</li>
<li><strong>非阻塞 I&#x2F;O</strong>：虽然线程不被阻塞，但会不断轮询检查数据是否就绪，造成CPU的空转，浪费资源</li>
</ul>
</li>
<li><strong>I&#x2F;O 多路复用</strong>解决了单线程处理多个 I&#x2F;O 事件时的低效问题<ul>
<li>通过<strong>一个线程</strong>配合**selector(选择器)**来监听多个文件描述符fd</li>
<li>当某个文件描述符有数据到达或事件就绪时，selector 会通知线程进行处理，提升 CPU 的利用效率</li>
</ul>
</li>
</ul>
<ul>
<li><p><strong>工作原理</strong>：</p>
<ul>
<li>**文件描述符 (fd)**：每个文件描述符代表一个 I&#x2F;O 资源（如 socket、文件），I&#x2F;O 多路复用通过监听这些描述符来判断它们的状态（可读、可写、出错等）</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/redis%E5%8E%9F%E7%90%86.assets/image-20240915161607660.png" alt="image-20240915161607660"></p>
<ul>
<li><strong>Selector（选择器）</strong>：<ul>
<li>应用程序将多个文件描述符注册到 selector，selector 负责监听这些文件描述符的状态</li>
<li>当有数据到达或者事件就绪时，selector 会通知线程处理该事件</li>
<li>好处是避免了线程轮询所有描述符的状态，只有当真正有数据时，线程才会被唤醒处理</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/redis%E5%8E%9F%E7%90%86.assets/image-20240915161552940.png" alt="image-20240915161552940"></p>
<ul>
<li><strong>根据监听文件描述符通知的方式不同，主要有三种实现：</strong>前两者只会通知用户进程有fd就绪，并不确定是哪个，需要用户进程遍历fd确定，最后一个 epoll 在通知用户进程fd就绪时会把fd写入用户空间<ul>
<li>select</li>
<li>poll</li>
<li>epoll</li>
</ul>
</li>
</ul>
<h5 id="select"><a href="#select" class="headerlink" title="select"></a>select</h5><ul>
<li><p>select 是 Linux 中最早的I&#x2F;O多路复用的实现方案，监听的事件类型：</p>
<ul>
<li><p>可读事件</p>
</li>
<li><p>可写事件</p>
</li>
<li><p>异常事件</p>
</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/redis%E5%8E%9F%E7%90%86.assets/image-20240915164716606.png" alt="image-20240915164716606"></p>
<ul>
<li><strong>执行流程</strong>：fd集合在保存fd时是按照比特位保存的，每一个比特位代表一个fd，下边以8个比特位为例（实际源码里是1024个比特位）<ul>
<li>调用select()函数会将监听的FD集合拷贝到内核空间，后续有事件就绪还会将FD集合拷贝回用户空间，不过依旧需要轮询的方式来查找就绪事件</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/redis%E5%8E%9F%E7%90%86.assets/image-20240915163812068.png" alt="image-20240915163812068"></p>
<ul>
<li><strong>缺点</strong>：<ul>
<li>监听FD的数量有限</li>
<li>每次调用select函数,都需要将监听的FD集合拷贝到内核空间,如果很多的话,拷贝很费性能(epoll_ctl只调用一次,剩余都epoll_await)</li>
<li>监听的事件就绪时,要采用轮询方式来查找,效率很低!(epoll_await只返回已经就绪的事件,不会全都返回)</li>
</ul>
</li>
</ul>
<h5 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h5><ul>
<li>poll 模式对 select 模式做了简单改进，仅仅解决了监听的FD集合数量有限的问题<ul>
<li>内核空间将拷贝的 pollfd 数组转链表存储，理论上无上限</li>
<li>性能提升并不明显，也是每次poll()时会将FD集合从内核空间拷贝到用户空间，会有多次的拷贝的过程</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/redis%E5%8E%9F%E7%90%86.assets/image-20240915164214638.png" alt="image-20240915164214638"></p>
<h5 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h5><ul>
<li>epoll 模式是对 select 和 poll 的改进，提供了三个函数：<ul>
<li><strong>epoll_create</strong>：负责<strong>在内核空间中创建eventpool的实例</strong>，一个eventpool维护了<ul>
<li>一个红黑树(记录要监听的FD)  [未就绪时在这里]</li>
<li>一个链表(记录已经就绪的FD)  [就绪了之后就在这里]</li>
</ul>
</li>
<li><strong>epoll_ctl</strong>：将要监听的FD拷贝到内核态的 eventpoll 的实例中，并为每一个要监听的FD设置一个callback()函数<ul>
<li>当<strong>事件就绪时会将红黑树中的该FD放到就绪的FD的链表</strong>中去，表示当前事件已经就绪</li>
<li><strong>注意这里只有一次FD的拷贝，区别于select和poll每次的拷贝</strong></li>
</ul>
</li>
<li><strong>epoll_await</strong>：内核会检查eventpool中维护的就绪链表(维护了已经就绪的FD)是否为空，不为空则返回就绪的FD的数量</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/redis%E5%8E%9F%E7%90%86.assets/image-20240915193233356.png" alt="image-20240915193233356"></p>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/redis%E5%8E%9F%E7%90%86.assets/image-20240915165311355.png" alt="image-20240915165311355"></p>
<ul>
<li><p><strong>epoll 解决的问题</strong>：</p>
<ul>
<li><strong>解决了监听的FD数量的限制</strong>： 通过<strong>红黑树</strong>的数据结构来管理文件描述符，支持大量的并发连接</li>
<li><strong>FD 拷贝和调用过程优化</strong>：<ul>
<li><strong>select</strong> 和 <strong>poll</strong> 每次调用时，都会将监听的<strong>所有文件描述符</strong>从用户空间拷贝到内核空间，并在内核中轮询是否有 I&#x2F;O 就绪事件。这导致了大量的内核态和用户态切换，浪费系统资源</li>
<li><strong>epoll</strong> 优化了这一过程：<ul>
<li>通过 <code>epoll_ctl()</code> 将文件描述符添加到内核的<strong>红黑树</strong>中，这个操作只在监听的文件描述符发生变化时进行，比如注册、删除或修改监听的 FD，这意味着文件描述符只需要拷贝<strong>一次</strong></li>
<li>当事件发生时，<strong>epoll</strong> 通过回调机制(callback函数)将事件加入到<strong>就绪链表</strong>中</li>
<li>后续只要不断调用<strong>epoll_wait()</strong> 只处理链表上<strong>就绪的文件描述符</strong>，不需重复的将要监听的FD从用户空间拷贝到内核空间</li>
</ul>
</li>
</ul>
</li>
<li><strong>减少内核和用户空间之间的拷贝</strong>：<ul>
<li><strong>select</strong> 和 <strong>poll</strong> 在每次 I&#x2F;O 事件发生时，会将所有的文件描述符集合（无论是否就绪）从内核空间拷贝回用户空间，应用程序再遍历这个集合来查找哪些文件描述符是就绪的，带来了额外的性能开销</li>
<li><strong>epoll</strong> 只将<strong>已经就绪的文件描述符</strong>拷贝回用户空间，这减少了无效的拷贝和无效的轮询操作</li>
</ul>
</li>
</ul>
</li>
<li><p>**epoll 的ET和LT模式(事件通知机制)**：</p>
<ul>
<li><p>调用epoll_await()时如果有可读&#x2F;可写的事件就绪了，就会得到事件的通知告诉你有事件就绪了，但事件通知的方式分为两种：</p>
<ul>
<li><strong>LT(水平触发)<strong>：当FD有数据可读时,会</strong>重复通知多次</strong>,直到数据处理完成. 且是默认方式</li>
<li><strong>ET(边缘触发)<strong>：</strong>只会在FD从不可读变成可读时通知一次,不管数据是否处理完</strong>.如果没有处理完,后面不会再返回未处理完的事件了</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/redis%E5%8E%9F%E7%90%86.assets/image-20240915200005980.png" alt="image-20240915200005980"></p>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/redis%E5%8E%9F%E7%90%86.assets/image-20240915200537451.png" alt="image-20240915200537451"></p>
</li>
<li><p>每次调用epoll_await()时，如果就绪链表中有就绪的事件，会看当前时LT还是ET，如果是<strong>ET则会直接将链表的指针断开</strong>，后续就没有该就绪FD了；如果是LT则不会断开，下次依旧可以返回上次未处理完的FD</p>
</li>
<li><p><strong>LT的缺陷</strong>：</p>
<ul>
<li>因为需要不断的epoll_await(),需要多次重复通知,所以性能上会有一定消耗</li>
<li>会有”惊群现象”，多个进程同时在监听一个FD，当FD就绪后,会导致所有的进程都会被通知到</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/redis%E5%8E%9F%E7%90%86.assets/image-20240915200810239.png" alt="image-20240915200810239"></p>
<ul>
<li><strong>基于 epoll 的服务端流程</strong>：<ul>
<li><code>epoll_create</code> 用于创建一个 epoll 实例</li>
<li><code>epoll_ctl</code> 用来操作 epoll 实例的内部监视列表，这里用它将 server socket (负责监听来自客户端连接的 socket) 注册到 epoll 实例上</li>
<li><code>epoll_wait</code> 被用来等待注册的文件描述符上的事件，例如有新的连接尝试，或者一个已连接的 socket 有数据可读，当 <code>epoll_wait</code> 检测到事件后，会返回这些事件的列表</li>
<li>对于新的连接，使用 <code>accept</code> 接收并创建一个新的 socket；对于数据接收，从 socket 读取数据</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/redis%E5%8E%9F%E7%90%86.assets/image-20240915202617520.png" alt="image-20240915202617520"></p>
<h4 id="2-2-4-信号驱动-IO"><a href="#2-2-4-信号驱动-IO" class="headerlink" title="2.2.4 信号驱动 IO"></a>2.2.4 信号驱动 IO</h4><ul>
<li><strong>使用信号（signal）来通知应用程序何时可以开始非阻塞地执行IO操作</strong>，当内核有FD就绪时会发出SIGIO信号通知用户，期间用户可以执行其他业务，无需阻塞等待(相比非阻塞IO，这里真正实现非阻塞)<ul>
<li><strong>缺点</strong>：当大量IO操作，信号队列可能溢出，而且内核和用户空间的频繁信号交互性能也较低</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/redis%E5%8E%9F%E7%90%86.assets/image-20240915204128892.png" alt="image-20240915204128892"></p>
<h4 id="2-2-5-异步-IO"><a href="#2-2-5-异步-IO" class="headerlink" title="2.2.5 异步 IO"></a>2.2.5 异步 IO</h4><ul>
<li><strong>等待数据就绪</strong>和<strong>读取数据</strong>两个过程<strong>都是非阻塞的</strong>，等到内核中数据就绪并拷贝到用户空间后才递交信号通知用户进程<ul>
<li><strong>缺点</strong>：用户进程不阻塞就又会处理新的用户请求，高并发情况下容易导致内核积累过多IO读写任务，需要编码做好限流工作，代码实现复杂度高</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/redis%E5%8E%9F%E7%90%86.assets/image-20240915204516650.png" alt="image-20240915204516650"></p>
<h4 id="2-2-6-对比总结"><a href="#2-2-6-对比总结" class="headerlink" title="2.2.6 对比总结"></a>2.2.6 对比总结</h4><blockquote>
<p>使用较多的还是IO多路复用，少数情况下也会使用异步IO</p>
</blockquote>
<ul>
<li><strong>同步IO VS 异步IO</strong>：同步和异步的区别关键在于内核与用户空间的数据拷贝过程是阻塞还是非阻塞的(所以即使是阻塞IO，本质还是同步的)</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/redis%E5%8E%9F%E7%90%86.assets/image-20240915204717437.png" alt="image-20240915204717437"></p>
<h3 id="2-7-Redis-网络模型"><a href="#2-7-Redis-网络模型" class="headerlink" title="2.7 Redis 网络模型"></a>2.7 Redis 网络模型</h3><h4 id="2-7-1-问题辨析"><a href="#2-7-1-问题辨析" class="headerlink" title="2.7.1 问题辨析"></a>2.7.1 问题辨析</h4><ul>
<li><strong>Redis 是单线程还是多线程？</strong><ul>
<li>如果只是针对一些<strong>核心业务部分</strong>(命令处理)，对数据的访问、操作等都是单线程，且结合多路复用的IO模型，此情况下是<strong>单线程</strong></li>
<li>但是对于<strong>整个redis</strong>而言是<strong>多线程</strong>，比如持久化时并不会由主进程来完成，而是fork一个子进程来完成操作</li>
</ul>
</li>
<li><strong>Redis 为什么要选择单线程？</strong><ul>
<li>redis 是<strong>纯内存操作</strong>，内存的执行速度是非常快，<strong>redis 的性能瓶颈</strong>从来都不是执行速度而<strong>是网络延迟，所以即使加入了多线程其实也不会有更多的提升</strong></li>
<li><strong>多线程会导致大量的上下文切换，带来不必要开销</strong></li>
<li>多线程间需要有合理的系统架构来控制多线程间的协调性，否则一味的线程多甚至效率更低，并且多线程下还有<strong>进行共享数据的并发访问控制，提高了很多复杂度</strong></li>
</ul>
</li>
</ul>
<h4 id="2-7-2-IO多路复用和事件派发机制"><a href="#2-7-2-IO多路复用和事件派发机制" class="headerlink" title="2.7.2 IO多路复用和事件派发机制"></a>2.7.2 IO多路复用和事件派发机制</h4><ul>
<li>Redis 网络模型基于<strong>多路复用IO来提升网络性能</strong>，并且支持多种不同的多路复用实现都进行了<strong>封装，提供统一的API库AE</strong></li>
<li>整体来看Redis的网络模型就是基于**”IO多路复用 + 事件派发机制”**<ul>
<li>客户端请求来了之后做多路复用的事件监听，无论是什么类型的事件，提前定义好各种各样的事件处理器，对于不同的事件就派发给不同的事件处理器来处理</li>
<li>在单线程模型下，性能瓶颈存在于网络IO &#x3D;&gt; 命令解析和响应结果的输出 &#x3D;&gt; 多线程改进</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/redis%E5%8E%9F%E7%90%86.assets/image-20240915213707476.png" alt="image-20240915213707476"></p>
<h2 id="3-通信协议"><a href="#3-通信协议" class="headerlink" title="3. 通信协议"></a>3. 通信协议</h2><h3 id="3-1-RESP-协议"><a href="#3-1-RESP-协议" class="headerlink" title="3.1 RESP 协议"></a>3.1 RESP 协议</h3><ul>
<li>Redis 是 CS 架构，通信一般分为两步(不包括pipeline和pubsub)</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/redis%E5%8E%9F%E7%90%86.assets/image-20240916083921993.png" alt="image-20240916083921993"></p>
<ul>
<li>Redis 采用的是 <strong>RESP(Redis Serialization Protocol) 协议</strong>，Redis6出的 RESP3 和之前的 RESP2 不太兼容，所以默认使用的还是 RESP2，以下学习中使用 RESP2 举例</li>
<li><strong>数据类型</strong>：RESP 中，通过首字母的字符来区分不同的数据类型<ul>
<li><strong>单行字符串</strong>：首字节为 <code>+</code>，不允许出现特殊字符，如 <code>\r\n</code> &#x3D;&gt; 二进制不安全，常用于服务端的返回响应</li>
<li>**错误(Errors)**：首字节为 <code>-</code>，常用于服务端的返回响应，类似单行字符串，只是内容是异常信息</li>
<li><strong>数值</strong>：首字节为 <code>:</code>，数字格式的字符串</li>
<li><strong>多行字符串</strong>：首字节为 <code>$</code>，二进制安全(底层记录了字符串占用字节大小)，最大支持 512MB</li>
<li><strong>数组</strong>：首字节为 <code>*</code>，后面跟上数组元素个数，再跟上元素，元素类型不限，一般客户端用数组发请求</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/redis%E5%8E%9F%E7%90%86.assets/image-20240916084259161.png" alt="image-20240916084259161"></p>
<h2 id="4-内存策略"><a href="#4-内存策略" class="headerlink" title="4. 内存策略"></a>4. 内存策略</h2><h3 id="4-1-内存过期策略"><a href="#4-1-内存过期策略" class="headerlink" title="4.1 内存过期策略"></a>4.1 内存过期策略</h3><h4 id="4-1-1-DB-结构"><a href="#4-1-1-DB-结构" class="headerlink" title="4.1.1 DB 结构"></a>4.1.1 DB 结构</h4><ul>
<li><strong>Redis 如何知道一个 key 是否过期</strong>：一个库中有专门的一个Dict<strong>字典来保存key和TTL(过期时间)的映射</strong></li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/redis%E5%8E%9F%E7%90%86.assets/image-20240916085728079.png" alt="image-20240916085728079"></p>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/redis%E5%8E%9F%E7%90%86.assets/image-20240916085946115.png" alt="image-20240916085946115"></p>
<ul>
<li><strong>是不是TTL到期就立刻删除了？</strong><ul>
<li>不一定，取决于过期策略</li>
</ul>
</li>
</ul>
<h4 id="4-1-2-删除策略"><a href="#4-1-2-删除策略" class="headerlink" title="4.1.2 删除策略"></a>4.1.2 删除策略</h4><ul>
<li><p>**惰性删除(单个删除)**：访问一个key的时候会检查是否过期，如果过期了再删除（用到的时候才删除）</p>
<ul>
<li><strong>问题</strong>：如果过期的key就再也没有人访问了呢？ &#x3D;&gt; 周期删除</li>
</ul>
</li>
<li><p>**周期删除(批量删除)**：通过一个定时任务[针对所有key的]，周期性的抽样部分的key，然后删除过期的key（最终确保所有Dict中的数据都会被抽到），执行周期有两种：</p>
<ul>
<li><strong>SLOW模式: 低频 高时长的清理</strong><ul>
<li>执行频率默认为10，每次不超过25ms</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/redis%E5%8E%9F%E7%90%86.assets/image-20240916090842181.png" alt="image-20240916090842181"></p>
<ul>
<li><strong>FAST模式: 高频 低时长的清理</strong><ul>
<li>执行频率不固定，但两次间隔不低于2ms，每次耗时不超过1ms</li>
<li>FAST 策略会<strong>减少对主线程的影响，因为每次执行非常快</strong></li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/redis%E5%8E%9F%E7%90%86.assets/image-20240916090847104.png" alt="image-20240916090847104"></p>
</li>
</ul>
<h3 id="4-2-内存淘汰策略"><a href="#4-2-内存淘汰策略" class="headerlink" title="4.2 内存淘汰策略"></a>4.2 内存淘汰策略</h3><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/redis%E5%8E%9F%E7%90%86.assets/image-20240916091732339.png" alt="image-20240916091732339"></p>
<ul>
<li><strong>四种算法，八种策略</strong>：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/redis%E5%8E%9F%E7%90%86.assets/image-20240916091921530.png" alt="image-20240916091921530"></p>
<ul>
<li><strong>修改策略配置</strong>：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/redis%E5%8E%9F%E7%90%86.assets/image-20240916091944818.png" alt="image-20240916091944818"></p>
<ul>
<li><strong>LRU 和 LFU</strong>：<ul>
<li><strong>LRU</strong>：最久没用的</li>
<li><strong>LFU</strong>：最少使用的</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/redis%E5%8E%9F%E7%90%86.assets/image-20240916092507514.png" alt="image-20240916092507514"></p>
<ul>
<li><strong>如何知道每个key最后一次被访问的时间？&#x2F; 如何知道每个key被访问的频率？</strong><ul>
<li>每个键值对KV都会被封装为RedisObject，在采用不同的策略时分别记录着对应的信息(上次访问时间&#x2F;访问频率)</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/redis%E5%8E%9F%E7%90%86.assets/image-20240916092958749.png" alt="image-20240916092958749"></p>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/redis%E5%8E%9F%E7%90%86.assets/image-20240916093435120.png" alt="image-20240916093435120"></p>
<ul>
<li><strong>流程梳理</strong>：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/redis%E5%8E%9F%E7%90%86.assets/image-20240916094227076.png" alt="image-20240916094227076"></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://tangsmallrong.github.io">thr</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://tangsmallrong.github.io/2024/09/16/Redis%E5%8E%9F%E7%90%86/">https://tangsmallrong.github.io/2024/09/16/Redis%E5%8E%9F%E7%90%86/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://tangsmallrong.github.io" target="_blank">thr's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/redis/">redis</a></div><div class="post_share"></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2024/09/13/JVM%E5%85%A5%E9%97%A8/" title="JVM 入门"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">JVM 入门</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/11/18/Redis%E5%9F%BA%E7%A1%80/" title="Redis 基础"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-18</div><div class="title">Redis 基础</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis-%E5%8E%9F%E7%90%86%E7%AF%87"><span class="toc-text">Redis 原理篇</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#0-%E5%87%86%E5%A4%87"><span class="toc-text">0. 准备</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-text">1. 数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2SDS"><span class="toc-text">1.1 动态字符串SDS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-IntSet"><span class="toc-text">1.2 IntSet</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-Dict"><span class="toc-text">1.3 Dict</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-ZipList"><span class="toc-text">1.4 ZipList</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-QuickList"><span class="toc-text">1.5 QuickList</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-6-SkipList-%E9%87%8D%E7%82%B9"><span class="toc-text">1.6 SkipList-重点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-7-RedisObject"><span class="toc-text">1.7 RedisObject</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-8-%E4%BA%94%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">1.8 五种数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-8-1-String"><span class="toc-text">1.8.1 String</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-8-2-List"><span class="toc-text">1.8.2 List</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-8-3-Set"><span class="toc-text">1.8.3 Set</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-8-4-ZSet"><span class="toc-text">1.8.4 ZSet</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-8-5-Hash"><span class="toc-text">1.8.5 Hash</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-9-%E6%80%BB%E7%BB%93"><span class="toc-text">1.9 总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B"><span class="toc-text">2. 网络模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4%E5%92%8C%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4"><span class="toc-text">2.1 用户空间和内核空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-Linux-%E4%BA%94%E7%A7%8D-IO-%E6%A8%A1%E5%9E%8B"><span class="toc-text">2.2 Linux 五种 IO 模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-1-%E9%98%BB%E5%A1%9E-IO"><span class="toc-text">2.2.1 阻塞 IO</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-2-%E9%9D%9E%E9%98%BB%E5%A1%9E-IO"><span class="toc-text">2.2.2 非阻塞 IO</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-3-IO-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8"><span class="toc-text">2.2.3 IO 多路复用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#select"><span class="toc-text">select</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#poll"><span class="toc-text">poll</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#epoll"><span class="toc-text">epoll</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-4-%E4%BF%A1%E5%8F%B7%E9%A9%B1%E5%8A%A8-IO"><span class="toc-text">2.2.4 信号驱动 IO</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-5-%E5%BC%82%E6%AD%A5-IO"><span class="toc-text">2.2.5 异步 IO</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-6-%E5%AF%B9%E6%AF%94%E6%80%BB%E7%BB%93"><span class="toc-text">2.2.6 对比总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-7-Redis-%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B"><span class="toc-text">2.7 Redis 网络模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-7-1-%E9%97%AE%E9%A2%98%E8%BE%A8%E6%9E%90"><span class="toc-text">2.7.1 问题辨析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-7-2-IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E5%92%8C%E4%BA%8B%E4%BB%B6%E6%B4%BE%E5%8F%91%E6%9C%BA%E5%88%B6"><span class="toc-text">2.7.2 IO多路复用和事件派发机制</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE"><span class="toc-text">3. 通信协议</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-RESP-%E5%8D%8F%E8%AE%AE"><span class="toc-text">3.1 RESP 协议</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%86%85%E5%AD%98%E7%AD%96%E7%95%A5"><span class="toc-text">4. 内存策略</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E5%86%85%E5%AD%98%E8%BF%87%E6%9C%9F%E7%AD%96%E7%95%A5"><span class="toc-text">4.1 内存过期策略</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-1-DB-%E7%BB%93%E6%9E%84"><span class="toc-text">4.1.1 DB 结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-2-%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5"><span class="toc-text">4.1.2 删除策略</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5"><span class="toc-text">4.2 内存淘汰策略</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By thr</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>