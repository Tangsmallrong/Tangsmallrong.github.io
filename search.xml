<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>JVM 入门</title>
      <link href="/2024/09/13/JVM%E5%85%A5%E9%97%A8/"/>
      <url>/2024/09/13/JVM%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><blockquote><p>学习视频：</p><p><a href="https://www.bilibili.com/video/BV1yE411Z7AP/?spm_id_from=333.337.search-card.all.click&vd_source=320ecdd8d14979567afe9d21045ad392">黑马程序员JVM完整教程，Java虚拟机快速入门，全程干货不拖沓_哔哩哔哩_bilibili</a></p><p><a href="https://www.bilibili.com/video/BV1sp4y1Y7ap?p=8&vd_source=ce97d263f08af76fc25ff49de530fe92">G1与zgc垃圾回收器剖析_哔哩哔哩_bilibili</a></p></blockquote><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><ul><li><strong>什么是 JVM？</strong><ul><li><strong>定义</strong>：java virtual machine 也就是 java 程序(准确说是 java 二进制字节码)的运行环境<ul><li>java 程序源代码经过 <code>javac</code> 编译成 class 字节码，字节码再通过 <code>java</code> 程序加载到虚拟机里即可运行</li></ul></li><li><strong>好处</strong>：<ul><li>一次编写，到处运行(跨平台是在jvm层面实现的,屏蔽了字节码和底层操作系统的差异,对外提供了一致的运行环境)</li><li>自动内存管理，垃圾回收功能(c和c++没有)</li><li>数组下标越界检查(c和c++没有)</li><li>多态是面向对象的基石(jvm内部使用虚方法表实现多态)</li></ul></li><li><strong>jdk &amp; jre &amp; jvm</strong><ul><li>jvm+基础类库 &#x3D;&gt; jre+编译工具 &#x3D;&gt; jdk</li></ul></li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JVM%E5%85%A5%E9%97%A8.assets/image-20240913162126431.png" alt="image-20240913162126431"></p><ul><li><p>jvm 只是一套规范，之后的笔记以 HotSpot 虚拟机为例</p></li><li><p><strong>jvm 的主要组成</strong></p></li><li><p>类加载系统</p></li><li><p>内存结构(运行时数据区域)</p></li><li><p>执行引擎</p></li><li><p>本地接口</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JVM%E5%85%A5%E9%97%A8.assets/image-20240913162159914.png" alt="image-20240913162159914"></p><h2 id="2-内存结构"><a href="#2-内存结构" class="headerlink" title="2. 内存结构"></a>2. 内存结构</h2><h3 id="2-1-程序计数器-PC"><a href="#2-1-程序计数器-PC" class="headerlink" title="2.1 程序计数器(PC)"></a>2.1 程序计数器(PC)</h3><ul><li><strong>代码执行流程</strong>：<ul><li>java 代码被编译为二进制字节码(jvm指令[在不同平台下一样,跨平台])</li><li>解释器将其解释为机器码(过程中<strong>解释器根据指令的类型和执行结果更新程序计数器的值</strong>,使其指向下一条要执行的字节码指令)</li><li>cpu 执行机器码</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JVM%E5%85%A5%E9%97%A8.assets/image-20240913164747410.png" alt="image-20240913164747410"></p><ul><li><strong>作用</strong>：<ul><li>记住下一条jvm指令的执行地址，保证程序执行的有序性</li><li>多线程环境下，程序计数器也会记住当前线程上次执行结束的位置，当再抢夺到cpu时间片的时候会接着上次执行的位置继续执行</li></ul></li><li>物理上实现程序计数器是通过”寄存器”来实现(快)，因为读取指令内存地址很频繁</li><li><strong>特点</strong>：<ul><li>线程私有</li><li>唯一一个不会存在内存溢出的内存结构</li></ul></li></ul><h3 id="2-2-虚拟机栈"><a href="#2-2-虚拟机栈" class="headerlink" title="2.2 虚拟机栈"></a>2.2 虚拟机栈</h3><ul><li><p>每个线程运行时所需要的内存，<strong>线程私有</strong></p></li><li><p>每个栈由多个栈帧组成，对应着每个方法运行时需要的内存(参数、局部变量、返回地址)</p></li><li><p>每个线程只能有一个活动栈帧，对应着正在执行的那个方法(栈顶的栈帧)</p></li><li><p>可以在idea调试的时候查看左下角的栈帧</p></li><li><p><strong>问题辨析</strong>：</p><ul><li><p>垃圾回收不涉及栈内存(一次次方法调用产生的栈帧内存,其在每次方法调用后都会被自动弹出栈,不用垃圾回收来管理)</p></li><li><p>jvm 可以通过 <code>-Xss</code> 参数设置栈内存(linux默认1024KB)，并不是越大越好(虽然越大可以支持更多的递归调用)，但其会增加每个线程占用内存，会使可执行的线程数变少(因为物理内存大小固定)</p></li><li><p>方法内的局部变量是否线程安全要看局部变量有没有逃离方法的作用范围，若没有则为线程私有&#x3D;&gt;安全，否则如果局部变量引用了对象(方法的参数是一个对象)，并逃离了方法的作用范围(比如将局部变量返回)，需要考虑线程安全</p></li></ul></li><li><p><strong>虚拟机栈的内存溢出问题</strong>：两种情况，java 会抛出 <strong>StackOverflowError 异常</strong></p><ul><li>栈帧过多(如递归调用没有设置正确的终止条件)</li><li>栈帧过大</li><li>调用第三方库也可能出现栈溢出(如使用 JSON 库进行序列化或反序列化时，若实体类的属性之间存在循环引用则可能导致栈溢出等问题) &#x3D;&gt; 若场景不可避免,可以使用注解啥的忽略某个字段</li></ul></li><li><p><strong>线程诊断相关问题</strong>：</p><ul><li>cpu 占用过多<ul><li><code>top</code>：实时查看系统中各个进程的资源使用情况</li><li><code>ps -H -eo pid,tid,%cpu | grep &lt;PID&gt;</code>：查看具体进程的线程资源使用情况</li><li><code>printf &quot;%x\n&quot; &lt;TID&gt;</code>：将 TID 转换为十六进制格式</li><li><code>jps</code>：列出所有 Java 进程</li><li><code>jstack &lt;PID&gt; &gt; thread_dump.txt</code>：获取指定 Java 进程的线程 dump,再根据TID的十六进制格式进行定位</li></ul></li><li>程序运行很长时间没有结果<ul><li>可能是死锁问题，使用 <code>jstack &lt;pID&gt;</code> 查看末尾会输出类似 <code>Found one Java level deadlock</code> 语句</li></ul></li></ul></li></ul><h3 id="2-3-本地方法栈"><a href="#2-3-本地方法栈" class="headerlink" title="2.3 本地方法栈"></a>2.3 本地方法栈</h3><ul><li>本地(native)方法是用非 Java 语言(如 C 或 C++)编写的代码</li><li>本地方法栈：在 java 虚拟机<strong>调用一些本地方法时为其提供内存空间，线程私有</strong></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JVM%E5%85%A5%E9%97%A8.assets/image-20240913165029364.png" alt="image-20240913165029364"></p><h3 id="2-4-堆"><a href="#2-4-堆" class="headerlink" title="2.4 堆"></a>2.4 堆</h3><ul><li><p><strong>特点</strong>（通过 new 关键字，创建对象都会使用堆内存）</p><ul><li>程序计数器 虚拟机栈 本地方法栈都是线程私有的，堆是线程共享的，需要考虑线程安全的问题</li><li>有垃圾回收机制</li></ul></li><li><p><strong>堆内存溢出问题</strong>：抛出 OutofMemoryError 异常</p><ul><li>可以通过参数指定堆内存大小：（有时候运行时间短不容易发现堆内存溢出问题,设置小些可以方便暴露问题）<ul><li>堆的最小值：-Xms 如-Xms2m</li><li>堆的最大值：-Xmx 如-Xmx8m</li></ul></li></ul></li><li><p><strong>堆内存诊断</strong>：</p><ul><li><code>jps</code> 查找 java 进程 PID</li><li><code>jmap -heap &lt;PID&gt;</code> 查看 java 进程的堆内存使用情况 &#x3D;&gt; 只能查询当前时刻</li><li><code>jconsole</code> 可连续检测，图形化界面，多功能</li><li>案例：垃圾回收后，内存占用仍然很高<ul><li>使用 JVisualVM 来监控 java 程序 &#x3D;&gt; 也是图形化界面，有个 dump 功能可以抓取堆的当前快照，分析堆转储文件里对内存占用大的对象</li></ul></li></ul></li></ul><h3 id="2-5-方法区"><a href="#2-5-方法区" class="headerlink" title="2.5 方法区"></a>2.5 方法区</h3><ul><li><strong>线程共享</strong>，存储所有类和常量的元数据信息，如类加载信息、运行时常量池、字符串常量池(JDK7 开始，字符串常量池被移到了 Java 堆中)</li><li>在虚拟机启动时创建，逻辑上是堆的组成部分(具体实现不一样,规范上不强制位置)<ul><li>如 Oracle 的 HotSpot，1.8以前方法区的实现叫做”永久代”(PermGen)，使用堆的一部分内存作为方法区</li><li>1.8以后，移除了”永久代”，换了一种实现叫”元空间”(Metaspace)，用的是本地的内存，也就是操作系统的内存</li><li>方法区都是一种规范，”永久代”和”元空间”都是它的一种实现</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JVM%E5%85%A5%E9%97%A8.assets/image-20240913170458211.png" alt="image-20240913170458211"></p><ul><li><p><strong>方法区的内存溢出问题</strong>：</p><ul><li>1.8 以前会导致永久代内存溢出</li><li>1.8 以后会导致元空间内存溢出</li><li>1.8 以后用的元空间(使用系统内存),一般不容易溢出</li><li><code>-XX:MaxMetaspaceSize=&lt;size&gt;</code> 设置元空间最大大小</li><li>实际场景中动态产生并加载类的情况很多，如 spring(使用 CGLIB 或 Java 动态代理生成 AOP 代理类) 和 mybatis(使用 Java 动态代理生成映射器接口的实现类) 等代理对象<ul><li>在这些动态生成类的过程中，类的加载和卸载频繁，加上框架所创建的类通常都不是轻量级类，这些类的元数据需要存储在方法区（永久代或元空间）中</li></ul></li></ul></li><li><p><strong>方法区中的一个组成部分：运行时常量池</strong></p><ul><li><strong>常量池</strong>：在编译时生成，存在于 <code>.class</code> 文件中<ul><li>反编译 target 目录下的 <code>.class</code> 文件(命令:<code>javap -v Hello.class</code>) ，该文件包括<ul><li>类基本信息</li><li>该类的常量池信息</li><li>类方法定义(包含JVM指令)</li></ul></li><li>常量池中包括编译时生成的各种字面量(如字符串常量、数值常量)和符号引用(如类名、方法名、字段名等)，作用是给JVM指令提供一些常量符号，保证虚拟机指令能够成功执行</li></ul></li><li><strong>运行时常量池</strong>：<ul><li>类加载时，<code>.class</code> 文件中的常量池内容会被加载到运行时常量池中</li><li>并在类加载(加载、链接[验证,准备,解析]、初始化) 的解析阶段，将class常量池中的原先的”符号引用”解析为”直接引用”</li><li>运行时常量池不仅包含编译时的常量池内容，还可以动态扩展，可能在运行阶段加入新的常量</li></ul></li><li><strong>运行时常量池的一部分：字符串常量池</strong><ul><li><code>StringTable</code> 是 JVM 内部用于实现字符串常量池的数据结构，底层是哈希表(固定大小的哈希表，带有开放地址法来处理哈希冲突)</li><li>在类加载过程中，编译后的 <code>.class</code> 文件中的常量池内容被加载到运行时常量池中，字符串字面量在这个阶段被加载到字符串常量池中 &#x3D;&gt; <code>s3 = &quot;ab&quot;</code></li><li><strong>Java 8 及之前</strong>：编译器将使用 <code>+</code> 操作符的字符串拼接(语法糖)优化为 <code>StringBuilder</code> 的拼接，如<code>new StringBuilder().append(&quot;a&quot;).qppend(&quot;b&quot;).toString()</code>  &#x3D;&#x3D;&gt; <code>s4 = s1 + s2</code> 存放在堆里</li><li><strong>Java 9 及之后</strong>：引入 <code>invokedynamic</code> 指令来实现字符串拼接，允许 JVM 在运行时选择最优的拼接方式</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringConcatExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;b&quot;</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;        <span class="comment">// 字面量形式</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> s1 + s2;     <span class="comment">// 变量拼接</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span> + <span class="string">&quot;b&quot;</span>;   <span class="comment">// 常量拼接</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 比较引用</span></span><br><span class="line">        System.out.println(s3 == s4); <span class="comment">// false</span></span><br><span class="line">        System.out.println(s3 == s5); <span class="comment">// true</span></span><br><span class="line">        System.out.println(s4 == s5); <span class="comment">// false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>字符串延迟加载</strong>：</p><ul><li>在 Java 编译过程中，所有字符串字面量确实被存储在 <code>.class</code> 文件的常量池中。但这并不意味着它们会在类加载时立即全部被加入到运行时字符串常量池中去</li><li><strong>字符串字面量在被首次使用时</strong>，会被放入字符串常量池</li><li>JVM 使用<strong>懒加载（lazy loading）技术</strong>，按需加载和管理字符串对象，以减少不必要的内存占用</li></ul></li><li><p><strong>intern 方法</strong>（串池存放对象还是引用有争议，先按着视频里的来）</p><blockquote><p><a href="https://blog.csdn.net/lotusPlant/article/details/125804308">https://blog.csdn.net/lotusPlant/article/details/125804308</a></p></blockquote><ul><li>针对 JDK1.8，intern() 方法的工作机制是尝试将字符串对象放入串池，如果有则不放，如果没有则放，并把串池中的对象返回</li><li>针对 JDK1.6，intern() 方法尝试将字符串对象放入串池，如果有则不放，如果没有则把对象复制一份放入串池，并把串池中的对象返回</li></ul></li><li><p><strong>StringTable 的位置</strong></p><ul><li>JDK1.6 StringTable 在永久代中，1.8 StringTable 在堆中，主要是为了优化垃圾回收效率，减少 <code>OutOfMemoryError</code> 的风险</li><li>永久代的大小是固定的，字符串常量池在 JDK 1.6 中容易导致 <code>OutOfMemoryError</code></li><li>规则：<strong>当 GC（垃圾回收）耗时超过 98% 且仅回收不到 2% 的堆内存时，会抛出 <code>OutOfMemoryError</code> 异常</strong>。<ul><li>这一规则是 JVM 为了避免系统陷入“GC回收但效果很差”的恶性循环而设计的</li><li>如果垃圾回收的效率非常低，即 GC 几乎占用了大部分的 CPU 时间，但实际上回收的内存却很少，那么 JVM 会认为当前的内存配置已经无法支持正常运行，因此抛出 <code>OutOfMemoryError</code></li></ul></li><li><code>-XX:MaxPermSize</code>：设置永久代的最大大小</li><li><code>-Xmx8m</code>：设置堆的最大内存</li></ul></li><li><p><strong>StringTable 垃圾回收</strong></p><ul><li><code>-Xmx10m</code> 指定堆内存大小</li><li><code>-XX:+PrintStringTableStatistics</code> 打印字符串常量池信息</li><li><code>-XX:+PrintGCDetails</code></li><li><code>-verbose:gc</code> 打印 gc 的次数，耗费时间等信息</li></ul></li><li><p><strong>StringTable 性能调优</strong></p></li><li><p>StringTable 底层是固定大小的哈希表(数组+链表)，如果数组长度较长，相当于存放的元素就会比较分散，哈希冲突的概率会小一些，查找的速度也会更快</p></li><li><p>所以如果系统里字符串常量非常多的话，可以设置桶的个数多一些，如：<code>-XX:StringTablesize=101010</code></p></li></ul><h3 id="2-6-操作系统的内存-直接内存"><a href="#2-6-操作系统的内存-直接内存" class="headerlink" title="2.6 操作系统的内存-直接内存"></a>2.6 操作系统的内存-直接内存</h3><ul><li><strong>特点</strong>：<ul><li>常见于 NIO 操作时，用于数据缓冲区</li><li>分配回收成本较高，但读写性能高</li><li>不受 JVM 内存回收管理</li></ul></li><li>直接内存也会有内存溢出的问题，其底层的分配和释放直接内存的原理：<ul><li><strong>底层使用 unsafe 对象来管理</strong><ul><li><code>base = unsafe.allocateMemory(size);</code></li><li><code>unsafe.freeMemory(address);</code></li></ul></li><li>Cleaner 继承虚引用类型，会将 unsafe 分配的直接内存地址与一个虚引用关联起来，并监控这个引用，当直接内存对象不再被使用时，虚引用会被添加到引用队列中，通知 Cleaner 需要执行清理操作</li><li>Cleaner 的清理线程会从引用队列中取出这个虚引用，并调用其 run() 方法(其内部调用unsafe的freeMemory方法来释放内存)</li></ul></li><li>JVM 调优有个参数 <code>-XX:+DisableExplicitGC</code>，用于防止手动用 <code>System.gc()</code> 释放内存，但是该参数可能会对直接内存的垃圾回收造成影响 &#x3D;&gt; 解决办法是对于直接内存回收直接使用底层的 <code>unsafe.freeMemory()</code></li></ul><h2 id="3-垃圾回收"><a href="#3-垃圾回收" class="headerlink" title="3. 垃圾回收"></a>3. 垃圾回收</h2><h3 id="3-1-判断对象是否可以回收"><a href="#3-1-判断对象是否可以回收" class="headerlink" title="3.1 判断对象是否可以回收"></a>3.1 判断对象是否可以回收</h3><ul><li><p>两种算法：引用计数、可达性分析(JVM使用的)</p></li><li><p><strong>引用计数</strong>：每个对象都维护一个引用计数器，用来记录有多少个引用指向该对象</p><ul><li>当对象被一个变量引用时+1，计数为0时说明可以被销毁</li><li>缺点是<strong>无法处理循环引用</strong>，如果两个对象相互引用，但没有其他对象引用它们</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JVM%E5%85%A5%E9%97%A8.assets/image-20240913170900311.png" alt="image-20240913170900311"></p></li><li><p><strong>可达性分析</strong>：看是否被根对象直接或间接的引用，不是则可以被回收</p></li><li><p><strong>补充</strong>：内存泄漏是指程序在运行过程中分配了内存，但这些内存由于某些原因没有被释放或回收，从而导致内存资源逐渐被耗尽</p><ul><li>未被释放的内存：程序动态分配了一块内存，但在不再需要这块内存时，没有显式或隐式地释放它</li><li>不可达但未被回收：在垃圾回收机制的语言中（如 Java），即使对象已经不可达（即没有任何引用指向它），但如果垃圾回收器没有及时或无法识别并回收这些内存，就会造成内存泄漏</li><li>持续的无用占用：虽然内存泄漏的内存仍然被分配和占用，但它已经对程序没有任何作用，这些内存无法再被程序利用，从而浪费了资源</li></ul></li></ul><h3 id="3-2-JVM-五种引用"><a href="#3-2-JVM-五种引用" class="headerlink" title="3.2 JVM 五种引用"></a>3.2 JVM 五种引用</h3><blockquote><p>参考：<a href="https://juejin.cn/post/7131175540874018830">https://juejin.cn/post/7131175540874018830</a></p></blockquote><ul><li><p><strong>强、软、弱、虚、终结器</strong></p><ul><li><p><strong>强引用</strong>：平时用的都是强引用(如new出来的对象被赋值给了某个变量,那么这个变量就强引用该对象)，特点就是只要能够沿着GC Root的引用链找到它,就不会被回收</p></li><li><p><strong>软引用</strong>：用 SoftReference 类实现，在没有强引用引用它的前提下，当垃圾回收且内存不足时会被回收掉</p></li><li><p><strong>弱引用</strong>：用 WeakReference 类实现，在没有强引用引用它的前提下，当垃圾回收时就会被回收掉</p></li><li><p><strong>虚引用</strong>：主要配置 ByteBuffer 使用(有关直接内存的释放&#x3D;&gt;因为直接内存不受JVM垃圾回收的管理)，当ByteBuffer对象没有强引用时，JVM 会将其内部关联的 Cleaner 对象(虚引用)放入引用队列中，系统中有一个专门的线程定期检查这个队列，一旦发现 Cleaner 对象，便会调用其 <code>clean</code> 方法，该方法内部会通过 <code>unsafe</code> 类的 <code>freeMemory</code> 方法来释放直接内存，从而避免内存泄漏</p></li><li><p><strong>终结器引用</strong>：Object 父类中的 finalize 方法(不推荐使用)，当对象被垃圾回收时，如果该对象重写了 finalize 方法，JVM 会生成一个与该对象关联的 终结器引用，并将这个 终结器引用 放入 终结器队列，JVM 会通过一个低优先级的后台线程调用队列中引用关联的对象的 finalize 方法，如果对象再次可达，它就会被自救，避免被回收</p></li></ul></li><li><p>软引用和弱引用也可以配合”引用队列”来使用,也可以不配合，<strong>虚引用和终结器引用必须配合引用队列使用</strong></p></li><li><p><code>[软引用][弱引用][虚引用][终结器引用]</code>本身都是对象，当这些对象引用的对象被回收后，它们就可以放到”引用队列”中去方便后续处理(如遍历队列释放内存它们占用的内存)</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JVM%E5%85%A5%E9%97%A8.assets/image-20240913171009096.png" alt="image-20240913171009096"></p><ul><li><strong>软引用的应用</strong>：针对内存敏感的资源(如图片等)，可以使用软引用引用，在内存紧张时，将该占有的内存释放掉，以后要使用到时再读取一遍</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JVM%E5%85%A5%E9%97%A8.assets/image-20240913171439542.png" alt="image-20240913171439542"></p><ul><li><strong>软引用和引用队列 (弱引用类似)</strong><ul><li>软引用引用的对象在内存紧张时被回收，但软引用对象本身也是占用内存的 &#x3D;&gt; 需要使用引用队列来清理</li><li>在创建软引用对象的时候，将[引用队列]作为参数传入，当软引用所关联的对象被回收时，软引用自己会加入到队列中</li><li>编写代码去轮询或检查这个引用队列，确定哪些软引用对象已经失效，并根据业务逻辑执行清理操作（如从缓存中移除条目或释放其他相关资源）</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JVM%E5%85%A5%E9%97%A8.assets/image-20240913171509781.png" alt="image-20240913171509781"></p><ul><li><p><strong>补充</strong>：</p><ul><li><strong>直接内存回收的具体工作流程(涉及虚引用)：</strong><ul><li><strong>ByteBuffer 分配直接内存</strong>：当创建一个直接内存 ByteBuffer 时，底层会通过 JNI (Java Native Interface) 调用操作系统分配一块直接内存，并使用 ByteBuffer 对象对其进行封装</li><li><strong>Cleaner 对象</strong>：ByteBuffer 内部通常会关联一个 Cleaner 对象，Cleaner 是一个虚引用，它注册了一个清理任务，该任务定义了如何在 ByteBuffer 被垃圾回收时释放对应的直接内存</li><li><strong>虚引用的使用</strong>：Cleaner 继承自 PhantomReference，当 ByteBuffer 对象没有强引用（即它不再被任何其他对象引用）时 JVM 的垃圾回收器会将 Cleaner 对象放入到一个引用队列（ReferenceQueue）中</li><li><strong>清理任务的执行</strong>：系统中有一个专门的线程（通常是 ReferenceHandler 线程）负责定期检查这个引用队列<br> 当 Cleaner 对象被放入队列中时，ReferenceHandler 线程会调用 Cleaner 中的清理任务。这个清理任务通常会调用 Unsafe 类的 freeMemory 方法来释放分配的直接内存，从而避免内存泄漏</li><li><strong>防止直接内存泄漏</strong>：通过这种机制，即使 ByteBuffer 对象被垃圾回收了，系统仍然能够确保其对应的直接内存被安全释放，防止内存泄漏</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">总结：虚引用主要配合 ByteBuffer 使用(有关直接内存的释放=&gt;因为直接内存不受JVM垃圾回收的管理)，当ByteBuffer对象没有强引用时，JVM 会将其内部关联的 Cleaner 对象(虚引用)放入引用队列中，系统中有一个专门的线程定期检查这个队列，一旦发现 Cleaner 对象，便会调用其 `clean` 方法，该方法内部会通过 `unsafe` 类的 `freeMemory` 方法来释放直接内存，从而避免内存泄漏。</span><br></pre></td></tr></table></figure><ul><li><strong>虚引用在直接内存管理中的作用</strong>：<ul><li>虚引用通过 Cleaner 机制确保 ByteBuffer 在被垃圾回收时，其对应的直接内存也能够被安全释放</li><li>这是因为 JVM 不会自动管理直接内存的回收，必须通过这种机制来避免内存泄漏</li></ul></li><li><strong>终结器引用</strong>：<ul><li>终结器引用和 finalize 方法是 Java 对象生命周期管理中的一个机制，主要用于在对象被垃圾回收之前执行一些清理操作</li><li>然而，由于性能和可靠性问题，finalize 方法已经被认为是不推荐使用的，并且在现代 Java 开发中基本上被废弃了。不推荐的原因：<ul><li>finalize 方法工作效率低</li><li>处理引用队列的线程优先级低，执行机会少，可能对象占用内存迟迟不被释放</li></ul></li></ul></li></ul></li></ul><h3 id="3-3-垃圾回收算法"><a href="#3-3-垃圾回收算法" class="headerlink" title="3.3 垃圾回收算法"></a>3.3 垃圾回收算法</h3><ul><li><strong>标记清除</strong>（两个阶段）<ul><li>对没有被 GC root 直接或间接引用的对象进行标记，然后将其所占用的空间进行释放(将起始结束地址记录在空闲表里)<ul><li><strong>标记阶段</strong>：通过引用链从 GC Roots 开始遍历所有可达的对象</li><li><strong>清除阶段</strong>：JVM 开始遍历整个堆内存区域，发现没有标记的对象则将其视为垃圾对象并释放其占用的内存（这里的释放是指标记未被使用的内存块的起始地址和结束地址，将这些空闲内存记录到一个“空闲列表”中以便后续内存分配时可以使用这些空闲内存）</li></ul></li><li><strong>优点：速度快；缺点：内存碎片</strong></li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JVM%E5%85%A5%E9%97%A8.assets/image-20240913172418578.png" alt="image-20240913172418578"></p><ul><li><strong>标记整理</strong> <ul><li>标记阶段都类似，整理阶段垃圾回收器会扫描整个堆内存区域，将所有标记为存活的对象移动到堆的一个连续区域(通常是内存的起始端)，然后更新所有相关的引用，确保引用指向的是对象的新地址</li><li><strong>优点：解决内存碎片问题，提高内存的利用率；缺点：时间长，耗性能(涉及对象的移动)</strong></li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JVM%E5%85%A5%E9%97%A8.assets/image-20240913172439486.png" alt="image-20240913172439486"></p><ul><li><strong>标记复制</strong><ul><li>内存空间被划分为两个大小相等的区域，假设为 From 和 To 区域。开始时，所有对象都分配在 From 中，To 空闲</li><li>当标记阶段完成后，垃圾回收器会<strong>将所有存活的对象从 From&#x2F;伊甸园 复制到 To 中，并进行寿命+1操作，然后交换 From 和 To</strong></li><li>适合年轻代，存活对象较少，复制的成本相对较低</li><li><strong>缺点：会占用双份的内存</strong></li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JVM%E5%85%A5%E9%97%A8.assets/image-20240913172518307.png" alt="image-20240913172518307"></p><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JVM%E5%85%A5%E9%97%A8.assets/image-20240913172526797.png" alt="image-20240913172526797"></p><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JVM%E5%85%A5%E9%97%A8.assets/image-20240913172535385.png" alt="image-20240913172535385"></p><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JVM%E5%85%A5%E9%97%A8.assets/image-20240913172542893.png" alt="image-20240913172542893"></p><ul><li><strong>总结</strong>：JVM 中这三种算法垃圾回收算法都是结合着一起使用，不会只使用一种</li></ul><h3 id="3-4-分代垃圾回收"><a href="#3-4-分代垃圾回收" class="headerlink" title="3.4 分代垃圾回收"></a>3.4 分代垃圾回收</h3><ul><li><strong>分代垃圾回收</strong><ul><li>JVM 协同三种算法进行垃圾回收的具体实现就是分代的垃圾回收机制，将<strong>堆内存分为老年代和新生代(包括伊甸园、幸存区from、幸存区to)</strong></li><li>长时间使用的放在老年代(回收频率低)，有些用的时间短的放在新生代(回收频率高)</li></ul></li><li><strong>分代垃圾回收的工作机制</strong><ul><li>创建的新对象默认会放在伊甸园，如果伊甸园放不下就会触发一次垃圾回收(新生代的垃圾回收一般被称为”Minor GC”)，然后根据可达性分析算法进行标记，执行标记复制算法，将伊甸园和from区中存活的对象复制到to区中，并将其寿命+1，然后回收伊甸园的对象，交换 from 和 to 的指针引用的指向，当幸存区的对象寿命超过了阈值(15)，晋升到老年代</li><li>如果新来的对象在伊甸园&#x2F;幸存区&#x2F;老年代都放不下，就会触发 “Full GC”</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JVM%E5%85%A5%E9%97%A8.assets/image-20240913172632578.png" alt="image-20240913172632578"></p><ul><li><p><strong>总结分代垃圾回收</strong></p><ul><li>对象首先分配在伊甸园区</li><li>新生代空间不足时触发 Minor GC，使用标记复制算法将伊甸园和from区存活的对象复制到to区，存活的对象年龄+1并且交换 from 和 to 指针</li><li>Minor GC 会引发 **stop the word(STW)**，暂停其他用户线程(因为回收过程中可能会导致对象地址的改变)，minor gc 暂停时间并不长(新生代大部分都是被回收，复制的存活的不多)</li><li>当对象寿命超过阈值时(最大15&#x3D;&gt;保存在对象的对象头中[4bit最大就是1111也就是15]&#x3D;&gt;不同垃圾回收器也不一样,也不一定到阈值了才晋升,可能空间不够了也晋升)，会晋升至老年代</li><li>当老年代空间不足，会先尝试触发 minor gc，如果之后空间仍然不足则触发 full gc，STW 时间更长，如果空间还是不够 &#x3D;&gt; out of memory error</li></ul></li><li><p><strong>案例演示垃圾回收过程</strong>：</p><ul><li>添加 <code>-XX:+PrintGCDetails -verbose:gc</code> 的参数可以查看垃圾回收的详细日志记录</li></ul><blockquote><p>新生代 10M &#x3D;&gt; 伊甸园:from:to &#x3D; 8:1:1<br>老年代 10M<br>图中的 total 没有算上 to 区的大小(因为 to 区要空着)</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JVM%E5%85%A5%E9%97%A8.assets/image-20240913172757606.png" alt="image-20240913172757606"></p><ul><li><strong>大对象如果一开始新生代都放不下，会先尝试直接放到老年代</strong>，如果还放不下，会触发 minor gc 和 full gc，还是不行就 OutOfMemoryError</li><li>java中某一个线程内发生了内存溢出异常，并不会导致整个java进程的结束</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JVM%E5%85%A5%E9%97%A8.assets/image-20240913173353913.png" alt="image-20240913173353913"></p><h3 id="3-5-垃圾回收器"><a href="#3-5-垃圾回收器" class="headerlink" title="3.5 垃圾回收器"></a>3.5 垃圾回收器</h3><blockquote><p>这块黑马视频讲的不太容易懂，参考下尚硅谷的 P176-185</p><p>同时参考下 <strong>书《深入理解Java虚拟机：JVM高级特性与最佳实践（第3版）》——周志明</strong></p></blockquote><ul><li><p><strong>垃圾回收器</strong></p><ul><li><p><strong>垃圾回收算法是方法论，垃圾回收器则是方法论的实践者</strong>；不同的垃圾回收器负责不同的区域，并采取不同的垃圾回收算法</p></li><li><p><strong>分类</strong>：</p><ul><li><strong>串行</strong>(单线程,适用于堆内存较小的)</li><li><strong>吞吐量优先</strong>(多线程,允许较长时间的 STW 事件以减少总的垃圾回收次数,进而减少垃圾回收的总时间)</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JVM%E5%85%A5%E9%97%A8.assets/image-20240913173529054.png" alt="image-20240913173529054"></p><ul><li><strong>响应时间优先</strong>(多线程,单次STW的时间最短,但可能会更频繁地触发垃圾回收,适用于延迟敏感的应用)</li></ul></li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JVM%E5%85%A5%E9%97%A8.assets/image-20240911140502885.png" alt="image-20240911140502885"></p><ul><li><strong>串行垃圾回收器 Serial</strong> <ul><li>开启参数：<code>-XX:+UseSerialGC=Serial+SerialOld</code></li><li>分为两个部分，Serial 工作在<strong>新生代(采用复制算法)<strong>，SerialOld 工作在</strong>老年代(采用标记整理算法)</strong></li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JVM%E5%85%A5%E9%97%A8.assets/image-20240913173404353.png" alt="image-20240913173404353"></p><ul><li><strong>并行的垃圾回收器-吞吐量优先 Parallel</strong> （Java8默认的 PS[新生代] 和 PO[老年代]）<ul><li>开启参数(1.8默认开启)：<code>-XX:+UseParallelGC</code>或<code>-XX:+UseParallelOldGC</code>（前者新生代后者老年代,开启一个另一个就连带开启，算法也是<strong>新生代复制，老年代标记整理</strong>）</li><li>控制线程数(默认开启,和CPU核数相关)：<code>-XX:ParallelGCThreads=n</code></li><li>目标是达到可控制的吞吐量，还可以通过设置参数达到自适应的条件策略，适合后台运算不需要太多交互的任务</li><li>并行垃圾回收 指的是垃圾回收器使用多个线程来执行垃圾回收工作，但在执行垃圾回收时，会完全暂停应用程序的所有线程(STW)</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JVM%E5%85%A5%E9%97%A8.assets/image-20240913173412117.png" alt="image-20240913173412117"></p><ul><li><p><strong>并发的垃圾回收器-响应时间优先（CMS）</strong></p><ul><li>开启参数：<code>-XX:UseConcMarkSweepGC</code></li><li>应用线程执行的同时，并发地(即在同一时间段内)执行部分垃圾回收工作，避免长时间的 STW 事件，适合对响应时间敏感的应用</li><li>使用的是<strong>标记清除算法</strong>，过程是：<ul><li><strong>初始标记</strong>(只标记GC Roots直接关联的对象,速度快)</li><li><strong>并发标记</strong>(遍历整个对象图,耗时长,但并发)，会产生浮动垃圾&#x2F;错标的情况<ul><li><strong>浮动垃圾</strong>：并发标记时标记对象是存活的，但因为用户线程的影响变为了垃圾对象</li><li><strong>错标</strong>：并发标记时标记对象是垃圾对象，但因为用户线程的影响变为了非垃圾对象</li><li>浮动垃圾无所谓，在下次垃圾回收的时候会把该垃圾回收即可；但是**”错标”会导致要使用的对象被回收了，所以接下来的”重新标记”阶段就是解决”错标”的问题！！**</li></ul></li><li><strong>重新标记</strong>(修正并发标记期间由于用户线程继续运作导致标记变动的记录)</li><li><strong>并发清理</strong>(用的清除,也是并发)</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JVM%E5%85%A5%E9%97%A8.assets/image-20240913173445561.png" alt="image-20240913173445561"></p><ul><li><strong>在初始标记和重新标记的时候会发生短暂的STW</strong></li><li>当 CMS 运行时，如果老年代内存不足且预留的空间不够分配新对象会导致并发失败，会先冻结用户线程,然后启动Serial Old来收集老年代</li><li><strong>缺点</strong>：产生内存碎片(导致提前触发full gc)、无法处理浮动垃圾(并发标记阶段用户线程又产生新的垃圾对象,CMS无法进行标记,这些对象就无法被及时回收)  &#x3D;&gt; JDK9废弃了</li></ul></li><li><p><strong>G1 垃圾回收器</strong>  </p><ul><li>JDK9 之后默认的垃圾回收器</li><li>将堆内存进行分区，优先回收垃圾最多的区间(Region)</li><li>优势：**兼具并行(多个GC线程同时工作)和并发(拥有与应用程序交替执行的能力)**；也是分代的(但空间上不要求连续,内存的回收以region为单位)；region之间是复制算法(但整体上看是标记整理,可以避免内存碎片)，大内存上有优势(内存小的时候和 CMS 差不多)</li><li>伊甸园空间耗尽则触发年轻代垃圾回收</li><li><strong>工作流程</strong>：<ul><li>**初始标记(STW)**：短暂停顿，标记 GC Roots 能直接关联到的对象</li><li>**并发标记(不会STW)**：与用户线程并发运行，可达性分析递归扫描堆中对象图，找出要回收的对象(通过写屏障的技术记录下会发生错标的对象)</li><li>**最终标记(STW)**：解决发生的错标问题，通过原始快照的算法解决，重新扫描被记录下来的灰色对象</li><li>**混合回收(STW-标记整理算法)**：<ul><li>根据G1跟踪生成的对于不同区的优先级列表，优先选择回收价值大的区</li><li>基于用户设定的 <strong>最大停顿时间(默认 200 毫秒)</strong> 生成回收计划，回收多个 Region，组成一个 <strong>回收集</strong></li><li>存活对象会被 <strong>复制到空闲的 Region</strong> 中，而旧的 Region 将被完全清空，因为涉及对象的移动，这一步需要 <strong>STW</strong></li></ul></li></ul><p></p></li><li><strong>与 CMS 比较</strong>：<ul><li><strong>回收算法</strong>：CMS 是 <strong>标记-清除</strong>，会产生内存碎片；G1 是 <strong>标记-整理</strong>，会进行内存压缩，避免碎片化，有利于程序长时间运行，在程序为大对象分配内存时不容易因无法找到连续内存空间而提前触发下一次收集</li><li><strong>内存占用</strong>：虽然G1和CMS都使用卡表来处理跨代引用，但G1的卡表实现更为复杂，而且堆中每个Region，都必须有一份卡表，这导致G1的记忆集（和其他内存消耗）可能会占整个堆容量的20%乃至更多的内存空间</li><li><strong>停顿时间</strong>：G1 支持用户设定最大停顿时间，具有更高的预测性，而 CMS 在老年代满时可能引发长时间的 Full GC</li></ul></li></ul></li></ul><h3 id="3-6-GC-相关参数"><a href="#3-6-GC-相关参数" class="headerlink" title="3.6 GC 相关参数"></a>3.6 GC 相关参数</h3><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JVM%E5%85%A5%E9%97%A8.assets/image-20240913173627895.png" alt="image-20240913173627895"></p><h3 id="补充：算法细节"><a href="#补充：算法细节" class="headerlink" title="补充：算法细节"></a>补充：算法细节</h3><h4 id="记忆集和卡表"><a href="#记忆集和卡表" class="headerlink" title="记忆集和卡表"></a>记忆集和卡表</h4><ul><li><strong>记忆集</strong>：一种用于记录从非收集区域指向收集区域的指针集合的抽象数据结构，用于记录跨代引用，减少 GC Roots 扫描范围</li><li><strong>卡表</strong>：是记忆集的一种实现形式，通过维护卡表记录内存区域的跨代引用情况<ul><li>在新生代上建立一个记忆集(Remembered Set)，把老年代划分成若干小块，标识出老年代的哪一块内存会存在跨代引用，如果当前某个card引用了新生代中的某对象，则这个card被称为脏card</li><li><strong>卡表元素何时变脏？</strong>&#x3D;&gt; 有其他分代区域中对象引用了本区域对象时，其对应的卡表元素就应该变脏，变脏时间点原则上应该发生在引用类型字段赋值的那一刻<ul><li>CMS中因为只需要维护一份卡表(老年代和新生代的引用问题),所以卡表的维护是同步的方式</li><li>G1中每一份region都需要持有一个Remembered Set(记忆集),卡表的维护较为繁琐，所以采取异步的方式(不会立即更新,会将脏卡的指令放到一个dirty card队列之中，将来由一个线程完成脏card的更新操作)</li></ul></li><li><strong>卡表元素如何变脏？</strong>&#x3D;&gt; HotSpot虚拟机里是通过写屏障（Write Barrier）技术维护卡表状态的</li></ul></li><li><strong>跨代引用问题</strong>：<ul><li><strong>分代垃圾回收</strong><ul><li>新生代对象可能被老年代对象引用，GC 在收集新生代时为了少量的跨代引用去扫描整个老年代并不划算</li><li>使用记忆集和卡表，在发生Minor GC时，只有包含了跨代引用的小块内存里的对象才会被加入到GCRoots进行扫描。避免了minor GC时需要对老年代全扫描一遍的低效</li></ul></li><li><strong>分区垃圾回收</strong>：<ul><li>将堆划分为多个大小相等的 <strong>Region</strong>，每个 Region 都有自己的记忆集，用于记录跨区域的引用，机制与分代垃圾回收相似</li><li>占用内存消耗更大</li></ul></li></ul></li></ul><h4 id="写屏障"><a href="#写屏障" class="headerlink" title="写屏障"></a>写屏障</h4><ul><li><p><strong>HotSpot 中通过”写屏障”的技术维护了卡表的更新状态</strong></p></li><li><p>写屏障可以看作<strong>在虚拟机层面对 “引用类型字段赋值” 这个动作的AOP切面，在引用对象赋值时会产生一个环绕（Around）通知</strong>，供程序执行额外的动作，也就是说赋值的前后都在写屏障的覆盖范畴内</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JVM%E5%85%A5%E9%97%A8.assets/image-20240911194844290.png" alt="image-20240911194844290"></p><ul><li>应用写屏障后，虚拟机就会为所有赋值操作生成相应的指令，一旦收集器在写屏障中增加了更新卡表操作，无论更新的是不是老年代对新生代对象的引用，每次只要对引用进行更新，就会产生额外的开销，不过这个开销与Minor GC时扫描整个老年代的代价相比还是低得多的</li><li><strong>应用</strong>：<ul><li>对卡表的状态的维护</li><li>在 <strong>并发标记阶段</strong> 记录根对象的引用变化(配合satb_mark_queue队列)，解决并发标记阶段的错标问题</li></ul></li></ul><h4 id="三色标记"><a href="#三色标记" class="headerlink" title="三色标记"></a>三色标记</h4><ul><li>想解决或者降低用户线程的停顿，就要先搞清楚为什么必须在一个能保障一致性的快照上才能进行对象图的遍历？</li><li>引入三色标记作为工具来辅助推导，把遍历对象图过程中遇到的对象，按照“是否访问过”这个条件标记成以下三种颜色：<ul><li>**黑色(不该被回收的对象)**：表示对象已经被垃圾收集器访问过，且这个对象的所有引用都已经扫描过。黑色的对象代表已经扫描过，它是安全存活的</li><li>**灰色(在该对象中找垃圾)**：表示对象已经被垃圾收集器访问过，但这个对象上至少存在一个引用还没有被扫描过</li><li>**白色(需要被回收的垃圾)**：表示对象尚未被垃圾收集器访问过，即代表不可达</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JVM%E5%85%A5%E9%97%A8.assets/image-20240911195722993.png" alt="image-20240911195722993"></p><ul><li><strong>对象消失问题</strong>：在并发标记过程中，用户线程可能会修改对象的引用关系，比如：<ul><li><strong>新增引用</strong>：原本被标记为黑色（安全存活）的对象突然引用了一个白色对象（还没被标记的对象）</li><li><strong>删除引用</strong>：灰色对象（正在扫描）突然不再引用某个白色对象</li><li>这些变化可能会导致垃圾回收器的标记过程出错，如：未标记的白色对象被错误回收，或者丢失了对已存在引用的对象的追踪</li></ul></li><li><strong>CMS和G1解决错标问题采用了三色标记法来辅助完成对对象状态的标记</strong>，解决并发标记时“对象消失问题”的两种方式：增量更新和原始快照 &#x3D;&gt; 都是通过写屏障实现的，在HotSpot虚拟机中，如CMS是基于增量更新来做并发标记的，G1、Shenandoah 则是用原始快照来实现<ul><li><strong>增量更新</strong>：在并发标记时，跟踪并标记新创建的引用。当用户线程修改对象引用时，系统会通过写屏障记录这些变化，确保在垃圾回收时不遗漏任何引用<ul><li>解决的是 <strong>黑色对象新增引用</strong> 导致的“错标”问题，通过写屏障记录新引用的白色对象，确保这些对象不会被错误地回收</li></ul></li><li><strong>原始快照</strong>：保持并发标记开始时的对象引用状态，即即使用户线程修改了引用，垃圾回收器仍然按照开始时的引用状态来标记。这种方式减少了对新引用的依赖，避免标记遗漏<ul><li>解决的是 <strong>灰色对象删除引用</strong> 导致的“错标”问题，通过写屏障保留最初的引用关系，确保原本引用的白色对象不会被漏标</li></ul></li></ul></li></ul><table><thead><tr><th><strong>增量更新（CMS）</strong></th><th><strong>原始快照（G1）</strong></th></tr></thead><tbody><tr><td><strong>关注新增引用</strong>：特别是黑色对象新增对白色对象的引用，需要重新扫描这些引用。</td><td><strong>关注删除引用</strong>：即使灰色对象删除了对某些白色对象的引用，依然按照原始快照继续标记。</td></tr><tr><td><strong>例子</strong>：黑色对象 A 新增了对白色对象 B 的引用，需要确保 B 不被误回收。</td><td><strong>例子</strong>：灰色对象 C 删除了对白色对象 D 的引用，D 仍然会被标记为存活对象。</td></tr><tr><td><strong>写屏障记录引用更新</strong>：跟踪对象引用新增的变化，确保垃圾回收不遗漏这些新增的白色对象。</td><td><strong>写屏障记录原始引用</strong>：即使引用关系发生变化，仍然按照并发标记开始时的快照继续标记。</td></tr><tr><td>主要避免因为 <strong>引用新增</strong> 导致对象漏标。</td><td>主要避免因为 <strong>引用删除</strong> 导致对象漏标。</td></tr></tbody></table><h2 id="4-垃圾回收调优"><a href="#4-垃圾回收调优" class="headerlink" title="4. 垃圾回收调优"></a>4. 垃圾回收调优</h2><blockquote><p>调优和应用、环境有关，因地制宜</p></blockquote><h3 id="4-1-GC-调优"><a href="#4-1-GC-调优" class="headerlink" title="4.1 GC 调优"></a>4.1 GC 调优</h3><ul><li><p><strong>调优领域</strong></p><ul><li><p>内存</p></li><li><p>锁竞争</p></li><li><p>cpu 占用</p></li><li><p>io</p></li></ul></li><li><p><strong>确定目标</strong></p><ul><li>低延迟(CMS，G1，ZGC)还是高吞吐(PS和PO)？</li></ul></li><li><p><strong>最快的GC是不发生GC</strong>，考虑思考几个问题</p><ul><li>是否加载太多数据到内存</li><li>数据表示是否太臃肿</li><li>是否存在内存泄漏，尝试用软弱引用或者考虑第三方缓存实现？</li></ul></li></ul><h3 id="4-2-新生代调优"><a href="#4-2-新生代调优" class="headerlink" title="4.2 新生代调优"></a>4.2 新生代调优</h3><blockquote><p>内存调优的点</p><ul><li>先检查代码由于自身问题可以优化的点</li><li>再进行内存调优，优先从新生代中调优…</li></ul></blockquote><ul><li><p><strong>新生代特点</strong>：</p><ul><li>所有new操作的内存分配非常廉价 &#x3D;&gt; 创建对象效率高<ul><li>**TLAB(thread-local allocation buffer)**：加速 <strong>对象分配</strong>，避免多线程之间对共享内存区域(Eden 区)的竞争和锁定开销<ul><li>每一个线程都会在伊甸园中给它分配一个私有的区域 TLAB</li><li>每次new一个对象，会检查TLAB缓冲区中有没有足够的空间来分配对象，如果有，会优先在这个区域里面进行对象内存分配，否则 JVM 会重新分配一个新的 TLAB 或者从 Eden 区的共享部分为对象分配内存</li><li>对象分配也会有线程安全问题，TLAB作用就是让每个线程用自己私有的这块伊甸园内存来进行对象分配</li></ul></li></ul></li><li>死亡对象回收代价是零 &#x3D;&gt; 复制算法</li><li>大部分对象用过即死</li><li>minor gc 时间远低于 full gc</li></ul></li><li><p>新生代空间太小会导致多次的 minor gc(多次的 STW)，太大会导致老年代空间小，容易触发 full gc(更长的 STW)，oracle 推荐新生代空间占堆的 25%-50% 之间</p></li><li><p>幸存区大到要能保留【当前活跃对象+需要晋升的对象】</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JVM%E5%85%A5%E9%97%A8.assets/image-20240912092019491.png" alt="image-20240912092019491"></p><h3 id="4-3-老年代调优"><a href="#4-3-老年代调优" class="headerlink" title="4.3 老年代调优"></a>4.3 老年代调优</h3><ul><li>以 CMS 为例，老年代内存越大越好(避免CMS的产生的浮动垃圾过多而导致的并发失败)<ul><li>先尝试不调老年代，再尝试新生代，除非还是有很多 full gc</li></ul></li></ul><h2 id="5-类加载和字节码技术"><a href="#5-类加载和字节码技术" class="headerlink" title="5. 类加载和字节码技术"></a>5. 类加载和字节码技术</h2><ul><li>在类加载器加载class文件到JVM虚拟机中，虚拟机中执行引擎的解释器会对jvm指令解释，解释阶段也会对一些代码进行”即使编译处理”，就是在虚拟机中是”解释+编译”</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JVM%E5%85%A5%E9%97%A8.assets/image-20240912092746712.png" alt="image-20240912092746712"></p><h3 id="5-1-类文件结构"><a href="#5-1-类文件结构" class="headerlink" title="5.1 类文件结构"></a>5.1 类文件结构</h3><blockquote><p>执行 <code>javac -parameters -d . HelloWorld.java</code> 编译java类</p><p>得到 class 文件，<code>od -t xC HelloWorld.class</code></p></blockquote><ul><li><strong>规范</strong>：魔数(前4个字节)、Class文件版本、常量池信息、访问标志、类索引,父类索引,接口索引集合、字段表集合、方法表集合、属性表集合</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JVM%E5%85%A5%E9%97%A8.assets/image-20240912092939463.png" alt="image-20240912092939463"></p><ul><li><strong>魔数</strong>：0-3字节，表示它是否是合法的 class 类型文件，java 的类的魔数：<code>ca fe ba be</code></li><li><strong>版本</strong>：4-7字节，表示类的版本，小版本和主版本各占俩字节，主要是后者，34(16进制)&#x3D;&gt;56 代表 JDK8</li><li><strong>常量池</strong>：8-9字节，表示常量池有几项，从1开始记录，如 <code>00 23</code> 表示十进制的 <code>35</code>，故有 <code>#1-#34</code> 共 34 项，后续就是这 34 项，(1个字节代表方法信息，后几个字节代表引用了常量池中的第几项来获得该方法的所属类和方法名)</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JVM%E5%85%A5%E9%97%A8.assets/image-20240912094143058.png" alt="image-20240912094143058"></p><h3 id="5-2-反编译-class-文件"><a href="#5-2-反编译-class-文件" class="headerlink" title="5.2 反编译 class 文件"></a>5.2 反编译 class 文件</h3><blockquote><p>使用 javap 工具反编译 class 文件</p></blockquote><ul><li>使用方式：<code>javap -v HelloWorld.class</code> （<code>-v</code> 表示输出类文件的详细信息）</li><li><strong>分析运行流程</strong>：<ul><li>**常量池载入运行时常量池(方法区的一部分)**：将class文件常量池中的信息载入方法区中的运行时常量池，并在解析阶段将符号引用转换为直接引用</li><li><strong>方法字节码载入方法区</strong>：小的数字和字节码指令存一起，超过 short 范围的数字存入常量池</li><li><strong>main 线程运行，分配栈帧内存</strong>：<code>.class</code> 文件中的 <code>stack</code> 和 <code>locals</code> 值代表了 <strong>方法的栈帧</strong> 中的 <strong>最大操作数栈深度</strong> 和 <strong>局部变量表的大小</strong>。这些信息由编译器在编译时确定(编译器基于方法的代码分析得出)，并在运行时用于分配栈帧资源</li><li><strong>执行引擎开始执行字节码</strong></li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JVM%E5%85%A5%E9%97%A8.assets/image-20240912100420482.png" alt="image-20240912100420482"></p><h3 id="5-3-构造方法"><a href="#5-3-构造方法" class="headerlink" title="5.3 构造方法"></a>5.3 构造方法</h3><ul><li><p><strong>字节码指令 <code>&lt;cinit&gt;()V</code></strong> </p><ul><li><strong>类构造器方法</strong>，用于初始化类变量和执行静态代码块</li><li><code>&lt;cinit&gt;()V</code> 方法会在类加载的初始化阶段被调用</li><li>编译器会按照从上至下的顺序，收集所有 static 静态代码块和静态成员复制的代码，合并成一个特殊的方法 <code>&lt;cinit&gt;()V</code></li><li>方法是类级别的，只执行一次，当类被首次使用时触发（如首次创建实例、访问静态字段、调用静态方法等）</li></ul></li><li><p><strong>字节码指令 <code>&lt;init&gt;()V</code></strong></p><ul><li><strong>对象构造器方法</strong>，通常是你在 Java 代码中定义的构造函数，以及任何实例初始化代码块（非静态代码块）和字段初始化表达式（确保了每个对象构造时其字段按照程序员的意图被正确初始化）</li><li>每次创建类的新实例时，<code>&lt;init&gt;()V</code> 方法都会被调用</li><li>编译器会按照从上至下的顺序，收集所有 {} 代码块和成员变量赋值的代码，形成新的构造方法，但原始构造方法内的代码总是在最后</li><li>方法是对象级别的，每创建一个实例就会调用一次</li></ul></li><li><p><strong>举例</strong>：</p><ul><li><strong>类初始化阶段（只一次）</strong><ul><li><code>staticValue = 10;</code></li><li><code>staticValue = 20;</code> (静态代码块)</li></ul></li><li><strong>每次实例化时</strong><ul><li><code>instanceValue = 100;</code> (实例变量初始化)</li><li><code>instanceValue = 200;</code> (实例初始化块)</li><li><code>instanceValue = 300;</code> (构造器)</li></ul></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">staticValue</span> <span class="operator">=</span> <span class="number">10</span>;    <span class="comment">// 静态变量初始化</span></span><br><span class="line">    <span class="keyword">static</span> &#123;                        <span class="comment">// 静态初始化块</span></span><br><span class="line">        staticValue = <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="variable">instanceValue</span> <span class="operator">=</span> <span class="number">100</span>;        <span class="comment">// 实例变量初始化</span></span><br><span class="line">    &#123;                               <span class="comment">// 实例初始化块</span></span><br><span class="line">        instanceValue = <span class="number">200</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyClass</span><span class="params">()</span> &#123;              <span class="comment">// 构造器</span></span><br><span class="line">        instanceValue = <span class="number">300</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-4-字节码指令解释"><a href="#5-4-字节码指令解释" class="headerlink" title="5.4 字节码指令解释"></a>5.4 字节码指令解释</h3><ul><li><p><code>istore</code>：将栈顶 int 类型的值弹出，并存储到局部变量表中的指定索引位置</p><ul><li><strong>使用场景</strong>：在方法执行中，对于基本类型的局部变量赋值操作，如将计算结果保存到一个局部变量中</li></ul></li><li><p><code>astore</code>：将栈顶引用类型的值弹出，并存储到局部变量表中的指定索引位置</p><ul><li>用于对象和数组类型的局部变量赋值，例如将一个对象引用存储到局部变量中</li></ul></li><li><p><code>aload</code>：从局部变量表中加载一个引用类型的值到操作数栈顶</p><ul><li><strong>使用场景</strong>：在需要使用局部变量表中的对象或数组时，如访问对象的成员或调用方法前</li></ul></li><li><p><code>bipush</code>：将一个 byte 类型的立即数（即直接指定的数值）压入至栈顶</p><ul><li><strong>使用场景</strong>：通常用于小范围的整数值赋值，如循环计数器的初始化。因为 <code>bipush</code> 可以直接将一个小整数（-128 到 127）推送到栈顶，常用于需要小整数的场景</li></ul></li></ul><h3 id="5-5-方法调用和多态原理"><a href="#5-5-方法调用和多态原理" class="headerlink" title="5.5 方法调用和多态原理"></a>5.5 方法调用和多态原理</h3><ul><li><p><strong>私有方法和 <code>final</code> 方法</strong> 使用 <code>invokespecial</code> 进行调用，因为它们在编译时已经确定，采用静态绑定</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">0</span>: <span class="keyword">new</span>           #<span class="number">3</span> <span class="comment">// class MyClass</span></span><br><span class="line"> <span class="number">3</span>: dup</span><br><span class="line"> <span class="number">4</span>: invokespecial #<span class="number">1</span> <span class="comment">// Method MyClass.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line"> <span class="number">7</span>: aload_1</span><br><span class="line"> <span class="number">8</span>: invokespecial #<span class="number">2</span> <span class="comment">// Method MyClass.privateMethod:()V</span></span><br><span class="line"><span class="number">11</span>: <span class="keyword">return</span></span><br></pre></td></tr></table></figure></li><li><p><strong>公共方法</strong> 使用 <code>invokevirtual</code> 进行调用，采用动态绑定，支持多态，运行时根据实际类型决定调用的具体实现</p><ul><li><strong>多态原理</strong>：每个类都有一个虚方法表 <code>vtable</code>，存储在类结构中，包含了指向类中所有虚方法的直接引用(虚方法是那些可能会被子类重写的方法)；<strong>虚方法表</strong> 通常是在类加载的 <strong>链接阶段</strong> (解析之后)生成的；类似 C++ 使用虚函数表来实现多态</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JVM%E5%85%A5%E9%97%A8.assets/image-20240912111357605.png" alt="image-20240912111357605"></p></li><li><p><strong>静态方法</strong> 使用 <code>invokestatic</code>，因为它不依赖对象实例，属于类级别的调用。使用对象调用静态方法时，JVM 需要先加载对象引用，会多出两条不必要的指令，因此推荐使用 <strong>类名</strong> 调用静态方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对象引用调用静态方法（不推荐）</span></span><br><span class="line"><span class="number">0</span>: <span class="keyword">new</span>           #<span class="number">3</span> <span class="comment">// class MyClass</span></span><br><span class="line"><span class="number">3</span>: dup</span><br><span class="line"><span class="number">4</span>: invokespecial #<span class="number">1</span> <span class="comment">// Method MyClass.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 两条多余指令</span></span><br><span class="line"><span class="number">7</span>: aload_1        <span class="comment">// 加载对象引用</span></span><br><span class="line"><span class="number">8</span>: pop            <span class="comment">// 弹出对象引用，因为静态方法不需要它</span></span><br><span class="line"></span><br><span class="line"><span class="number">9</span>: invokestatic   #<span class="number">2</span> <span class="comment">// Method MyClass.staticMethod:()V</span></span><br><span class="line"><span class="number">12</span>: <span class="keyword">return</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="5-6-异常处理"><a href="#5-6-异常处理" class="headerlink" title="5.6 异常处理"></a>5.6 异常处理</h3><ul><li><p><strong>异常表</strong>：当Java代码中包含<code>try-catch</code>结构时，编译器会在字节码中生成一个异常表。这个表里面记录了：</p><ul><li>哪些区域的代码是<code>try</code>块（哪行开始，哪行结束）</li><li>如果在这些区域中抛出异常，应该跳转到哪个位置去处理这个异常</li><li>每种异常类型对应的处理代码在哪里</li></ul></li><li><p><strong>多个 catch 块</strong>：当一个<code>try</code>块后面跟着多个<code>catch</code>块时：</p><ul><li>如果异常发生，JVM会查看异常表，找到第一个匹配的<code>catch</code>块，然后跳转到那里去执行</li><li>这些<code>catch</code>块通常会共用一些局部变量槽位。比如，多个<code>catch</code>块可能都会有一个用来存储异常信息的局部变量。这是一种内存优化手段，避免为每个<code>catch</code>块分配新的存储空间</li></ul></li><li><p><strong>multi-catch</strong>：在 Java 7 及以上版本，可以使用一个 catch 块捕获多种类型的异常，如<code> catch (IOException | SQLException ex)</code></p></li><li><p><strong>finally 块</strong>：确保无论 try 块是否抛出异常，finally 块中的代码都会被执行</p><ul><li><strong>实现原理</strong>：在字节码中，<code>finally</code> 块的代码被<strong>复制</strong>到每个可能的退出路径上(确保了无论是<code>try</code>块、<code>catch</code>块正常返回还是抛出异常，<code>finally</code> 块的代码都会被执行)。具体来说，<code>finally</code> 块的代码被复制了<strong>三份</strong>：<ul><li>一份在 <code>try</code> 块<strong>正常执行完毕</strong>后执行</li><li>一份在 <code>catch</code> 块处理完异常后执行</li><li>一份在 <code>catch</code> 处理不到的剩余异常（<code>any</code> 类型）时执行</li></ul></li><li><strong>注意</strong>：<ul><li>**不要在<code>finally</code>块中使用<code>return</code>**：方法会在执行 <code>finally</code> 块的 <code>return</code> 之后直接返回，而抛出的异常会被忽略掉(控制台不会看到异常抛出)</li><li><strong><code>finally</code>中的变量赋值不影响返回值</strong>：如果在<code>try</code>块中有一个<code>return</code>语句，而<code>finally</code>块中修改了该返回值，这个修改不会影响方法的实际返回值。因为执行时先把返回结果暂存，等finally执行完了再把暂存结果返回(恢复到栈顶)，所以最后返回的还是 try 块执行时已经存储的值，不影响返回结果</li></ul></li></ul></li></ul><h3 id="5-7-synchronized"><a href="#5-7-synchronized" class="headerlink" title="5.7 synchronized"></a>5.7 synchronized</h3><blockquote><p>从字节码的角度分析 synchronized 代码块</p><p>方法级别的 synchronized 不会体现在字节码中</p><p>这里是对象级别的 synchronized</p></blockquote><ul><li><p>先 new 对象，并复制(dup指令)了一份该对象的引用</p><ul><li>一份用于调用构造方法(会消耗一个引用)，一份存储到局部变量表中</li></ul></li><li><p>new 对象后将锁对象的引用加载到操作数栈顶</p><ul><li>再次复制一份该对象的引用，一个给加锁指令 monitorenter 用，一个给解锁指令 monitorexit 用</li></ul></li><li><p>加锁之后，当代码块中代码执行完毕，如果没有异常，则再执行monitorexit 来给对象解锁；如果代码块中出现了异常，会通过”异常表”也会进行解锁</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JVM%E5%85%A5%E9%97%A8.assets/image-20240912140006491.png" alt="image-20240912140006491"></p><h3 id="5-8-语法糖"><a href="#5-8-语法糖" class="headerlink" title="5.8 语法糖"></a>5.8 语法糖</h3><blockquote><p>语法糖：java 编译器将源码 .java 文件编译为 .class 字节码的过程中自动生成和转换的代码，目的是减轻程序员编码负担</p></blockquote><ul><li><strong>默认构造器</strong>：若本身代码没实现构造器，编译后默认生成的构造方法里调用 super() 的无参构造方法</li><li><strong>自动拆装箱</strong>：JDK5 后 java 的基本类型和包装类型的自动转换</li><li><strong>泛型集合取值</strong>：JDK5 后的泛型，java 在编译泛型代码会有<strong>泛型擦除</strong>的动作，即泛型信息在编译为字节码后就丢失了，实际的类型都当作了 Object 类型处理<ul><li>泛型是为了编译期间的类型检查，泛型擦除是为了便于字节码处理(方便向下兼容)</li><li>通过反射只可以拿到方法返回值和方法参数上的泛型信息，其他地方的泛型信息都会被”泛型擦除”</li></ul></li><li><strong>可变参数</strong>：如编译器会在编译期间把参数从 <code>String... args</code> 变为 <code>String[] args</code></li><li><strong>foreach 循环</strong>：如果遍历数组，会被编译器转换为 for 循环；如果遍历集合，会被转换成对迭代器的调用</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JVM%E5%85%A5%E9%97%A8.assets/image-20240912145244637.png" alt="image-20240912145244637"></p><ul><li><p><strong>switch</strong>：JDK7 开始 switch 可以作用于字符串和枚举类</p><ul><li><p>对 String 的支持，转换后的代码：</p><ul><li>执行了两遍 switch，第一遍根据字符串的 hashCode 和 equals 将字符串转换为相应 byte 类型，第二遍利用 byte 进行 switch 判断比较</li><li>先比较 hashCode 是为了提高比较效率，再比较 equals 是为了防止哈希冲突（因为hashCode相等不代表两个对象相同）</li></ul></li><li><p>对 enum 的支持，转换后的代码：</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JVM%E5%85%A5%E9%97%A8.assets/image-20240912150334768.png" alt="image-20240912150334768"></p></li><li><p><strong>枚举类</strong>：</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JVM%E5%85%A5%E9%97%A8.assets/image-20240912150506659.png" alt="image-20240912150506659"></p><ul><li><p><strong>try-with-resources</strong>：JDK7 引入的用于简化资源的关闭，省略 finally 块，前提是资源对象需要实现 <code>AutoCloseable</code> 接口</p><ul><li>代码示例</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JVM%E5%85%A5%E9%97%A8.assets/image-20240912151100950.png" alt="image-20240912151100950"></p><ul><li>转换后：不管是自己代码的异常还是关闭资源的异常，只要有就都会抛出</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JVM%E5%85%A5%E9%97%A8.assets/image-20240912151206091.png" alt="image-20240912151206091"></p></li><li><p><strong>方法重写时的桥接方法</strong>：方法重写时对返回值分两种情况</p><ul><li>父子类返回值类型一致</li><li>子类返回值可以是父类返回值的子类</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JVM%E5%85%A5%E9%97%A8.assets/image-20240912152318986.png" alt="image-20240912152318986"></p><ul><li><strong>匿名内部类</strong>：编译时额外生成了一个类，如果匿名内部类引用了局部变量，那么编译时生成的类里会新增一个属性，通过构造方法参数传入<ul><li>所以语法上匿名内部类引用局部变量时，局部变量必须是 final 的，因为底层内部类里的属性没有机会跟着一起变动，保证一致性</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JVM%E5%85%A5%E9%97%A8.assets/image-20240912152813205.png" alt="image-20240912152813205"></p><h2 id="6-类加载阶段"><a href="#6-类加载阶段" class="headerlink" title="6. 类加载阶段"></a>6. 类加载阶段</h2><blockquote><p>加载、链接、初始化</p></blockquote><h3 id="6-1-加载"><a href="#6-1-加载" class="headerlink" title="6.1 加载"></a>6.1 加载</h3><blockquote><p>方法区中的二进制字节码元数据(c++中一个数据结构,用来描述java类的)  和  堆中class类对象xxx.class</p></blockquote><ul><li>java 类编译成 class 字节码后，想要运行，需要通过 <strong>类加载器 把类的字节码加载到方法区中</strong>(底层用的 C++ 的 instanceKlass 描述 Java 类)<ul><li>instanceKlass 存储在方法区(1.8后也就是在元空间)，其包含的属性包括 <code>_java_mirror</code> 和类的一些其他信息 </li><li><code>_java_mirror</code> 是 Java 的类镜像(相当于桥梁，java 只能通过这个镜像来访问类的一些信息 &#x3D;&gt; 存储在堆中)，其实就是堆中的 Class类对象，如对于 String 类来说，<code>_java_mirror</code> 就是 <code>String.class</code></li><li>可以理解为 <strong>堆中的class对象是方法区中该类二进制字节码元数据的镜像</strong></li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JVM%E5%85%A5%E9%97%A8.assets/image-20240912154518799.png" alt="image-20240912154518799"></p><ul><li>如果这个类还有父类没有加载，会先加载父类</li><li>加载和链接可能是交替运行的</li></ul><h3 id="6-2-链接"><a href="#6-2-链接" class="headerlink" title="6.2 链接"></a>6.2 链接</h3><blockquote><p>验证、准备、解析</p></blockquote><ul><li><strong>验证</strong>：验证类是否符合 JVM 字节码规范 和 安全性检查(是否会对jvm虚拟机造成伤害)，比如魔数啥的是否正确</li><li><strong>准备</strong>：为静态变量开辟内存空间并设置默认值<ul><li>JDK8 后静态变量和class类对象(java_mirror)存储在一起，都是存储在堆中（JDK8 之前存储在方法区中的二进制元数据instanceKlass中）</li><li>静态变量分配空间和复制是两个步骤，分配空间在准备阶段完成，赋值在初始化阶段完成，但<ul><li>如果静态变量是 final 的基本类型以及字符串常量，那么编译阶段值就确定了，赋值就在准备阶段完成</li><li>如果静态变量是 final 的引用类型(new 出来的)或者包装类型，那么赋值还是推迟到初始化阶段完成</li></ul></li></ul></li><li><strong>解析</strong>：将运行时常量池中符号引用解析为直接引用(能确切知道类&#x2F;方法&#x2F;属性在内存中的位置)</li></ul><h3 id="6-3-初始化"><a href="#6-3-初始化" class="headerlink" title="6.3 初始化"></a>6.3 初始化</h3><blockquote><p>执行 clinit() 方法的过程，会将自己给静态变量赋值语句和静态代码块拼接起来组成 clinit() 方法</p><p> <code>&lt;clinit&gt;()</code> 代表 “class initialization method”，即类初始化方法</p></blockquote><ul><li><strong>触发的时机</strong>：</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JVM%E5%85%A5%E9%97%A8.assets/image-20240912161444041.png" alt="image-20240912161444041"></p><ul><li><strong>类加载阶段的前两个阶段是会执行的，但是初始化阶段并不一定会被执行</strong><ul><li>当 JVM 开始加载某个类时，<strong>加载</strong> 和 <strong>链接</strong> 阶段会自动进行，这些是类加载过程的必要步骤</li><li><strong>初始化</strong> 阶段只有在<strong>类被主动使用</strong>时才会触发。如果一个类被加载到 JVM，但从未主动使用，那么类的初始化阶段（包括静态变量的赋值和静态代码块的执行）可能永远不会发生，JVM 规范中定义了<strong>类的主动使用</strong>场景，例如：<ul><li>创建类的实例</li><li>访问类的静态字段（非常量静态字段）</li><li>调用类的静态方法</li><li>反射使用这个类</li><li>子类初始化时会初始化父类</li></ul></li></ul></li><li><strong>练习-利用静态内部类的初始化机制实现懒汉式的单例模式</strong>：(线程安全)<ul><li>**<code>main</code> 方法调用 <code>getInstance()</code>**：在 <code>main</code> 方法中调用 <code>Singleton.getInstance()</code> 时，JVM 开始查找 <code>Singleton</code> 类中的静态方法 <code>getInstance()</code></li><li><strong>类的初始化触发</strong>：<ul><li>因为访问了 <code>Singleton</code> 类的静态方法（<code>getInstance()</code>），这会触发 <strong><code>Singleton</code> 类的加载和初始化</strong></li><li>但此时，<strong>静态内部类 <code>SingletonHolder</code> 还没有被加载</strong>，因为 <code>SingletonHolder</code> 只会在首次使用时才被加载（即懒加载）</li></ul></li><li><strong>调用 <code>getInstance()</code></strong> 方法：<ul><li><code>getInstance()</code> 方法返回的是 <code>SingletonHolder.INSTANCE</code>，这就触发了 <strong><code>SingletonHolder</code> 静态内部类的加载和初始化</strong></li></ul></li><li><strong>加载 <code>SingletonHolder</code> 类</strong>：<ul><li>在 <code>SingletonHolder</code> 被加载时，它的静态成员 <code>INSTANCE</code>（<code>Singleton</code> 类的唯一实例）会被初始化。这是单例实例创建的时刻</li><li>JVM 会自动执行 <code>SingletonHolder</code> 类中的静态代码块或静态成员初始化，因此 <strong><code>INSTANCE</code> 会被创建</strong></li></ul></li><li><strong>返回单例实例</strong>：<ul><li>现在，<code>getInstance()</code> 方法返回 <code>SingletonHolder.INSTANCE</code>，这就是 <code>Singleton</code> 类的唯一实例</li><li>因为静态成员 <code>INSTANCE</code> 是在 <code>SingletonHolder</code> 被加载时创建的，并且只会初始化一次，所以无论你调用 <code>getInstance()</code> 多少次，返回的都是同一个实例</li></ul></li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JVM%E5%85%A5%E9%97%A8.assets/image-20240912171116449.png" alt="image-20240912171116449"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">// 私有构造函数，防止外部实例化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态内部类负责持有 Singleton 的唯一实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonHolder</span> &#123;</span><br><span class="line">        <span class="comment">// 在内部类被加载和初始化时，创建单例实例</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 公共静态方法，供外界获取单例实例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主函数，演示单例模式的调用</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取 Singleton 的实例</span></span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">instance1</span> <span class="operator">=</span> Singleton.getInstance();</span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">instance2</span> <span class="operator">=</span> Singleton.getInstance();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查两次获取的是否为同一个实例</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Instance 1 hash: &quot;</span> + instance1.hashCode());</span><br><span class="line">        System.out.println(<span class="string">&quot;Instance 2 hash: &quot;</span> + instance2.hashCode());</span><br><span class="line">        System.out.println(<span class="string">&quot;Same instance? &quot;</span> + (instance1 == instance2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>JVM 内部是如何保证一个类的静态代码块只会被执行一次？并且每个类只有一次？</strong><ul><li>类加载过程中的初始化阶段是执行 <code>clinit()</code> 方法的过程</li><li><strong><code>&lt;clinit&gt;()</code> 方法</strong>：静态变量初始化和静态代码块会被编译器合并成一个特殊的类初始化方法 <code>&lt;clinit&gt;()</code>，这个方法会在类加载的<strong>初始化阶段</strong>执行，并且只会被调用一次</li><li>当多个线程同时访问一个类的静态成员时，只有<strong>第一个访问该类的线程</strong>会触发类的加载和初始化，其他线程会被阻塞，等待初始化完成。JVM 在初始化类时对类加载过程进行加锁控制，以确保静态初始化代码（即 <code>&lt;clinit&gt;()</code> 方法）在多线程环境下的<strong>安全性</strong></li></ul></li></ul><h2 id="7-类加载器"><a href="#7-类加载器" class="headerlink" title="7. 类加载器"></a>7. 类加载器</h2><h3 id="7-1-概述"><a href="#7-1-概述" class="headerlink" title="7.1 概述"></a>7.1 概述</h3><ul><li><strong>向上委托，向下加载</strong>（先由下向上询问，再自上而下加载）</li><li><strong>父级加载器并不是父类加载器，并没有继承关系！！</strong></li><li>对于一个<strong>普通类的加载过程</strong>：<ul><li>先会自下而上去询问父级加载器是否加载过，加载过就终止，没有加载过就一直往父级询问</li><li>然后加载的时候自上而下的先寻找自己负责加载的目录下有没有该类，有该类的直接加载，没有就会让子加载器自己加载，从而保证类加载的安全性和类的唯一性</li></ul></li></ul><blockquote><p>启动类加载器、扩展类加载器、应用程序类加载器、自定义类加载器</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JVM%E5%85%A5%E9%97%A8.assets/image-20240912183244471.png" alt="image-20240912183244471"></p><ul><li><p><strong>启动类加载器</strong></p><ul><li><p>可以携带一些虚拟机启动参数设置”启动类加载器”来加载指定的类</p></li><li><p>获取加载当前class类对象的类加载器：<code>Class.forName(&quot;xxx.xx...&quot;).getClassLoader();</code></p></li><li><p>启动类加载器无法通过 java 代码直接获得，打印获得到的是null，因为这个加载器是由 c++ 写的</p></li></ul></li><li><p><strong>扩展类加载器</strong></p><ul><li>当你想让扩展类加载器加载一个类的时候，把该类打成jar包,然后放到 <code>Java_HOME/jre/lib/ext</code> 目录下</li><li>扩展类加载器就会加载这个目录下的jar包类，这样就轮不到应用程序类加载器来加载了</li></ul></li></ul><h3 id="7-2-双亲委派模式"><a href="#7-2-双亲委派模式" class="headerlink" title="7.2 双亲委派模式"></a>7.2 双亲委派模式</h3><ul><li>双亲委派指的是调用类加载器的 <code>loadClass</code> 方法时<strong>查找类的规则</strong></li><li><strong>源码分析</strong>：<ul><li><code>loadclass()</code>：<ul><li>当某个类加载器收到类加载请求时，它首先不会自己去加载，而是将请求委托给父加载器的 <code>loadClass()</code> 方法</li><li>递归调用父级加载的loadClass()方法来委托父级来进行加载</li></ul></li><li><code>findclass()</code>：如果父加载器找不到类，当前的类加载器会调用自己的 <code>findClass()</code> 方法，尝试加载这个类</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JVM%E5%85%A5%E9%97%A8.assets/image-20240912190620066.png" alt="image-20240912190620066"></p><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JVM%E5%85%A5%E9%97%A8.assets/image-20240912190637001.png" alt="image-20240912190637001"></p><ul><li><strong>好处</strong>：<ul><li><strong>安全性</strong>：防止自定义类加载器加载与核心类库同名的类，防止类篡改。例如，你不能通过自定义类加载器去加载一个伪造的 <code>java.lang.String</code> 类</li><li><strong>避免重复加载</strong>：通过委派机制，每个类只会被加载一次。如果类已经被某个父级加载器加载，子加载器就不再重新加载同一个类，避免了类的重复加载</li></ul></li></ul><h3 id="7-3-线程上下文类加载器"><a href="#7-3-线程上下文类加载器" class="headerlink" title="7.3 线程上下文类加载器"></a>7.3 线程上下文类加载器</h3><ul><li><p><strong>SPI（Service Provider Interface）</strong></p><ul><li><p><strong>目的</strong>：允许第三方提供类和接口的具体实现，这些实现可以在运行时被替换或添加，提供了极高的可扩展性</p></li><li><p><strong>工作原理</strong>：</p><ul><li><strong>定义服务接口</strong>：首先定义一个服务接口，这是服务提供者和服务消费者共同遵守的合同</li><li><strong>服务提供者实现接口</strong>：服务提供者根据定义好的接口实现具体的服务</li><li><strong>注册服务实现</strong>：服务提供者在自己的 JAR 文件中通过配置文件声明服务实现。这个配置文件通常位于 <code>META-INF/services</code> 目录下，并以服务接口的全限定类名命名。文件内容包含实现该服务接口的具体类的全限定名</li><li><strong>服务加载</strong>：使用 <code>ServiceLoader</code> 类，应用程序可以加载这些服务。<code>ServiceLoader</code> 读取配置文件，然后使用当前线程的上下文类加载器加载这些实现类</li></ul></li><li><p><strong>举例说明</strong>：</p><ul><li>在 JDBC 的案例中，服务接口是 <code>java.sql.Driver</code>。这是 Java 提供的一个接口，所有的 JDBC 驱动都必须实现这个接口，以便能被 <code>java.sql.DriverManager</code> 管理和使用</li><li>每个 JDBC 驱动的 JAR 文件中，会包含一个特定的配置文件，位于 <code>META-INF/services</code> 目录下。对于 <code>java.sql.Driver</code> 接口，配置文件的名称会是：<code>META-INF/services/java.sql.Driver</code></li><li>这个文件内部会列出实现了 <code>java.sql.Driver</code> 授课的具体类的全限定名。例如，如果你有一个 MySQL 数据库驱动的 JAR，文件内容可能会是：<code>com.mysql.cj.jdbc.Driver</code></li><li>当应用程序启动时，或者当你需要连接到数据库时，<code>DriverManager</code> 会尝试加载这些驱动。它会使用 <code>ServiceLoader</code> 来查找和加载所有可用的 JDBC 驱动程序</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ServiceLoader&lt;Driver&gt; loader = ServiceLoader.load(Driver.class);</span><br><span class="line"><span class="keyword">for</span> (Driver driver : loader) &#123;</span><br><span class="line">    <span class="comment">// 这里可以访问到每个加载的驱动实例</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Loaded driver: &quot;</span> + driver.getClass().getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>当每个驱动类被 <code>ServiceLoader</code> 加载时，通常在它们的静态初始化块中，它们会自动将自己注册到 <code>DriverManager</code> 中。这通常是通过调用 <code>DriverManager.registerDriver()</code> 方法实现的</p></li><li><p>一旦驱动程序注册，你就可以通过 <code>DriverManager</code> 来获取数据库连接了：<code>Connection conn = DriverManager.getConnection(&quot;jdbc:mysql://example.com:3306/mydb&quot;, &quot;user&quot;, &quot;password&quot;);</code></p></li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JVM%E5%85%A5%E9%97%A8.assets/image-20240912192208389.png" alt="image-20240912192208389"></p><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JVM%E5%85%A5%E9%97%A8.assets/image-20240912192214896.png" alt="image-20240912192214896"></p><ul><li><strong>以 JDBC 驱动程序加载为例</strong>：<ul><li><code>java.sql.DriverManager</code> 类负责管理数据库驱动程序的注册和连接，本身是由启动类加载器加载的，因为<code>java.sql</code> 包是 JDK 的标准 API 的一部分，位于 <code>rt.jar</code> 之中，这是 Java 的核心类库。因此，**<code>java.sql.DriverManager</code> 和其他 JDBC 核心接口位于启动类加载器的加载路径下**</li><li>但是 jdbc 的<strong>驱动是各个厂商来实现的，不在启动类加载路径下，启动类无法加载，而驱动管理需要用到这些驱动</strong></li><li>只能<strong>打破双亲委派，启动类直接请求启动类加载器去classpath下加载驱动</strong>（正常是向上委托，这个反过来了），而打破双亲委派的就是这个线程上下文类加载器</li></ul></li><li><strong>线程上下文类加载器的作用</strong>：<ul><li><strong>注册驱动</strong>：线程上下文类加载器用于在运行时加载外部驱动程序，这些驱动程序通常不是由 Java 系统类加载器加载的，因为它们不位于 Java 核心库的路径中</li><li>在java.sql.DriverManager被类加载(启动类加载器)的时候，该类的静态代码块中成对驱动的加载，但对驱动的加载并不是通过启动类加载器，而是利用java的SPI机制，先<strong>获取线程上下文类加载器，该加载器默认为应用程序加载器，然后<code>ServiceLoader.load()</code> 方法中会通过线程上下文类加载器来进行对驱动的加载</strong></li></ul></li><li>SPI 主要是为了解耦，允许服务接口的实现在运行时被动态加载和替换，而不需要修改原有的代码，使得应用程序可以插拔不同的服务实现 &#x3D;&gt; <strong>【面向接口编程+解耦】思想</strong></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JVM%E5%85%A5%E9%97%A8.assets/image-20240912201119134.png" alt="image-20240912201119134"></p><h3 id="7-4-自定义类加载器"><a href="#7-4-自定义类加载器" class="headerlink" title="7.4 自定义类加载器"></a>7.4 自定义类加载器</h3><ul><li><strong>什么时候需要自定义类加载器</strong>：</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JVM%E5%85%A5%E9%97%A8.assets/image-20240912202936863.png" alt="image-20240912202936863"></p><ul><li><strong>步骤</strong>：</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JVM%E5%85%A5%E9%97%A8.assets/image-20240912203028421.png" alt="image-20240912203028421"></p><ul><li><strong>在 Java 中，类的唯一性由其全限定名（即包名和类名的组合）和加载它的类加载器共同决定</strong><ul><li>如果包名类名一样，但是类加载器对象不一样，就会被认为是不同的类，会被加载两次，是隔离的</li></ul></li></ul><h2 id="8-运行期优化"><a href="#8-运行期优化" class="headerlink" title="8. 运行期优化"></a>8. 运行期优化</h2><h3 id="8-1-逃逸分析"><a href="#8-1-逃逸分析" class="headerlink" title="8.1 逃逸分析"></a>8.1 逃逸分析</h3><blockquote><p><a href="https://blog.csdn.net/Herishwater/article/details/123780967">JVM系列之：关于逃逸分析的学习_cannot use jvmci compiler: no jvmci compiler found-CSDN博客</a></p><p>[逃逸分析]属于C2即时编译器优化手段的一种</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JVM%E5%85%A5%E9%97%A8.assets/image-20240913084340242.png" alt="image-20240913084340242"></p><ul><li><strong>原因分析</strong>：</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JVM%E5%85%A5%E9%97%A8.assets/image-20240913084543858.png" alt="image-20240913084543858"></p><ul><li><strong>解释器和即时编译器(JIT-Just In Time Compiler)的区别</strong>：<ul><li>解释器每次遇到字节码都会一个字节一个字节解释成为机器码，下次遇到相同的字节码，还会解释执行</li><li>即时编译器会识别一些热点代码(字节码)，会将这些字节码编译为机器码并存入Code Cache，下次遇到相同代码，直接执行，无需再编译</li><li>解释器是将字节码解释为针对所有平台都通用的机器码</li><li>JIT 会根据平台类型，生成平台特定的机器码</li></ul></li></ul><blockquote><p><strong>编译器</strong>：在程序执行之前，将源代码一次性编译成字节码或机器码</p><p><strong>即时编译器（JIT 编译器）</strong>：在程序运行期间，将热点字节码编译为机器码，以提升运行时性能</p></blockquote><ul><li><strong>C1即时编译器和C2即时编译器优化程度不同</strong>：<ul><li><strong>[逃逸分析]是在C2即时编译器中做的优化！</strong></li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JVM%E5%85%A5%E9%97%A8.assets/image-20240913085229194.png" alt="image-20240913085229194"></p><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JVM%E5%85%A5%E9%97%A8.assets/image-20240913085248935.png" alt="image-20240913085248935"></p><ul><li><p><strong>逃逸分析(Escape Analysis)</strong> 并不是直接的优化手段，而是通过动态分析对象的作用域为其它优化手段提供依据的分析技术，用来分析一个对象的作用范围，判断该对象是否会<strong>逃逸</strong>出当前的作用域(如方法或线程)</p><ul><li>根据逃逸分析的结果，JVM 可以对对象的分配和垃圾回收进行优化，主要有以下几种典型的优化策略：<ul><li><strong>栈上分配</strong>：通常，Java 中的对象是在堆上分配内存的，但是如果通过逃逸分析确定对象没有逃逸出当前方法，那么 JVM 可以将对象直接分配在栈上而不是堆上。栈上的内存分配和回收比堆内存更快，也不需要垃圾回收的参与</li><li><strong>标量替换</strong>：如果逃逸分析表明对象可以完全分解成一组标量(如对象的属性)，并且这些标量可以在栈上分配，JVM 可以将对象分解为多个基本数据类型，而不需要真正创建对象。这种方式进一步减少了对象的分配和垃圾回收压力</li><li>**同步省略(锁消除)**：如果逃逸分析表明某个对象不会被其他线程访问，JVM 可以去掉不必要的同步代码。比如，在单线程方法中，如果对象只在当前线程中使用，JVM 可以认为不需要对该对象加锁，从而消除同步开销</li></ul></li><li>事实上，逃逸分析的结果更多被用于将新建对象操作转换成栈上分配或者标量替换</li></ul></li><li><p><strong>HotSpot JVM</strong> 并未真正实现 <strong>栈上分配</strong>，而是使用了 <strong>标量替换</strong></p><ul><li><strong>标量</strong>：不可再分割的基本数据类型，如 <code>int</code>、<code>float</code>、<code>boolean</code> 等</li><li><strong>聚合量</strong>：可以分割的数据结构，比如对象。一个对象由多个标量组成，比如一个 <code>Point</code> 对象有 <code>x</code> 和 <code>y</code> 两个 <code>int</code> 字段</li><li><strong>标量替换的原理</strong>：<ul><li>标量替换可以将原先对对象字段(聚合量)的访问,替换代替成为对一些局部变量(标量)的访问，就是将聚合量分解成为一个个标量，减少对象创建和垃圾回收的负担，提高了程序的执行效率</li><li>例如，如果你创建了一个 <code>Point</code> 对象，并且该对象没有逃逸，JVM 可以将 <code>Point</code> 的 <code>x</code> 和 <code>y</code> 字段作为局部变量直接在栈中存储，而无需真正创建 <code>Point</code> 对象</li></ul></li><li>默认情况下，<strong>标量替换</strong>是开启的，但你可以通过 JVM 参数（如 <code>-XX:-EliminateAllocations</code>）来禁用它</li></ul></li><li><p><strong>对象的内存分配策略</strong>：</p><ul><li><strong>优先在堆的伊甸园区分配</strong>：小对象通常会在堆的年轻代中（Eden 区）分配内存。这是默认的分配区域</li><li><strong>TLAB（Thread-Local Allocation Buffer）分配</strong>：如果开启了 TLAB（线程本地分配缓冲区），每个线程会有一个私有的小块内存（来自 Eden 区），用来加速对象的分配。这样可以减少多线程环境下的同步开销</li><li><strong>大对象直接分配到老年代</strong>：如果对象很大（通常是长数组或大数据结构），它会直接分配到堆的老年代，以避免年轻代垃圾回收的频繁触发</li><li><strong>逃逸分析和栈上分配</strong>：如果 JIT 编译器通过逃逸分析确定对象不会逃逸（即对象的生命周期局限于一个方法内），则理论上该对象可以直接分配在栈上，这样对象在方法结束时内存就会自动释放，无需依赖垃圾回收。不过在 HotSpot JVM 中，这种栈上分配通常通过标量替换的方式实现</li></ul></li></ul><h3 id="8-2-方法内联"><a href="#8-2-方法内联" class="headerlink" title="8.2 方法内联"></a>8.2 方法内联</h3><blockquote><p>[方法内联]也属于即时编译器优化手段的一种</p></blockquote><ul><li>内联就是把方法内代码拷贝粘贴到调用者的位置</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JVM%E5%85%A5%E9%97%A8.assets/image-20240913091234098.png" alt="image-20240913091234098"></p><ul><li><strong>代码示例</strong>：</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JVM%E5%85%A5%E9%97%A8.assets/image-20240913091351334.png" alt="image-20240913091351334"></p><h3 id="8-3-字段优化"><a href="#8-3-字段优化" class="headerlink" title="8.3 字段优化"></a>8.3 字段优化</h3><ul><li>字段优化：主要是针对”成员变量”和”静态变量”读写操作的优化</li><li><strong>开启方法内联的情况下(默认开启)，会结合字段优化来优化</strong>：</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JVM%E5%85%A5%E9%97%A8.assets/image-20240913093112752.png" alt="image-20240913093112752"></p><ul><li>**也可自己手动优化或编译器优化(foreach语法糖)**：</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JVM%E5%85%A5%E9%97%A8.assets/image-20240913093313836.png" alt="image-20240913093313836"></p><ul><li><p><strong>补充</strong>：<strong>JMH（Java Microbenchmark Harness）</strong> 是一个专门用于 Java 语言的基准测试框架，用来准确地测量 Java 代码性能</p><ul><li><p><strong>关键注解</strong></p><ul><li><p>**<code>@Benchmark</code>**：标记基准测试方法。JMH 会运行这个方法多次，并统计其执行时间</p></li><li><p>**<code>@BenchmarkMode</code>**：指定测试模式，如吞吐量、平均时间、单次执行时间等</p></li><li><p>**<code>@OutputTimeUnit</code>**：指定测试结果的输出时间单位，如秒、毫秒、纳秒等</p></li><li><p>**<code>@State</code>**：指定基准测试的状态范围，可以是线程级、进程级等，确保对象在基准测试中的状态</p></li><li><p>**<code>@Warmup</code>**：指定预热的轮数和时间，帮助 JIT 编译器优化代码</p></li></ul></li><li><p><strong>JMH 是 Java 的微基准测试框架</strong>，用于测量方法、代码段等小粒度代码的性能，添加依赖编写测试代码即可</p></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.openjdk.jmh.annotations.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="meta">@BenchmarkMode(Mode.AverageTime)</span> <span class="comment">// 使用平均时间模式</span></span><br><span class="line"><span class="meta">@OutputTimeUnit(TimeUnit.MILLISECONDS)</span> <span class="comment">// 输出结果以毫秒为单位</span></span><br><span class="line"><span class="meta">@State(Scope.Thread)</span> <span class="comment">// 定义测试状态为每个线程独立</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBenchmark</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 基准测试方法</span></span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        calculate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 要测试的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">calculate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-4-反射优化"><a href="#8-4-反射优化" class="headerlink" title="8.4 反射优化"></a>8.4 反射优化</h3><ul><li>反射调用的性能相对较低，因为它需要通过 <code>Method.invoke()</code> 进行间接调用，涉及到安全检查和参数处理等<ul><li>为了提高反射调用的性能，JVM 会采用一种 “膨胀” 机制：当某个反射调用非常频繁时，JVM 会将它优化为一种更高效的直接调用形式，从而减少反射调用的开销</li><li>具体来说，<strong>膨胀</strong>就是指将原本使用通用的反射调用路径（<code>Method.invoke()</code>）的操作，转换为更高效的字节码路径，类似于直接调用的方法。JVM 通过这种方式来加速频繁的反射调用</li></ul></li><li>**膨胀阈值(Inflation Threshold)**：是控制 “膨胀” 机制何时触发的关键参数。也就是说，当反射调用的次数达到一定的阈值后，JVM 就会触发膨胀机制，将反射调用转化为更高效的直接调用<ul><li>在 <code>ReflectionFactory</code> 源码的实现中，这个膨胀阈值默认值是 <strong>15</strong>，表示当某个反射方法被调用 15 次之后，JVM 就会对该方法进行膨胀，将其优化为直接调用路径</li><li>如果反射调用次数<strong>低于 15 次</strong>，JVM 使用 <code>NativeMethodAccessorImpl</code> 处理反射调用，它是<strong>基于本地方法的实现</strong>，适合处理少量调用</li><li><strong>膨胀发生</strong>：当反射调用次数超过膨胀阈值（15 次）后，<code>MethodAccessor</code> 会被替换为一个更高效的实现，称为 <code>GeneratedMethodAccessor</code>，它是通过字节码生成直接调用路径的方法</li></ul></li></ul><h2 id="9-JMM-Java-内存模型"><a href="#9-JMM-Java-内存模型" class="headerlink" title="9. JMM-Java 内存模型"></a>9. JMM-Java 内存模型</h2><blockquote><p>可以配合 黑马 的并发编程视频学习，这里快速过下</p></blockquote><ul><li>JMM 规定了在<strong>多线程下对共享数据的读写时对数据的原子性、有序性、可见性的规则和保障</strong></li></ul><h3 id="9-1-原子性"><a href="#9-1-原子性" class="headerlink" title="9.1 原子性"></a>9.1 原子性</h3><ul><li>例如：Java 中对静态变量的自增、自减不是原子操作，有可能被 CPU 交错执行</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JVM%E5%85%A5%E9%97%A8.assets/image-20240913095254956.png" alt="image-20240913095254956"></p><ul><li><p><strong>从 JMM 角度分析</strong>：对静态变量的自增、自减需要再主内存和线程内存(工作内存)中进行数据交换</p><ul><li>共享的变量信息是放在主内存中的，线程是在工作内存中</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JVM%E5%85%A5%E9%97%A8.assets/image-20240913095415931.png" alt="image-20240913095415931"></p><ul><li>多线程情况下(轮流使用CPU)指令交错产生的问题</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JVM%E5%85%A5%E9%97%A8.assets/image-20240913095659878.png" alt="image-20240913095659878"></p><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JVM%E5%85%A5%E9%97%A8.assets/image-20240913095707201.png" alt="image-20240913095707201"></p><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JVM%E5%85%A5%E9%97%A8.assets/image-20240913095756344.png" alt="image-20240913095756344"></p></li><li><p><strong>问题解决</strong>：java中通过synchronized来保证了原子性</p></li></ul><h3 id="9-2-可见性"><a href="#9-2-可见性" class="headerlink" title="9.2 可见性"></a>9.2 可见性</h3><ul><li><strong>举例</strong>：main 线程对 run 变量的修改对 t 线程不可见，导致了 t 线程无法停止</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JVM%E5%85%A5%E9%97%A8.assets/image-20240913100118675.png" alt="image-20240913100118675"></p><ul><li><strong>原因分析</strong>：t 线程频繁的读取 boolean 这个变量，然后即时编译器就会视为热点代码，将boolean的值缓存到高速缓存中，所以 t 线程每次读取都是从自己的工作内存中读取，主内存中改了值，其实 t 线程是感知不到的</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JVM%E5%85%A5%E9%97%A8.assets/image-20240913100422046.png" alt="image-20240913100422046"></p><ul><li><p><strong>解决方法</strong>：</p><ul><li><p>使用 <code>volatile</code> 关键字修饰变量</p><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JVM%E5%85%A5%E9%97%A8.assets/image-20240913100604050.png" alt="image-20240913100604050"></p><ul><li><p>volatile 可以保证可见性和有序性，但是不能保证原子性，它只适用于一个写线程，多个读线程的情况</p></li><li><p>通过读写屏障保证线程之间的可见性和禁止编译器&#x2F;处理器对指令进行指令重排序</p></li></ul></li><li><p>synchronized 既可以保证原子性，也可以保证可见性，但属于重量级的操作，是一种重量级锁，线程的用户态-&gt;内核态的转变，比较重量级操作</p></li></ul></li><li><p><strong>注意</strong>：</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JVM%E5%85%A5%E9%97%A8.assets/image-20240913101110351.png" alt="image-20240913101110351"></p><h3 id="9-3-有序性"><a href="#9-3-有序性" class="headerlink" title="9.3 有序性"></a>9.3 有序性</h3><ul><li><p><strong>指令重排</strong>是指编译器和 CPU 在不改变单线程语义的前提下，出于性能优化的目的，可以对指令的执行顺序进行调整。指令重排可以提高程序的执行效率，但在多<strong>线程环境下，它可能会导致并发问题</strong></p></li><li><p>在多线程环境下，指令重排可能导致线程之间的数据可见性问题，举例：<strong>双重检查锁定的单例模式</strong>  &#x3D;&gt; <strong>变量需要加volatile</strong>，否则会指令重排造成问题，使得返回的对象不完整</p><ul><li><code>instance = new Singleton()</code> 实际上它可能会被分解为以下三个步骤：<ul><li>分配内存给 <code>Singleton</code> 对象</li><li>调用 <code>Singleton</code> 的构造方法</li><li>将分配的内存地址赋值给 <code>instance</code></li></ul></li><li>由于指令重排的存在，步骤 2 和步骤 3 可能会被重排，可能会出现 <code>instance</code> 已经指向了分配的内存（步骤 3 已经执行），但对象还没有完全初始化（步骤 2 尚未执行完毕）。导致另一个线程在未完全初始化的情况下获取了 <code>instance</code>，从而导致程序异常</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();  <span class="comment">// 指令重排可能发生在这里</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JVM%E5%85%A5%E9%97%A8.assets/image-20240913123834849.png" alt="image-20240913123834849"></p><h3 id="9-4-happens-before-规则"><a href="#9-4-happens-before-规则" class="headerlink" title="9.4 happens-before 规则"></a>9.4 happens-before 规则</h3><ul><li>happens-before 规则描述了哪些写操作可以对其他线程的读操作可见，是保证可见性与有序性的一套规则：<ul><li>简单地说，如果一个操作 A <strong>happens-before</strong> 另一个操作 B，那么 A 的结果对 B 可见，A 的操作完成后，B 才会开始</li><li>这里的变量都是共享变量，也就是成员变量或静态变量</li></ul></li><li><strong>总结</strong>：并不是指代码在物理上的执行顺序，而是确保逻辑上的操作顺序<ul><li><strong>程序顺序</strong>：同一线程中，前面的操作 <strong>happens-before</strong> 后面的操作</li><li><strong>锁规则</strong>：解锁 <strong>happens-before</strong> 后续的加锁</li><li><strong>volatile 规则</strong>：<code>volatile</code> 写操作 <strong>happens-before</strong> 读操作</li><li><strong>线程启动</strong>：<code>start()</code> <strong>happens-before</strong> 子线程开始运行</li><li><strong>线程终止</strong>：线程结束 <strong>happens-before</strong> 其他线程检测到它结束（如 <code>join()</code>）</li><li><strong>中断规则</strong>：<code>interrupt()</code> <strong>happens-before</strong> 中断状态的检测</li><li><strong>终结规则</strong>：对象的构造 <strong>happens-before</strong> <code>finalize()</code> 方法</li><li><strong>传递性</strong>：A <strong>happens-before</strong> B 且 B <strong>happens-before</strong> C，那么 A <strong>happens-before</strong> C</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JVM%E5%85%A5%E9%97%A8.assets/image-20240913140702468.png" alt="image-20240913140702468"></p><h2 id="10-CAS"><a href="#10-CAS" class="headerlink" title="10. CAS"></a>10. CAS</h2><ul><li>CAS(Compare-and-Swap) 是配合 volatile 使用的一项技术，体现的是一种乐观锁的思想，是一种无锁并发技术<ul><li>获取”主内存中值时”，<strong>为了保证变量的可见性，需要使用volatile来修饰</strong>！集合CAS和volatile可以实现无锁并发！</li><li>CAS <strong>适用场景：竞争不激烈，多核CPU的情况下</strong><ul><li>因为等待的线程并不是进行进入阻塞状态，而是一种在尝试尝试 &#x3D;&gt; 效率提升的原因之一(在低竞争时效率比synchronized高)</li><li>但其他线程也需要占用CPU资源，如果竞争激烈，会影响效率</li></ul></li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JVM%E5%85%A5%E9%97%A8.assets/image-20240913125937970.png" alt="image-20240913125937970"></p><ul><li><strong>CAS 操作底层依赖于一个 Unsafe 类直接调用操作系统底层的 CAS 指令</strong><ul><li>CAS 在操作系统中就是一条指令，所以是原子性的</li></ul></li><li><strong>原子操作类</strong>：<ul><li>java中的悲观锁：synchronized</li><li>java中的乐观锁：CAS</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JVM%E5%85%A5%E9%97%A8.assets/image-20240913131020822.png" alt="image-20240913131020822"></p><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JVM%E5%85%A5%E9%97%A8.assets/image-20240913131209281.png" alt="image-20240913131209281"></p><h2 id="11-Synchronized-优化"><a href="#11-Synchronized-优化" class="headerlink" title="11. Synchronized 优化"></a>11. Synchronized 优化</h2><blockquote><p><code>synchronized</code> 的传统实现是一种重量级锁，性能相对较低，尤其是在频繁竞争和上下文切换时。为了解决性能问题，Java 虚拟机（JVM）引入了一系列<strong>锁优化机制</strong>，包括<strong>偏向锁</strong>、<strong>轻量级锁</strong>、<strong>重量级锁</strong></p><p>注意锁只能升级不能降级！</p></blockquote><ul><li><strong>对象头</strong>：Java 对象头主要分为两部分<ul><li><strong>Mark Word</strong>：存储对象的状态信息（如锁信息、GC 信息等）</li><li><strong>Class Pointer</strong>：指向该对象所属类的元数据（Class 元数据）</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JVM%E5%85%A5%E9%97%A8.assets/image-20240913131316057.png" alt="image-20240913131316057"></p><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JVM%E5%85%A5%E9%97%A8.assets/image-20240913141301268.png" alt="image-20240913141301268"></p><ul><li><p><strong>锁状态</strong>：对象头的Mark Word中”锁标志位”分别对应四种锁状态</p><ul><li>无锁</li><li>偏向锁</li><li>轻量级锁</li><li>重量级锁</li></ul></li><li><p><strong>轻量级锁</strong></p><ul><li>采用了 <strong>CAS（Compare-And-Swap）操作</strong> 来尝试获取锁，而不直接进入重量级锁状态</li><li><strong>适用场景</strong>：适合线程竞争不激烈（锁持有时间短）的场景，轻量级锁可以通过自旋来减少线程上下文切换的开销</li><li>当一个线程持有轻量级锁时，另一个线程尝试获取该锁。如果失败，会进行自旋。自旋一定次数后，如果仍然无法获取锁，轻量级锁会升级为重量级锁，则轻量级锁会升级为重量级锁（锁膨胀）</li></ul></li><li><p><strong>重量级锁</strong></p><ul><li>当锁升级为重量级锁时，JVM 会采用操作系统级的线程阻塞机制来进行线程同步。获取锁失败的线程会进入阻塞状态，直到锁释放</li><li>重量级锁会导致线程上下文切换，性能较差</li><li><strong>适用场景</strong>：适合锁竞争激烈的场景，但由于线程阻塞和唤醒的开销较大，效率较低</li></ul></li><li><p><strong>偏向锁</strong>：偏向锁的设计是为了<strong>消除轻量级锁在单线程无竞争情况下的锁开销</strong>。如果只有一个线程反复获取锁，偏向锁不需要执行 CAS 操作，而是直接让该线程“偏向”该锁</p><ul><li>JVM 会在锁对象的<strong>对象头（Mark Word）中记录持有偏向锁的线程 ID</strong>，在接下来该线程的加锁和解锁操作中，无需执行 CAS 操作，直接进入临界区</li><li>如果另一个线程尝试获取已经偏向某个线程的锁时，偏向锁会被撤销，Java 15 中默认禁用偏向锁，并在后续版本中完全移除，因为偏向锁的撤销过程会带来额外的性能开销，对性能的提升有限</li></ul></li><li><p><strong>其他优化</strong>：</p><ul><li><strong>减少上锁时间</strong>：尽量缩短锁定临界区的代码块</li><li><strong>减少锁粒度</strong>：减少不必要的锁竞争，提高并发性能</li><li><strong>锁粗化</strong>：将多个连续的小的锁合并为一个大锁，以避免频繁的加锁和解锁操作，减少锁重入的开销</li><li><strong>锁消除</strong>：JVM 在运行时通过逃逸分析判断锁是否有必要存在，如果确定某个锁只在单线程内使用，且不会逃逸到其他线程，则可以消除不必要的锁操作</li><li><strong>读写分离</strong>：使用 <strong>读写锁（<code>ReadWriteLock</code>）</strong> 来区分读操作和写操作，允许多个线程同时进行读操作，但写操作依然是互斥的</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lua 脚本</title>
      <link href="/2024/07/14/Lua%E8%84%9A%E6%9C%AC/"/>
      <url>/2024/07/14/Lua%E8%84%9A%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<h1 id="Lua-脚本"><a href="#Lua-脚本" class="headerlink" title="Lua 脚本"></a>Lua 脚本</h1><blockquote><p>学习视频：</p><p><a href="https://www.bilibili.com/video/BV1WR4y1E7ud/?spm_id_from=333.788.recommend_more_video.-1">Lua教程-进阶部分 - 4K超清【不定期更新】_哔哩哔哩_bilibili</a></p><p><a href="https://www.runoob.com/lua/lua-tutorial.html">Lua 教程 | 菜鸟教程 (runoob.com)</a></p></blockquote><ul><li><p>文档：<a href="https://wiki.luatos.com/">LuatOS 文档</a></p><ul><li><a href="https://www.lua.org/manual/5.3/">Lua 5.3 Reference Manual - contents</a></li></ul></li><li><p>轻量级、嵌入式脚本语言</p></li><li><p>最常见的中间件 <code>Redis</code> <code>MySQL Proxy</code> 和 <code>MySQL WorkBench</code>都是可以通过lua脚本进行扩展功能</p></li></ul><h2 id="1-环境搭建"><a href="#1-环境搭建" class="headerlink" title="1. 环境搭建"></a>1. 环境搭建</h2><h3 id="1-1-Win-环境下载"><a href="#1-1-Win-环境下载" class="headerlink" title="1.1 Win 环境下载"></a>1.1 Win 环境下载</h3><blockquote><p><a href="https://blog.csdn.net/ChinarCSDN/article/details/78667262">Lua在Windows下的安装、配置、运行_lua-language-server win7-CSDN博客</a></p></blockquote><ul><li>官网：<a href="https://www.lua.org/">https://www.lua.org/</a></li><li>在线编译界面：<a href="https://onecompiler.com/lua/42jmby4vv">https://onecompiler.com/lua/42jmby4vv</a></li><li>下载界面：[Download lua-5.4.2_Win32_bin.zip (LuaBinaries) (sourceforge.net)](<a href="https://sourceforge.net/projects/luabinaries/files/5.4.2/Tools">https://sourceforge.net/projects/luabinaries/files/5.4.2/Tools</a> Executables&#x2F;lua-5.4.2_Win32_bin.zip&#x2F;download)</li><li>解压后配置环境变量：<code>D:\lua-5.4.2_Win32_bin</code></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/Lua%E8%84%9A%E6%9C%AC.assets/image-20240709144147601.png" alt="image-20240709144147601"></p><ul><li>打开 cmd，输入 <code>lua54</code> 或 <code>lua54 -i</code> 即可打开 Lua 交互式编程模式（54 指的是版本是5.4，具体看文件夹里exe的命名）<ul><li>点击 <code>ctrl+Z</code> 后再回车即可退出该交互式环境</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/Lua%E8%84%9A%E6%9C%AC.assets/image-20240709144254315.png" alt="image-20240709144254315"></p><h3 id="1-2-IDEA-配置-Lua-开发环境"><a href="#1-2-IDEA-配置-Lua-开发环境" class="headerlink" title="1.2 IDEA 配置 Lua 开发环境"></a>1.2 IDEA 配置 Lua 开发环境</h3><blockquote><p><a href="https://blog.csdn.net/qq_38628046/article/details/126043343">搭建Lua开发环境（Lua解释器+IDEA编译器）_lua ide-CSDN博客</a></p></blockquote><ul><li>IDEA 中安装 Lua 插件：EmmyLua</li><li>新建 lua 项目：</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/Lua%E8%84%9A%E6%9C%AC.assets/image-20240709144830450.png" alt="image-20240709144830450"></p><ul><li>设置 SDK：<code>Ctrl+Alt+Shift+S</code> 打开配置SDK，添加 Lua 的SDK 并配置 Lua 的 SDK 安装位置</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/Lua%E8%84%9A%E6%9C%AC.assets/image-20240709145321935.png" alt="image-20240709145321935"></p><ul><li>设置解释器程序</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/Lua%E8%84%9A%E6%9C%AC.assets/image-20240709145230174.png" alt="image-20240709145230174"></p><ul><li>编写 lua 脚本即可运行：<code>Hello.lua</code></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/Lua%E8%84%9A%E6%9C%AC.assets/image-20240709150004999.png" alt="image-20240709150004999"></p><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/Lua%E8%84%9A%E6%9C%AC.assets/image-20240709170749390.png" alt="image-20240709170749390"></p><h3 id="1-3-VSCode-配置-Lua-环境"><a href="#1-3-VSCode-配置-Lua-环境" class="headerlink" title="1.3 VSCode 配置 Lua 环境"></a>1.3 VSCode 配置 Lua 环境</h3><ul><li>创建文件夹：<code>Lua_Vscode_code</code></li><li>安装 Lua 语言插件和调试器</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/Lua%E8%84%9A%E6%9C%AC.assets/image-20240709230353198.png" alt="image-20240709230353198"></p><ul><li>设置中搜索 executorMap，点击在 setting.json 中编辑</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/Lua%E8%84%9A%E6%9C%AC.assets/image-20240709230841290.png" alt="image-20240709230841290"></p><ul><li>修改默认 Lua 配置，指定安装包地址，如图所示（没有就直接加）</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;code-runner.executorMap&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;lua&quot;</span><span class="punctuation">:</span> <span class="string">&quot;D:\\lua-5.4.2_Win32_bin\\lua54.exe&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/Lua%E8%84%9A%E6%9C%AC.assets/image-20240709230927020.png" alt="image-20240709230927020"></p><ul><li>运行成功：</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/Lua%E8%84%9A%E6%9C%AC.assets/image-20240709231014547.png" alt="image-20240709231014547"></p><h2 id="2-基本语法"><a href="#2-基本语法" class="headerlink" title="2. 基本语法"></a>2. 基本语法</h2><blockquote><p><a href="https://www.runoob.com/lua/lua-basic-syntax.html">Lua 基本语法 | 菜鸟教程 (runoob.com)</a></p></blockquote><h3 id="2-1-注释"><a href="#2-1-注释" class="headerlink" title="2.1 注释"></a>2.1 注释</h3><ul><li>变量默认是全局的，不需要声明，赋值后即创建完成</li><li>访问未初始化的全局变量得到 nil</li></ul><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 单行注释</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">--[[</span></span><br><span class="line"><span class="comment">    多行注释</span></span><br><span class="line"><span class="comment">    多行注释</span></span><br><span class="line"><span class="comment">--]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 变量默认是全局的, 不需要声明, 赋值后即创建完成</span></span><br><span class="line">a = <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 访问未初始化的全局变量得到 nil</span></span><br><span class="line"><span class="built_in">print</span>(b) <span class="comment">-- nil</span></span><br></pre></td></tr></table></figure><h3 id="2-2-数据类型"><a href="#2-2-数据类型" class="headerlink" title="2.2 数据类型"></a>2.2 数据类型</h3><ul><li>Lua 是动态类型语言，变量不要类型定义，只需要为变量赋值</li><li>值可以存储在变量中，作为参数传递或结果返回</li></ul><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 数据类型</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="string">&quot;Hello world&quot;</span>))  <span class="comment">-- string</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="number">10.4</span>*<span class="number">3</span>))  <span class="comment">-- number</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="built_in">print</span>))  <span class="comment">-- function</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="built_in">type</span>))  <span class="comment">-- function</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="literal">true</span>))  <span class="comment">-- boolean</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="literal">nil</span>))  <span class="comment">-- nil</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="built_in">type</span>(X)))  <span class="comment">-- string</span></span><br></pre></td></tr></table></figure><ul><li>Lua 中有 8 个基本类型分别为：<strong>nil、boolean、number、string、userdata、function、thread 和 table</strong></li></ul><table><thead><tr><th align="left">数据类型</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">nil</td><td align="left">这个最简单，只有值nil属于该类，表示一个无效值（在条件表达式中相当于false）</td></tr><tr><td align="left">boolean</td><td align="left">包含两个值：false和true</td></tr><tr><td align="left">number</td><td align="left">表示双精度类型的实浮点数</td></tr><tr><td align="left">string</td><td align="left">字符串由一对双引号或单引号来表示</td></tr><tr><td align="left">function</td><td align="left">由 C 或 Lua 编写的函数</td></tr><tr><td align="left">userdata</td><td align="left">表示任意存储在变量中的C数据结构</td></tr><tr><td align="left">thread</td><td align="left">表示执行的独立线路，用于执行协同程序</td></tr><tr><td align="left">table</td><td align="left">Lua 中的表（table）其实是一个”关联数组”（associative arrays），数组的索引可以是数字、字符串或表类型。在 Lua 里，table 的创建是通过”构造表达式”来完成，最简单构造表达式是{}，用来创建一个空表</td></tr></tbody></table><ul><li><strong>nil 类型</strong>：</li></ul><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--[[ nil 类型:</span></span><br><span class="line"><span class="comment">给全局变量或者 table 表里的变量赋一个 nil 值, 等同于把它们删掉</span></span><br><span class="line"><span class="comment">table 可以同时包含数组部分(以整数索引访问)和键值对部分(以字符串或其他非整数类型为键访问)</span></span><br><span class="line"><span class="comment">--]]</span></span><br><span class="line">tab1 = &#123; key1 = <span class="string">&quot;val1&quot;</span>, key2 = <span class="string">&quot;val2&quot;</span>, <span class="string">&quot;val3&quot;</span> &#125;</span><br><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> <span class="built_in">pairs</span>(tab1) <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(k .. <span class="string">&quot; - &quot;</span> .. v)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">tab1.key1 = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> <span class="built_in">pairs</span>(tab1) <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(k .. <span class="string">&quot; - &quot;</span> .. v)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- nil 作比较时应该加上双引号 &quot;</span></span><br><span class="line"><span class="built_in">type</span>(X)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(X) == <span class="literal">nil</span>)  <span class="comment">-- false</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(X) == <span class="string">&quot;nil&quot;</span>)  <span class="comment">-- true (type(X)实质是返回的 &quot;nil&quot; 字符串, 是一个 string 类型)</span></span><br></pre></td></tr></table></figure><ul><li><strong>boolean 类型</strong>：</li></ul><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--[[ boolean 类型</span></span><br><span class="line"><span class="comment">false 和 nil 看作 false, 其余均为 true (包括数字0)</span></span><br><span class="line"><span class="comment">--]]</span></span><br><span class="line"><span class="keyword">if</span> <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;数字 0 是 true&quot;</span>)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;数字 0 为 false&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><ul><li><strong>number 类型</strong>：</li></ul><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--[[ number 类型</span></span><br><span class="line"><span class="comment">默认只有 double 类型</span></span><br><span class="line"><span class="comment">--]]</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="number">2</span>))  <span class="comment">-- number</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="number">0.2</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="number">0.2e-1</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="number">7.8263692594256e-06</span>))</span><br></pre></td></tr></table></figure><ul><li><strong>string 类型</strong>：<ul><li>长度计算可以用 <code>string.len(str)</code> 或 <code>utf8.len(str)</code></li></ul></li></ul><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--[[ string 类型</span></span><br><span class="line"><span class="comment">可以用单引号/双引号</span></span><br><span class="line"><span class="comment">也可以用两个方括号表示一块字符串</span></span><br><span class="line"><span class="comment">--]]</span></span><br><span class="line">html = <span class="string">[[</span></span><br><span class="line"><span class="string">&lt;html&gt;</span></span><br><span class="line"><span class="string">&lt;head&gt;&lt;/head&gt;</span></span><br><span class="line"><span class="string">&lt;body&gt;</span></span><br><span class="line"><span class="string">&lt;a href=&quot;http://www.aaa.com/&quot;&gt;hhh&lt;/a&gt;</span></span><br><span class="line"><span class="string">&lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;</span></span><br><span class="line"><span class="string">]]</span></span><br><span class="line"><span class="built_in">print</span>(html)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 字符串连接使用 ..</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;hhh&quot;</span> .. <span class="string">&quot;aaa&quot;</span>)  <span class="comment">-- hhhaaa</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用 # 计算字符串的长度</span></span><br><span class="line"><span class="built_in">len</span> = <span class="string">&quot;www.aaa.com&quot;</span></span><br><span class="line"><span class="built_in">print</span>(#<span class="built_in">len</span>)  <span class="comment">-- 11</span></span><br></pre></td></tr></table></figure><ul><li><strong>table 类型</strong>：<ul><li>Lua 中并没有专门的数组类型，而是使用一种被称为 <strong>“table”</strong> 的数据结构来实现数组的功能</li><li>可以使用整数索引来访问数组元素，如果指定的索引没有值则返回 <strong>nil</strong>，除此外我们还可以以负数为数组索引值</li><li>Lua 提供了<strong>元表</strong>(是一个特殊的表, 是普通表的扩展功能)允许我们改变 table 的行为，每个行为关联了对应的元方法<ul><li>使用元表我们可以定义 Lua 如何计算两个 table 的相加操作 a+b</li><li>元方法是元表中的特定字段，用于定义表的行为</li></ul></li></ul></li></ul><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--[[ table 表</span></span><br><span class="line"><span class="comment">通过 构造表达式 完成创建, 最简单的构造表达式是 &#123;&#125;</span></span><br><span class="line"><span class="comment">其实是一个关联数组, 数组的索引可以是数字或者是字符串</span></span><br><span class="line"><span class="comment">本质上是一个无序的集合,  Lua 的 table 是基于哈希表实现的, 元素的存储顺序可能会因为哈希冲突和哈希表重建等因素而变化</span></span><br><span class="line"><span class="comment">Lua 里表的默认初始索引一般以 1 开始</span></span><br><span class="line"><span class="comment">table 不会固定长度大小, 有新数据添加时 table 长度会自动增长, 没初始的 table 都是 nil</span></span><br><span class="line"><span class="comment">--]]</span></span><br><span class="line"><span class="comment">-- 创建一个空的 table</span></span><br><span class="line"><span class="keyword">local</span> tbl1 = &#123;&#125;</span><br><span class="line"><span class="comment">-- 直接初始表</span></span><br><span class="line"><span class="keyword">local</span> tbl2 = &#123;<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;pear&quot;</span>, <span class="string">&quot;orange&quot;</span>, <span class="string">&quot;grape&quot;</span>&#125;</span><br><span class="line">a = &#123;&#125;</span><br><span class="line">a[<span class="string">&quot;key&quot;</span>] = <span class="string">&quot;value&quot;</span></span><br><span class="line">key = <span class="number">10</span></span><br><span class="line">a[key] = <span class="number">22</span></span><br><span class="line">a[key] = a[key] + <span class="number">11</span></span><br><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> <span class="built_in">pairs</span>(a) <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(k .. <span class="string">&quot; : &quot;</span> .. v)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建一个数组</span></span><br><span class="line"><span class="keyword">local</span> myArray = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;</span><br><span class="line"><span class="comment">-- 添加新元素到数组末尾</span></span><br><span class="line">myArray[#myArray + <span class="number">1</span>] = <span class="number">60</span></span><br><span class="line"><span class="comment">-- 循环遍历数组</span></span><br><span class="line"><span class="keyword">for</span> i = <span class="number">1</span>, #myArray <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(myArray[i])</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 删除第三个元素</span></span><br><span class="line"><span class="built_in">table</span>.<span class="built_in">remove</span>(myArray, <span class="number">3</span>)</span><br></pre></td></tr></table></figure><ul><li><strong>function 函数</strong></li></ul><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--[[ function 函数</span></span><br><span class="line"><span class="comment">--]]</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial1</span><span class="params">(n)</span></span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> n * factorial1(n - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">print</span>(factorial1(<span class="number">5</span>))</span><br><span class="line">factorial2 = factorial1  <span class="comment">-- 函数可以存在变量里</span></span><br><span class="line"><span class="built_in">print</span>(factorial2(<span class="number">5</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 可以以匿名函数的方式通过参数传递</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testFun</span><span class="params">(tab,fun)</span></span>  <span class="comment">-- 接受一个 table 和一个函数作为参数</span></span><br><span class="line">    <span class="keyword">for</span> k ,v <span class="keyword">in</span> <span class="built_in">pairs</span>(tab) <span class="keyword">do</span></span><br><span class="line">        <span class="built_in">print</span>(fun(k,v));</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">tab=&#123;key1=<span class="string">&quot;val1&quot;</span>,key2=<span class="string">&quot;val2&quot;</span>&#125;;</span><br><span class="line">testFun(tab,</span><br><span class="line">    <span class="function"><span class="keyword">function</span><span class="params">(key,val)</span></span>  <span class="comment">-- 匿名函数</span></span><br><span class="line">        <span class="keyword">return</span> key..<span class="string">&quot;=&quot;</span>..val;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li><strong>线程</strong></li></ul><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--[[ 线程</span></span><br><span class="line"><span class="comment">在 lua 中的线程实际上是协程, 允许在不同的执行点之间切换, 而无需使用多线程的复杂性和开销</span></span><br><span class="line"><span class="comment">轻量级线程, 它们在单个线程内执行, 并且由程序显式地管理执行的切换点</span></span><br><span class="line"><span class="comment">--]]</span></span><br><span class="line">co = <span class="built_in">coroutine</span>.<span class="built_in">create</span>(<span class="function"><span class="keyword">function</span><span class="params">()</span></span>  <span class="comment">-- 创建协程</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Hello from coroutine&quot;</span>)</span><br><span class="line">    <span class="keyword">end</span>)</span><br><span class="line"><span class="comment">-- 执行协程</span></span><br><span class="line"><span class="built_in">coroutine</span>.<span class="built_in">resume</span>(co)  <span class="comment">-- Hello from coroutine</span></span><br></pre></td></tr></table></figure><h3 id="2-3-变量"><a href="#2-3-变量" class="headerlink" title="2.3 变量"></a>2.3 变量</h3><ul><li>Lua 变量有三种类型：全局变量、局部变量、表中的域<ul><li>Lua 中的变量全是全局变量，哪怕是语句块或是函数里，除非用 local 显式声明为局部变量</li><li>局部变量的作用域为从声明位置开始到所在语句块结束</li><li>变量的默认值均为 nil</li></ul></li></ul><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--[[全局变量 VS 局部变量</span></span><br><span class="line"><span class="comment">--]]</span></span><br><span class="line">a = <span class="number">5</span>               <span class="comment">-- 全局变量</span></span><br><span class="line"><span class="keyword">local</span> b = <span class="number">5</span>         <span class="comment">-- 局部变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">joke</span><span class="params">()</span></span></span><br><span class="line">    c = <span class="number">5</span>           <span class="comment">-- 全局变量</span></span><br><span class="line">    <span class="keyword">local</span> d = <span class="number">6</span>     <span class="comment">-- 局部变量</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">joke()</span><br><span class="line"><span class="built_in">print</span>(c,d)          <span class="comment">--&gt; 5 nil</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="keyword">local</span> a = <span class="number">6</span>     <span class="comment">-- 局部变量</span></span><br><span class="line">    b = <span class="number">6</span>           <span class="comment">-- 对局部变量重新赋值</span></span><br><span class="line">    <span class="built_in">print</span>(a,b);     <span class="comment">--&gt; 6 6</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a,b)      <span class="comment">--&gt; 5 6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 赋值语句</span></span><br><span class="line">a, b, c = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(a,b,c)             <span class="comment">--&gt; 0   1   nil</span></span><br><span class="line"></span><br><span class="line">a, b = a+<span class="number">1</span>, b+<span class="number">1</span>, b+<span class="number">2</span>     <span class="comment">-- value of b+2 is ignored</span></span><br><span class="line"><span class="built_in">print</span>(a,b)               <span class="comment">--&gt; 1   2</span></span><br><span class="line"></span><br><span class="line">a, b, c = <span class="number">0</span></span><br><span class="line"><span class="built_in">print</span>(a,b,c)             <span class="comment">--&gt; 0   nil   nil</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 索引, 对 table 的索引使用 [] 或 .</span></span><br><span class="line">t = &#123;key1=<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;hh&quot;</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(t[<span class="number">1</span>])  <span class="comment">-- hh</span></span><br><span class="line"><span class="built_in">print</span>(t.key1)  <span class="comment">-- key1 当索引为字符串类型时的一种简化写法</span></span><br></pre></td></tr></table></figure><h3 id="2-4-运算符"><a href="#2-4-运算符" class="headerlink" title="2.4 运算符"></a>2.4 运算符</h3><ul><li>算术、关系、逻辑、其他运算符</li><li>算术运算符：＋、-、*、&#x2F;、%、^、&#x2F;&#x2F;(整除,&gt;&#x3D;lua5.3)</li><li>关系运算符：&#x3D;&#x3D;、~&#x3D;(不等于)、&gt;、&lt;、&gt;&#x3D;、&lt;&#x3D;</li><li>逻辑运算符：and or not</li><li>其他运算符：..(连接两个字符串)、#(返回字符串或表的长度)</li><li>优先级：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">^</span><br><span class="line">not    - (unary)</span><br><span class="line">*      /       %</span><br><span class="line">+      -</span><br><span class="line">..</span><br><span class="line">&lt;      &gt;      &lt;=     &gt;=     ~=     ==</span><br><span class="line">and</span><br><span class="line">or</span><br></pre></td></tr></table></figure><ul><li><strong>代码示例</strong>：</li></ul><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--[[ 运算符</span></span><br><span class="line"><span class="comment">--]]</span></span><br><span class="line"><span class="comment">-- 算术运算符</span></span><br><span class="line">a = <span class="number">21</span></span><br><span class="line">b = <span class="number">10</span></span><br><span class="line">c = a + b</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Line 1 - c 的值为 &quot;</span>, c )  <span class="comment">-- 31</span></span><br><span class="line">c = a - b</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Line 2 - c 的值为 &quot;</span>, c )  <span class="comment">-- 11</span></span><br><span class="line">c = a * b</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Line 3 - c 的值为 &quot;</span>, c )  <span class="comment">-- 210</span></span><br><span class="line">c = a / b</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Line 4 - c 的值为 &quot;</span>, c )  <span class="comment">-- 2.1</span></span><br><span class="line">c = a // b</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Line 5 - c 的值为 &quot;</span>, c )  <span class="comment">-- 2</span></span><br><span class="line">c = a % b</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Line 6 - c 的值为 &quot;</span>, c )  <span class="comment">-- 1</span></span><br><span class="line">c = a^<span class="number">2</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Line 7 - c 的值为 &quot;</span>, c )  <span class="comment">-- 441.0</span></span><br><span class="line">c = -a</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Line 8 - c 的值为 &quot;</span>, c )  <span class="comment">-- -21</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 关系运算符</span></span><br><span class="line">a = <span class="number">21</span></span><br><span class="line">b = <span class="number">10</span></span><br><span class="line"><span class="keyword">if</span>( a ~= b )</span><br><span class="line">    <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Line 9 - a 不等于 b&quot;</span> )</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Line 9 - a 等于 b&quot;</span> )</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 逻辑运算符 and or not</span></span><br><span class="line">a = <span class="literal">false</span></span><br><span class="line">b = <span class="literal">true</span></span><br><span class="line"><span class="keyword">if</span> ( a <span class="keyword">and</span> b )</span><br><span class="line">    <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;a and b - 条件为 true&quot;</span> )</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;a and b - 条件为 false&quot;</span> )</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 其他运算符 ..(连接两个字符串)、#(返回字符串或表的长度)</span></span><br><span class="line">a = <span class="string">&quot;Hello &quot;</span></span><br><span class="line">b = <span class="string">&quot;World&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;连接字符串 a 和 b &quot;</span>, a..b )  <span class="comment">-- Hello World</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;b 字符串长度 &quot;</span>, #b)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;字符串 Test 长度 &quot;</span>, #<span class="string">&quot;Test&quot;</span> )</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;网址长度 &quot;</span>, #<span class="string">&quot;www.run.com&quot;</span> )</span><br></pre></td></tr></table></figure><ul><li><p><strong>三元操作符</strong>：举例</p><ul><li><p><code>(szMod == nil) and false or szMod</code> Lua 中的三元操作符（条件运算符）模式，用于根据条件选择不同的值</p></li><li><p><code>(szMod == nil)</code>：检查 <code>szMod</code> 是否为 <code>nil</code></p><ul><li>如果 <code>szMod</code> 为 <code>nil</code>，则表达式结果为 <code>true</code></li><li>否则表达式结果为 <code>false</code></li></ul></li><li><p><code>and false</code>：如果 <code>(szMod == nil)</code> 为 <code>true</code>，则返回 <code>false</code></p></li><li><p><code>or szMod</code>：如果 <code>and</code> 左侧为 <code>false</code>（即 <code>(szMod == nil)</code> 为 <code>false</code>），则返回 <code>szMod</code> 的值</p></li></ul></li></ul><h2 id="3-控制语句"><a href="#3-控制语句" class="headerlink" title="3. 控制语句"></a>3. 控制语句</h2><h3 id="3-1-循环"><a href="#3-1-循环" class="headerlink" title="3.1 循环"></a>3.1 循环</h3><p>Lua 语言提供了以下几种循环处理方式：</p><table><thead><tr><th align="left">循环类型</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">while 循环</td><td align="left">在条件为 true 时，让程序重复地执行某些语句。执行语句前会先检查条件是否为 true。</td></tr><tr><td align="left">for 循环</td><td align="left">重复执行指定语句，重复次数可在 for 语句中控制。</td></tr><tr><td align="left">repeat…until</td><td align="left">重复执行循环，直到 指定的条件为真时为止</td></tr><tr><td align="left">循环嵌套</td><td align="left">可以在循环内嵌套一个或多个循环语句（while do … end;for … do … end;repeat … until;）</td></tr></tbody></table><ul><li><strong>代码示例</strong>：</li></ul><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--[[ 循环</span></span><br><span class="line"><span class="comment">--]]</span></span><br><span class="line"><span class="comment">-- while 循环</span></span><br><span class="line">a = <span class="number">10</span></span><br><span class="line"><span class="keyword">while</span>( a &lt; <span class="number">20</span> )</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;a 的值为:&quot;</span>, a)</span><br><span class="line">    a = a+<span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- for 循环</span></span><br><span class="line"><span class="comment">-- 数值 for 循环</span></span><br><span class="line"><span class="keyword">for</span> i=<span class="number">10</span>,<span class="number">1</span>,<span class="number">-1</span> <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 泛型 for 循环</span></span><br><span class="line">a = &#123;<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>&#125;</span><br><span class="line"><span class="keyword">for</span> i, v <span class="keyword">in</span> <span class="built_in">ipairs</span>(a) <span class="keyword">do</span>  <span class="comment">-- ipairs是Lua提供的一个迭代器函数, 用来迭代数组</span></span><br><span class="line">    <span class="built_in">print</span>(i, v)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- repeat...until 循环</span></span><br><span class="line"><span class="comment">--[ 变量定义 --]</span></span><br><span class="line">a = <span class="number">10</span></span><br><span class="line"><span class="comment">--[ 执行循环 --]</span></span><br><span class="line"><span class="keyword">repeat</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;a的值为:&quot;</span>, a)</span><br><span class="line">    a = a + <span class="number">1</span></span><br><span class="line"><span class="keyword">until</span>( a &gt; <span class="number">15</span> )</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 循环嵌套</span></span><br><span class="line">j=<span class="number">2</span></span><br><span class="line"><span class="keyword">for</span> i=<span class="number">2</span>,<span class="number">10</span> <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">for</span> j=<span class="number">2</span>,(i/j),<span class="number">2</span> <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">not</span>(i%j))</span><br><span class="line">            <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">if</span>(j &gt; (i/j))<span class="keyword">then</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;i 的值为：&quot;</span>,i)  <span class="comment">-- 8 9 10</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="3-2-选择"><a href="#3-2-选择" class="headerlink" title="3.2 选择"></a>3.2 选择</h3><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--[[ 选择语句</span></span><br><span class="line"><span class="comment">--]]</span></span><br><span class="line"><span class="comment">-- if 语句</span></span><br><span class="line">a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">if</span>( a &lt; <span class="number">20</span> )</span><br><span class="line">    <span class="keyword">then</span></span><br><span class="line">    <span class="comment">--[ if 条件为 true 时打印以下信息 --]</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;a 小于 20&quot;</span> );</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a 的值为:&quot;</span>, a);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- if..else 语句</span></span><br><span class="line">a = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">if</span>( a &lt; <span class="number">20</span> ) <span class="keyword">then</span></span><br><span class="line">    <span class="comment">--[ if 条件为 true 时执行该语句块 --]</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;a 小于 20&quot;</span> )</span><br><span class="line"><span class="keyword">elseif</span> (a == <span class="number">20</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;a 等于 20&quot;</span>)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="comment">--[ if 条件为 false 时执行该语句块 --]</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;a 大于 20&quot;</span> )</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a 的值为 :&quot;</span>, a)</span><br></pre></td></tr></table></figure><h2 id="4-函数"><a href="#4-函数" class="headerlink" title="4. 函数"></a>4. 函数</h2><ul><li>函数默认为全局函数，若需要设置函数为局部函数需要使用关键字 <strong>local</strong></li></ul><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 函数</span></span><br><span class="line"><span class="comment">--[[ 函数返回两个值的最大值 --]]</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">max</span><span class="params">(num1, num2)</span></span></span><br><span class="line">    <span class="keyword">if</span> (num1 &gt; num2) <span class="keyword">then</span></span><br><span class="line">        result = num1;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        result = num2;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 调用函数</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;两值比较最大值为 &quot;</span>,<span class="built_in">max</span>(<span class="number">10</span>,<span class="number">4</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;两值比较最大值为 &quot;</span>,<span class="built_in">max</span>(<span class="number">5</span>,<span class="number">6</span>))</span><br><span class="line"><span class="comment">-- 可以将函数作为参数传递给函数</span></span><br><span class="line">myPrint = <span class="function"><span class="keyword">function</span><span class="params">(param)</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;这是打印函数 - ##&quot;</span>, param, <span class="string">&quot;##&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span><span class="params">(num1,num2,functionPrint)</span></span></span><br><span class="line">    result = num1 + num2</span><br><span class="line">    <span class="comment">-- 调用传递的函数参数</span></span><br><span class="line">    functionPrint(result)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">myPrint(<span class="number">10</span>)</span><br><span class="line"><span class="comment">-- myPrint 函数作为参数传递</span></span><br><span class="line">add(<span class="number">2</span>,<span class="number">5</span>,myPrint)</span><br><span class="line"><span class="comment">-- 可变参数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">average</span><span class="params">(...)</span></span></span><br><span class="line">    result = <span class="number">0</span></span><br><span class="line">    <span class="keyword">local</span> <span class="built_in">arg</span>=&#123;...&#125;    <span class="comment">--&gt; arg 为一个表，局部变量</span></span><br><span class="line">    <span class="keyword">for</span> _,v <span class="keyword">in</span> <span class="built_in">ipairs</span>(<span class="built_in">arg</span>) <span class="keyword">do</span></span><br><span class="line">        result = result + v</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;总共传入 &quot;</span> .. #<span class="built_in">arg</span> .. <span class="string">&quot; 个数&quot;</span>)  <span class="comment">-- 总共传入 6 个数</span></span><br><span class="line">    <span class="keyword">return</span> result/#<span class="built_in">arg</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;平均值为&quot;</span>,average(<span class="number">10</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>))  <span class="comment">-- 平均值为 5.5</span></span><br><span class="line"><span class="comment">-- 几个固定参数加上可变参数，固定参数必须放在变长参数之前</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fWrite</span><span class="params">(fmt, ...)</span></span>  <span class="comment">---&gt; 固定的参数fmt</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">io</span>.<span class="built_in">write</span>(<span class="built_in">string</span>.<span class="built_in">format</span>(fmt, ...))</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">fWrite(<span class="string">&quot;run\n&quot;</span>)       <span class="comment">---&gt;fmt = &quot;run\n&quot;, 没有变长参数, 输出 run\n</span></span><br><span class="line">fWrite(<span class="string">&quot;%d%d\n&quot;</span>, <span class="number">1</span>, <span class="number">2</span>)   <span class="comment">---&gt;fmt = &quot;%d%d&quot;, 变长参数为 1 和 2, 输出 12\n</span></span><br></pre></td></tr></table></figure><h2 id="5-多文件调用"><a href="#5-多文件调用" class="headerlink" title="5. 多文件调用"></a>5. 多文件调用</h2><ul><li>模块类似于一个封装库，从 Lua 5.1 开始，Lua 加入了标准的模块管理机制，可以把一些公用的代码放在一个文件里，以 API 接口的形式在其他地方调用，有利于代码的重用和降低代码耦合度</li><li><strong>Lua 的模块是由变量、函数等已知元素组成的 table</strong>，因此创建一个模块很简单，就是创建一个 table，然后把需要导出的常量、函数放入其中，最后返回这个 table 就行</li></ul><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 文件名为 module.lua</span></span><br><span class="line"><span class="comment">-- 定义一个名为 module 的模块</span></span><br><span class="line"><span class="built_in">module</span> = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 定义一个常量</span></span><br><span class="line"><span class="built_in">module</span>.constant = <span class="string">&quot;这是一个常量&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 定义一个函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">module.func1</span><span class="params">()</span></span></span><br><span class="line">    <span class="built_in">io</span>.<span class="built_in">write</span>(<span class="string">&quot;这是一个公有函数！\n&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">func2</span><span class="params">()</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;这是一个私有函数！&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">module.func3</span><span class="params">()</span></span></span><br><span class="line">    func2()</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">module</span></span><br></pre></td></tr></table></figure><ul><li><strong>require 函数</strong>：用来加载模块。要加载一个模块，只需要简单地调用就可以了<ul><li>可以运行指定的文件，末尾不带扩展名</li><li>目录层级用 <code>.</code> 分割  <code>require(&quot;path.hello2&quot;)</code></li><li>只会运行一次，每次调用的返回值都是第一次调用的结果</li></ul></li></ul><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 文件名为 main.lua</span></span><br><span class="line"><span class="keyword">local</span> <span class="built_in">module</span> = <span class="built_in">require</span> <span class="string">&quot;module&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 调用公有函数</span></span><br><span class="line"><span class="built_in">module</span>.func1()  <span class="comment">-- 输出：这是一个公有函数！（没有自动换行，因为手动添加了 \n）</span></span><br><span class="line"><span class="built_in">module</span>.func3()  <span class="comment">-- 输出：这是一个私有函数！（自动换行）</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">module</span>.constant)  <span class="comment">-- 输出：这是一个常量（自动换行）</span></span><br></pre></td></tr></table></figure><ul><li>查找时从 <code>package.path</code> 里查找</li></ul><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- test.lua 文件</span></span><br><span class="line"><span class="built_in">_G</span>.count = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">require</span>(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line"><span class="built_in">require</span>(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line"><span class="built_in">require</span>(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line"><span class="keyword">local</span> r = <span class="built_in">require</span>(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(r)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">_G</span>.count)  <span class="comment">-- 2</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">package</span>.<span class="built_in">path</span>)</span><br><span class="line"><span class="comment">-- 路径是从 package.path 里查找的</span></span><br><span class="line"><span class="comment">-- 此处添加路径path文件夹下的路径至 package.path, 就可以直接 require hello2.lua, 不用再写路径了</span></span><br><span class="line"><span class="built_in">package</span>.<span class="built_in">path</span> = <span class="built_in">package</span>.<span class="built_in">path</span> .. <span class="string">&quot;;./path/?.lua&quot;</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">&quot;hello2&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- hello.lua 文件</span></span><br><span class="line"><span class="built_in">_G</span>.count = <span class="built_in">_G</span>.count + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> name = <span class="string">&quot;world&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hello, &quot;</span> .. name)  <span class="comment">-- Hello, world</span></span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;done&quot;</span></span><br></pre></td></tr></table></figure><ul><li><strong>多次调用</strong>：若想多次调用某个 <code>lua</code> 文件里的函数，可以使用 table，将函数放在 table 里下</li></ul><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- test.lua 文件</span></span><br><span class="line"><span class="built_in">package</span>.<span class="built_in">path</span> = <span class="built_in">package</span>.<span class="built_in">path</span> .. <span class="string">&quot;;./path/?.lua&quot;</span></span><br><span class="line"><span class="keyword">local</span> hello2 = <span class="built_in">require</span>(<span class="string">&quot;hello2&quot;</span>)</span><br><span class="line">hello2.say()  <span class="comment">-- hello2 world</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- path/hello2.lua 文件</span></span><br><span class="line"><span class="keyword">local</span> hello2 = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- say 函数直接位于 hello2 这个 table 下面</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hello2.say</span><span class="params">()</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;hello2 world&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> hello2;</span><br></pre></td></tr></table></figure><h2 id="6-迭代器"><a href="#6-迭代器" class="headerlink" title="6. 迭代器"></a>6. 迭代器</h2><ul><li><strong>普通迭代</strong>：下标到table长度</li></ul><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> t = &#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i = <span class="number">1</span>, #t <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(i, t[i])  <span class="comment">-- 1 a 2 b 3 c 4 d</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><ul><li><strong>ipairs 迭代</strong>：适用于纯数字下标且按顺序的迭代<ul><li>对于不连续的数字下标的迭代，只会遍历到中断的位置</li></ul></li></ul><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i, j <span class="keyword">in</span> <span class="built_in">ipairs</span>(t) <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(i, j)  <span class="comment">-- 1 a 2 b 3 c 4 d</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> ta = &#123;</span><br><span class="line">    [<span class="number">1</span>] = <span class="string">&quot;a&quot;</span>,</span><br><span class="line">    [<span class="number">2</span>] = <span class="string">&quot;b&quot;</span>,</span><br><span class="line">    [<span class="number">4</span>] = <span class="string">&quot;c&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, j <span class="keyword">in</span> <span class="built_in">ipairs</span>(ta) <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(i, j)  <span class="comment">-- 1 a 2 b</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><ul><li><strong>pairs 迭代</strong>：可以迭代所有的下标<ul><li>常用于字符串下标的 table</li><li>其内部使用了 next 函数， 但是每次输出结果不同(因为底层是哈希表)，可以利用这个函数快速判断 table 是否为空</li></ul></li></ul><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">t = &#123;</span><br><span class="line">    apple = <span class="string">&quot;a&quot;</span>,</span><br><span class="line">    banana = <span class="string">&quot;b&quot;</span>,</span><br><span class="line">    eraser = <span class="string">&quot;c&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i,j <span class="keyword">in</span> <span class="built_in">pairs</span>(t) <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(i, j)  <span class="comment">-- banana b eraser c applea</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- table 的键值对是存储在哈希表中的, 存储顺序是不确定的</span></span><br><span class="line">t = &#123;</span><br><span class="line">    a = <span class="number">1</span>,</span><br><span class="line">    b = <span class="number">2</span>,</span><br><span class="line">    c = <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(t))  <span class="comment">-- a 1</span></span><br><span class="line"><span class="comment">-- 第二个参数是表中的某个键</span></span><br><span class="line"><span class="comment">-- next 返回该键的下一个键及其关联的值</span></span><br><span class="line"><span class="comment">-- 每次结果不同, 返回的顺序不同, 因为底层实现是哈希表</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(t, <span class="string">&quot;a&quot;</span>))  <span class="comment">-- b 2</span></span><br><span class="line"></span><br><span class="line">t = &#123;&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(t))  <span class="comment">-- nil</span></span><br></pre></td></tr></table></figure><h2 id="7-字符串库"><a href="#7-字符串库" class="headerlink" title="7. 字符串库"></a>7. 字符串库</h2><blockquote><p><a href="https://www.lua.org/manual/5.3/manual.html#6.4">Lua 5.3 参考手册</a></p></blockquote><ul><li>存储的是一串数字，lua 里的字符串可以存储任何 Byte 值，只要是一个字节的数就可以存</li><li>字符串的索引从 1 开始</li></ul><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> s = <span class="string">&quot;123456789&quot;</span></span><br><span class="line"><span class="comment">-- print(s:byte(1)) </span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">byte</span>(s, <span class="number">1</span>))  <span class="comment">-- 查看字符串某一位的原始值, 此处输出 49</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- string.byte 的逆运算是 string.char</span></span><br><span class="line"><span class="comment">-- 0x35 是十六进制表示, 等于十进制的 53, 对应的 ASCII 字符是 &#x27;5&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">char</span>(<span class="number">0x35</span>, <span class="number">0x36</span>, <span class="number">0x37</span>))  <span class="comment">-- 567</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> b = <span class="built_in">string</span>.<span class="built_in">char</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(b:<span class="built_in">byte</span>(<span class="number">1</span>, <span class="number">-1</span>))  <span class="comment">-- 00123</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 格式化字符串: string.format (formatstring, ···)</span></span><br><span class="line"><span class="keyword">local</span> f = <span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;%d, %d&quot;</span>, <span class="number">1</span>, <span class="number">2</span>)  <span class="comment">-- 1, 2</span></span><br><span class="line"><span class="built_in">print</span>(f)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 长度: string.len (s)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">len</span>(s))  <span class="comment">-- 9</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 子字符串 lua 的字符串是左闭右闭区间</span></span><br><span class="line"><span class="comment">-- 或 print(string.sub(s, 4))</span></span><br><span class="line"><span class="built_in">print</span>(s:<span class="built_in">sub</span>(<span class="number">4</span>))  <span class="comment">-- 456789</span></span><br></pre></td></tr></table></figure><ul><li>正则：<code>string.find()</code> 和 <code>string.match()</code><ul><li>前者返回找到的起始和终止位置，后者返回找到的目标字符串</li></ul></li></ul><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 正则</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">find</span>(s, <span class="string">&quot;123&quot;</span>))  <span class="comment">-- 13</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">match</span>(s, <span class="string">&quot;123&quot;</span>))  <span class="comment">-- 123</span></span><br></pre></td></tr></table></figure><ul><li><a href="https://wiki.luatos.com/_static/string-match/index.html">Lua正则在线测试工具 (luatos.com)</a><ul><li>% 用于转义</li><li><code>*</code> 匹配 0 个或多个</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/Lua%E8%84%9A%E6%9C%AC.assets/image-20240710101043801.png" alt="image-20240710101043801"></p><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/Lua%E8%84%9A%E6%9C%AC.assets/image-20240710101558385.png" alt="image-20240710101558385"></p><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/Lua%E8%84%9A%E6%9C%AC.assets/image-20240710101529103.png" alt="image-20240710101529103"></p><ul><li><code>string.gsub()</code> 用于替换，<code>string.gmatch()</code> 用于匹配多个</li></ul><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 替换</span></span><br><span class="line"><span class="comment">-- 此处将字符串中的所有数字替换成x, 返回替换后的字符串以及替换的字符个数</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">gsub</span>(s, <span class="string">&quot;%d&quot;</span>, <span class="string">&quot;x&quot;</span>))  <span class="comment">-- xxxxxxxxx9</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 匹配多个, 类似迭代器</span></span><br><span class="line">s = <span class="string">&quot;hello world from Lua&quot;</span></span><br><span class="line"><span class="keyword">for</span> w <span class="keyword">in</span> <span class="built_in">string</span>.<span class="built_in">gmatch</span>(s, <span class="string">&quot;%a+&quot;</span>) <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(w)  <span class="comment">-- hello  world  from  Lua</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="8-元表及元方法"><a href="#8-元表及元方法" class="headerlink" title="8. 元表及元方法"></a>8. 元表及元方法</h2><ul><li><code>__add</code> 加法重载</li><li><code>__index</code> 索引访问</li><li><code>__newindex</code> 索引赋值</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/Lua%E8%84%9A%E6%9C%AC.assets/image-20240710103730927.png" alt="image-20240710103730927"></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 元表和元方法</span></span><br><span class="line"><span class="keyword">local</span> t = &#123;a = <span class="number">1</span>&#125;</span><br><span class="line"><span class="comment">-- print(t + 1) 不合法的操作</span></span><br><span class="line"><span class="comment">-- print(t[&quot;abc&quot;]) 返回 nil</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用元表</span></span><br><span class="line"><span class="keyword">local</span> mt = &#123;</span><br><span class="line">    <span class="comment">-- 类似运算符重载?</span></span><br><span class="line">    <span class="built_in">__add</span> = <span class="function"><span class="keyword">function</span> <span class="params">(a, b)</span></span></span><br><span class="line">        <span class="comment">-- 当对 t 进行加法操作时，如果 t 作为第一个操作数且 t 中有键 a，返回 t.a + b</span></span><br><span class="line">        <span class="keyword">return</span> a.a + b</span><br><span class="line">    <span class="keyword">end</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 访问不存在的索引</span></span><br><span class="line">    <span class="built_in">__index</span> = &#123;</span><br><span class="line">        abc = <span class="number">123</span></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 索引赋值</span></span><br><span class="line">    <span class="built_in">__newindex</span> = <span class="function"><span class="keyword">function</span> <span class="params">(t, k, v)</span></span></span><br><span class="line">        <span class="built_in">rawset</span>(t, k, v)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">setmetatable</span>(t, mt)</span><br><span class="line"><span class="built_in">print</span>(t + <span class="number">1</span>)  <span class="comment">-- 2</span></span><br><span class="line"><span class="built_in">print</span>(t[<span class="string">&quot;abc&quot;</span>])  <span class="comment">-- 123</span></span><br><span class="line"><span class="comment">-- 直接给 t 赋值会进入到 newIndex 里, 所以使用 rawset 进行赋值, 绕过触发元方法</span></span><br><span class="line">t[<span class="string">&quot;abc&quot;</span>] = <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(t[<span class="string">&quot;abc&quot;</span>])  <span class="comment">-- 1</span></span><br></pre></td></tr></table></figure><ul><li>语法糖：</li></ul><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">t = &#123;</span><br><span class="line">    a = <span class="number">0</span>,</span><br><span class="line">    add = <span class="function"><span class="keyword">function</span> <span class="params">(tab, sum)</span></span></span><br><span class="line">        tab.a = tab.a + sum</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">t.add(t, <span class="number">10</span>)  <span class="comment">-- 语法糖, 可直接 t:add(10)</span></span><br><span class="line"><span class="built_in">print</span>(t.a)  <span class="comment">-- 10</span></span><br></pre></td></tr></table></figure><h2 id="9-面向对象"><a href="#9-面向对象" class="headerlink" title="9. 面向对象"></a>9. 面向对象</h2><ul><li><p><code>table</code> 是一个标准库表，它包含了一些用于操作 Lua 表的函数，比如 <code>table.insert</code>、<code>table.remove</code> 等</p></li><li><p>举例：</p><ul><li>对象名 bag</li><li>构造函数 new</li><li>装入东西 put</li><li>拿出东西 take</li><li>列出所有东西 list</li><li>清空 clear</li></ul></li></ul><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> bag = &#123;&#125;</span><br><span class="line"><span class="keyword">local</span> bagmt = &#123;</span><br><span class="line">    put = <span class="function"><span class="keyword">function</span> <span class="params">(self, item)</span></span></span><br><span class="line">        <span class="built_in">table</span>.<span class="built_in">insert</span>(<span class="built_in">self</span>.items, item)</span><br><span class="line">    <span class="keyword">end</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">-- take 方法从 items 表中取出最后一个元素</span></span><br><span class="line">    take = <span class="function"><span class="keyword">function</span> <span class="params">(self)</span></span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">table</span>.<span class="built_in">remove</span>(<span class="built_in">self</span>.items)</span><br><span class="line">    <span class="keyword">end</span>,</span><br><span class="line"></span><br><span class="line">    list = <span class="function"><span class="keyword">function</span> <span class="params">(self)</span></span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">table</span>.<span class="built_in">concat</span>(<span class="built_in">self</span>.items, <span class="string">&quot;,&quot;</span>)</span><br><span class="line">    <span class="keyword">end</span>,</span><br><span class="line"></span><br><span class="line">    clear = <span class="function"><span class="keyword">function</span> <span class="params">(self)</span></span></span><br><span class="line">        <span class="built_in">self</span>.items = &#123;&#125;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">-- 将 bagmt 设为元表，并将 __index 指向自己</span></span><br><span class="line">bagmt[<span class="string">&quot;__index&quot;</span>] = bagmt</span><br><span class="line"><span class="comment">-- 定义 bag 的构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bag.new</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">local</span> instance = &#123;</span><br><span class="line">        items = &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">-- 设置元表，使得未定义的元素从 bagmt 中查找</span></span><br><span class="line">    <span class="built_in">setmetatable</span>(instance, bagmt)</span><br><span class="line">    <span class="keyword">return</span> instance</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建 bag 对象 b</span></span><br><span class="line"><span class="keyword">local</span> b = bag.new()</span><br><span class="line"><span class="comment">-- 调用 b 的 put 方法</span></span><br><span class="line">b:put(<span class="string">&quot;apple&quot;</span>)</span><br><span class="line">b:put(<span class="string">&quot;apple&quot;</span>)</span><br><span class="line">b:put(<span class="string">&quot;apple&quot;</span>)</span><br><span class="line">b:put(<span class="string">&quot;apple&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(#(b.items))  <span class="comment">-- 4</span></span><br><span class="line"><span class="built_in">print</span>(b:list())  <span class="comment">-- apple,apple,apple,apple</span></span><br><span class="line"><span class="built_in">print</span>(b:take())  <span class="comment">-- apple</span></span><br><span class="line">b:clear()</span><br><span class="line"><span class="built_in">print</span>(#(b.items))  <span class="comment">-- 0</span></span><br></pre></td></tr></table></figure><h2 id="10-协程-单线程"><a href="#10-协程-单线程" class="headerlink" title="10. 协程(单线程)"></a>10. 协程(单线程)</h2><blockquote><p><a href="https://www.lua.org/manual/5.3/manual.html#6.2">Lua 5.3 Reference Manual</a></p></blockquote><ul><li>一个 lua 虚拟机只是一个单线程，并不是多线程</li></ul><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建协程</span></span><br><span class="line">co = <span class="built_in">coroutine</span>.<span class="built_in">create</span>(<span class="function"><span class="keyword">function</span> <span class="params">()</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">    <span class="comment">-- 暂停调用协程的执行</span></span><br><span class="line">    <span class="keyword">local</span> r1, r2, r3 = <span class="built_in">coroutine</span>.<span class="built_in">yield</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;inside&quot;</span>, <span class="built_in">coroutine</span>.<span class="built_in">status</span>(co))  <span class="comment">-- insiderunning 运行</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;continue run~~&quot;</span>, r1, r2, r3)</span><br><span class="line"><span class="keyword">end</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(co))  <span class="comment">-- thread 类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 以字符串形式返回协程的状态</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;1&quot;</span>, <span class="built_in">coroutine</span>.<span class="built_in">status</span>(co))  <span class="comment">-- 1suspended 暂停</span></span><br><span class="line"><span class="comment">-- 运行协程</span></span><br><span class="line"><span class="built_in">coroutine</span>.<span class="built_in">resume</span>(co)  <span class="comment">-- hello world</span></span><br><span class="line"><span class="built_in">coroutine</span>.<span class="built_in">resume</span>(co, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)  <span class="comment">-- continue run~~456</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;2&quot;</span>, <span class="built_in">coroutine</span>.<span class="built_in">status</span>(co))  <span class="comment">-- 2dead 死掉</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用 wrap 创建协程, 相当与是一个函数</span></span><br><span class="line"><span class="keyword">local</span> cor = <span class="built_in">coroutine</span>.<span class="built_in">wrap</span>(<span class="function"><span class="keyword">function</span> <span class="params">()</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line"><span class="keyword">end</span>)</span><br><span class="line"><span class="comment">-- 直接使用</span></span><br><span class="line">cor()  <span class="comment">-- hello world</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> DataBase </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Lua </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JUC 并发编程</title>
      <link href="/2024/05/14/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
      <url>/2024/05/14/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="JUC"><a href="#JUC" class="headerlink" title="JUC"></a>JUC</h1><blockquote><p>学习视频：<br><a href="https://www.bilibili.com/video/BV1B7411L7tE/?spm_id_from=333.337.search-card.all.click&vd_source=ce97d263f08af76fc25ff49de530fe92">【狂神说Java】JUC并发编程最新版通俗易懂_哔哩哔哩_bilibili</a></p></blockquote><h2 id="1-基本介绍"><a href="#1-基本介绍" class="headerlink" title="1. 基本介绍"></a>1. 基本介绍</h2><ul><li><strong>JUC</strong>：<code>java.util.concurrent</code> 包，简称 JUC，是 Java 5 引入的并发工具包，提供了大量的并发编程工具和高级特性，用于简化多线程编程</li><li><strong>进程和线程</strong>：<ul><li><strong>进程</strong>：计算机中<strong>正在执行的独立程序</strong>，每个进程拥有独立的内存空间和系统资源，进程是CPU<strong>资源分配的最小单位</strong></li><li><strong>线程</strong>：进程内部的执行单元，<strong>一个进程可以包含多个线程</strong>，线程共享进程的内存空间和资源，线程是CPU<strong>调度和执行的最小单位</strong><ul><li><strong>Java 默认有2个线程</strong> &#x3D;&#x3D;&gt; main线程、GC线程</li></ul></li></ul></li><li><strong>Java 真的可以开启线程？</strong><ul><li>从源码看，Java 是使用本地 native 方法调用底层的 C&#x2F;C++ 代码来开启线程</li><li><code>start0</code> 是 <code>Thread</code> 类的私有本地方法，由 JVM 通过 C&#x2F;C++ 代码实现</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++ 底层, Java是没有权限操作底层硬件的</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">start0</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (threadStatus != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalThreadStateException</span>();</span><br><span class="line">    group.add(<span class="built_in">this</span>);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">started</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        start0();  <span class="comment">// 本地方法，实际启动线程</span></span><br><span class="line">        started = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!started) &#123;</span><br><span class="line">                group.threadStartFailed(<span class="built_in">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ignore) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>并发和并行</strong>：并发编程的<strong>本质：充分利用CPU的资源！</strong></p><ul><li><strong>并发</strong>：在<strong>单核</strong>处理器上模拟出多条线程，任务通过操作系统的调度，轮流占用CPU时间片，从<strong>宏观上看似乎是同时进行</strong>（多线程操作同一个资源）</li><li><strong>并行</strong>：在多核处理器上，多个任务可以真正同时在不同的处理器核心上运行，<strong>可以使用线程池提高性能</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//获取cpu的核数</span></span><br><span class="line">        System.out.println(Runtime.getRuntime().availableProcessors());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>多线程</strong> 是实现并发的<strong>一种方式</strong>，通过并发（交替或同时）执行多个线程实现</p></li><li><p><strong>Java 中线程的 6 种状态</strong>：NEW,RUNNABLE,BLOCKED,WAITING,TIMED_WAITING,TERMINATED</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">State</span> &#123;</span><br><span class="line">    <span class="comment">// 新生</span></span><br><span class="line">    NEW,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 运行</span></span><br><span class="line">    RUNNABLE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞</span></span><br><span class="line">    BLOCKED,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待</span></span><br><span class="line">    WAITING,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 超时等待</span></span><br><span class="line">    TIMED_WAITING,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 终止</span></span><br><span class="line">    TERMINATED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-wait-和-sleep-的区别"><a href="#2-wait-和-sleep-的区别" class="headerlink" title="2. wait 和 sleep 的区别"></a>2. wait 和 sleep 的区别</h2><ul><li><strong>来自不同的类</strong>：<ul><li>wait &#x3D;&gt; Object</li><li>sleep &#x3D;&gt; Thread</li></ul></li></ul><p>一般情况企业中使用休眠是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 来自 java.util.concurrent 包下的 TimeUnit 类</span></span><br><span class="line">TimeUnit.DAYS.sleep(<span class="number">1</span>); <span class="comment">// 休眠1天</span></span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">1</span>); <span class="comment">// 休眠1s</span></span><br></pre></td></tr></table></figure><ul><li><strong>关于锁的释放</strong>：<ul><li>wait 会释放锁对象，使其他等待该锁的线程能够获得锁并继续执行</li><li>sleep 不会释放锁 &#x3D;&#x3D;&gt; 抱着锁睡觉</li></ul></li><li><strong>使用的范围不同</strong>：<ul><li>wait 必须在同步方法&#x2F;同步代码块中调用，否则会抛出 <code>IllegalMonitorStateException</code> 异常</li><li>sleep 可以在任何地方睡</li></ul></li><li><strong>是否需要捕获异常</strong>：<ul><li>都需要捕获 <code>InterruptedException</code> 异常</li></ul></li></ul><h2 id="3-Lock-锁-重点"><a href="#3-Lock-锁-重点" class="headerlink" title="3. Lock 锁(重点)"></a>3. Lock 锁(重点)</h2><h3 id="3-1-传统的-Synchronized-锁"><a href="#3-1-传统的-Synchronized-锁" class="headerlink" title="3.1 传统的 Synchronized 锁"></a>3.1 传统的 Synchronized 锁</h3><ul><li><strong>减少耦合</strong>：线程就是一个单独的资源类，没有任何的附属操作！</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 真正的多线程开发</span></span><br><span class="line"><span class="comment"> * 线程就是一个单独的资源类，没有任何的附属操作！</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SaleTicketDemo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 多线程操作</span></span><br><span class="line">        <span class="comment">// 并发：多线程操作同一个资源类，把资源类丢入线程</span></span><br><span class="line">        <span class="type">Ticket</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Ticket</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Runnable 是 @FunctionalInterface 函数式接口 </span></span><br><span class="line">        <span class="comment">// jdk1.8 之后使用 lambda 表达式</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">40</span>; i++) &#123;</span><br><span class="line">                ticket.sale();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">40</span>; i++) &#123;</span><br><span class="line">                ticket.sale();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">40</span>; i++) &#123;</span><br><span class="line">                ticket.sale();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;C&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 资源类: 属性+方法 oop思想</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Ticket</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 卖票的方式</span></span><br><span class="line">    <span class="comment">// synchronized 本质：队列+锁</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sale</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (number &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 卖出了第 &quot;</span> + (number--) + <span class="string">&quot; 张票,剩余：&quot;</span> + number + <span class="string">&quot; 张票&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-Lock-锁"><a href="#3-2-Lock-锁" class="headerlink" title="3.2 Lock 锁"></a>3.2 Lock 锁</h3><ul><li><strong>加锁解锁</strong>：<code>lock()</code>、<code>unlock()</code></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B.assets/image-20240509203720427.png" alt="image-20240509203720427"></p><ul><li><strong>3个实现类</strong>：<ul><li><strong><code>ReentrantLock</code>：</strong> 可重入锁</li><li><strong><code>ReentrantReadWriteLock.ReadLock</code>：</strong> 可重入读锁</li><li><strong><code>ReentrantReadWriteLock.WriteLock</code>：</strong> 可重入写锁</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B.assets/image-20240509203744318.png" alt="image-20240509203744318"></p><ul><li><strong>公平锁与非公平锁：</strong><ul><li><strong>公平锁：</strong> 必须先来后到</li><li><strong>非公平锁：</strong> 可以插队**(默认为非公平锁)**</li></ul></li><li><strong>使用 <code>Lock</code> 的三步曲：</strong><ul><li>创建 <code>Lock</code> 对象：<code>Lock lock = new ReentrantLock();</code></li><li>加锁：<code>lock.lock();</code></li><li>解锁：在 <code>finally</code> 块中解锁 <code>lock.unlock();</code></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SaleTicketDemo02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//多线程操作</span></span><br><span class="line">        <span class="comment">//并发：多线程操作同一个资源类，把资源类丢入线程</span></span><br><span class="line">        <span class="type">Ticket2</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Ticket2</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">40</span>; i++) ticket.sale();</span><br><span class="line">        &#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">40</span>; i++) ticket.sale();</span><br><span class="line">        &#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">40</span>; i++) ticket.sale();</span><br><span class="line">        &#125;, <span class="string">&quot;C&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// lock三部曲</span></span><br><span class="line"><span class="comment">// 1. Lock lock=new ReentrantLock();</span></span><br><span class="line"><span class="comment">// 2. lock.lock() 加锁</span></span><br><span class="line"><span class="comment">// 3. finally=&gt; 解锁：lock.unlock();</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Ticket2</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//卖票的方式</span></span><br><span class="line">    <span class="comment">// 使用Lock 锁</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sale</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//加锁</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//业务代码</span></span><br><span class="line">            <span class="keyword">if</span> (number &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 卖出了第&quot;</span> + (number--) + <span class="string">&quot; 张票,剩余：&quot;</span> + number + <span class="string">&quot; 张票&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//解锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-Synchronized-VS-Lock"><a href="#3-3-Synchronized-VS-Lock" class="headerlink" title="3.3 Synchronized VS. Lock"></a>3.3 Synchronized VS. Lock</h3><ul><li><p><strong>锁的实现</strong>：</p><ul><li><strong>Synchronized</strong>：<strong>内置的 Java 关键字</strong>，直接由 JVM 实现</li><li><strong>Lock</strong>：接口，由 Java 类实现，需要显式调用 <code>lock</code> 和 <code>unlock</code> 方法</li></ul></li><li><p><strong>获取锁状态</strong>：</p><ul><li><strong>Synchronized</strong>：无法判断获取锁的状态</li><li><strong>Lock</strong>： 可以通过 <code>tryLock</code> 方法判断是否成功获得锁</li></ul></li><li><p><strong>锁的释放</strong>：</p><ul><li><strong>Synchronized</strong>： 出了同步块或方法范围后，自动释放锁</li><li><strong>Lock</strong>：需要手动加锁和手动释放锁，<strong>如果没有释放锁，可能会导致死锁</strong></li></ul></li><li><p><strong>锁等待行为</strong>：</p><ul><li><p><strong>Synchronized</strong>：线程1获得锁，线程2必须等待，直到线程1释放锁</p></li><li><p><strong>Lock</strong>：可以通过 <code>tryLock</code> 方法尝试获取锁，<strong>不会导致长时间等待</strong></p></li></ul></li><li><p><strong>可重入性</strong>：又称<strong>递归锁</strong>，指一个线程在持有锁的情况下可以再次获取该锁的能力；当一个线程已经获得了某个锁，可以再次获取该锁而不会被阻塞；<strong>每次获取锁的计数增加 1，每次释放锁的计数减少 1，直到计数为 0 时，锁才真正被释放</strong></p><ul><li><strong>Synchronized</strong>：是可重入锁，不可以中断的，非公平的</li><li><strong>Lock</strong>：<code>ReentrantLock</code> 实现了可重入锁，可以判断锁，可以自己设置公平锁和非公平锁</li></ul></li><li><p><strong>使用场景</strong>：</p><ul><li><strong>Synchronized</strong>：适合锁定<strong>少量代码的同步问题</strong></li><li><strong>Lock</strong>：适合<strong>锁定大量同步代码的复杂场景</strong></li></ul></li></ul><p><strong>锁到底是什么？ 如何判断锁的是谁？</strong></p><ul><li><strong>锁：</strong> 一种并发控制机制，用于协调多个线程对共享资源的访问，确保数据的正确性和一致性</li><li><strong>锁的粒度</strong>：锁可以锁定方法、代码块或对象实例</li><li><strong>锁的持有者</strong>：可以使用调试工具或日志记录来判断哪个线程当前持有锁</li></ul><h2 id="4-生产者和消费者问题-线程通信"><a href="#4-生产者和消费者问题-线程通信" class="headerlink" title="4. 生产者和消费者问题-线程通信"></a>4. 生产者和消费者问题-线程通信</h2><blockquote><p>面试常考：单例模式、排序算法、生产者和消费者、死锁</p></blockquote><h3 id="4-1-Synchronized-版"><a href="#4-1-Synchronized-版" class="headerlink" title="4.1 Synchronized 版"></a>4.1 Synchronized 版</h3><ul><li><code>wait</code>、<code>notify</code> 和 <code>notifyAll</code> 的使用中必须谨防虚假唤醒</li><li><strong>虚假唤醒</strong>：多线程环境下，有多个线程执行了wait()方法，需要其他线程执行notify()或者notifyAll()方法去唤醒它们，假如多个线程都被唤醒了，但是只有其中一部分是有用的唤醒操作，其余的唤醒都是无用功；对于不应该被唤醒的线程而言，便是虚假唤醒</li><li><strong>防止虚假唤醒问题</strong>：<code>wait</code> 方法的调用应该始终放在循环（<code>while</code>）中，而不是条件判断（<code>if</code>）中<ul><li>当某个线程被错误地唤醒后，如果使用 <code>if</code> 判断条件，线程会继续执行，而不是重新检查条件是否满足，导致逻辑错误</li></ul></li></ul><blockquote><p>目前只有 A 和 B 两个线程，一个 +1，一个 -1，用 if 不会出问题，但是<strong>如果增加 C 和 D 线程</strong>，就会变成两个 +1，两个 -1，<strong>此时用 if ，可能会出现问题</strong>，如：</p><p>A先执行，执行时调用了<strong>wait方法</strong>，那它会等待，此时<strong>会释放锁</strong>，如果线程C获得锁并且也会执行wait方法，两个加线程一起等待被唤醒，此时减线程中的某一个线程执行完毕并且唤醒了这俩加线程，那么A获取了锁并且加1，执行完毕之后B再执行，如果是if的话，那么A修改完num后，B不会再去判断num的值，直接会给num+1。如果是while的话，A执行完之后，B还会去判断num的值，因此就不会执行</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程之间的通信问题: 生产者和消费者问题  等待唤醒、通知唤醒</span></span><br><span class="line"><span class="comment"> * 线程交替执行 A B 操作同一个变量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Data</span> <span class="variable">data</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Data</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 线程操作资源类, 降低耦合</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    data.increment();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    data.decrement();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断等待 =&gt; 业务 =&gt; 通知</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Data</span> &#123;  <span class="comment">// 数字  资源类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// +1</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">while</span> (number != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 等待操作</span></span><br><span class="line">            <span class="built_in">this</span>.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        number++;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;=&gt;&quot;</span> + number);</span><br><span class="line">        <span class="comment">// 通知其他线程 我+1完毕了</span></span><br><span class="line">        <span class="built_in">this</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// -1</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">decrement</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">while</span> (number == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 等待操作</span></span><br><span class="line">            <span class="built_in">this</span>.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        number--;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;=&gt;&quot;</span> + number);</span><br><span class="line">        <span class="comment">// 通知其他线程  我-1完毕了</span></span><br><span class="line">        <span class="built_in">this</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-Lock-版"><a href="#4-2-Lock-版" class="headerlink" title="4.2 Lock 版"></a>4.2 Lock 版</h3><ul><li>对应于 synchronized，JUC 版本下，Lock 锁也有对应的唤醒与停止方法，分别是 <strong>condition接口下的signal()与await()</strong></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B.assets/image-20240510113250698.png" alt="image-20240510113250698"></p><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B.assets/image-20240510113305892.png" alt="image-20240510113305892"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Data2</span> <span class="variable">data</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Data2</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++) &#123;</span><br><span class="line">            data.increment();</span><br><span class="line">        &#125;</span><br><span class="line">                       &#125;,<span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++) &#123;</span><br><span class="line">            data.decrement();</span><br><span class="line">        &#125;&#125;,<span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++) &#123;</span><br><span class="line">            data.increment();</span><br><span class="line">        &#125;</span><br><span class="line">                       &#125;,<span class="string">&quot;C&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++) &#123;</span><br><span class="line">            data.decrement();</span><br><span class="line">        &#125;</span><br><span class="line">                       &#125;,<span class="string">&quot;D&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Data2</span>&#123;</span><br><span class="line">    <span class="comment">//数字  资源类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//lock锁</span></span><br><span class="line">    <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//+1</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span>  &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//业务</span></span><br><span class="line">            <span class="keyword">while</span> (number!=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//等待操作</span></span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            number++;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;=&gt;&quot;</span>+number);</span><br><span class="line">            <span class="comment">//通知其他线程 我+1完毕了</span></span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//-1</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">decrement</span><span class="params">()</span>  &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//业务</span></span><br><span class="line">            <span class="keyword">while</span> (number==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//等待操作</span></span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            number--;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;=&gt;&quot;</span>+number);</span><br><span class="line">            <span class="comment">//通知其他线程 我+1完毕了</span></span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>Condition 的优势？</strong><ul><li><strong>可以实现精准的通知和唤醒线程</strong>，如：在A线程执行完后精准唤醒B线程执行，B线程执行完后精准唤醒C线程执行，C线程执行完后精准唤醒A线程执行</li><li><strong>线程 A：</strong> 其他同理<ul><li>通过 <code>condition1.await()</code> 等待 <code>number</code> 变为 1。</li><li>打印 <code>AAAAA</code>，设置 <code>number</code> 为 2，唤醒 <code>condition2</code> 上的等待线程（B）</li></ul></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A 执行完 调用B</span></span><br><span class="line"><span class="comment"> * B 执行完 调用C</span></span><br><span class="line"><span class="comment"> * C 执行完 调用A</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Data3</span> <span class="variable">data3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Data3</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                data3.printA();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                data3.printB();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                data3.printC();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;C&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Data3</span> &#123;  <span class="comment">// 资源类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">condition1</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">condition2</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">condition3</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">1</span>;  <span class="comment">// 1A 2B 3C</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printA</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 判断 -&gt; 执行 -&gt; 通知</span></span><br><span class="line">            <span class="keyword">while</span> (number != <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">//等待</span></span><br><span class="line">                condition1.await();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 执行</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;,AAAAA&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 唤醒指定的线程</span></span><br><span class="line">            number = <span class="number">2</span>;</span><br><span class="line">            condition2.signal();  <span class="comment">// 唤醒2</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printB</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 判断 -&gt; 执行 -&gt; 通知</span></span><br><span class="line">            <span class="keyword">while</span> (number != <span class="number">2</span>) &#123;</span><br><span class="line">                condition2.await();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;,BBBBB&quot;</span>);</span><br><span class="line">            <span class="comment">// 唤醒3</span></span><br><span class="line">            number = <span class="number">3</span>;</span><br><span class="line">            condition3.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printC</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 判断 -&gt; 执行 -&gt; 通知</span></span><br><span class="line">            <span class="keyword">while</span> (number != <span class="number">3</span>) &#123;</span><br><span class="line">                condition3.await();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;,CCCCC&quot;</span>);</span><br><span class="line">            <span class="comment">// 唤醒1</span></span><br><span class="line">            number = <span class="number">1</span>;</span><br><span class="line">            condition1.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-8锁现象"><a href="#5-8锁现象" class="headerlink" title="5. 8锁现象"></a>5. 8锁现象</h2><ul><li><strong>如何判断锁锁的到底是谁？</strong><ul><li><strong>锁：</strong> 线程同步的机制，用来确保多个线程能够安全访问共享资源</li><li>锁的是谁：<ul><li><strong>实例方法的锁：</strong> 锁的是调用方法的实例对象</li><li><strong>静态方法的锁：</strong> 锁的是该类的 <code>Class</code> 对象</li></ul></li></ul></li><li>从 <strong>8 个锁相关问题</strong>深刻理解锁</li></ul><h3 id="5-1-一对象，两同步"><a href="#5-1-一对象，两同步" class="headerlink" title="5.1 一对象，两同步"></a>5.1 一对象，两同步</h3><blockquote><p><strong>同一个对象，两个同步方法，</strong>标准情况下是先发短信还是打电话</p></blockquote><ul><li><strong>问题：</strong> 两个同步实例方法 <code>sendSms</code> 和 <code>call</code>，哪个先执行？</li><li><strong>结论：</strong> 先发短信，再打电话，因为<strong>两个方法用的是同一个锁</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 8锁,就是关于锁的8个问题</span></span><br><span class="line"><span class="comment"> * 1. 标准情况下是先发短信还是打电话</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       <span class="type">Phone</span> <span class="variable">phone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; phone.sendSms(), <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; phone.call(), <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Phone</span> &#123;</span><br><span class="line">    <span class="comment">// synchronized 锁的对象是方法的调用者</span></span><br><span class="line">    <span class="comment">// 两个方法用的是同一个锁, 谁先拿到谁先执行</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendSms</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;sendSms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;call&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-2-一对象，两同步，延迟4s"><a href="#5-2-一对象，两同步，延迟4s" class="headerlink" title="5.2 一对象，两同步，延迟4s"></a>5.2 一对象，两同步，延迟4s</h3><blockquote><p><strong>同一个对象，两个同步方法</strong></p></blockquote><ul><li><strong>问题：</strong> 如果 <code>sendSms</code> 方法延迟 4 秒，哪个先执行？</li><li><strong>结论：</strong> 还是先发短信，再打电话，因为<strong>两个方法用的是同一个锁</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Phone</span> &#123;</span><br><span class="line">    <span class="comment">// 同步实例方法，锁的对象是调用者</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendSms</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">4</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;sendSms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;call&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Phone</span> <span class="variable">phone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; phone.sendSms(), <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; phone.call(), <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-3-一对象，一同步，一普通"><a href="#5-3-一对象，一同步，一普通" class="headerlink" title="5.3 一对象，一同步，一普通"></a>5.3 一对象，一同步，一普通</h3><blockquote><p><strong>同一个对象，一个同步方法，一个普通方法</strong></p></blockquote><ul><li><p><strong>问题：</strong> 如果<strong>增加一个普通方法</strong> <code>hello</code>，是先执行发短信还是 hello？</p></li><li><p><strong>结论：</strong> 先执行 <code>hello</code>，再执行发短信，因为<strong>普通方法没有锁，不受同步方法的影响</strong></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Phone2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendSms</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">4</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;sendSms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;call&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 普通方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Phone2</span> <span class="variable">phone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone2</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; phone.sendSms(), <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; phone.hello(), <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-4-两对象，两同步"><a href="#5-4-两对象，两同步" class="headerlink" title="5.4 两对象，两同步"></a>5.4 两对象，两同步</h3><blockquote><p><strong>两个对象，两个同步方法</strong></p></blockquote><ul><li><strong>问题：</strong> 两个不同的对象，分别调用同步方法 <code>call</code> 和 <code>sendSms</code>，哪个先执行？</li><li><strong>结论：</strong> 先打电话，再发短信，因为<strong>两个不同的对象对应不同的锁</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Phone2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendSms</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">4</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;sendSms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;call&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Phone2</span> <span class="variable">phone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone2</span>();</span><br><span class="line">        <span class="type">Phone2</span> <span class="variable">phone2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone2</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; phone.sendSms(), <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; phone2.call(), <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-5-一对象，两静态同步"><a href="#5-5-一对象，两静态同步" class="headerlink" title="5.5 一对象，两静态同步"></a>5.5 一对象，两静态同步</h3><blockquote><p><strong>一个对象，两个静态同步方法</strong></p></blockquote><ul><li><strong>问题：</strong> 如果修改为两个静态同步方法，哪个先执行？</li><li><strong>结论：</strong> 先发短信，再打电话，因为<strong>两个方法用的是同一个锁，即 <code>Class</code> 对象</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Phone3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendSms</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">4</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;sendSms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;call&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Phone3</span> <span class="variable">phone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone3</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; phone.sendSms(), <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; phone.call(), <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-6-两对象，两静态同步"><a href="#5-6-两对象，两静态同步" class="headerlink" title="5.6 两对象，两静态同步"></a>5.6 两对象，两静态同步</h3><blockquote><p><strong>两个对象，两个静态同步方法</strong></p></blockquote><ul><li><strong>问题：</strong> 两个不同的对象，分别调用静态同步方法 <code>sendSms</code> 和 <code>call</code>，哪个先执行？</li><li><strong>结论：</strong>先发短信，再打电话，因为<strong>静态方法锁的是 <code>Class</code> 对象，两个对象共享一个 <code>Class</code> 锁</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Phone3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendSms</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">4</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;sendSms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;call&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Phone3</span> <span class="variable">phone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone3</span>();</span><br><span class="line">        <span class="type">Phone3</span> <span class="variable">phone2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone3</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; phone.sendSms(), <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; phone2.call(), <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-7-一对象，一同步，一静态同步"><a href="#5-7-一对象，一同步，一静态同步" class="headerlink" title="5.7 一对象，一同步，一静态同步"></a>5.7 一对象，一同步，一静态同步</h3><blockquote><p><strong>一个对象，一个静态同步方法，一个普通同步方法</strong></p></blockquote><ul><li><strong>问题：</strong> 同一个对象上调用静态同步方法 <code>sendSms</code> 和普通同步方法 <code>call</code>，哪个先执行？</li><li><strong>结论：</strong> 先打电话，再发短信，因为<strong>静态同步方法和普通同步方法锁定的是不同的对象，一个是 <code>Class</code> 对象，一个是实例对象</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Phone4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendSms</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">4</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;sendSms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;call&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Phone4</span> <span class="variable">phone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone4</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; phone.sendSms(), <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; phone.call(), <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-8-两对象，一同步，一静态同步"><a href="#5-8-两对象，一同步，一静态同步" class="headerlink" title="5.8 两对象，一同步，一静态同步"></a>5.8 两对象，一同步，一静态同步</h3><blockquote><p><strong>两个对象，一个静态同步方法，一个普通的同步方法</strong></p></blockquote><ul><li><strong>问题：</strong> 两个不同的对象，分别调用静态同步方法 <code>sendSms</code> 和普通同步方法 <code>call</code>，哪个先执行？</li><li><strong>结论：</strong> 还是先打电话，再发短信，因为<strong>静态同步方法和普通同步方法锁定的是不同的对象，一个是 <code>Class</code> 对象，一个是实例对象</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Phone4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendSms</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">4</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;sendSms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;call&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Phone4</span> <span class="variable">phone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone4</span>();</span><br><span class="line">        <span class="type">Phone4</span> <span class="variable">phone2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone4</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; phone.sendSms(), <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; phone2.call(), <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-线程不安全的集合类"><a href="#6-线程不安全的集合类" class="headerlink" title="6. 线程不安全的集合类"></a>6. 线程不安全的集合类</h2><h3 id="6-1-List"><a href="#6-1-List" class="headerlink" title="6.1 List"></a>6.1 List</h3><ul><li><strong>并发修改异常：</strong> <code>ArrayList</code> 在多线程并发修改下不安全，可能会导致 <strong><code>ConcurrentModificationException</code></strong></li><li><strong>解决方案</strong>：<ul><li><strong>使用 <code>Vector</code>：</strong><ul><li><code>Vector</code> 是早期集合框架的一部分，实现了线程安全</li><li>内部方法大多通过 <code>synchronized</code> 关键字同步，但性能较低</li></ul></li><li><strong>使用 <code>Collections.synchronizedList</code>：</strong><ul><li>提供线程安全的 <code>List</code> 封装</li><li>通过<strong>内部的同步代码块</strong>实现安全性</li></ul></li><li><strong>使用 <code>CopyOnWriteArrayList</code>：</strong>写入时复制！ <strong>COW 计算机程序设计领域的一种优化策略</strong><ul><li>高效的线程安全 <code>List</code> 实现</li><li><strong>读写分离，写操作时复制整个底层数组，写入效率较低但读取效率高</strong><ul><li><strong>写操作</strong>：<ul><li>每次写操作都会复制整个数组，保证写入操作的原子性</li><li>使用 <code>ReentrantLock</code> 锁实现线程安全</li></ul></li><li><strong>读操作</strong>：<ul><li>读取操作不加锁，使用数组副本提供一致性读</li></ul></li></ul></li></ul></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CopyOnWriteArrayList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * java.util.ConcurrentModificationException 并发修改异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 并发下 ArrayList 不安全的</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 解决方案：</span></span><br><span class="line"><span class="comment">         * 1、List&lt;String&gt; list = new Vector&lt;&gt;();</span></span><br><span class="line"><span class="comment">         * 2、List&lt;String&gt; list = Collections.synchronizedList(new ArrayList&lt;&gt;());</span></span><br><span class="line"><span class="comment">         * 3、List&lt;String&gt; list = new CopyOnWriteArrayList&lt;&gt;();</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// CopyOnWrite 写入时复制 COW 计算机程序设计领域的一种优化策略</span></span><br><span class="line">        <span class="comment">// 多个线程调用的时候，list，读取的时候固定的，写入（覆盖）</span></span><br><span class="line">        <span class="comment">// 在写入的时候避免覆盖，造成数据问题！</span></span><br><span class="line">        <span class="comment">// 读写分离</span></span><br><span class="line">        <span class="comment">// CopyOnWriteArrayList 比Vector 好在哪里?（看源码）</span></span><br><span class="line">        <span class="comment">// vector底层运用大量的synchronized关键字，而CopyOnWriteArrayList底层运用的是ReentrantLock锁</span></span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">2000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                list.add(UUID.randomUUID().toString().substring(<span class="number">0</span>, <span class="number">5</span>));</span><br><span class="line">                System.out.println(list);</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>性能对比</strong>：</p><ul><li><strong><code>Vector</code> 性能较低的原因：</strong><ul><li>每个方法都使用 <code>synchronized</code> 关键字锁定整个对象，导致锁争用严重，特别是在多线程环境下。</li><li>无论读写操作，均需获取锁，降低了并发性能。</li></ul></li><li><strong><code>Collections.synchronizedList</code>：</strong><ul><li>使用独立的锁对象，避免锁定整个 <code>List</code> 对象。</li><li>提供线程安全的 <code>List</code> 封装，通过内部的同步代码块实现安全性。</li></ul></li></ul><blockquote><p><code>Vector</code> 与 <code>Collections.synchronizedList</code> 在性能上差异较小，因为都使用 <code>synchronized</code> 关键字同步</p></blockquote><ul><li><strong><code>CopyOnWriteArrayList</code> 性能较高的原因：</strong><ul><li>读写分离，读操作无需加锁，写操作时使用 <code>ReentrantLock</code> 锁实现线程安全。</li><li>适用于读多写少的场景，提高了读取性能。</li></ul></li></ul></li></ul><h3 id="6-2-Set"><a href="#6-2-Set" class="headerlink" title="6.2 Set"></a>6.2 Set</h3><ul><li><strong>HashSet 的底层就是 HashMap</strong>，都是线程不安全的，也就是在在多线程环境下可能会出现 <code>ConcurrentModificationException</code> 或数据丢失等问题</li><li><strong>解决方案</strong>：<ul><li><strong><code>Collections.synchronizedSet</code>：</strong><ul><li>使用 <code>Collections</code> 工具类提供线程安全封装</li><li>通过内部的同步代码块保证线程安全</li></ul></li><li><strong><code>CopyOnWriteArraySet</code>：</strong><ul><li>基于 <code>CopyOnWriteArrayList</code> 实现的线程安全 <code>Set</code></li><li>读写分离，读操作无需加锁，写操作复制底层数组</li><li>适用于读多写少的场景</li></ul></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CopyOnWriteArraySet;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 同理可证：ConcurrentModificationException</span></span><br><span class="line"><span class="comment"> * 1、Set&lt;String&gt; set = Collections.synchronizedSet(new HashSet&lt;&gt;());</span></span><br><span class="line"><span class="comment"> * 2、Set&lt;String&gt; set = new CopyOnWriteArraySet&lt;&gt;();</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SetTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//        Set&lt;String&gt; set = Collections.synchronizedSet(new HashSet&lt;&gt;());</span></span><br><span class="line">        <span class="comment">//        Set&lt;String&gt; set = new CopyOnWriteArraySet&lt;&gt;();</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">30</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                set.add(UUID.randomUUID().toString().substring(<span class="number">0</span>, <span class="number">5</span>));</span><br><span class="line">                System.out.println(set);</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-3-Map"><a href="#6-3-Map" class="headerlink" title="6.3 Map"></a>6.3 Map</h3><ul><li><code>HashMap</code> 是线程不安全的</li><li><strong>解决方案</strong>：<ul><li><strong><code>Hashtable</code>：</strong><ul><li>早期集合框架中的线程安全 <code>Map</code> 实现</li><li>内部通过 <code>synchronized</code> 关键字同步</li><li>性能较低，因为所有方法都需要获取锁</li></ul></li><li><strong><code>Collections.synchronizedMap</code>：</strong><ul><li>使用 <code>Collections</code> 工具类提供线程安全封装</li><li>内部通过同步代码块实现线程安全</li></ul></li><li><strong><code>ConcurrentHashMap</code>：</strong><ul><li>JUC 包中提供的高效线程安全 <code>Map</code> 实现</li><li>使用<strong>分段锁定技术</strong>，允许更高的并发度</li></ul></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 使用 ConcurrentHashMap</span></span><br><span class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">30</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                map.put(Thread.currentThread().getName(), UUID.randomUUID().toString().substring(<span class="number">0</span>, <span class="number">5</span>));</span><br><span class="line">                System.out.println(map);</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-4-总结"><a href="#6-4-总结" class="headerlink" title="6.4 总结"></a>6.4 总结</h3><ul><li><strong>线程安全集合的选择：</strong><ul><li><strong><code>List</code>：</strong> <code>Collections.synchronizedList</code>, <code>CopyOnWriteArrayList</code></li><li><strong><code>Set</code>：</strong> <code>Collections.synchronizedSet</code>, <code>CopyOnWriteArraySet</code></li><li><strong><code>Map</code>：</strong> <code>Collections.synchronizedMap</code>, <code>ConcurrentHashMap</code></li></ul></li><li><strong>线程安全集合框架对比：</strong></li></ul><table><thead><tr><th>集合类型</th><th>线程安全性</th><th>锁机制</th><th>读操作性能</th><th>写操作性能</th></tr></thead><tbody><tr><td><code>ArrayList</code></td><td>线程不安全</td><td>无</td><td>高</td><td>高</td></tr><tr><td><code>Vector</code></td><td>线程安全</td><td><code>synchronized</code>同步方法</td><td>低</td><td>低</td></tr><tr><td><code>Collections.synchronizedList</code></td><td>线程安全</td><td><code>synchronized</code>同步代码块</td><td>低</td><td>低</td></tr><tr><td><code>CopyOnWriteArrayList</code></td><td>线程安全</td><td><code>ReentrantLock</code></td><td>高</td><td>中（复制成本）</td></tr><tr><td><code>HashSet</code></td><td>线程不安全</td><td>无</td><td>高</td><td>高</td></tr><tr><td><code>Collections.synchronizedSet</code></td><td>线程安全</td><td><code>synchronized</code></td><td>低</td><td>低</td></tr><tr><td><code>CopyOnWriteArraySet</code></td><td>线程安全</td><td><code>ReentrantLock</code></td><td>高</td><td>中（复制成本）</td></tr><tr><td><code>HashMap</code></td><td>线程不安全</td><td>无</td><td>高</td><td>高</td></tr><tr><td><code>Hashtable</code></td><td>线程安全</td><td><code>synchronized</code></td><td>低</td><td>低</td></tr><tr><td><code>Collections.synchronizedMap</code></td><td>线程安全</td><td><code>synchronized</code></td><td>低</td><td>低</td></tr><tr><td><code>ConcurrentHashMap</code></td><td>线程安全</td><td>分段锁定（<code>ReentrantLock</code>）</td><td>高</td><td>高</td></tr></tbody></table><h2 id="7-Callable-接口"><a href="#7-Callable-接口" class="headerlink" title="7. Callable 接口"></a>7. Callable 接口</h2><ul><li><p>类似 Runnable 接口，但 Callable 接口：</p><ul><li><p><strong>可以有返回值，可以抛出异常</strong></p></li><li><p>重写的方法不同，Runnable 是 run()，而 <strong>Callable 是 call()</strong></p></li></ul></li><li><p><strong>如何启动 Callable？</strong> </p><ul><li><strong><code>FutureTask</code> 接受一个 <code>Callable</code> 实现，作为适配器，使其可以作为 <code>Runnable</code> 传递给 <code>Thread</code> 构造器</strong></li><li><strong>原理</strong>：<code>FutureTask</code> 实现了 <code>Runnable</code> 接口的子接口<code>RunnableFuture</code>，<code>FutureTask</code> 有一个带 <code>Callable</code> 类型参数的构造器，所以 <code>FutureTask</code> 可以作为 <code>Runnable</code> 接口的实现类传到 <code>Thread</code> 的构造器中</li></ul></li><li><p><strong>结果缓存机制</strong>：</p><ul><li><code>FutureTask</code> 通过内部<strong>状态 <code>state</code> 管理</strong>任务的执行和结果缓存，共有 5 种状态：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> state;</span><br><span class="line"><span class="comment">// NEW: 初始状态，任务未启动</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">NEW</span>          <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">// COMPLETING: 任务正在完成中</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">COMPLETING</span>   <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="comment">// NORMAL: 任务成功完成</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">NORMAL</span>       <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"><span class="comment">// EXCEPTIONAL: 任务抛出了异常</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">EXCEPTIONAL</span>  <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"><span class="comment">// CANCELLED: 任务被取消</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CANCELLED</span>    <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line"><span class="comment">// INTERRUPTING/INTERRUPTED: 任务正在被中断</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">INTERRUPTING</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">INTERRUPTED</span>  <span class="operator">=</span> <span class="number">6</span>;</span><br></pre></td></tr></table></figure><ul><li><strong>源码分析</strong>：<ul><li><code>FutureTask</code> 的 <code>run()</code> 方法负责执行 <code>Callable</code>，并在执行后保存结果</li><li>只有当 <code>state</code> 为 <code>NEW</code> 时才会执行任务，否则直接返回</li><li>执行过程中会将 <code>state</code> 更新为 <code>COMPLETING</code>，然后再更新为 <code>NORMAL</code> 或 <code>EXCEPTIONAL</code></li></ul></li><li>当一个 <code>Callable</code> 被 <code>FutureTask</code> 包装后，任务执行后会缓存其结果，避免重复执行</li></ul></li><li><p><strong><code>FutureTask</code> 线程安全机制：</strong></p><ul><li><strong>CAS：</strong> 使用 <code>Unsafe</code> 类的 CAS 操作保证状态变更的原子性</li><li><strong>锁：</strong> 使用 <code>ReentrantLock</code> 锁控制任务执行和结果获取的同步</li></ul></li><li><p><strong>阻塞调用：</strong></p><ul><li><code>get()</code> 方法会阻塞等待任务完成，如果任务已经完成，则直接返回结果（缓存机制）</li><li>可以使用异步方式获取结果，例如结合 <code>ExecutorService</code></li></ul></li><li><p><strong>代码示例</strong>：为什么结果只打印出了一个 call() ?</p><ul><li><strong>线程 A：</strong><ul><li>首次启动 <code>Thread</code>，执行 <code>futureTask.run()</code></li><li><code>state</code> 为 <code>NEW</code>，成功进入执行逻辑</li><li>执行 <code>call()</code> 方法，打印 “call()” 并返回结果</li><li>更新 <code>state</code> 为 <code>NORMAL</code>，缓存结果</li></ul></li><li><strong>线程 B：</strong><ul><li>启动 <code>Thread</code>，再次执行 <code>futureTask.run()</code></li><li><strong><code>state</code> 已经是 <code>NORMAL</code>（或其他非 <code>NEW</code> 状态），直接返回</strong></li><li>任务没有被再次执行</li></ul></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CallableTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        <span class="type">FutureTask</span> <span class="variable">futureTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FutureTask</span>(thread);<span class="comment">// 适配类</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask,<span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask,<span class="string">&quot;B&quot;</span>).start();  <span class="comment">//结果会被缓存，效率高</span></span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">o</span> <span class="operator">=</span> (String)futureTask.get();  <span class="comment">//获取Callable的返回结果; 这个get方法可能会产生阻塞！把它放在最后</span></span><br><span class="line">        <span class="comment">// FutureTask.get()是一个阻塞调用，它会等待直到任务完成才能返回结果。这就是为什么在多线程编程中，我们通常使用FutureTask或者类似的任务，以便在后台线程上执行长时间运行的任务，而不会阻塞主线程。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//或者使用异步通信来处理！</span></span><br><span class="line">        System.out.println(o);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;call()&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;fsaf&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果希望两个线程都能执行 <code>call()</code>，需要为每个线程创建独立的 <code>FutureTask</code> 实例：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FutureTask&lt;String&gt; futureTask1 = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(thread);</span><br><span class="line">FutureTask&lt;String&gt; futureTask2 = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(thread);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask1, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask2, <span class="string">&quot;B&quot;</span>).start();</span><br></pre></td></tr></table></figure><h2 id="8-常用的辅助类"><a href="#8-常用的辅助类" class="headerlink" title="8. 常用的辅助类"></a>8. 常用的辅助类</h2><h3 id="8-1-CountDownLatch"><a href="#8-1-CountDownLatch" class="headerlink" title="8.1 CountDownLatch"></a>8.1 CountDownLatch</h3><blockquote><p>组团插队</p></blockquote><ul><li><strong>作用</strong>：允许一组线程等待另一组线程完成特定任务之后再继续执行，可以用于线程之间的协调和同步<ul><li>可以看作一个减法计数器，当计数器归零时，所有等待的线程被唤醒</li></ul></li><li><strong>主要方法</strong><ul><li><code>countDown()</code>：<ul><li>将计数器减 1</li><li>当计数器变为 0 时，所有阻塞在 <code>await()</code> 方法的线程将被唤醒</li></ul></li><li><code>await()</code>：使当前线程阻塞，直到计数器归零就唤醒，再继续向下运行</li></ul></li><li><strong>使用限制：</strong><ul><li><strong>一次性工具：</strong> 不能复用</li><li><strong>计数器不可重置：</strong> 每次需要新的 <code>CountDownLatch</code> 实例</li></ul></li><li><strong>代码示例</strong>：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例：计数器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CountDownLatchDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 初始化计数器，总数为 6</span></span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建并启动 6 个线程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">6</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; Go out&quot;</span>);</span><br><span class="line">                countDownLatch.countDown(); <span class="comment">// 计数器减 1</span></span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待计数器归零，然后继续执行</span></span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        System.out.println(<span class="string">&quot;Close Door&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>工作原理</strong>：<ul><li><strong>计数器初始化：</strong> 在创建 <code>CountDownLatch</code> 对象时，指定计数器的初始值（如 <code>new CountDownLatch(6)</code>）</li><li><strong>任务线程执行：</strong> 每个线程执行任务后调用 <code>countDown()</code>，使计数器减 1</li><li><strong>等待线程阻塞：</strong> 调用 <code>await()</code> 的线程进入阻塞状态，等待计数器归零</li><li><strong>计数器归零：</strong> 当所有任务线程执行完毕（即计数器减为 0），所有等待线程被唤醒，继续执行后续代码</li></ul></li></ul><h3 id="8-2-CyclicBarrier"><a href="#8-2-CyclicBarrier" class="headerlink" title="8.2 CyclicBarrier"></a>8.2 CyclicBarrier</h3><ul><li><p>允许一组线程彼此等待，直到所有线程都到达某个公共屏障点。与 <code>CountDownLatch</code> 不同的是，它是一种<strong>可重用的屏障机制</strong></p></li><li><p><strong>主要特性：</strong></p><ul><li><strong>加法计数器：</strong> 指定线程数的栅栏点，只有所有线程都达到该点后才会继续执行</li><li><strong>可重用：</strong> 计数器归零后可以重新使用，不同于 <code>CountDownLatch</code> 的一次性计数器</li><li><strong>公共屏障点：</strong> 可以在所有线程到达屏障点后执行特定任务</li></ul></li><li><p><strong>主要方法：</strong></p><ul><li><strong><code>await()</code>：</strong><ul><li>使当前线程等待，直到所有线程都调用 <code>await()</code> 并达到屏障点</li><li>当所有线程都调用该方法时，将执行可选的 <code>barrierAction</code></li></ul></li><li><strong><code>getNumberWaiting()</code>：</strong><ul><li>返回当前等待屏障点的线程数</li></ul></li><li><strong><code>isBroken()</code>：</strong><ul><li>返回屏障是否被打破</li><li>若某个线程在等待时被中断或超时，屏障被打破，所有等待线程抛出 <code>BrokenBarrierException</code></li></ul></li></ul></li><li><p><strong>应用场景：</strong></p><ul><li><strong>并行任务协调：</strong> 等待一组线程都到达某个屏障点再继续执行</li><li><strong>分阶段执行：</strong> 分批次执行多线程任务</li></ul></li><li><p><strong>源码分析</strong>：</p><ul><li><strong>构造方法：</strong>初始化计数器和可选的屏障动作</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">CyclicBarrier</span><span class="params">(<span class="type">int</span> parties, Runnable barrierAction)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (parties &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    <span class="built_in">this</span>.parties = parties;</span><br><span class="line">    <span class="built_in">this</span>.count = parties;</span><br><span class="line">    <span class="built_in">this</span>.barrierCommand = barrierAction;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong><code>await()</code> 方法：</strong><ul><li>调用 <code>dowait()</code> 方法等待</li><li>计数器减 1，当减到 0 时，执行屏障动作并重置计数器</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dowait</span><span class="params">(<span class="type">boolean</span> timed, <span class="type">long</span> nanos)</span></span><br><span class="line">    <span class="keyword">throws</span> InterruptedException, BrokenBarrierException, TimeoutException &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> --count;</span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">0</span>) &#123; </span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>代码示例</strong>：</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CyclicBarrierDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个屏障点，指定 7 个线程，并在最后一个线程到达后执行召唤神龙的任务</span></span><br><span class="line">        <span class="type">CyclicBarrier</span> <span class="variable">cyclicBarrier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(<span class="number">7</span>, () -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;召唤神龙成功！&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建并启动 7 个线程，模拟收集 7 颗龙珠的过程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">7</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 收集第 &quot;</span> + temp + <span class="string">&quot; 颗龙珠&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    cyclicBarrier.await(); <span class="comment">// 等待其他线程到达屏障点</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>工作原理：</strong><ul><li><strong>计数器初始化：</strong> 创建 <code>CyclicBarrier</code> 时，指定需要互相等待的线程数（<code>parties</code>）</li><li><strong>线程等待：</strong> 每个线程调用 <code>await()</code> 方法，计数器减 1，并阻塞等待</li><li><strong>屏障点到达</strong>： 当计数器减到 0 时：<ul><li>执行可选的 <code>barrierAction</code>。</li><li>唤醒所有等待线程。</li><li>重置计数器，以便屏障重新使用。</li></ul></li><li><strong>屏障被打破</strong>： 当等待的线程被中断或超时：<ul><li>抛出 <code>BrokenBarrierException</code>。</li><li>屏障被打破，所有等待线程不再阻塞。</li></ul></li></ul></li></ul><h3 id="8-3-Semaphore"><a href="#8-3-Semaphore" class="headerlink" title="8.3 Semaphore"></a>8.3 Semaphore</h3><ul><li>一种信号量实现，用于<strong>控制对共享资源的访问</strong><ul><li>信号量维护了一个计数器，计数器的值表示当前可用的资源数</li><li>线程可以<strong>通过信号量获取或释放资源，从而控制同时访问共享资源的线程数量</strong></li></ul></li><li><strong>主要方法：</strong><ul><li><strong><code>acquire()</code>：</strong><ul><li>获取一个许可，如果没有可用许可，则阻塞等待</li><li>可重载为 <code>acquire(int permits)</code> 来获取多个许可</li></ul></li><li><strong><code>release()</code>：</strong><ul><li>释放一个许可，增加可用许可的数量</li><li>可重载为 <code>release(int permits)</code> 来释放多个许可</li></ul></li></ul></li><li><strong>构造方法：</strong><ul><li><code>Semaphore(int permits)</code>：构造一个具有指定许可数量的信号量</li><li><code>Semaphore(int permits, boolean fair)</code>：构造一个具有指定许可数量的信号量，并指定公平性<ul><li><code>fair</code> 为 <code>true</code> 时，实现公平性，按照线程的等待顺序分配许可</li></ul></li></ul></li><li><strong>应用场景</strong>：<ul><li><strong>限流控制：</strong> 控制同时访问的线程数量，类似于限制并发访问的连接池（如：限制 Web 服务的最大并发请求数）</li><li><strong>资源互斥：</strong> 访问资源时确保互斥性，类似于互斥锁的实现</li><li><strong>多线程协作：</strong> 控制任务的执行顺序，实现多个线程间的协调</li></ul></li><li><strong>代码示例</strong>：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SemaphoreDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个具有 3 个许可的信号量</span></span><br><span class="line">        <span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模拟 6 辆车争抢 3 个停车位</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">6</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 获取一个停车位</span></span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 抢到车位&quot;</span>);</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 离开车位&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// 释放停车位</span></span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="string">&quot;车&quot;</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>工作原理：</strong><ul><li><strong>信号量初始化：</strong><ul><li>创建 <code>Semaphore</code> 对象时，指定初始的许可数量（<code>permits</code>）</li><li>内部通过 AQS（<code>AbstractQueuedSynchronizer</code>）的状态来维护许可数量</li></ul></li><li><strong>获取资源：</strong><code>acquire()</code><ul><li>如果可用资源大于 0，则直接减 1 并返回</li><li>否则，当前线程进入等待队列，<strong>阻塞等待资源释放</strong></li></ul></li><li><strong>释放资源：</strong><code>release()</code><ul><li>增加可用资源数量，<strong>唤醒等待队列中的第一个线程</strong></li></ul></li></ul></li></ul><h2 id="9-读写锁-ReadWriteLock"><a href="#9-读写锁-ReadWriteLock" class="headerlink" title="9. 读写锁 ReadWriteLock"></a>9. 读写锁 ReadWriteLock</h2><h3 id="9-1-概述"><a href="#9-1-概述" class="headerlink" title="9.1 概述"></a>9.1 概述</h3><ul><li><p><code>ReadWriteLock</code> 是 JUC 中的一种高级锁，实现了读写锁机制</p><ul><li><code>ReentrantReadWriteLock</code> 是 <code>ReadWriteLock</code> 接口的实现类，包含<strong>内部类</strong> <code>ReadLock</code> 和 <code>WriteLock</code></li><li><code>ReadLock</code> 和 <code>WriteLock</code> 实现了 <code>Lock</code> 接口</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReentrantReadWriteLock</span> <span class="keyword">implements</span> <span class="title class_">ReadWriteLock</span>, java.io.Serializable &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ReadLock</span> <span class="keyword">implements</span> <span class="title class_">Lock</span>, java.io.Serializable &#123;  <span class="comment">// 读锁</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">WriteLock</span> <span class="keyword">implements</span> <span class="title class_">Lock</span>, java.io.Serializable &#123;  <span class="comment">// 写锁</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="9-2-读写锁特点"><a href="#9-2-读写锁特点" class="headerlink" title="9.2 读写锁特点"></a>9.2 读写锁特点</h3><ul><li><p><strong>读锁与写锁的互斥关系</strong>：</p><ul><li><strong>共享锁（读锁）：</strong> 多个线程可以同时持有读锁</li><li><strong>独占锁（写锁）：</strong> 只能有一个线程持有写锁</li></ul></li><li><p><strong>读写锁特点：</strong></p><ul><li><strong>读-读共存：</strong> 允许多个线程同时读取数据</li><li><strong>读-写互斥：</strong> 读操作和写操作不能同时进行(保证读操作读取到一致的已提交数据)</li><li><strong>写-写互斥：</strong> 只允许一个线程执行写操作</li></ul></li><li><p><strong>读写锁的作用：</strong></p><ul><li><p>提高多线程环境下读操作的并发性，适用于读多写少的场景</p></li><li><p>提供锁降级机制，实现数据一致性和性能的平衡</p></li></ul></li><li><p><strong>与其他锁的对比：</strong></p><ul><li><strong><code>synchronized</code>：</strong> 独占锁，每次只能一个线程访问</li><li><strong><code>ReentrantLock</code>：</strong> 独占锁，具备可重入性和公平性</li><li><strong><code>ReentrantReadWriteLock</code>：</strong> 读写锁，读读共享、读写互斥</li></ul></li><li><p><strong>应用场景：</strong>适用于读多写少的场景，提高读操作并发性</p><ul><li>如：缓存系统、配置中心</li></ul></li><li><p><strong>代码示例</strong>：使用读写锁的缓存实现</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyCacheLock</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Map&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">ReadWriteLock</span> <span class="variable">rwLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(String key, Object value)</span> &#123;</span><br><span class="line">        rwLock.writeLock().lock(); <span class="comment">// 加写锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 写入 &quot;</span> + value);</span><br><span class="line">            map.put(key, value);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 写入成功&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            rwLock.writeLock().unlock(); <span class="comment">// 释放写锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">get</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        rwLock.readLock().lock(); <span class="comment">// 加读锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 读取 &quot;</span> + key);</span><br><span class="line">            <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 读取成功&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            rwLock.readLock().unlock(); <span class="comment">// 释放读锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-3-锁降级"><a href="#9-3-锁降级" class="headerlink" title="9.3 锁降级"></a>9.3 锁降级</h3><ul><li><strong>读写锁的锁降级：</strong>指将持有的写锁降级为读锁，在持有写锁的情况下获取读锁，然后释放写锁的过程<ul><li><strong>作用</strong>：在一边读一边写的情况下提高性能<ul><li>确保数据的一致性和可见性</li></ul></li><li><strong>锁降级和不降级的区别</strong>：<ul><li><strong>降级步骤</strong>：<strong>获取写锁 &#x3D;&gt; 获取读锁 &#x3D;&gt; 释放写锁 &#x3D;&gt; 持有读锁，确保数据一致性</strong><ul><li>保证数据的可见性，<strong>在释放写锁后继续保持读锁</strong>，确保在写锁被释放后，其他线程不能立即获取写锁修改数据（写了之后读完了别人才能写）</li><li>降低锁的竞争，<strong>提高读操作的并发性</strong></li></ul></li><li><strong>不降级步骤</strong>：获取写锁 &#x3D;&gt; 释放写锁 &#x3D;&gt; 获取读锁 &#x3D;&gt; 释放读锁<ul><li>直接释放写锁并获取读锁，可能存在数据被其他写操作修改的风险</li><li>在高并发场景中，可能会出现读到不一致的数据，降低数据的一致性</li></ul></li></ul></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyCacheWithLockDowngrade</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Map&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReadWriteLock</span> <span class="variable">rwLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入操作，带锁降级</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(String key, Object value)</span> &#123;</span><br><span class="line">        rwLock.writeLock().lock(); <span class="comment">// 获取写锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 写入 &quot;</span> + value);</span><br><span class="line">            map.put(key, value);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 写入成功&quot;</span>);</span><br><span class="line"></span><br><span class="line">            rwLock.readLock().lock(); <span class="comment">// 锁降级</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            rwLock.writeLock().unlock(); <span class="comment">// 释放写锁</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 读取 &quot;</span> + key + <span class="string">&quot; after write&quot;</span>);</span><br><span class="line">            <span class="type">Object</span> <span class="variable">readValue</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 读取成功: &quot;</span> + readValue);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            rwLock.readLock().unlock(); <span class="comment">// 释放读锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">get</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        rwLock.readLock().lock(); <span class="comment">// 获取读锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 读取 &quot;</span> + key);</span><br><span class="line">            <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 读取成功: &quot;</span> + o);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            rwLock.readLock().unlock(); <span class="comment">// 释放读锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10-阻塞队列"><a href="#10-阻塞队列" class="headerlink" title="10. 阻塞队列"></a>10. 阻塞队列</h2><h3 id="10-1-基本介绍"><a href="#10-1-基本介绍" class="headerlink" title="10.1 基本介绍"></a>10.1 基本介绍</h3><ul><li>阻塞队列是 Java 并发包中的一种数据结构，提供了一种线程安全的队列操作方式，具有阻塞特性，即<strong>在队列满或空时，添加或移除元素的操作会被阻塞，直到队列发生变化</strong></li><li><strong>继承关系</strong>：<ul><li><code>BlockingQueue</code> 接口是 <code>Queue</code> 接口的子接口，位于 <code>java.util.concurrent</code> 包中</li><li>阻塞队列的实现类有 <code>ArrayBlockingQueue</code>、<code>LinkedBlockingQueue</code>、<code>SynchronousQueue</code> 等</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B.assets/image-20240511145808363.png" alt="image-20240511145808363"></p><ul><li><strong>应用场景</strong>：<ul><li>多线程并发处理场景：用于生产者-消费者模式等</li><li>线程池：用于任务调度和任务队列管理</li></ul></li></ul><h3 id="10-2-四组-API"><a href="#10-2-四组-API" class="headerlink" title="10.2 四组 API"></a>10.2 四组 API</h3><ul><li>阻塞队列提供了四组 API，分别适用于不同的场景，具体如下：<ul><li><strong>抛出异常：</strong> 在操作失败时，抛出异常</li><li><strong>不抛出异常，有返回值：</strong> 在操作失败时，返回特定值或标识</li><li><strong>阻塞等待：</strong> 在操作失败时，线程会阻塞等待</li><li><strong>超时等待：</strong> 在操作失败时，线程会阻塞等待一段时间后返回</li></ul></li></ul><table><thead><tr><th>方式</th><th>抛出异常</th><th>有返回值,不抛出异常</th><th>阻塞等待</th><th>超时等待</th></tr></thead><tbody><tr><td>添加</td><td>add(E e)</td><td>offer(E e)</td><td>put()</td><td>offer(E e, long timeout, TimeUnit unit)</td></tr><tr><td>移除</td><td>remove()</td><td>poll()</td><td>take()</td><td>poll(long timeout, TimeUnit unit)</td></tr><tr><td>获取队首元素</td><td>element()</td><td>peek()</td><td>-</td><td>-</td></tr></tbody></table><ul><li><p><strong>代码测试</strong>：</p><ul><li><strong>抛出异常</strong>：<code>add()</code> 方法底层调用的 <code>offer()</code> 方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    BlockingQueue&lt;String&gt; blockingQueue = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取队首元素 队首不存抛异常: NoSuchElementException</span></span><br><span class="line">        <span class="comment">// System.out.println(blockingQueue.element()); </span></span><br><span class="line">    System.out.println(blockingQueue.add(<span class="string">&quot;a&quot;</span>));  <span class="comment">// true</span></span><br><span class="line">    System.out.println(blockingQueue.add(<span class="string">&quot;b&quot;</span>));  <span class="comment">// true</span></span><br><span class="line">    System.out.println(blockingQueue.add(<span class="string">&quot;c&quot;</span>));  <span class="comment">// true</span></span><br><span class="line">    System.out.println(blockingQueue.element());  <span class="comment">// a 获取队首元素</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 抛出异常: IllegalStateException: Queue full</span></span><br><span class="line">    <span class="comment">// System.out.println(blockingQueue.add(&quot;d&quot;));</span></span><br><span class="line"></span><br><span class="line">    System.out.println(blockingQueue.remove());  <span class="comment">// a</span></span><br><span class="line">    System.out.println(blockingQueue.remove());  <span class="comment">// b</span></span><br><span class="line">    System.out.println(blockingQueue.remove());  <span class="comment">// c</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 抛出异常: NoSuchElementException</span></span><br><span class="line">    <span class="comment">// System.out.println(blockingQueue.remove());</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>不抛出异常</strong>：而是返回特殊值（通常是 <code>false</code> 或 <code>null</code>）<ul><li><code>offer()</code> 方法的源码第一句就是判断是否为 null，也就是不能添加 null 值；而 <code>add()</code> 方法底层也是直接调用的 <code>offer()</code> 方法，所以也不可以添加 null 值</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    BlockingQueue&lt;String&gt; blockingQueue = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取队首元素 队首不存在不抛异常</span></span><br><span class="line">    System.out.println(blockingQueue.peek());  <span class="comment">// null</span></span><br><span class="line">    System.out.println(blockingQueue.offer(<span class="string">&quot;a&quot;</span>));  <span class="comment">// true</span></span><br><span class="line">    System.out.println(blockingQueue.offer(<span class="string">&quot;b&quot;</span>));  <span class="comment">// true</span></span><br><span class="line">    System.out.println(blockingQueue.offer(<span class="string">&quot;c&quot;</span>));  <span class="comment">// true</span></span><br><span class="line">    <span class="comment">// 不抛出异常</span></span><br><span class="line">    System.out.println(blockingQueue.offer(<span class="string">&quot;d&quot;</span>));  <span class="comment">// false</span></span><br><span class="line">    System.out.println(blockingQueue.peek());  <span class="comment">// a</span></span><br><span class="line"></span><br><span class="line">    System.out.println(blockingQueue.poll());  <span class="comment">// a</span></span><br><span class="line">    System.out.println(blockingQueue.poll());  <span class="comment">// b</span></span><br><span class="line">    System.out.println(blockingQueue.poll());  <span class="comment">// c</span></span><br><span class="line">    <span class="comment">// 不抛出异常</span></span><br><span class="line">    System.out.println(blockingQueue.poll());  <span class="comment">// null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>阻塞等待</strong>：线程在操作不能立即执行时阻塞等待，直到操作可以执行</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    BlockingQueue&lt;String&gt; blockingQueue = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    blockingQueue.put(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">    blockingQueue.put(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">    blockingQueue.put(<span class="string">&quot;c&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此时队列已满, 控制台窗口会一直阻塞等待</span></span><br><span class="line">    <span class="comment">// blockingQueue.put(&quot;d&quot;);</span></span><br><span class="line"></span><br><span class="line">    System.out.println(blockingQueue.take());  <span class="comment">// a</span></span><br><span class="line">    System.out.println(blockingQueue.take());  <span class="comment">// b</span></span><br><span class="line">    System.out.println(blockingQueue.take());  <span class="comment">// c</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此时队列已空, 控制台窗口会一直阻塞等待</span></span><br><span class="line">    <span class="comment">// System.out.println(blockingQueue.take());</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>超时等待</strong>：线程在操作不能立即执行时阻塞等待一定的时间，如果在指定的时间内操作不能执行，则返回特殊值</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    BlockingQueue&lt;String&gt; blockingQueue = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    blockingQueue.offer(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">    blockingQueue.offer(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">    blockingQueue.offer(<span class="string">&quot;c&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试在2秒内添加元素，如果不能添加则放弃</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">status</span> <span class="operator">=</span> blockingQueue.offer(<span class="string">&quot;d&quot;</span>, <span class="number">2</span>, TimeUnit.SECONDS);</span><br><span class="line">    System.out.println(status);  <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">    System.out.println(blockingQueue.poll());  <span class="comment">// a</span></span><br><span class="line">    System.out.println(blockingQueue.poll());  <span class="comment">// b</span></span><br><span class="line">    System.out.println(blockingQueue.poll());  <span class="comment">// c</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试在2秒内取出元素，如果队列空则放弃</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">element</span> <span class="operator">=</span> blockingQueue.poll(<span class="number">2</span>, TimeUnit.SECONDS);</span><br><span class="line">    System.out.println(element);  <span class="comment">// null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="10-3-SynchronousQueue-同步队列"><a href="#10-3-SynchronousQueue-同步队列" class="headerlink" title="10.3 SynchronousQueue 同步队列"></a>10.3 SynchronousQueue 同步队列</h3><ul><li><p><code>SynchronousQueue</code> 是阻塞队列的特殊实现(一种无缓冲的等待队列)，没有容量，也可以视为容量为1的队列</p><ul><li>相对于有缓冲的 BlockingQueue 来说，少了一个中间经销商的环节（缓冲区）</li></ul></li><li><p><strong>特点</strong>：添加一个元素必须等待另一个线程取走，否则一直阻塞</p></li><li><p><strong>方法</strong>：</p><ul><li><code>put(E e)</code>：将元素放入队列中。如果没有其他线程正在尝试取走元素，此方法会阻塞</li><li><code>take()</code>：取走队列中的元素。如果没有元素可取，此方法会阻塞，使用<strong>Lock 锁保证线程安全</strong></li></ul></li><li><p><strong>公平性选择</strong>：构造 <code>SynchronousQueue</code> 时可以选择公平性。如果设置为公平模式，则线程按照等待时间的长短获得访问权；非公平模式则随机分配</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果输出不一致可能是因为 System.out.println 导致的竞态条件或线程调度问题</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronousQueueDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        BlockingQueue&lt;String&gt; synchronousQueue = <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; Put 1&quot;</span>);</span><br><span class="line">                synchronousQueue.put(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; Put 2&quot;</span>);</span><br><span class="line">                synchronousQueue.put(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; Put 3&quot;</span>);</span><br><span class="line">                synchronousQueue.put(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;T1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; Take &quot;</span> + synchronousQueue.take());</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; Take &quot;</span> + synchronousQueue.take());</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; Take &quot;</span> + synchronousQueue.take());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;T2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="11-线程池-重点"><a href="#11-线程池-重点" class="headerlink" title="11. 线程池(重点)"></a>11. 线程池(重点)</h2><h3 id="11-1-概述"><a href="#11-1-概述" class="headerlink" title="11.1 概述"></a>11.1 概述</h3><ul><li><p>线程池是一种<strong>基于池化技术的资源管理工具</strong>，用于有效管理线程资源</p></li><li><p><strong>线程池的好处</strong>：线程可以复用，可以控制最大并发量，管理线程</p><ul><li><strong>降低资源消耗</strong>：通过重复利用已创建的线程<strong>降低线程创建和销毁的开销</strong></li><li><strong>提高响应速度</strong>：减少了线程创建的时间，改善了程序的响应速度</li><li><strong>方便线程管理</strong>：线程池可以统一分配、调优和监控线程</li></ul></li><li><p><strong>Java线程池关键组件</strong></p><ul><li>Executor 框架：Java 提供的线程池实现框架，包括以下几个关键类：<ul><li><code>Executor</code>：负责线程使用和调度的根接口。</li><li><code>Executors</code>：工厂类，用于创建不同类型的线程池。</li><li><code>ExecutorService</code>：继承自Executor接口，定义了线程池的生命周期管理方法，如启动、关闭、提交任务等。</li><li><code>AbstractExecutorService</code>：ExecutorService 接口的抽象实现类，提供了 ExecutorService 的基本实现。  </li><li><code>ThreadPoolExecutor</code>：AbstractExecutorService 的具体实现类，提供了创建线程池的完整功能。</li></ul></li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B.assets/image-20240511171447844.png" alt="image-20240511171447844"></p><ul><li>线程池：三大方法,7大参数,4种拒绝策略</li></ul><h3 id="11-2-三大方法"><a href="#11-2-三大方法" class="headerlink" title="11.2 三大方法"></a>11.2 三大方法</h3><ul><li><p><strong>线程池的三种常用创建方式（通过Executors）</strong></p><ul><li><strong>SingleThreadExecutor</strong>：单个后台线程的线程池</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">singleThreadExecutor</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br></pre></td></tr></table></figure><ul><li><strong>FixedThreadPool</strong>：固定大小的线程池</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">fixedThreadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">5</span>);</span><br></pre></td></tr></table></figure><ul><li><strong>CachedThreadPool</strong>：大小不固定的线程池，根据需求自动更改数量</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">cachedThreadPool</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br></pre></td></tr></table></figure></li><li><p><strong>代码示例</strong>：</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Executors 三大方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();<span class="comment">//单个线程</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">threadPool2</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">5</span>); <span class="comment">//创建一个固定的线程池的大小</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">threadPool3</span> <span class="operator">=</span> Executors.newCachedThreadPool(); <span class="comment">//可伸缩的</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 线程池用完必须要关闭线程池</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;=<span class="number">100</span> ; i++) &#123;</span><br><span class="line">                <span class="comment">//通过线程池创建线程</span></span><br><span class="line">                threadPool.execute(()-&gt;&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+ <span class="string">&quot; ok&quot;</span>);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            threadPool.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>注意</strong>：阿里开发规范文档指出 &#x3D;&gt; <strong>线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式</strong>，这样的处理方式让编写人员更加明确线程池的运行规则，同时规避资源耗尽的风险，<strong>Executors 各个方法的弊端</strong>：<ul><li><strong>FixedThreadPool</strong> 和 <strong>SingleThreadExecutor</strong>：允许的请求队列长度为 <code>Integer.MAX_VALUE</code>，可能会堆积大量的请求，从而导致 OOM</li><li><strong>CachedThreadPool</strong> 和 <strong>ScheduledThreadPool</strong>：允许创建的线程数量为 <code>Integer.MAX_VALUE</code>(约为21亿)，可能会创建大量的线程，从而导致 OOM</li></ul></li></ul><h3 id="11-3-七大参数-自定义线程池"><a href="#11-3-七大参数-自定义线程池" class="headerlink" title="11.3 七大参数-自定义线程池"></a>11.3 七大参数-自定义线程池</h3><ul><li><strong>Executors 创建方式底层源码分析</strong>：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newSingleThreadExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 核心线程数和最大线程数都为1，即只有一个线程</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FinalizableDelegatedExecutorService</span></span><br><span class="line">        (<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThreads)</span> &#123;</span><br><span class="line">    <span class="comment">// 创建 ThreadPoolExecutor 实例，核心线程数和最大线程数都为指定的线程数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newCachedThreadPool</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 创建 ThreadPoolExecutor 实例，核心线程数为0，最大线程数为 Integer.MAX_VALUE，表示大小不固定</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>本质</strong>：三种方法都是调用的 <strong>ThreadPoolExecutor</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolExecutorAnalysis</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,  // 核心线程池大小</span></span><br><span class="line"><span class="params">                              <span class="type">int</span> maximumPoolSize, // 最大的线程池大小</span></span><br><span class="line"><span class="params">                              <span class="type">long</span> keepAliveTime,  // 超时了没有人调用就会释放</span></span><br><span class="line"><span class="params">                              TimeUnit unit, // 超时单位</span></span><br><span class="line"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue, // 阻塞队列</span></span><br><span class="line"><span class="params">                              ThreadFactory threadFactory, // 线程工厂 创建线程的 一般不用动</span></span><br><span class="line"><span class="params">                              RejectedExecutionHandler handler // 拒绝策略</span></span><br><span class="line"><span class="params">    )</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> || maximumPoolSize &lt;= <span class="number">0</span> || maximumPoolSize &lt; corePoolSize || keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">        <span class="keyword">if</span> (workQueue == <span class="literal">null</span> || threadFactory == <span class="literal">null</span> || handler == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将传入的参数赋值给对应的属性</span></span><br><span class="line">        <span class="built_in">this</span>.corePoolSize = corePoolSize; <span class="comment">// 设置核心线程池大小</span></span><br><span class="line">        <span class="built_in">this</span>.maximumPoolSize = maximumPoolSize; <span class="comment">// 设置最大的线程池大小</span></span><br><span class="line">        <span class="built_in">this</span>.workQueue = workQueue; <span class="comment">// 设置阻塞队列</span></span><br><span class="line">        <span class="built_in">this</span>.keepAliveTime = unit.toNanos(keepAliveTime); <span class="comment">// 设置超时时间</span></span><br><span class="line">        <span class="built_in">this</span>.threadFactory = threadFactory; <span class="comment">// 设置线程工厂</span></span><br><span class="line">        <span class="built_in">this</span>.handler = handler; <span class="comment">// 设置拒绝策略</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>推荐使用底层线程池手动创建方式</strong>：使用 <code>ThreadPoolExecutor</code> 直接构造，这种方式允许自定义参数，更灵活，可以明确线程池的运行规则，避免资源耗尽的风险，<strong>七大参数：</strong><ul><li><strong>corePoolSize</strong>：核心线程数，即不被回收的线程数量，除非设置了<code>allowCoreThreadTimeOut</code>。</li><li><strong>maximumPoolSize</strong>：最大线程数，能容纳的最大线程数量。</li><li><strong>keepAliveTime</strong>：线程空闲后的存活时长。</li><li><strong>unit</strong>：时间单位，与 <code>keepAliveTime</code> 配合使用。</li><li><strong>workQueue</strong>：任务队列，被提交但未执行的任务。</li><li><strong>threadFactory</strong>：线程工厂，用于创建线程。</li><li><strong>handler</strong>：拒绝策略，当任务太多来不及处理时，如何拒绝任务。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomThreadPoolExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 自定义线程池，设置核心线程数为2，最大线程数为5，线程空闲时间为3秒，</span></span><br><span class="line">        <span class="comment">// 使用有界队列 LinkedBlockingQueue 容量为3，使用默认线程工厂，使用丢弃最旧任务的拒绝策略</span></span><br><span class="line">        <span class="type">ThreadPoolExecutor</span> <span class="variable">threadPoolExecutor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">                <span class="number">2</span>, <span class="comment">// 核心线程池大小</span></span><br><span class="line">                <span class="number">5</span>, <span class="comment">// 最大线程池大小</span></span><br><span class="line">                <span class="number">3</span>, <span class="comment">// 超时时间</span></span><br><span class="line">                TimeUnit.SECONDS, <span class="comment">// 超时单位</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="number">3</span>), <span class="comment">// 使用有界队列 LinkedBlockingQueue，容量为3</span></span><br><span class="line">                Executors.defaultThreadFactory(), <span class="comment">// 默认线程工厂</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.DiscardOldestPolicy() <span class="comment">// 丢弃最旧任务的拒绝策略</span></span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最大承载：队列容量 + 最大线程数</span></span><br><span class="line">        <span class="comment">// 提交8个任务给自定义线程池执行</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 使用线程池来执行任务</span></span><br><span class="line">            threadPoolExecutor.execute(() -&gt; &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; ok&quot;</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭线程池</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            threadPoolExecutor.shutdown();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>底层工作原理</strong>：</p><ul><li>假设来了9个线程，在执行execute()方法才创建线程</li><li>第1-2个线程进入线程池创建</li><li>第3-5个线程进入阻塞队列</li><li>第6-8个线程会为他们创建新线程执行（直接运行线程6而非线程3）</li><li>第9个线程会被拒绝</li></ul><blockquote><p>总结：先到常驻线程，满了之后再到阻塞队列进行等待，阻塞队列满了之后，在往外扩容线程，扩容线程不能大于最大线程数。<strong>大于最大线程数和阻塞队列之和后，会执行拒绝策略</strong></p></blockquote></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B.assets/image-20240511192424588.png" alt="image-20240511192424588"></p><h3 id="11-4-四种策略"><a href="#11-4-四种策略" class="headerlink" title="11.4 四种策略"></a>11.4 四种策略</h3><ul><li><code>new ThreadPoolExecutor.AbortPolicy()</code>：<strong>默认策略，抛出异常</strong>阻止系统正常运行</li><li><code>new ThreadPoolExecutor.CallerRunsPolicy()</code>：调用者运行，<strong>将任务回退到调用者</strong>，降低新任务流量</li><li><code>new ThreadPoolExecutor.DiscardPolicy()</code>：<strong>丢弃任务，不抛出异常</strong></li><li><code>new ThreadPoolExecutor.DiscardOldestPolicy()</code>：<strong>抛弃队列中等待最久的任务，尝试再次提交当前任务</strong></li></ul><h3 id="11-5-如何设置线程池的最大大小"><a href="#11-5-如何设置线程池的最大大小" class="headerlink" title="11.5 如何设置线程池的最大大小"></a>11.5 如何设置线程池的最大大小</h3><blockquote><p>在设置线程池的最大大小时，针对CPU密集型和IO密集型任务有不同考虑</p><p>对于不同类型的任务，应该根据任务的特点和系统资源情况来灵活设置线程池的最大大小，以提高系统的效率和性能</p></blockquote><ul><li><strong>CPU密集型任务</strong>：<ul><li>设置线程池的最大大小为处理器核心数，这样可以最大程度地利用CPU资源，避免线程过多导致线程切换频繁而降低效率</li><li>可以通过代码获取处理器核心数，然后将最大线程数设置为相应的核心数</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">coreCount</span> <span class="operator">=</span> Runtime.getRuntime().availableProcessors();</span><br></pre></td></tr></table></figure><ul><li><strong>IO密集型任务</strong>：<ul><li>根据程序中IO操作的情况来确定最大线程池大小</li><li>通常情况下，可以将最大线程数设置为大约是最大I&#x2F;O数的一倍到两倍之间，以保证足够的线程处理IO任务</li></ul></li></ul><h2 id="12-四大函数式接口-必须掌握！"><a href="#12-四大函数式接口-必须掌握！" class="headerlink" title="12. 四大函数式接口(必须掌握！)"></a>12. 四大函数式接口(必须掌握！)</h2><blockquote><p>Java 程序员必须掌握：</p><p><strong>泛型、枚举、反射</strong></p><p><strong>lambda表达式、链式编程、函数式接口、Stream流式计算</strong></p></blockquote><h3 id="12-1-概述"><a href="#12-1-概述" class="headerlink" title="12.1 概述"></a>12.1 概述</h3><ul><li><strong>函数式接口</strong>：仅定义一个抽象方法的接口</li><li>函数式接口通常标注了<code>@FunctionalInterface</code>注解，这不是必需的，但有助于编译器检查接口是否符合函数式接口的定义</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>Java 8引入的四大函数式接口分别是<code>Consumer</code>、<code>Function</code>、<code>Predicate</code>、和<code>Supplier</code>，这些接口主要用于常见的操作：消费、转换、断言和提供</p></li><li><p><strong>应用场景</strong>：</p><ul><li><strong>Function</strong>：适用于转换数据，如从一种类型映射到另一种类型</li><li><strong>Predicate</strong>：常用于筛选数据，如在集合操作中进行条件过滤</li><li><strong>Consumer</strong>：常用于处理从数据源消费数据，如打印、存储操作</li><li><strong>Supplier</strong>：适用于需要多次返回结果的场景，如工厂方法、构造器引用等</li></ul></li><li><p>在特定的应用场景下，还可以定义自己的函数式接口来更好地满足需求</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CheckedFunction</span>&lt;T, R&gt; &#123;</span><br><span class="line">    R <span class="title function_">apply</span><span class="params">(T t)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="12-2-Function-接口"><a href="#12-2-Function-接口" class="headerlink" title="12.2 Function 接口"></a>12.2 Function 接口</h3><ul><li><strong>函数型接口</strong>：接受一个输入参数，返回一个结果</li><li><strong>源码</strong>：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Function</span>&lt;T, R&gt; &#123;</span><br><span class="line">    R <span class="title function_">apply</span><span class="params">(T t)</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>代码测试</strong>：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Function函数型接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Function&lt;String,String&gt; function = (str) -&gt;&#123;<span class="keyword">return</span> str;&#125;;</span><br><span class="line">        System.out.println(function.apply(<span class="string">&quot;starasdas&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="12-3-Predicate-接口"><a href="#12-3-Predicate-接口" class="headerlink" title="12.3 Predicate 接口"></a>12.3 Predicate 接口</h3><ul><li><strong>断定型接口</strong>：接受一个输入参数，返回一个布尔值</li><li><strong>源码</strong>：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Predicate</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">test</span><span class="params">(T t)</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>代码测试</strong>：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 断定型接口：有一个输入参数，返回值只能是 布尔值！</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//判断字符串是否为空</span></span><br><span class="line">        Predicate&lt;String&gt; predicate = (str)-&gt;&#123;<span class="keyword">return</span> str.isEmpty();&#125;;</span><br><span class="line">        System.out.println(predicate.test(<span class="string">&quot;11&quot;</span>));</span><br><span class="line">        System.out.println(predicate.test(<span class="string">&quot;&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="12-4-Consumer-接口"><a href="#12-4-Consumer-接口" class="headerlink" title="12.4 Consumer 接口"></a>12.4 Consumer 接口</h3><ul><li><strong>消费型接口</strong>：接受单一输入参数，不返回结果</li><li><strong>源码</strong>：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Consumer</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(T t)</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>代码测试</strong>：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 消费型接口 没有返回值！只有输入！</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Consumer&lt;String&gt; consumer = (str)-&gt;&#123;</span><br><span class="line">            System.out.println(str);</span><br><span class="line">        &#125;;</span><br><span class="line">        consumer.accept(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="12-5-Supplier-接口"><a href="#12-5-Supplier-接口" class="headerlink" title="12.5 Supplier 接口"></a>12.5 Supplier 接口</h3><ul><li><strong>供给型接口</strong>：无参数，返回一个结果</li><li><strong>源码</strong>：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Supplier</span>&lt;T&gt; &#123;</span><br><span class="line">    T <span class="title function_">get</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>代码测试</strong>：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 供给型接口，只返回，不输入</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Supplier&lt;String&gt; supplier = ()-&gt;&#123;<span class="keyword">return</span> <span class="string">&quot;1024&quot;</span>;&#125;;</span><br><span class="line">        System.out.println(supplier.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="13-Stream-流式计算"><a href="#13-Stream-流式计算" class="headerlink" title="13. Stream 流式计算"></a>13. Stream 流式计算</h2><ul><li><p>Stream 流式计算是Java 8中引入的一项强大的新特性，它<strong>允许以声明性方式处理数据集合</strong></p><ul><li>通过 <strong>Stream API 对数据进行高效的查询、过滤、转换、聚合等操作</strong>，无需编写冗长的代码</li><li>对集合对象功能的增强，专注于对集合对象进行各种便捷和高效的聚合操作或大批量数据操作，借鉴了函数式编程语言的许多概念，利用更丰富的语法对集合数据进行查询和处理</li></ul></li><li><p><strong>特点</strong>：</p><ul><li><strong>不是数据结构</strong>：Stream不存储数据，它只是在源数据（如集合、数组）的基础上提供了一种对数据的高效处理方式</li><li><strong>只能遍历一次</strong>：和迭代器类似，流一旦遍历过一次，便不能重复使用或“倒带”</li><li><strong>延迟执行</strong>：很多Stream操作都是延迟执行的，只有在需要结果的时候才执行（只有在终端操作执行时，所有中间操作才会被实际执行）<ul><li>可以避免对数据的不必要处理，特别是在链式调用中，可以合并多个操作，减少遍历次数</li></ul></li><li><strong>支持并行处理</strong>：Stream有串行和并行两种模式，通过并行模式可以利用多核处理器的优势，提高执行效率</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>);</span><br><span class="line"><span class="comment">// 并行处理一组数字，筛选出偶数并计算它们的和</span></span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> numbers.parallelStream()</span><br><span class="line">    .filter(n -&gt; n % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">    .mapToInt(Integer::intValue)</span><br><span class="line">    .sum();</span><br><span class="line">System.out.println(<span class="string">&quot;Sum of even numbers: &quot;</span> + sum);</span><br></pre></td></tr></table></figure></li><li><p><strong>核心操作</strong>：Stream 操作可以分为中间操作和终端操作两种：</p><ul><li><strong>中间操作</strong>：中间操作都会<strong>返回一个新的 Stream</strong>。常见的中间操作有<code>filter</code>（过滤）、<code>map</code>（映射）、<code>sorted</code>（排序）等</li><li><strong>终端操作</strong>：终端操作会从 Stream <strong>产生结果</strong>，之后不能再使用Stream。常见的终端操作包括<code>forEach</code>( 遍历流中的每个元素，执行给定的操作)、<code>collect</code>(将Stream转换成不同类型的结果)、<code>reduce</code>(通过某个连接操作将所有元素汇聚成一个汇总结果)、<code>findAny</code>(返回流中的任意元素)等</li></ul></li><li><p><strong>代码示例</strong>：</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">1</span>, <span class="string">&quot;a&quot;</span>, <span class="number">21</span>);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">2</span>, <span class="string">&quot;b&quot;</span>, <span class="number">22</span>);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">3</span>, <span class="string">&quot;c&quot;</span>, <span class="number">23</span>);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">4</span>, <span class="string">&quot;d&quot;</span>, <span class="number">24</span>);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">5</span>, <span class="string">&quot;e&quot;</span>, <span class="number">25</span>);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">6</span>, <span class="string">&quot;f&quot;</span>, <span class="number">26</span>);</span><br><span class="line">        List&lt;User&gt; list = Arrays.asList(user1, user2, user3, user4, user5, user6);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算交给流，使用链式编程</span></span><br><span class="line">        list.stream()</span><br><span class="line">            .filter(u -&gt; u.getId() % <span class="number">2</span> == <span class="number">0</span>)   <span class="comment">// 筛选出ID为偶数的用户</span></span><br><span class="line">            .filter(u -&gt; u.getAge() &gt; <span class="number">23</span>)      <span class="comment">// 进一步筛选出年龄大于23的用户</span></span><br><span class="line">            .map(u -&gt; u.getName().toUpperCase()) <span class="comment">// 将用户的名字转换为大写</span></span><br><span class="line">            .sorted((uu1, uu2) -&gt; uu2.compareTo(uu1)) <span class="comment">// 按名字降序排序, 也可直接 Comparator.reverseOrder()</span></span><br><span class="line">            .limit(<span class="number">1</span>)  <span class="comment">// 限制结果数量为1</span></span><br><span class="line">            .forEach(System.out::println); <span class="comment">// 打印最终结果  F</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// list.stream()</span></span><br><span class="line">        <span class="comment">//         .filter(u -&gt; u.getId() % 2 == 0)   // 筛选出ID为偶数的用户</span></span><br><span class="line">        <span class="comment">//         .filter(u -&gt; u.getAge() &gt; 23)      // 进一步筛选出年龄大于23的用户</span></span><br><span class="line">        <span class="comment">//         .map(u-&gt;&#123;u.setName(u.getName().toUpperCase()); return u;&#125;) // 将用户的名字转换为大写</span></span><br><span class="line">        <span class="comment">//         .sorted((uu1, uu2) -&gt; uu2.getName().compareTo(uu1.getName())) // 按名字降序排序, 也可直接 Comparator.reverseOrder()</span></span><br><span class="line">        <span class="comment">//         .limit(1)  // 限制结果数量为1</span></span><br><span class="line">        <span class="comment">//         .forEach(System.out::println); // 打印最终结果  User&#123;id=6, name=&#x27;F&#x27;, age=26&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>应用场景</strong>：</p><ul><li><p><strong>数据筛选和转换</strong>：如从数据库查询到的记录进行预处理，例如过滤、转换等</p></li><li><p><strong>聚合统计</strong>：如统计某个字段的平均值、最大值、最小值等</p></li><li><p><strong>并行运算</strong>：利用Stream的并行流大幅提高数据处理速度</p></li></ul></li></ul><h2 id="14-Fork-Join-分支合并"><a href="#14-Fork-Join-分支合并" class="headerlink" title="14. Fork&#x2F;Join 分支合并"></a>14. Fork&#x2F;Join 分支合并</h2><h3 id="14-1-概述"><a href="#14-1-概述" class="headerlink" title="14.1 概述"></a>14.1 概述</h3><ul><li><p>Fork&#x2F;Join 框架是自 Java 7 引入的一个用于并行执行任务的工具，尤其适合处理那些可以递归方式拆分成更小任务的大问题</p><ul><li><strong>基于“分治法”的设计思想</strong>，旨在充分利用多核处理器的计算能力来提高应用性能</li></ul></li><li><p><strong>特点</strong>：<strong>工作窃取（Work Stealing）</strong></p><ul><li>Fork&#x2F;Join 框架采用工作窃取算法来平衡工作负载。<strong>每个线程都维护一个双端队列</strong>，忙碌的线程可以将部分任务（从队列尾部拿取）转移给空闲的线程（从队列头部拿取）</li></ul></li><li><p><strong>实现原理</strong>：<strong>双端队列</strong></p><ul><li>每个工作线程都有自己的双端队列，用来存放分配给自己的任务</li><li>线程主要从自己的队列中取任务执行，当自己的队列空时，可以从其他线程的队列尾部“窃取”任务</li></ul></li><li><p><strong>核心</strong>：Fork&#x2F;Join 框架的核心在于两个操作：<code>fork()</code> 和 <code>join()</code></p><ul><li><strong>Fork</strong>：将<strong>大任务拆分成若干子任务</strong>，子任务可以并行执行</li><li><strong>Join</strong>：等待子任务完成，并将所有子任务的结果合并成总结果</li></ul></li><li><p><strong>使用场景</strong>：</p><ul><li>大数据处理</li><li>图像处理</li><li>大规模数值处理</li></ul></li><li><p><strong>使用方法</strong>：</p><ul><li><strong>创建 ForkJoinPool</strong>：所有 ForkJoin 任务都需要通过 ForkJoinPool 来执行，ForkJoinPool 是任务管理和执行的核心</li><li><strong>定义任务</strong>：创建继承自<code>ForkJoinTask</code>（通常是它的子类 <code>RecursiveAction</code> 或 <code>RecursiveTask</code>）的类<ul><li><code>RecursiveTask</code>（有返回值）</li><li><code>RecursiveAction</code>（无返回值）</li></ul></li><li><strong>启动任务</strong>：通过 <code>ForkJoinPool</code> 的 <code>invoke()</code> 或 <code>submit()</code> 方法启动任务</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B.assets/image-20240512150955213.png" alt="image-20240512150955213"></p><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B.assets/image-20240512151114324.png" alt="image-20240512151114324"></p><h3 id="14-2-代码示例"><a href="#14-2-代码示例" class="headerlink" title="14.2 代码示例"></a>14.2 代码示例</h3><ul><li><p><strong>ForkJoinDemo 类</strong>：继承自 <code>RecursiveTask&lt;Long&gt;</code>，是一个可以返回结果的任务</p><ul><li><p>**临界值 (<code>temp</code>)**：用于控制任务分解的粒度。如果任务的大小小于此值，则不再继续分解任务，而是直接进行计算。</p></li><li><p>**fork()**：将子任务推送到ForkJoinPool的工作队列。</p></li><li><p>**join()**：等待子任务完成，并获取其结果。</p></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ForkJoinDemo</span> <span class="keyword">extends</span> <span class="title class_">RecursiveTask</span>&lt;Long&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> star;  <span class="comment">// 任务的起始点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> end;   <span class="comment">// 任务的结束点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//临界值，当任务的规模小于这个值时直接进行计算而不再继续分解</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">1000000L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ForkJoinDemo</span><span class="params">(<span class="type">long</span> star, <span class="type">long</span> end)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.star = star;</span><br><span class="line">        <span class="built_in">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Long <span class="title function_">compute</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ((end - star) &lt;= temp) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">long</span> <span class="variable">i</span> <span class="operator">=</span> star; i &lt;= end; i++) &#123;</span><br><span class="line">                sum += i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 当任务大于临界值时，继续分解任务</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">middle</span> <span class="operator">=</span> (star + end) / <span class="number">2</span>;</span><br><span class="line">            <span class="type">ForkJoinDemo</span> <span class="variable">task1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinDemo</span>(star, middle);</span><br><span class="line">            task1.fork();  <span class="comment">// 将任务推送到ForkJoinPool的工作队列</span></span><br><span class="line">            <span class="type">ForkJoinDemo</span> <span class="variable">task2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinDemo</span>(middle + <span class="number">1</span>, end);</span><br><span class="line">            task2.fork();</span><br><span class="line">            <span class="comment">// 等待任务执行结束并合并结果</span></span><br><span class="line">            <span class="keyword">return</span> task1.join() + task2.join();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>测试类</strong>：使用三种不同的方法来计算从 1 到 20亿的整数和<ul><li>**test1()**：使用单线程迭代的方法计算总和</li><li>**test2()**：使用 ForkJoin 框架执行同样的计算。通过 <code>ForkJoinPool.invoke()</code> 方法启动 ForkJoin 任务</li><li>**test3()**：使用 Java 8 Stream API 的并行流进行计算。Stream API 的并行流内部使用的也是 ForkJoinPool<ul><li><code>.parallel().reduce(0, Long::sum)</code> 使用并行流来执行归约操作，这里用于计算一个长整型数列的总和</li><li>**.parallel()**：用于将流转换为并行流，并行流利用Java的Fork&#x2F;Join框架，允许在多核处理器上并行处理任务，从而加快执行速度</li><li>**.reduce(0, Long::sum)**：通过指定的函数来合并流中的元素，这里使用的是两参数版本的 <code>reduce</code> 方法<ul><li>第一个参数 <code>0</code> 是流为空时的默认结果</li><li>第二个参数 <code>Long::sum</code> 是一个方法引用，指向一个接受两个参数并返回它们的和的方法。它定义了如何合并流中的元素</li></ul></li><li>reduce 方法的<strong>优点</strong>：灵活、不需要存储中间状态，并行性能高、不会修改原始数据源</li></ul></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        test1(); <span class="comment">// 普通迭代方法  sum=2000000001000000000 时间：539</span></span><br><span class="line">        <span class="comment">//test2(); // 使用 ForkJoin  sum=2000000001000000000 时间：184</span></span><br><span class="line">        <span class="comment">//test3(); // 使用 Stream 并行流  sum=2000000001000000000 时间：160</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">long</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">20_0000_0000L</span>; i++) &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;sum=&quot;</span> + sum + <span class="string">&quot; 时间：&quot;</span> + (end - start));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">ForkJoinPool</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinPool</span>();</span><br><span class="line">        ForkJoinTask&lt;Long&gt; task = <span class="keyword">new</span> <span class="title class_">ForkJoinDemo</span>(<span class="number">0L</span>, <span class="number">20_0000_0000L</span>);</span><br><span class="line">        <span class="type">Long</span> <span class="variable">result</span> <span class="operator">=</span> pool.invoke(task);</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;sum=&quot;</span> + result + <span class="string">&quot; 时间：&quot;</span> + (end - start));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> LongStream.rangeClosed(<span class="number">0L</span>, <span class="number">20_0000_0000L</span>).parallel().reduce(<span class="number">0</span>, Long::sum);</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;sum=&quot;</span> + sum + <span class="string">&quot; 时间：&quot;</span> + (end - start));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Stream 并行流提供了最好的性能和最简洁的代码。</li><li>Fork&#x2F;Join 框架提供了较好的性能提升，适用于更复杂的任务分解和自定义并行处理逻辑。</li><li>普通迭代方法虽然实现最简单，但在处理大数据量时性能最低。</li></ul><blockquote><p>对于<strong>大多数大规模计算任务</strong>，推荐使用 Stream 并行流或 Fork&#x2F;Join 框架来利用现代多核 CPU 的计算能力</p></blockquote><h2 id="15-异步回调"><a href="#15-异步回调" class="headerlink" title="15. 异步回调"></a>15. 异步回调</h2><h3 id="15-1-同步和异步"><a href="#15-1-同步和异步" class="headerlink" title="15.1 同步和异步"></a>15.1 同步和异步</h3><ul><li><strong>同步操作</strong>：程序按顺序执行，必须等待当前操作完全完成后才能继续到下一步<ul><li>例如，从数据库读取数据或从网络加载资源，线程会被<strong>阻塞</strong>，直到操作完成</li></ul></li><li><strong>异步操作</strong>：程序可以在等待操作完成的同时继续执行其他任务。<ul><li>异步操作常见于不希望阻塞主线程的场景，例如GUI应用程序、大规模计算和高性能Web服务器</li></ul></li></ul><h3 id="15-2-CompletableFuture"><a href="#15-2-CompletableFuture" class="headerlink" title="15.2 CompletableFuture"></a>15.2 CompletableFuture</h3><ul><li><code>CompletableFuture</code> 是在Java 8中引入的，用于增强现有的<code>Future</code>接口，主要用于异步编程<ul><li>异步通常意味着非阻塞，可以使得我们的任务单独运行在与主线程分离的其他线程中，并且可以通过回调在主线程中获取异步任务的执行状态、完成情况以及异常信息等</li><li>CompletableFuture 实现了 Future，CompletionStage 接口，使得它既兼容现有的线程池框架，又提供了异步编程的接口抽象</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B.assets/image-20240512185425536.png" alt="image-20240512185425536"></p><ul><li><strong>常用方法</strong>：<ul><li>runAsync：执行没有返回值的异步任务</li><li>supplyAsync：执行有返回值的异步任务</li></ul></li><li><strong>特点</strong>：<ul><li>支持手动完成，可以显式地设置其结果</li><li>提供了异常处理机制</li><li>支持回调函数，当<code>Future</code>完成时可以自动触发</li><li>支持链式调用，允许将多个异步操作的结果串联起来</li><li>支持合并多个<code>CompletableFuture</code>，可以等待多个<code>CompletableFuture</code>完成后再继续执行</li></ul></li><li><strong>代码示例</strong>：<ul><li><code>whenComplete</code>：此方法接收两个参数：<code>t</code> 和 <code>u</code><ul><li>t：代表<strong>正常返回的结果</strong></li><li>u：代表<strong>抛出异常的错误信息</strong></li></ul></li><li>异常处理：<ul><li><code>exceptionally</code>：当异步操作发生异常时，可以通过该方法来定义一个回调函数，用于处理异常，该方法接收一个函数，该函数的输入是引发问题的异常对象，并返回一个替代值来“修复”异常情况，继续后续的处理流程</li><li><code>get</code> 方法在调用时会阻塞直到异步操作完成。如果操作成功完成，则返回正常的结果；如果操作中发生异常且没有被 <code>exceptionally</code> 方法处理，则会抛出一个 <code>ExecutionException</code>。如果使用 <code>exceptionally</code> 处理了异常，则 <code>get</code> 将返回 <code>exceptionally</code> 中定义的替代值</li></ul></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 没有返回值的异步回调</span></span><br><span class="line">    CompletableFuture&lt;Void&gt; voidCompletableFuture = CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; run&quot;</span>);  <span class="comment">// ForkJoinPool.commonPool-worker-9 run</span></span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(<span class="string">&quot;发起了异步请求&quot;</span>);</span><br><span class="line">    <span class="comment">// 阻塞等待任务完成</span></span><br><span class="line">    voidCompletableFuture.get();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有返回值的异步回调</span></span><br><span class="line">    <span class="comment">// 模拟异步操作，例如ajax请求，成功和失败回调</span></span><br><span class="line">    CompletableFuture&lt;Integer&gt; completableFuture = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        <span class="comment">// completableFuture ForkJoinPool.commonPool-worker-9</span></span><br><span class="line">        System.out.println(<span class="string">&quot;completableFuture &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">        <span class="comment">// 模拟异常情况</span></span><br><span class="line">        <span class="comment">// int i = 10 / 0;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1024</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用whenComplete处理正常返回结果和异常</span></span><br><span class="line">    System.out.println(completableFuture.whenComplete((t, u) -&gt; &#123;  <span class="comment">// 1024 / 233</span></span><br><span class="line">        <span class="keyword">if</span> (u == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 正常的返回结果</span></span><br><span class="line">            System.out.println(<span class="string">&quot;正常结果：&quot;</span> + t);  <span class="comment">// 正常结果：1024</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 异常信息：java.util.concurrent.CompletionException: java.lang.ArithmeticException: / by zero</span></span><br><span class="line">            System.out.println(<span class="string">&quot;异常信息：&quot;</span> + u);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).exceptionally((e) -&gt; &#123;</span><br><span class="line">        <span class="comment">// 异常处理</span></span><br><span class="line">        System.out.println(<span class="string">&quot;发生异常：&quot;</span> + e.getMessage());  <span class="comment">// 发生异常：java.lang.ArithmeticException: / by zero</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">233</span>;</span><br><span class="line">    &#125;).get()); <span class="comment">// 阻塞等待任务完成，并获取最终结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="15-3-Future-VS-CompletableFuture"><a href="#15-3-Future-VS-CompletableFuture" class="headerlink" title="15.3 Future VS. CompletableFuture"></a>15.3 Future VS. CompletableFuture</h3><ul><li><p><strong>Futrue</strong> 在 Java 里面，通常用来表示一个异步任务的引用，比如我们将任务提交到线程池里面，然后我们会得到一个 Futrue，在 Future 里面有 isDone 方法来 判断任务是否处理结束，还有 get 方法可以一直阻塞直到任务结束然后获取结果</p><ul><li>但整体来说这种方式，还<strong>是同步的</strong>，因为需要客户端不断阻塞等待或者不断轮询才能知道任务是否完成</li></ul></li><li><p>对比Future和CompletableFuture，<strong>CompletableFuture优势</strong>：</p><ul><li><p><strong>支持非阻塞回调</strong>：<code>CompletableFuture</code>支持在任务完成时，自动执行某些函数（回调），而<code>Future</code>则需要调用者不断检查</p></li><li><p><strong>更丰富的操作</strong>：<code>CompletableFuture</code>支持更丰富的方法和流式操作，如<code>thenApply</code>, <code>thenAccept</code>, <code>thenCompose</code>, 和<code>combine</code>等，这些都是<code>Future</code>所不具备的</p></li><li><p><strong>异常处理</strong>：<code>CompletableFuture</code>提供了异常处理的直接支持，而<code>Future</code>则没有</p></li></ul></li></ul><h2 id="16-JMM"><a href="#16-JMM" class="headerlink" title="16. JMM"></a>16. JMM</h2><ul><li><p><strong>JMM(Java Memory Model)<strong>：JAVA 内存模型，</strong>是一个抽象的概念</strong>或约定，用于定义Java程序中变量的访问规则以及在多线程环境下如何进行线程间的通信</p><ul><li>它描述了程序中各种变量（包括类实例字段、静态字段和构造数组对象）的访问方式</li></ul></li><li><p><strong>JMM 的同步约定</strong>：</p><ul><li><strong>线程解锁前必须立即将共享变量刷新回主存</strong>：确保释放锁时，对变量的修改能够被接下来获取该锁的其他线程看到</li><li><strong>线程加锁前必须读取主存中的最新值到工作内存中</strong>：确保获取锁后，工作内存中的变量是最新的</li><li><strong>加锁和解锁必须是同一把锁</strong>：保证锁的获取和释放的一致性</li></ul></li><li><p><strong>线程内存交互操作</strong>：Java 内存模型定义了以下<strong>8种操作</strong>来控制线程对内存的交互</p><ul><li>**Read(读取)**：从主内存中读取变量到线程的工作内存</li><li>**Load(载入)**：在工作内存中对变量赋值(跟随Read操作)</li><li>**Use(使用)**：使用工作内存中的变量</li><li>**Assign(赋值)**：向工作内存中的变量赋新值</li><li>**Store(存储)**：将工作内存中的变量的值写回主内存(准备写入操作)</li><li>**Write(写入)**：将Store的值真正写入主内存</li><li>**Lock(锁定)**：标记变量在主内存中开始处于锁定状态</li><li>**Unlock(解锁)**：标记变量在主内存中结束锁定状态</li></ul></li><li><p><strong>JMM 的操作规定</strong>：</p><ul><li><strong>Read和Load、Store和Write操作必须成对出现</strong>：保证内存值的正确传递</li><li><strong>线程对变量的修改必须同步回主内存</strong>：保证其他线程能看到最新值</li><li><strong>初始化变量必须在主内存中进行</strong>：避免使用未初始化的数据</li><li><strong>变量锁定和解锁必须一致</strong>：确保每次只有一个线程可以修改变量</li></ul></li><li><p><strong>代码示例问题分析</strong>：<code>num</code> 变量的更新可能对另一个线程不可见，因为没有适当的同步措施。这可能导致程序无法如预期终止，因为线程1可能永远看不到 <code>num</code> 的更新</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;  <span class="comment">// 线程1</span></span><br><span class="line">        <span class="keyword">while</span> (num == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 这里可能永远看不到num变化</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">    num = <span class="number">1</span>;  <span class="comment">// 主线程更新num</span></span><br><span class="line">    System.out.println(num);</span><br><span class="line">    <span class="comment">// 线程1可能不知道num已更新</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为解决这一问题，可以通过添加<code>volatile</code>关键字来声明<code>num</code>变量，这将保证每次读写都直接从主内存完成，从而保证了可见性</p><h2 id="17-Volatile"><a href="#17-Volatile" class="headerlink" title="17. Volatile"></a>17. Volatile</h2><h3 id="17-1-概述"><a href="#17-1-概述" class="headerlink" title="17.1 概述"></a>17.1 概述</h3><ul><li><strong>Volatile</strong> 是 Java 虚拟机提供的一种<strong>轻量级的同步机制</strong></li><li><strong>特点</strong>：<ul><li><strong>保证可见性</strong>：确保一个线程修改了该变量的值后，其他线程能够立即得知这个修改</li><li><strong>不保证原子性</strong>：虽然 volatile 变量的读写是原子的，但复合操作（如递增）不是原子的</li><li><strong>禁止指令重排</strong>：确保编译器在编译过程中不会对涉及 volatile变量的指令进行重排序，这是通过插入<strong>内存屏障</strong>来实现的</li></ul></li></ul><h3 id="17-2-保证可见性"><a href="#17-2-保证可见性" class="headerlink" title="17.2 保证可见性"></a>17.2 保证可见性</h3><ul><li><strong>代码示例</strong>：使用 volatile 防止死循环<ul><li>不使用<code>volatile</code>修饰<code>number</code>，其他线程可能无法看到<code>number</code>的改变，导致无限循环</li><li>使用<code>volatile</code>后，一旦<code>number</code>的值被修改，所有线程都能立即看到这一变化</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JMMDemo01</span> &#123;</span><br><span class="line">    <span class="comment">// 如果不加 volatile 程序会死循环</span></span><br><span class="line">    <span class="comment">// 加了 volatile 是可以保证可见性的</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="type">Integer</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (number == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 循环等待number变化</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        number = <span class="number">1</span>;</span><br><span class="line">        System.out.println(number);  <span class="comment">// 1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="17-3-不保证原子性"><a href="#17-3-不保证原子性" class="headerlink" title="17.3 不保证原子性"></a>17.3 不保证原子性</h3><ul><li><strong>原子性</strong>：不可分割，线程在执行任务的时候要么同时成功，要么同时失败</li><li><strong>代码示例</strong>：验证 volatile 不保证原子性<ul><li>代码中即使<code>number</code>是volatile变量，<code>number++</code>操作的非原子性导致最终结果可能不是预期的20000</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 不保证原子性</span></span><br><span class="line"><span class="comment"> * number &lt;= 2w</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VDemo02</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span> &#123;</span><br><span class="line">        number++;  <span class="comment">// ++ 不是原子性操作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 理论上number  === 20000</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">20</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= <span class="number">1000</span>; j++) &#123;</span><br><span class="line">                    add();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (Thread.activeCount() &gt; <span class="number">2</span>) &#123;  <span class="comment">// main  gc</span></span><br><span class="line">            <span class="comment">// 只要除了主线程和可能的垃圾收集线程之外还有其他线程在运行, 循环就会继续</span></span><br><span class="line">            <span class="comment">// 确保主线程（或任何等待所有其他线程完成的线程）最后执行</span></span><br><span class="line">            Thread.<span class="keyword">yield</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;,num=&quot;</span> + number);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>如何保证原子性</strong>？除了使用<code>lock</code>和<code>synchronized</code>关键字？<ul><li>Java 还提供了<strong>基于<code>java.util.concurrent.atomic </code>包中的一系列原子类</strong></li><li>这些原子类使用了<strong>高效</strong>的机制来保证单个变量操作的原子性，通常是<strong>通过底层的CAS（Compare-And-Swap）操作实现</strong></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 适用 AtomicInteger 类代替普通的 int 变量</span></span><br><span class="line"><span class="comment">// 确保在多线程环境中对数值的原子性增加操作</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">AtomicInteger</span> <span class="variable">number</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span>&#123;</span><br><span class="line">    number.incrementAndGet();  <span class="comment">// 底层是CAS保证的原子性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>底层原理</strong>：<ul><li><strong>原子类的工作原理</strong>：原子类在底层使用了CAS操作<ul><li>CAS操作涉及三个操作数：内存位置（在这里是<code>number</code>的值）、预期原值和新值</li><li>如果内存位置的当前值与预期原值相匹配，那么处理器会自动将该位置值更新为新值。这个过程是原子的，即不可中断，保证了更新操作的原子性</li></ul></li><li><strong><code>Unsafe</code>类</strong>：原子类的实现依赖于<code>Unsafe</code>类，这是 Java 中一个<strong>提供底层、不安全操作的类</strong>，如直接内存访问和非常规的对象实例化等。<code>Unsafe</code>类使得Java能够执行类似指针的操作，并且<strong>能够进行底层的内存操作</strong></li></ul></li></ul><blockquote><p>使用<code>AtomicInteger</code>类和其他原子类是在不想使用显式同步（例如<code>synchronized</code>或Java锁API）时确保数据完整性的一种有效方式。它们特别适用于计数器或累加器，以及任何只需要对单个变量进行原子操作的场景。这些原子类不仅效率高，而且代码简洁，易于理解和维护</p></blockquote><h3 id="17-4-防止指令重排"><a href="#17-4-防止指令重排" class="headerlink" title="17.4 防止指令重排"></a>17.4 防止指令重排</h3><ul><li><strong>指令重排</strong>：指计算机程序执行过程中，<strong>为了优化性能和利用硬件的并行处理能力，编译器和处理器可能会改变指令的执行顺序</strong>。重排可以发生在多个阶段：<ul><li><strong>编译器优化重排</strong>：编译器在生成机器代码时，可能会重新安排指令顺序以提高执行效率</li><li><strong>指令并行重排</strong>：现代处理器可能会并行执行多个指令，无需严格按照程序中的原始顺序</li><li><strong>内存系统重排</strong>：处理器和内存系统可能会改变操作执行的顺序，这与缓存和内存访问的优化有关</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">源代码–&gt;编译器优化重排–&gt;指令并行也可能会重排–&gt;内存系统也会重排–&gt;执行</span><br></pre></td></tr></table></figure><ul><li><p><strong>数据依赖性</strong>：处理器<strong>在进行重排时会考虑到指令之间的数据依赖性</strong>。如果一条指令的结果依赖于前一条指令的结果，处理器会保留这种依赖关系，<strong>确保程序的执行结果符合逻辑的预期</strong></p><ul><li>如：理论上，执行顺序可能变为 <code>2-1-3-4</code> 或 <code>1-3-2-4</code>，但不会是 <code>4-1-2-3</code>，因为 <code>4</code> 操作依赖于 <code>3</code> 操作的结果</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span>;  <span class="comment">// 1</span></span><br><span class="line"><span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">2</span>;  <span class="comment">// 2</span></span><br><span class="line">x = x + <span class="number">5</span>;  <span class="comment">// 3</span></span><br><span class="line">y = x * x;  <span class="comment">// 4</span></span><br></pre></td></tr></table></figure></li><li><p><strong>volatile 防止指令重排</strong>：使用 <strong>volatile 变量时，JVM 会插入内存屏障来防止指令重排</strong></p><ul><li><strong>内存屏障</strong>：是一种CPU指令，用于实现以下两个主要目的：<ul><li><strong>保证特定操作的执行顺序</strong>：防止屏障前后的指令进行重排</li><li><strong>保证变量的内存可见性</strong>：确保屏障前的写操作在屏障后的读操作可见</li></ul></li><li>通过插入读屏障和写屏障，<code>volatile</code>确保在读取<code>volatile</code>变量之前的所有操作完成，且结果对后续的读取可见；写入<code>volatile</code>变量后的操作不会被重排到写操作之前，示例如下：<ul><li>理论上，最终<code>x</code>和<code>y</code>的值可能是 <code>(0,1)</code>, <code>(1,0)</code>, <code>(1,1)</code>，但由于<code>volatile</code>的使用，不会出现 <code>(0,0)</code>，因为每个线程对<code>a</code>或<code>b</code>的写入在另一个线程读取之前已经完成和可见</li><li><strong>情况 <code>(1, 0)</code></strong><ul><li><strong>线程B</strong> 执行 <code>b = 1</code> 完成后的写内存屏障确保 <code>b</code> 的更新对所有其他线程可见</li><li><strong>线程A</strong> 在执行 <code>x = b</code> 时，必须通过读内存屏障，确保看到 <code>b</code> 的最新值（即1）。但在此之前，<code>a</code> 可能还未被 <strong>线程B</strong> 读到，所以 <code>y</code> 可能仍是0</li></ul></li><li><strong>情况 <code>(0, 1)</code></strong><ul><li><strong>线程A</strong> 执行 <code>a = 1</code> 完成后的写内存屏障确保 <code>a</code> 的更新对所有其他线程可见</li><li><strong>线程B</strong> 在执行 <code>y = a</code> 时，必须通过读内存屏障，确保看到 <code>a</code> 的最新值（即1）。但在此之前，<code>b</code> 可能还未被 <strong>线程A</strong> 读到，所以 <code>x</code> 可能仍是0</li></ul></li><li><strong>情况 <code>(1, 1)</code></strong><ul><li>如果 <strong>线程A</strong> 和 <strong>线程B</strong> 的写操作（<code>a = 1</code> 和 <code>b = 1</code>）都完成，并且各自的写内存屏障生效之后，对方线程的读操作（<code>x = b</code> 和 <code>y = a</code>）发生。这意味着每个线程都能看到对方的变量更新，结果就是 <code>(1, 1)</code></li></ul></li></ul></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程A</span></span><br><span class="line"><span class="type">Thread</span> <span class="variable">A</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    a = <span class="number">1</span>;            <span class="comment">// A1: 写操作，后面跟着写内存屏障</span></span><br><span class="line">    <span class="comment">// ---- 写屏障 (确保a的写入对所有线程可见，且之前的写操作不会被重排到屏障后面)</span></span><br><span class="line">    x = b;            <span class="comment">// A2: 读操作，前面有读内存屏障</span></span><br><span class="line">    <span class="comment">// ---- 读屏障 (确保读取b时获取的是最新值，且之后的读操作不会被重排到屏障前面)</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程B</span></span><br><span class="line"><span class="type">Thread</span> <span class="variable">B</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    b = <span class="number">1</span>;            <span class="comment">// B1: 写操作，后面跟着写内存屏障</span></span><br><span class="line">    <span class="comment">// ---- 写屏障 (确保b的写入对所有线程可见，且之前的写操作不会被重排到屏障后面)</span></span><br><span class="line">    y = a;            <span class="comment">// B2: 读操作，前面有读内存屏障</span></span><br><span class="line">    <span class="comment">// ---- 读屏障 (确保读取a时获取的是最新值，且之后的读操作不会被重排到屏障前面)</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>在单例模式等场景中，<code>volatile</code>常被用于确保对象创建过程的安全性</strong>，防止对象未完全构造就被其他线程访问</p><h2 id="18-单例模式"><a href="#18-单例模式" class="headerlink" title="18. 单例模式"></a>18. 单例模式</h2><ul><li>单例模式是一种设计模式，<strong>用于确保一个类只有一个实例，并提供一个全局访问点</strong></li><li>在 Java 中，单例模式的实现主要有几种方式：<strong>饿汉式、懒汉式（DCL双重检查锁定实现）、静态内部类和枚举方式</strong></li></ul><h3 id="18-1-饿汉式"><a href="#18-1-饿汉式" class="headerlink" title="18.1 饿汉式"></a>18.1 饿汉式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 饿汉式单例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hungry</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有构造函数防止外部实例化(虽然反正了多线程并发对单例的破坏, 但还是有可能被反射破坏单例模式)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Hungry</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内部创建类的实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Hungry</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hungry</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 全局访问点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Hungry <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用反射破坏饿汉式单例模式</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Class&lt;?&gt; clazz = Hungry.class;</span><br><span class="line">        Constructor&lt;?&gt; constructor = clazz.getDeclaredConstructor();</span><br><span class="line">        constructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">Hungry</span> <span class="variable">instance1</span> <span class="operator">=</span> (Hungry) constructor.newInstance();</span><br><span class="line">        <span class="type">Hungry</span> <span class="variable">instance2</span> <span class="operator">=</span> Hungry.getInstance();</span><br><span class="line">        System.out.println(<span class="string">&quot;instance1 == instance2: &quot;</span> + (instance1 == instance2)); <span class="comment">// 输出false，单例被破坏</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="18-2-懒汉式-DCL实现"><a href="#18-2-懒汉式-DCL实现" class="headerlink" title="18.2 懒汉式-DCL实现"></a>18.2 懒汉式-DCL实现</h3><ul><li><strong>DCL懒汉式单例</strong> 是在需要时才创建实例，利用<strong>双重检查锁定机制确保只创建一个实例，同时使用 <code>volatile</code> 关键字防止指令重排，确保线程安全</strong><ul><li>通过在私有构造器中使用同步代码块和标识量来防止反射破解。然而，<strong>由于反射机制可以绕过私有构造器的限制，所以即使在构造器中使用了同步代码块和标识量，也无法阻止反射机制创建新的实例</strong></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * DCL 懒汉式单例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LazyMan</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">LazyMan</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">key</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 即使在私有构造器里添加同步代码块, 反射也能破坏单例模式 =&gt; 使用反射获取类的私有构造器的引用</span></span><br><span class="line">    <span class="comment">// 尝试通过设置一个标识量 key 防止反射破坏单例模式 =&gt; 还是能使用反射获取到实例来修改类中的标识量 key</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">LazyMan</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (LazyMan.class) &#123;</span><br><span class="line">            <span class="keyword">if</span> (key == <span class="literal">false</span>) &#123;</span><br><span class="line">                key = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;不要试图使用反射破坏异常&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; ok&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 双重检测锁模式 简称 DCL 懒汉式</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> LazyMan <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 加锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (LazyMan.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">LazyMan</span>();</span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">                     * 此步骤非原子操作, 对于指令重排问题 =&gt; volatile 解决</span></span><br><span class="line"><span class="comment">                     * 1、分配内存空间</span></span><br><span class="line"><span class="comment">                     * 2、执行构造方法，初始化对象</span></span><br><span class="line"><span class="comment">                     * 3、把这个对象指向这个空间</span></span><br><span class="line"><span class="comment">                     *</span></span><br><span class="line"><span class="comment">                     *  就有可能出现指令重排问题</span></span><br><span class="line"><span class="comment">                     *  比如执行的顺序是1 3 2 等</span></span><br><span class="line"><span class="comment">                     *  可以添加volatile保证指令重排问题</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用反射破坏 DCL 懒汉式单例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException, IllegalAccessException,</span><br><span class="line">    InvocationTargetException, InstantiationException, NoSuchFieldException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 反射获取标识量</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">key</span> <span class="operator">=</span> LazyMan.class.getDeclaredField(<span class="string">&quot;key&quot;</span>);</span><br><span class="line">        key.setAccessible(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 反射获取私有构造器的引用</span></span><br><span class="line">        Constructor&lt;LazyMan&gt; declaredConstructor = LazyMan.class.getDeclaredConstructor(<span class="literal">null</span>);</span><br><span class="line">        declaredConstructor.setAccessible(<span class="literal">true</span>);  <span class="comment">// 无视了私有的构造器</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用反射获取的构造器创建实例</span></span><br><span class="line">        <span class="type">LazyMan</span> <span class="variable">lazyMan1</span> <span class="operator">=</span> declaredConstructor.newInstance();</span><br><span class="line">        key.set(lazyMan1, <span class="literal">false</span>);  <span class="comment">// 绕过标识量的限制</span></span><br><span class="line">        <span class="type">LazyMan</span> <span class="variable">instance</span> <span class="operator">=</span> declaredConstructor.newInstance();</span><br><span class="line"></span><br><span class="line">        System.out.println(instance);  <span class="comment">// com.thr.singleton.LazyMan@1540e19d</span></span><br><span class="line">        System.out.println(lazyMan1);  <span class="comment">// com.thr.singleton.LazyMan@677327b6</span></span><br><span class="line">        System.out.println(instance == lazyMan1);  <span class="comment">// false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="18-3-静态内部类"><a href="#18-3-静态内部类" class="headerlink" title="18.3 静态内部类"></a>18.3 静态内部类</h3><ul><li>使用<strong>静态内部类</strong>可以达到懒加载的效果，并且由于类加载机制保证了实例的唯一性和线程安全性<ul><li>还是防止不了反射，因为还是有私有构造器</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Holder</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Holder</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">InnerClass</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Holder</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Holder</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Holder <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> InnerClass.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="18-4-枚举-防止反射破坏单例"><a href="#18-4-枚举-防止反射破坏单例" class="headerlink" title="18.4 枚举-防止反射破坏单例"></a>18.4 枚举-防止反射破坏单例</h3><ul><li><p>Java的<strong>枚举</strong>提供了一种简洁的方式来实现单例</p><ul><li><strong>枚举自带防反射和防序列化破坏的功能</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.lang.reflect.Constructor.java 源码</span></span><br><span class="line"><span class="comment">// 可以看到在使用反射获取的构造器创建实例的源码底层设计了禁止通过反射创建枚举对象</span></span><br><span class="line"><span class="comment">// 如果是枚举类型，就会抛出异常</span></span><br><span class="line"><span class="keyword">if</span> ((clazz.getModifiers() &amp; Modifier.ENUM) != <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Cannot reflectively create enum objects&quot;</span>);</span><br></pre></td></tr></table></figure><ul><li>使用枚举不仅简单，而且由于<strong>Java虚拟机从根本上保证了每个枚举常量的唯一性</strong>，因此通过枚举实现的单例模式也是线程安全的</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// enum 本身就是一个 Class 类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">EnumSingle</span> &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> EnumSingle <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException &#123;</span><br><span class="line">        <span class="type">EnumSingle</span> <span class="variable">instance1</span> <span class="operator">=</span> EnumSingle.INSTANCE;</span><br><span class="line">        <span class="comment">// 查看枚举类的源码, 找到构造器, 尝试用反射获取</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            protected Enum(String name, int ordinal) &#123;</span></span><br><span class="line"><span class="comment">                this.name = name;</span></span><br><span class="line"><span class="comment">                this.ordinal = ordinal;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Constructor&lt;EnumSingle&gt; declaredConstructor = EnumSingle.class.getDeclaredConstructor(String.class, <span class="type">int</span>.class);</span><br><span class="line">        declaredConstructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用反射获取的构造器创建实例</span></span><br><span class="line">        <span class="comment">// 报错: java.lang.NoSuchMethodException: com.ogj.single.EnumSingle.&lt;init&gt;()</span></span><br><span class="line">        <span class="type">EnumSingle</span> <span class="variable">instance2</span> <span class="operator">=</span> declaredConstructor.newInstance();</span><br><span class="line">        System.out.println(instance1);</span><br><span class="line">        System.out.println(instance2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="19-CAS"><a href="#19-CAS" class="headerlink" title="19. CAS"></a>19. CAS</h2><h3 id="19-1-概述"><a href="#19-1-概述" class="headerlink" title="19.1 概述"></a>19.1 概述</h3><ul><li><p><strong>CAS（Compare-And-Swap）</strong>是一种用于实现同步原语的技术，广泛用于<strong>多线程编程中实现无锁的并发算法</strong></p><ul><li><strong>锁-Free机制</strong>：不依赖传统的锁机制（如互斥锁、读写锁）来同步线程的访问，而是通过原子操作来保证代码的安全执行</li></ul></li><li><p><strong>操作元素</strong>：CAS涉及三个基本操作数</p><ul><li>**V (内存位置)**：需要更新的内存地址</li><li>**A (预期原值)**：期望内存位置的值</li><li>**B (新值)**：如果位置的当前值与预期相符，需要写入的新值</li></ul></li><li><p><strong>工作原理</strong>：CAS操作会原子性地执行以下步骤</p><ul><li><strong>读取当前值</strong>：从内存位置V读取当前值</li><li><strong>比较当前值与预期值</strong>：检查内存位置的当前值是否与预期值A相等</li><li><strong>条件更新</strong>：如果当前值与预期值相等，那么将内存位置的值更新为新值B</li></ul></li><li><p><strong>缺点</strong>：</p><ul><li><strong>循环时间长、开销大</strong>：如果多个线程同时尝试更新同一变量，可能导致高CPU占用，因为线程需要在循环中不断尝试</li><li><strong>仅保证单一变量的原子性</strong>：对于涉及多个变量的复合操作，CAS无法直接保障其原子性</li><li><strong>ABA问题</strong>：变量在被更新前后可能会被改变多次，导致CAS认为没有变化，实际上值已经被修改过<ul><li>eg. 变量V先从A变为B，然后又从B变回A，那么使用CAS进行检查时会认为这个变量没有被修改过，但实际上它已经被修改了两次</li></ul></li></ul></li></ul><h3 id="19-2-代码示例"><a href="#19-2-代码示例" class="headerlink" title="19.2 代码示例"></a>19.2 代码示例</h3><ul><li>在 Java 中利用原子操作类实现，<code>java.util.concurrent.atomic</code> 包下的类例如<code>AtomicBoolean</code>，<code>AtomicInteger</code>，<code>AtomicLong</code>  以Atomic开头的包装类提供了 CAS 功能。它们分别用于 Boolean，Integer，Long 类型的原子性操作</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CASDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AtomicInteger</span> <span class="variable">atomicInteger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">2020</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// CAS操作：如果当前值为2020，则更新为2021</span></span><br><span class="line">        System.out.println(atomicInteger.compareAndSet(<span class="number">2020</span>, <span class="number">2021</span>)); <span class="comment">// true</span></span><br><span class="line">        System.out.println(atomicInteger.get()); <span class="comment">// 2021</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>Unsafe</code>类在Java中提供了一个低级别的非安全机制，包括对内存的直接操作和对CAS操作的支持<ul><li><code>Unsafe</code>提供的<code>compareAndSwap</code>方法<strong>直接映射到硬件的原子指令，使得Java能够利用这些底层指令来实现原子操作</strong></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Unsafe.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndAddInt</span><span class="params">(Object var1, <span class="type">long</span> var2, <span class="type">int</span> var4)</span> &#123;</span><br><span class="line">    <span class="type">int</span> var5;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        var5 = <span class="built_in">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">    &#125; <span class="keyword">while</span>(!<span class="built_in">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));  <span class="comment">// 自旋锁</span></span><br><span class="line">    <span class="comment">// 比较当前工作内存中的值 和 主内存中的值，如果这个值是期望的，那么则执行操作！如果不是就一直循环，使用的是自旋锁</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 本地 native 方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">compareAndSwapInt</span><span class="params">(Object var1, <span class="type">long</span> var2, <span class="type">int</span> var4, <span class="type">int</span> var5)</span>;</span><br></pre></td></tr></table></figure><h3 id="19-3-ABA-问题"><a href="#19-3-ABA-问题" class="headerlink" title="19.3 ABA 问题"></a>19.3 ABA 问题</h3><ul><li>本质是 CAS 操作只能检查变量当前的值是否与预期的值相同，但它不能检测在操作间隙内该值是否被修改过<ul><li>如果一个变量的值原先是A，被改变为B，然后又被改回A，使用CAS进行比较时将无法识别出变量已经被修改过</li></ul></li><li>举例：<ul><li><strong>初始状态</strong>：小童的账户余额为1000元</li><li><strong>操作序列</strong>：<ul><li><strong>线程1</strong>：尝试从账户中提取500元。它检查余额是否为1000元，并准备更新为500元</li><li><strong>线程1</strong> 成功执行，账户余额现在是500元</li><li><strong>线程2</strong> 也想从账户中提取500元。它开始时检查余额为1000元，但在它执行时，<strong>线程1</strong> 已经将余额改为500元。此时，<strong>线程2</strong> 被暂停或阻塞</li><li><strong>线程3</strong>（小童的妈妈）为账户汇入500元，余额恢复为1000元</li><li><strong>线程2</strong> 恢复执行，检查余额仍然为其记忆中的1000元，然后尝试将余额更新为500元。由于当前余额确实是1000元，CAS检查通过，余额被更新为500元</li></ul></li><li><strong>结果</strong>：账户本应仅被扣款500元，最终却被错误地扣款两次，余额变为500元</li></ul></li></ul><h3 id="19-4-解决-ABA-问题-带版本号的原子引用"><a href="#19-4-解决-ABA-问题-带版本号的原子引用" class="headerlink" title="19.4 解决 ABA 问题-带版本号的原子引用"></a>19.4 解决 ABA 问题-带版本号的原子引用</h3><ul><li>为了<strong>解决ABA问题，可以使用带版本号的原子引用</strong></li><li><code>AtomicStampedReference</code> 是Java提供的一个用于解决ABA问题的类。它通过维护一个“时间戳”（或称为版本号）来管理每个变量的版本，从而防止ABA问题<ul><li>每次变量更新都伴随一个版本号的增加，即使数据再次回到原始状态，版本号也会不同，从而避免ABA问题</li></ul></li><li>代码示例：<ul><li><strong>线程a</strong>：成功地两次改变了值，并且每次操作后版本号都递增了</li><li><strong>线程b</strong>：尽管在它执行时值又回到了1，但由于它的操作基于过时的版本号1，所以它的更新操作失败</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ABASolution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化AtomicStampedReference，初始值为1，初始版本号为1</span></span><br><span class="line">        AtomicStampedReference&lt;Integer&gt; objectAtomicStampedReference = <span class="keyword">new</span> <span class="title class_">AtomicStampedReference</span>&lt;&gt;(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第一个线程，模拟值的变更和版本号的更新</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">stamp</span> <span class="operator">=</span> objectAtomicStampedReference.getStamp(); <span class="comment">// 获取当前版本号</span></span><br><span class="line">            System.out.println(<span class="string">&quot;a1-&gt;&quot;</span> + stamp);  <span class="comment">// a1-&gt;1</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>); <span class="comment">// 线程休眠1秒，模拟操作延迟</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            objectAtomicStampedReference.compareAndSet(<span class="number">1</span>, <span class="number">2</span>,</span><br><span class="line">                    objectAtomicStampedReference.getStamp(), objectAtomicStampedReference.getStamp() + <span class="number">1</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;a2-&gt;&quot;</span> + objectAtomicStampedReference.getStamp());  <span class="comment">// a2-&gt;2</span></span><br><span class="line">            objectAtomicStampedReference.compareAndSet(<span class="number">2</span>, <span class="number">1</span>,</span><br><span class="line">                    objectAtomicStampedReference.getStamp(), objectAtomicStampedReference.getStamp() + <span class="number">1</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;a3-&gt;&quot;</span> + objectAtomicStampedReference.getStamp());  <span class="comment">// a3-&gt;3</span></span><br><span class="line">        &#125;, <span class="string">&quot;a&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第二个线程，尝试基于原始的版本号进行修改</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">stamp</span> <span class="operator">=</span> objectAtomicStampedReference.getStamp(); <span class="comment">// 获取版本号</span></span><br><span class="line">            System.out.println(<span class="string">&quot;b1-&gt;&quot;</span> + stamp);  <span class="comment">// b1-&gt;1</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>); <span class="comment">// 线程休眠2秒，等待第一个线程先行执行</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            objectAtomicStampedReference.compareAndSet(<span class="number">1</span>, <span class="number">6</span>, stamp, stamp + <span class="number">1</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;b2-&gt;&quot;</span> + objectAtomicStampedReference.getStamp());  <span class="comment">// b2-&gt;3</span></span><br><span class="line">            <span class="comment">// 值看似匹配，版本号不匹配，更新操作失败。打印最终的版本号，仍为b2-&gt;3（未能更新，版本号没有变化）</span></span><br><span class="line">        &#125;, <span class="string">&quot;b&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>注意</strong>：</p><ul><li><strong><code>compareAndSet</code>方法内部使用<code>==</code>来比较当前引用和传入的期望引用</strong>。对于<code>Integer</code>类型，这种比较是基于对象的内存地址，而非其数值</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">compareAndSet</span><span class="params">(V   expectedReference,</span></span><br><span class="line"><span class="params">                             V   newReference,</span></span><br><span class="line"><span class="params">                             <span class="type">int</span> expectedStamp,</span></span><br><span class="line"><span class="params">                             <span class="type">int</span> newStamp)</span> &#123;</span><br><span class="line">    Pair&lt;V&gt; current = pair;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">        expectedReference == current.reference &amp;&amp;</span><br><span class="line">        expectedStamp == current.stamp &amp;&amp;</span><br><span class="line">        ((newReference == current.reference &amp;&amp;</span><br><span class="line">          newStamp == current.stamp) ||</span><br><span class="line">         casPair(current, Pair.of(newReference, newStamp)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>自动装箱问题</strong>：<ul><li>在Java中，整数类型如<code>Integer</code>在-128到127之间使用了对象缓存机制。超出这个范围，或者在特定情况下，整数会被重新装箱成新的对象，导致即使数值相同，内存地址也可能不同</li><li>在<code>compareAndSet</code>操作中，如果期望的引用数值是通过字面量或计算得出的新<code>Integer</code>对象，可能会因为对象地址不同而导致比较失败</li><li>所以使用 Integer 作为泛型进行测试时，如果使用的数字大于128了，使用原子引用时就不会进行版本上升</li></ul></li><li>正常业务操作中，我们一般使用的是对象类型作为泛型(如 User 类)，一般情况不会遇到这种情况</li></ul></li></ul><h2 id="20-理解各种锁"><a href="#20-理解各种锁" class="headerlink" title="20. 理解各种锁"></a>20. 理解各种锁</h2><h3 id="20-1-公平锁、非公平锁"><a href="#20-1-公平锁、非公平锁" class="headerlink" title="20.1 公平锁、非公平锁"></a>20.1 公平锁、非公平锁</h3><ul><li><strong>公平锁</strong>：<ul><li>确保获取锁的顺序按照线程请求锁的顺序来进行，即<strong>先到先得</strong></li><li>可以防止线程饥饿，但可能导致整体吞吐量较低，因为每次都需要在多个线程中严格排序</li></ul></li><li><strong>非公平锁</strong>：<ul><li>允许插队，不保证请求锁的顺序，可以<strong>减少线程切换的开销</strong>，提高系统整体的吞吐量</li><li><strong>可能导致线程饥饿</strong>，即某些线程可能长时间获取不到锁</li></ul></li><li><strong>用法：</strong> 在创建可重入锁时，想构造器中传入true</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">fairLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(<span class="literal">true</span>); <span class="comment">// 公平锁</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">unfairLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(); <span class="comment">// 非公平锁，默认为非公平</span></span><br></pre></td></tr></table></figure><ul><li>ReentrantLock 的构造器源码如下：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">()</span> &#123;  <span class="comment">// 公平锁</span></span><br><span class="line">    sync = <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">(<span class="type">boolean</span> fair)</span> &#123;  <span class="comment">// 非公平锁</span></span><br><span class="line">    sync = fair ? <span class="keyword">new</span> <span class="title class_">FairSync</span>() : <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="20-2-可重入锁-递归锁"><a href="#20-2-可重入锁-递归锁" class="headerlink" title="20.2 可重入锁(递归锁)"></a>20.2 可重入锁(递归锁)</h3><ul><li><strong>可重入锁</strong>允许线程进入任何一个它已经拥有的锁同步的代码块<ul><li>synchronized 和 lock 都是可重入锁</li></ul></li><li><code>synchronized</code>关键字提供的锁是内置的Java关键字，并且是<strong>隐式的可重入锁</strong>，不用手工上锁与解锁</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Phone</span> <span class="variable">phone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            phone.sms();</span><br><span class="line">        &#125;,<span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            phone.sms();</span><br><span class="line">        &#125;,<span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Phone</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sms</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;=&gt; sms&quot;</span>);</span><br><span class="line">        call(); <span class="comment">// 再次获取同一把对象锁</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;=&gt; call&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>Lock</code>是<strong>显式的可重入</strong>锁，必须手动地锁定和解锁</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Phone2</span> &#123;</span><br><span class="line">    <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sms</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// lock锁必须配对，否则会死锁</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;=&gt; sms&quot;</span>);</span><br><span class="line">            call(); <span class="comment">// 再次获取同一把锁</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;=&gt; call&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="20-3-自旋锁"><a href="#20-3-自旋锁" class="headerlink" title="20.3 自旋锁"></a>20.3 自旋锁</h3><ul><li><p><strong>自旋锁</strong>是指尝试获取锁的线程不会立即阻塞，而是<strong>采用循环的方式尝试获取锁</strong>，这样可以减少线程上下文切换的消耗，提高效率</p></li><li><p><strong>代码示例</strong>：设计一个自己的锁</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpinLock</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">AtomicBoolean</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicBoolean</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取锁的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (!lock.compareAndSet(<span class="literal">false</span>, <span class="literal">true</span>)) &#123;</span><br><span class="line">            <span class="comment">// 自旋等待直到锁被释放</span></span><br><span class="line">            <span class="comment">// 在这里进行自旋等待意味着不停地循环，直到获取到锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放锁的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.set(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>测试类</strong>：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestSpinLock</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">SpinLock</span> <span class="variable">spinLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SpinLock</span>();  <span class="comment">// 创建自旋锁的实例</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 线程1尝试获取锁，然后睡眠3秒，最后释放锁</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 尝试获取锁&quot;</span>);</span><br><span class="line">            spinLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 获取到锁&quot;</span>);</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                spinLock.unlock();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 释放锁&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 让主线程稍微延迟1秒，确保t1线程先运行</span></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 线程2也尝试获取锁，然后同样睡眠3秒，之后释放锁</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 尝试获取锁&quot;</span>);</span><br><span class="line">            spinLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 获取到锁&quot;</span>);</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                spinLock.unlock();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 释放锁&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>运行过程</strong>：<ul><li><strong>t1线程</strong>首先启动，尝试并成功获取自旋锁。获取锁后，它将持有锁3秒钟，期间其他线程不能获取锁</li><li><strong>t2线程</strong>随后启动，由于t1线程已经持有锁，<strong>t2线程会进入自旋状态</strong>，不断尝试获取锁，直到t1线程释放锁</li><li>当t1线程释放锁后，t2线程立即获取锁，然后也保持3秒后释放</li></ul></li></ul><h3 id="20-4-死锁"><a href="#20-4-死锁" class="headerlink" title="20.4 死锁"></a>20.4 死锁</h3><ul><li><p>死锁是多个线程在执行过程中因争夺资源而造成的一种僵局</p></li><li><p><strong>代码示例</strong>：<strong>背</strong></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadLockDemo</span> &#123;</span><br><span class="line">    <span class="comment">// 创建两个资源</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">resource1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">resource2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (resource1) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 持有资源1，试图获取资源2&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (resource2) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 获取资源2&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;Thread-1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (resource2) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 持有资源2，试图获取资源1&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (resource1) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 获取资源1&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;Thread-2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>检测死锁</strong>：</p><ul><li><strong>jps（Java Virtual Machine Process Status Tool）</strong>：<ul><li>用于查看在系统中运行的Java进程</li><li>命令：<code>jps -l</code>（列出系统中所有Java进程的PID和主类的全名）</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B.assets/image-20240513214925881.png" alt="image-20240513214925881"></p><ul><li><strong>jstack</strong>：<ul><li>用于生成Java虚拟机当前时刻的线程快照（<strong>堆栈跟踪</strong>）</li><li>命令：<code>jstack [pid]</code>（<code>pid</code>是通过<code>jps</code>查到的Java进程ID）</li><li>死锁信息通常出现在输出的最后部分，标识为Deadlock</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B.assets/image-20240513214900923.png" alt="image-20240513214900923"></p></li></ul><blockquote><p>排查问题的方法：日志、堆栈信息</p></blockquote><h3 id="20-5-乐观-悲观锁"><a href="#20-5-乐观-悲观锁" class="headerlink" title="20.5 乐观&#x2F;悲观锁"></a>20.5 乐观&#x2F;悲观锁</h3><ul><li><p>在Java中，乐观锁和悲观锁是用于管理并发操作中数据一致性和完整性的两种策略</p></li><li><p><strong>悲观锁</strong>：假设最坏的情况，即认为数据在被读取的同时，一定会有其他线程来尝试修改这些数据</p><ul><li>因此，<strong>悲观锁在数据被读取时立即对其进行锁定，直到事务完成才释放锁</strong>。这种锁的主要目的是避免数据被其他事务修改</li><li>在Java中，悲观锁可以通过<code>synchronized</code>关键字或<code>Lock</code>接口实现的各种锁（如<code>ReentrantLock</code>）实现</li></ul></li><li><p><strong>乐观锁</strong>：基于数据不会被频繁修改的假设，每次去更新数据时，它都会假设没有其他线程对这些数据进行修改</p><ul><li>乐观锁通常会使用版本号或时间戳来实现</li><li>Java 中使用<code>Atomic</code>类（如<code>AtomicInteger</code>, <code>AtomicReference</code>）提供的原子操作实现乐观锁</li></ul></li><li><p><strong>使用场景比较</strong>：</p><ul><li><p><strong>悲观锁</strong>更适合写操作多的场景，可以避免数据更新的冲突</p></li><li><p><strong>乐观锁</strong>适用于读操作多的场景，减少了锁的开销，可以提高查询性能，但需要处理更新失败的情况</p></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> juc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 集合</title>
      <link href="/2024/05/01/Java%E9%9B%86%E5%90%88/"/>
      <url>/2024/05/01/Java%E9%9B%86%E5%90%88/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-集合"><a href="#Java-集合" class="headerlink" title="Java 集合"></a>Java 集合</h1><blockquote><p>学习视频：<br><a href="https://www.bilibili.com/video/BV1YA411T76k/?spm_id_from=333.999.0.0">【韩顺平讲Java】Java集合专题 -ArrayList HashMap HashSet List Map TreeMap TreeSet等_哔哩哔哩_bilibili</a></p></blockquote><h2 id="1-集合介绍"><a href="#1-集合介绍" class="headerlink" title="1. 集合介绍"></a>1. 集合介绍</h2><ul><li><strong>数组的不足</strong>：<strong>不够灵活</strong><ul><li>长度开始时必须指定，而且一旦指定，不能更改</li><li>保存的必须为同一类型的元素</li><li>使用数组进行增加元素的示意代码比较麻烦</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组扩容示例代码</span></span><br><span class="line">Person[] pers = <span class="keyword">new</span> <span class="title class_">Person</span>[<span class="number">1</span>];</span><br><span class="line">pers[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩容</span></span><br><span class="line">Person[] pers2 = <span class="keyword">new</span> <span class="title class_">Person</span>[pers.length + <span class="number">1</span>]  <span class="comment">// 创建新数组</span></span><br><span class="line"><span class="keyword">for</span>() &#123;&#125;  <span class="comment">// 拷贝 pers 数组的元素到 pers2</span></span><br><span class="line">pers2[pers2.length - <span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">Person</span>();  <span class="comment">// 添加新的对象</span></span><br></pre></td></tr></table></figure><ul><li><strong>集合的好处</strong>：<ul><li>可以<strong>动态保存</strong>任意多个对象，使用比较方便</li><li>提供了一系列方便的操作对象的方法(crud)：add、remove、set、get 等</li><li>使用集合添加，删除新元素代码更加简洁</li></ul></li></ul><h2 id="2-集合的框架体系-背"><a href="#2-集合的框架体系-背" class="headerlink" title="2. 集合的框架体系-背"></a>2. 集合的框架体系-背</h2><ul><li><strong>Collection 接口</strong>继承了 Iterable 接口<ul><li>List Set 接口继承了 Collection 接口</li><li>List 接口常用的实现类有 ArrayList,LinkedList</li><li>Set 接口常用的实现类有 HashSet,TreeSet</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/Java%E9%9B%86%E5%90%88.assets/image-20240429195653117.png" alt="image-20240429195653117"></p><ul><li><strong>Map 接口</strong><ul><li>常见实现类：HashMap、LinkedHashMap、TreeMap</li><li>LinkedHashMap 继承了 HashMap 的同时实现了 Map 接口</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/Java%E9%9B%86%E5%90%88.assets/image-20240420134000294.png" alt="image-20240420134000294"></p><ul><li>集合主要有2组：<ul><li>一组是<strong>单列集合</strong>（集合里面放的是单个对象）<ul><li>Collection 接口有 List 和 Set 这两个主要的接口，他们的实现类都是单列集合</li></ul></li><li>另一组是<strong>双列集合</strong>（存储的往往是键值对形式的）<ul><li>Map 接口的实现子类是双列集合，存放 key 和 value 数据</li></ul></li></ul></li></ul><h2 id="3-Collection"><a href="#3-Collection" class="headerlink" title="3. Collection"></a>3. Collection</h2><h3 id="3-1-Collection-接口实现类的特点"><a href="#3-1-Collection-接口实现类的特点" class="headerlink" title="3.1 Collection 接口实现类的特点"></a>3.1 Collection 接口实现类的特点</h3><ul><li><strong>接口声明</strong>： <code>Collection</code> 是一个泛型接口，继承自 <code>Iterable</code> 接口，允许其实现类的对象能被迭代</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Collection</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">Iterable</span>&lt;E&gt;</span><br></pre></td></tr></table></figure><ul><li>Collection 实现子类可以存放多个元素，每个元素可以是Object</li><li>不同的 Collection 实现具有不同的元素存储特性：<ul><li><strong>允许重复元素</strong>：例如 <code>List</code> 实现类（如 <code>ArrayList</code>, <code>LinkedList</code>）允许插入重复元素。</li><li><strong>不允许重复元素</strong>：<code>Set</code> 实现类（如 <code>HashSet</code>, <code>TreeSet</code>）保证元素唯一性。</li></ul></li><li>集合是否有序取决于具体实现：<ul><li><strong>有序集合</strong>：<code>List</code> 接口的实现类保持元素插入的顺序。</li><li><strong>无序集合</strong>：<code>Set</code> 接口的实现类通常不保持任何特定顺序（<code>LinkedHashSet</code> 除外，它按照插入顺序维护元素）。</li></ul></li><li>Collection 接口没有直接的实现子类，是通过它的子接口 Set 和 List 来实现的</li></ul><h3 id="3-2-Collection-接口常用方法"><a href="#3-2-Collection-接口常用方法" class="headerlink" title="3.2 Collection 接口常用方法"></a>3.2 Collection 接口常用方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Collection 接口常用方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CollectionMethod</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// add: 添加单个元素</span></span><br><span class="line">        list.add(<span class="string">&quot;hhh&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;10&quot;</span>);  <span class="comment">// 自动装箱 相当于 list.add(new Integer(10))</span></span><br><span class="line">        list.add(<span class="literal">true</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;list = &quot;</span> + list);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// remove: 删除指定元素</span></span><br><span class="line">        <span class="comment">// list.remove(0);  // 删除第一个元素</span></span><br><span class="line">        list.remove(<span class="literal">true</span>);  <span class="comment">// 指定删除某个元素</span></span><br><span class="line">        System.out.println(<span class="string">&quot;list = &quot;</span> + list);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// contains: 查找元素是否存在</span></span><br><span class="line">        System.out.println(list.contains(<span class="string">&quot;hhh&quot;</span>));  <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// size: 获取元素个数</span></span><br><span class="line">        System.out.println(list.size());  <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// isEmpty: 判断是否为空</span></span><br><span class="line">        System.out.println(list.isEmpty());  <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// clear: 清空</span></span><br><span class="line">        list.clear();</span><br><span class="line">        System.out.println(<span class="string">&quot;list = &quot;</span> + list);  <span class="comment">// list = []</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// addAll: 添加多个元素</span></span><br><span class="line">        ArrayList&lt;Object&gt; list2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list2.add(<span class="string">&quot;111&quot;</span>);</span><br><span class="line">        list2.add(<span class="string">&quot;222&quot;</span>);</span><br><span class="line">        list2.add(<span class="string">&quot;333&quot;</span>);</span><br><span class="line">        list.addAll(list2);</span><br><span class="line">        System.out.println(<span class="string">&quot;list = &quot;</span> + list);  <span class="comment">// list = [111, 222, 333]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// containsAll: 查找多个元素是否都存在</span></span><br><span class="line">        System.out.println(list.containsAll(list2));  <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// removeAll: 删除多个元素</span></span><br><span class="line">        list.add(<span class="string">&quot;444&quot;</span>);</span><br><span class="line">        list.removeAll(list2);</span><br><span class="line">        System.out.println(<span class="string">&quot;list = &quot;</span> + list);  <span class="comment">// list = [444]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/Java%E9%9B%86%E5%90%88.assets/image-20240420141355143.png" alt="image-20240420141355143"></p><h3 id="3-3-Collection-接口遍历元素"><a href="#3-3-Collection-接口遍历元素" class="headerlink" title="3.3 Collection 接口遍历元素"></a>3.3 Collection 接口遍历元素</h3><h4 id="遍历元素方式1—使用-Iterator-迭代器"><a href="#遍历元素方式1—使用-Iterator-迭代器" class="headerlink" title="遍历元素方式1—使用 Iterator 迭代器"></a>遍历元素方式1—使用 Iterator 迭代器</h4><ul><li><p>迭代器是一个对象，这个对象实现了 <code>Iterator</code> 接口，主要用于遍历 Collection 集合中的元素，该接口包含几个方法：</p><ul><li><code>hasNext()</code>: 检查集合中是否还有元素可以遍历。如果有，返回 <code>true</code>；如果没有，返回 <code>false</code>。</li><li><code>next()</code>: 迭代器将其内部游标向前移动到下一个元素的位置，同时返回游标所到达位置的元素。</li></ul><blockquote><p>在调用 next() 方法之前必须要调用 hasNext() 进行检测，若不调用且下一条记录无效，直接调用 next() 会抛出 NoSuchElementException 异常</p></blockquote><ul><li><code>remove()</code>: 删除最近通过 <code>next()</code> 方法返回的元素。这个方法是可选的，集合本身可以不支持这个操作。</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/Java%E9%9B%86%E5%90%88.assets/image-20240420145421113.png" alt="image-20240420145421113"></p><ul><li>使用迭代器可以<strong>通过一个统一的接口遍历不同类型的集合（如 <code>ArrayList</code>, <code>HashSet</code> 等），而不必关心它们内部是如何组织数据的</strong></li><li>所有<strong>实现了Collection 接口的集合类都有一个 iterator() 方法</strong>，用于返回一个实现了 Iterator 接口的对象，即可以返回一个迭代器</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/Java%E9%9B%86%E5%90%88.assets/image-20240420145934243.png" alt="image-20240420145934243"></p><ul><li><p><strong>Iterator 仅用于遍历集合，Iterator 本身不存放对象</strong></p></li><li><p><strong>代码示例</strong>：快捷键 <code>itit</code></p><ul><li>（提示所有快捷键的快捷键：<code>ctrl + j</code>）</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CollectionIterator</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Collection</span> <span class="variable">col</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line"></span><br><span class="line">        col.add(<span class="keyword">new</span> <span class="title class_">Book</span>(<span class="string">&quot;11&quot;</span>, <span class="string">&quot;1&quot;</span>, <span class="number">1.1</span>));</span><br><span class="line">        col.add(<span class="keyword">new</span> <span class="title class_">Book</span>(<span class="string">&quot;22&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="number">2.2</span>));</span><br><span class="line">        col.add(<span class="keyword">new</span> <span class="title class_">Book</span>(<span class="string">&quot;33&quot;</span>, <span class="string">&quot;3&quot;</span>, <span class="number">3.3</span>));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;col = &quot;</span> + col);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历集合</span></span><br><span class="line">        <span class="comment">// 1. 先得到 col 对应的迭代器</span></span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> col.iterator();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 使用 while 循环遍历, 快捷键 itit</span></span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;  <span class="comment">// 判断是否还有数据</span></span><br><span class="line">            <span class="comment">// 返回下一个元素, 类型为 Object</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">            System.out.println(<span class="string">&quot;obj = &quot;</span> + obj);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3. 当退出 while 循环后, 这时 iterator 迭代器指向最后的元素</span></span><br><span class="line">        <span class="comment">// 4. 若希望再次遍历, 需要重置迭代器</span></span><br><span class="line">        iterator = col.iterator();</span><br><span class="line">        System.out.println(<span class="string">&quot;======第二次遍历&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;  </span><br><span class="line">            <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">            System.out.println(<span class="string">&quot;obj = &quot;</span> + obj);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="遍历元素方式2—使用-for-循环增强"><a href="#遍历元素方式2—使用-for-循环增强" class="headerlink" title="遍历元素方式2—使用 for 循环增强"></a>遍历元素方式2—使用 for 循环增强</h4><ul><li>增强 for循环，可以代替 iterator 迭代器，特点：<strong>增强 for 就是简化版的 iterator</strong>，本质一样。只能用于<strong>遍历集合或数组</strong></li><li><strong>基本语法</strong>：</li><li>“元素类型”是集合或数组中包含的元素的数据类型</li><li>“元素变量”是在循环体内部用于访问当前遍历元素的变量名</li><li>“集合名或数组名”是要遍历的集合或数组的变量名</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (元素类型 元素变量 : 集合对象或数组) &#123;</span><br><span class="line">    <span class="comment">// 访问元素变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>代码示例</strong>：快捷键 <code>I</code> 或者 <code>集合对象.for</code><ul><li>补充：传统 for 循环的快捷键：<code>fori</code></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用增强 for 遍历集合</span></span><br><span class="line"><span class="keyword">for</span> (Object book : col) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;book = &quot;</span> + book);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 增强 for 也可以直接在数组使用</span></span><br><span class="line"><span class="type">int</span>[] nums = &#123;<span class="number">1</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">90</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i : nums) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;i = &quot;</span> + i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>使用注意事项</strong>：</p><ul><li><p><strong>只读遍历</strong>：使用增强 <code>for</code> 循环时，不能修改正在遍历的集合的结构，例如添加或删除元素，这可能会导致 <code>ConcurrentModificationException</code> 异常。如果需要在遍历过程中修改集合，应使用显式的迭代器并调用其 <code>remove()</code> 方法</p></li><li><p><strong>遍历对象类型</strong>：增强 <code>for</code> 循环可以遍历任何实现了 <code>Iterable</code> 接口的集合类以及所有类型的数组</p></li><li><p><strong>局限性</strong>：尽管增强 <code>for</code> 循环语法简单，但它<strong>不适合在需要使用元素索引或需要从集合中间开始遍历的场景</strong>。在这种情况下，使用传统的 <code>for</code> 循环会更合适</p></li></ul></li></ul><h3 id="3-4-练习题"><a href="#3-4-练习题" class="headerlink" title="3.4 练习题"></a>3.4 练习题</h3><p>编写程序 <code>CollectionExercise</code>：</p><ul><li>创建3个Dog{name,age}对象,放入到ArrayList中，赋给List使用</li><li>用迭代器和增强for循环两种方式来遍历</li><li>重写Dog的toString方法，输出name和age</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CollectionEx</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Dog&gt; dogLists = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  <span class="comment">// 接口多态的传递</span></span><br><span class="line"></span><br><span class="line">        dogLists.add(<span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;aa&quot;</span>, <span class="string">&quot;1&quot;</span>));</span><br><span class="line">        dogLists.add(<span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;bb&quot;</span>, <span class="string">&quot;2&quot;</span>));</span><br><span class="line">        dogLists.add(<span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;cc&quot;</span>, <span class="string">&quot;3&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 迭代器遍历</span></span><br><span class="line">        Iterator&lt;Dog&gt; iterator = dogLists.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            <span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">            System.out.println(<span class="string">&quot;dog = &quot;</span> + dog);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;==============&quot;</span>);</span><br><span class="line">        <span class="comment">// 增强 for 遍历</span></span><br><span class="line">        <span class="keyword">for</span> (Dog dog : dogLists) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;dog = &quot;</span> + dog);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-List"><a href="#4-List" class="headerlink" title="4. List"></a>4. List</h2><h3 id="4-1-List-接口基本介绍"><a href="#4-1-List-接口基本介绍" class="headerlink" title="4.1 List 接口基本介绍"></a>4.1 List 接口基本介绍</h3><p>List 接口是 Collection 接口的子接口，特点如下：</p><ul><li><strong>有序性</strong>：List 集合类中元素<strong>有序</strong>(即添加顺序和取出顺序一致)</li><li><strong>元素重复</strong>：与 Set 接口不同，List 允许重复的元素，即同一个值可以出现多次</li><li><strong>索引访问</strong>：List 集合支持索引，每个元素都有其对应的顺序索引，开始于0</li><li><strong>整数型序号</strong>：List 容器中的元素都对应一个整数型的序号，记录其在容器中的位置，可以根据序号存取容器中的元素</li><li>List 接口的常用实现类有：<strong>ArrayList、LinkedList 和 Vector</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">List_</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. List集合类中元素有序(即添加顺序和取出顺序一致)、且可重复</span></span><br><span class="line">        <span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        list.add(<span class="string">&quot;jack&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;tom&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;list=&quot;</span> + list);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. List集合中的每个元素都有其对应的顺序索引, 即支持索引</span></span><br><span class="line">        <span class="comment">// 索引是从0开始的</span></span><br><span class="line">        System.out.println(list.get(<span class="number">1</span>));  <span class="comment">// tom</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-List-接口常用方法"><a href="#4-2-List-接口常用方法" class="headerlink" title="4.2 List 接口常用方法"></a>4.2 List 接口常用方法</h3><ul><li><code>void add(int index, Object ele)</code>：在index位置插入ele元素，没有index，默认在最后插入</li><li><code>boolean addAll(int index, Collection eles)</code>：从index位置开始将eles中的所有元素添加进来</li><li><code>Object get(int index)</code>：获取指定index位置的元素</li><li><code>int indexOf(Object obj)</code>：返回obj在集合中首次出现的位置</li><li><code>int lastIndexOf(Object obj)</code>：返回obj在当前集合中末次出现的位置</li><li><code>Object remove(int index)</code>：移除指定index位置的元素，并返回此元素</li><li><code>Object set(int index, Object ele)</code>：设置指定index位置的元素为ele , 相当于是替换</li><li><code>List subList(int fromIndex, int toIndex)</code>：返回从fromIndex到toIndex位置的子集合，注意返回的子集合 fromIndex &lt;&#x3D; subList &lt; toIndex</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListMethod</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        list.add(<span class="string">&quot;111&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;222&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// void add(int index, Object ele): 在index位置插入ele元素</span></span><br><span class="line">        <span class="comment">// 在 index = 1 的位置插入一个对象</span></span><br><span class="line">        list.add(<span class="number">1</span>, <span class="string">&quot;333&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;list = &quot;</span> + list);  <span class="comment">// list = [111, 333, 222]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// boolean addAll(int index, Collection eles): 从index位置开始将eles中的所有元素添加进来</span></span><br><span class="line">        <span class="type">List</span> <span class="variable">list2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        list2.add(<span class="string">&quot;44&quot;</span>);</span><br><span class="line">        list2.add(<span class="string">&quot;55&quot;</span>);</span><br><span class="line">        list.addAll(<span class="number">1</span>, list2);</span><br><span class="line">        System.out.println(<span class="string">&quot;list = &quot;</span> + list);  <span class="comment">// list=[111, 44, 55, 333, 222]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Object get(int index): 获取指定index位置的元素</span></span><br><span class="line">        System.out.println(list.get(<span class="number">1</span>));  <span class="comment">// 44</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// int indexOf(Object obj): 返回obj在集合中首次出现的位置</span></span><br><span class="line">        System.out.println(list.indexOf(<span class="string">&quot;44&quot;</span>));  <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// int lastIndexOf(Object obj): 返回obj在当前集合中末次出现的位置</span></span><br><span class="line">        list.add(<span class="string">&quot;333&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;list = &quot;</span> + list);  <span class="comment">// list=[111, 44, 55, 333, 222, 333]</span></span><br><span class="line">        System.out.println(list.lastIndexOf(<span class="string">&quot;333&quot;</span>));  <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Object remove(int index): 移除指定index位置的元素，并返回此元素</span></span><br><span class="line">        list.remove(<span class="number">0</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;list = &quot;</span> + list);  <span class="comment">// list = [44, 55, 333, 222, 333]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Object set(int index, Object ele): 设置指定index位置的元素为ele, 相当于是替换</span></span><br><span class="line">        list.set(<span class="number">1</span>, <span class="string">&quot;66&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;list = &quot;</span> + list);  <span class="comment">// list = [44, 66, 333, 222, 333]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// List subList(int fromIndex, int toIndex): 返回从fromIndex到toIndex位置的子集合</span></span><br><span class="line">        <span class="comment">// 注意返回的子集合 fromIndex &lt;= subList &lt; toIndex</span></span><br><span class="line">        <span class="type">List</span> <span class="variable">returnList</span> <span class="operator">=</span> list.subList(<span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;returnList = &quot;</span> + returnList);  <span class="comment">// returnList = [44, 66]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-List-的三种遍历方式"><a href="#4-3-List-的三种遍历方式" class="headerlink" title="4.3 List 的三种遍历方式"></a>4.3 List 的三种遍历方式</h3><blockquote><p> ArrayList, LinkedList,Vector 三种遍历使用的方式一致</p></blockquote><ul><li>方式一：使用<strong>迭代器</strong></li><li>方式二：<strong>增强for循环</strong></li><li>方式三：使用<strong>普通for循环</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// List 接口主要的实现子类</span></span><br><span class="line">        <span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line"><span class="comment">//        List list = new Vector();</span></span><br><span class="line"><span class="comment">//        List list = new LinkedList();</span></span><br><span class="line"></span><br><span class="line">        list.add(<span class="string">&quot;11&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;22&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;33&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;44&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历</span></span><br><span class="line">        <span class="comment">// 1. 迭代器</span></span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> list.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">            System.out.println(obj);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;=====增强for=====&quot;</span>);</span><br><span class="line">        <span class="comment">// 2. 增强 for</span></span><br><span class="line">        <span class="keyword">for</span> (Object o : list) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;o = &quot;</span> + o);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;=====普通for====&quot;</span>);</span><br><span class="line">        <span class="comment">// 3. 使用普通 for</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;对象 = &quot;</span> + list.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>练习</strong>：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    List&lt;Book&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//        List&lt;Book&gt; list = new LinkedList&lt;&gt;();</span></span><br><span class="line">    <span class="comment">//        List&lt;Book&gt; list = new Vector&lt;&gt;();</span></span><br><span class="line"></span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="title class_">Book</span>(<span class="string">&quot;11&quot;</span>, <span class="number">5.1</span>, <span class="string">&quot;aa&quot;</span>));</span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="title class_">Book</span>(<span class="string">&quot;22&quot;</span>, <span class="number">1.1</span>, <span class="string">&quot;bb&quot;</span>));</span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="title class_">Book</span>(<span class="string">&quot;33&quot;</span>, <span class="number">2.1</span>, <span class="string">&quot;cc&quot;</span>));</span><br><span class="line"></span><br><span class="line">    BubbleSort(list);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Book book : list) &#123;</span><br><span class="line">        System.out.println(book);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 冒泡排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">BubbleSort</span><span class="params">(List&lt;Book&gt; list)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; list.size() - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (list.get(j).getPrice() &gt; list.get(j + <span class="number">1</span>).getPrice()) &#123;</span><br><span class="line">                <span class="type">Book</span> <span class="variable">temp</span> <span class="operator">=</span> list.get(j);</span><br><span class="line">                list.set(j, list.get(j + <span class="number">1</span>));</span><br><span class="line">                list.set(j + <span class="number">1</span>, temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-4-List-接口实现类-ArrayList"><a href="#4-4-List-接口实现类-ArrayList" class="headerlink" title="4.4 List 接口实现类-ArrayList"></a>4.4 List 接口实现类-ArrayList</h3><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li><strong>空元素支持</strong>：<code>ArrayList</code> 允许包含任意数量的 <code>null</code> 元素。这使得它在某些使用场景中非常灵活，例如在数据集中可能存在的缺失数据可以用 <code>null</code> 表示</li><li><strong>内部数据存储</strong>：<code>ArrayList</code> 是基于<strong>动态数组</strong>实现的，这意味着它的元素存放在数组中。这也解释了为什么 <code>ArrayList</code> 可以提供快速的随机访问能力</li><li><strong>与 <code>Vector</code> 的比较</strong>：<ul><li><strong>相似性</strong>：<code>ArrayList</code> 和 <code>Vector</code> 都是基于数组的实现，提供快速的随机访问和有序的元素存储</li><li><strong>线程安全</strong>：<code>ArrayList</code> 是非同步的，因此它是线程不安全的，而 <code>Vector</code> 是同步的，因此是线程安全的。这使得 <code>ArrayList</code> 在单线程环境下性能更优，但在多线程环境中可能需要外部同步措施</li></ul></li><li><strong>对于需要线程安全的 <code>ArrayList</code> 替代方案</strong>：<ul><li>使用 Vector 容器</li><li>使用 Collections 的静态方法 <code>synchronizedList(List&lt; T&gt; list)</code></li><li>采用 CopyOnWriteArrayList 容器</li></ul></li></ul><blockquote><p><a href="https://blog.csdn.net/weixin_45668482/article/details/117396603">三种线程安全的List-CSDN博客</a></p><ul><li><strong>读多写少</strong>的情况下，推荐使用 <code>CopyOnWriteArrayList</code> 方式</li><li><strong>读少写多</strong>的情况下，推荐使用<code>Collections.synchronizedList()</code> 的方式</li></ul></blockquote><h4 id="底层结构和源码分析"><a href="#底层结构和源码分析" class="headerlink" title="底层结构和源码分析"></a>底层结构和源码分析</h4><ul><li>ArrayList 中维护了一个 Object 类型的数组 elementData</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// transient 表示瞬间，短暂的，表示该属性不能被序列化</span></span><br><span class="line"><span class="comment">// 序列化是将对象的状态信息转换为可以存储或传输的形式的过程</span></span><br><span class="line"><span class="keyword">transient</span> Object[] elementData;</span><br></pre></td></tr></table></figure><blockquote><p>在 Java 中，序列化通常指的是将对象转换为字节流，以便可以将其写入磁盘、通过网络等发送。反序列化是序列化的逆过程，它从字节流中重构对象。</p><p>序列化的目的是持久化存储&#x2F;网络通信等等，使 <code>elementData</code> 成为 <code>transient</code> 的原因：</p><ul><li><strong>空间效率</strong>：通常 <code>elementData</code> 的大小（容量）比实际存储的元素数量要大，如果 <code>elementData</code> 被序列化，那么即使数组中有大量未使用的空间，这些空间也会被序列化，导致不必要的存储和传输开销。</li><li><strong>时间效率</strong>：序列化和反序列化一个包含许多 <code>null</code> 值的大数组会显著降低性能，尤其是在网络传输等场景中。</li></ul></blockquote><ul><li><p>当创建 ArrayList 对象时，</p><ul><li>如果使用的是<strong>无参构造器</strong>，则初始 elementData 容量为0，<strong>第1次添加，则扩容 elementData 为 10</strong>，如果需要再次扩容，则扩容 elementData 为1.5倍</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);  <span class="comment">// 10 + 10/2 = 15 (即 10 的 1.5 倍)</span></span><br><span class="line"><span class="comment">// 0 =&gt; 10 =&gt; 15 =&gt; 22 =&gt; 33 =&gt; ...</span></span><br></pre></td></tr></table></figure><ul><li>如果使用的是<strong>指定大小的构造器</strong>，则<strong>初始 elementData 容量为指定大小</strong>，如果<strong>需要扩容，则直接扩容 elementData 为 1.5 倍</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设初始指定为 8, 则:</span></span><br><span class="line"><span class="comment">// 8 =&gt; 12(8+8/2) =&gt; 18 =&gt; 27 =&gt; ...</span></span><br></pre></td></tr></table></figure></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/Java%E9%9B%86%E5%90%88.assets/image-20240421090400667.png" alt="image-20240421090400667"></p><ul><li><strong>注意</strong>：Idea 默认情况下，Debug 显示的数据是简化后的(比如数组不会显示 null 的元素)，如果希望看到完整的数据，需要做如下设置：</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/Java%E9%9B%86%E5%90%88.assets/image-20240421085925779.png" alt="image-20240421085925779"></p><ul><li><strong>加断点分析源码</strong>：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 使用无参构造器创建 ArrayList 对象</span></span><br><span class="line">    <span class="type">ArrayList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    <span class="comment">// ArrayList list = new ArrayList(8);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 for 给 list 集合添加 1-10 数据</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">        list.add(i);  <span class="comment">// 触发 Integer 类的 valueOf(int i) 方法，自动装箱</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 for 给 list 集合添加 11-15 数据</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">11</span>; i &lt;= <span class="number">15</span>; i++) &#123;</span><br><span class="line">        list.add(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    list.add(<span class="number">100</span>);</span><br><span class="line">    list.add(<span class="number">200</span>);</span><br><span class="line">    list.add(<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>使用无参构造器，创建和使用 ArrayList</strong>：</p><ul><li>创建静态空数组 <code>elementData</code>，<code>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code> 是一个静态的空数组实例</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>添加元素</strong><ul><li>调用 <code>add(E e)</code> 来添加一个元素</li><li><code>add</code> 方法首先调用 <code>ensureCapacityInternal(size + 1)</code> 来确保容量</li><li><code>ensureCapacityInternal</code> 调用 <code>calculateCapacity</code> 来确定所需的容量，然后调用 <code>ensureExplicitCapacity</code></li><li><code>ensureExplicitCapacity</code> 检查当前容量是否足够，如果不够，调用 <code>grow</code> 来扩容</li><li>添加元素到数组，增加 <code>size</code></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="comment">// 确保 ArrayList 有足够的空间来存储新添加的元素</span></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  </span><br><span class="line">    <span class="comment">// 将新元素 e 存储在 elementData 数组的 size 索引位置, 赋值完成后增加 size 的值</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 确保内部数组 elementData 有足够的容量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityInternal</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">// 调用 calculateCapacity 来确定所需的容量</span></span><br><span class="line">    <span class="comment">// 然后调用 ensureExplicitCapacity</span></span><br><span class="line">    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算并返回 ArrayList 所需的最小容量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">calculateCapacity</span><span class="params">(Object[] elementData, <span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">// 检查是否是默认空数组，如果是，意味着这是首次添加元素，此将容量设为 DEFAULT_CAPACITY = 10 和 minCapacity 中的较大值，以避免过早的数组扩容</span></span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);  <span class="comment">// max(10, 1)，返回 10</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果不是空数组，直接返回传入的 minCapacity</span></span><br><span class="line">    <span class="keyword">return</span> minCapacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ensureExplicitCapacity 检查当前容量是否足够，如果不够，调用 grow 来扩容</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureExplicitCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    modCount++;  <span class="comment">// 记录当前集合被修改的次数，防止多线程操作出现异常</span></span><br><span class="line">    <span class="comment">// 如果所需最小容量大于当前数组长度，则需要扩容</span></span><br><span class="line">    <span class="comment">// 10 - 0 &gt; 0 不够的</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩容</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;  <span class="comment">// 10</span></span><br><span class="line">    <span class="comment">// 获取旧容量</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;  <span class="comment">// 0</span></span><br><span class="line">    <span class="comment">// 新容量为旧容量的1.5倍</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);  <span class="comment">// 首次 0 + 0/2 = 0</span></span><br><span class="line">    <span class="comment">// 如果1.5倍仍不满足需求，则直接使用所需最小容量</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)  <span class="comment">// 0-10&lt;0 第一次由于初始容量为0，没法按照 1.5 倍机制扩容，所以新容量就是 newCapacity = 10</span></span><br><span class="line">        newCapacity = minCapacity;  </span><br><span class="line">    <span class="comment">// 如果新容量超出了最大数组大小，则调用 hugeCapacity 来处理</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// 将 elementData 数组扩展到 newCapacity 指定的大小，并保留所有现有元素，新扩展的部分（如果有）将初始化为 null</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理在数组需要扩容到非常大的尺寸时的特殊情况，，保证 ArrayList 不会因为数组大小请求不当而导致程序崩溃或安全问题</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">hugeCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果 minCapacity 小于 0，这通常是由于整数溢出导致的，抛出 OutOfMemoryError，表示内存溢出错误</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">OutOfMemoryError</span>();</span><br><span class="line">    <span class="comment">// Java 的数组最大长度是 MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8，因为某些 JVM 实现通过使用数组的一部分作为数组头部</span></span><br><span class="line">    <span class="comment">// 如果 minCapacity 要求的容量超过了 MAX_ARRAY_SIZE 但未溢出，方法返回 MAX_ARRAY_SIZE，即数组能达到的最大安全容量</span></span><br><span class="line">    <span class="comment">// 如果 minCapacity 请求超过了 Integer.MAX_VALUE，则方法返回 Integer.MAX_VALUE</span></span><br><span class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">        Integer.MAX_VALUE :</span><br><span class="line">    MAX_ARRAY_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/Java%E9%9B%86%E5%90%88.assets/image-20240421105512124.png" alt="image-20240421105512124"></p><ul><li><p><strong>使用指定大小的构造器，创建和使用 ArrayList</strong>：</p><ul><li><strong>创建一个指定大小的 elementData 数组</strong>：传入的初始化容量 (<code>initialCapacity</code>) 大于 0，构造函数会创建一个新的 <code>Object</code> 数组，其长度等于指定的 <code>initialCapacity</code></li><li>第一次扩容就按照elementData 的 1.5 倍扩容，其他步骤同无参构造器</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.elementData = <span class="keyword">new</span> <span class="title class_">Object</span>[initialCapacity];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果传入的初始化容量为 0，则构造函数不分配任何数据存储空间，而是将 elementData 初始化为 EMPTY_ELEMENTDATA（一个预定义的空数组）</span></span><br><span class="line">        <span class="built_in">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果传入的初始化容量小于 0，则构造函数抛出 IllegalArgumentException</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal Capacity: &quot;</span> +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="4-5-List-接口实现类-Vector"><a href="#4-5-List-接口实现类-Vector" class="headerlink" title="4.5 List 接口实现类-Vector"></a>4.5 List 接口实现类-Vector</h3><h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><ul><li>Vector 类的定义说明：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Vector</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">AbstractList</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Vector <strong>底层也是一个对象数组</strong>，</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object[] elementData</span><br></pre></td></tr></table></figure><ul><li>Vector 是线程同步的，即线程安全，Vector 类的操作方法基本都带有 <strong>synchronized</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    ensureCapacityHelper(elementCount + <span class="number">1</span>);</span><br><span class="line">    elementData[elementCount++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>开发中一般用 JUC 包中绝对线程安全的集合</strong>，Vector 只是相对安全，add、remove 这些方法不是原子操作，所以还是别用 Vector</li></ul><h4 id="Vector-VS-ArrayList"><a href="#Vector-VS-ArrayList" class="headerlink" title="Vector VS. ArrayList"></a>Vector VS. ArrayList</h4><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/Java%E9%9B%86%E5%90%88.assets/image-20240421151636473.png" alt="image-20240421151636473"></p><ul><li><code>Vector()</code>无参构造器内部调用了另一个构造器<code>Vector(int initialCapacity)</code>，并且传递了一个默认的初始容量值<code>10</code><ul><li>如果初始容量不是负数，这个构造器将创建一个新的对象数组<code>elementData</code>，数组的长度为<code>initialCapacity</code></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Vector</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 若是有参构造器，就直接进入这个函数里，其他区别不大</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Vector</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(initialCapacity, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Vector</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">int</span> capacityIncrement)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="built_in">this</span>.elementData = <span class="keyword">new</span> <span class="title class_">Object</span>[initialCapacity];</span><br><span class="line">    <span class="built_in">this</span>.capacityIncrement = capacityIncrement;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>ArrayList</code>使用的是一种称为<strong>延迟初始化</strong>的策略（Lazy Initialization）。这意味着除非真正需要（即首次添加元素），否则不会创建存储元素的内部数组</p><p>在很多使用场景中，<code>ArrayList</code>可能仅仅是被实例化但并未使用，或者只添加了少量元素。使用延迟初始化可以避免在这些情况下分配不必要的内存，从而更高效地使用资源</p></blockquote><h4 id="Vector-的底层扩容结构"><a href="#Vector-的底层扩容结构" class="headerlink" title="Vector 的底层扩容结构"></a>Vector 的底层扩容结构</h4><ul><li>**调用 <code>add(E e)</code>**：开始添加元素。</li><li>**调用 <code>ensureCapacityHelper(int minCapacity)</code>**：确保有足够的容量。</li><li><strong>调用 <code>grow(int minCapacity)</code>（如果需要）</strong>：进行实际的数组扩容。</li><li>**完成 <code>add(E e)</code>**：元素添加到数组，方法结束。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加一个元素 e 到 Vector 的末尾</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    ensureCapacityHelper(elementCount + <span class="number">1</span>);</span><br><span class="line">    elementData[elementCount++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查并确保有足够的容量来存储至少 minCapacity 个元素</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityHelper</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果所需的最小容量 minCapacity 大于当前数组 elementData 的长度，则调用 grow 方法来扩容数组</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩容</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取旧容量</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;</span><br><span class="line">    <span class="comment">// 如果 capacityIncrement 大于 0，则新容量为 oldCapacity + capacityIncrement；否则，新容量为 oldCapacity * 2（默认行为是翻倍扩容）</span></span><br><span class="line">    <span class="comment">// capacityIncrement 是构造时指定的扩容大小(如果有)</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + ((capacityIncrement &gt; <span class="number">0</span>) ?</span><br><span class="line">                                     capacityIncrement : oldCapacity);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-6-List-接口实现类-LinkedList"><a href="#4-6-List-接口实现类-LinkedList" class="headerlink" title="4.6 List 接口实现类-LinkedList"></a>4.6 List 接口实现类-LinkedList</h3><h4 id="底层结构"><a href="#底层结构" class="headerlink" title="底层结构"></a>底层结构</h4><ul><li>LinkedList 实现了<strong>双向链表</strong>和<strong>双端队列</strong>特点<ul><li>双向链表的结构 <code>LinkedList</code> 不仅支持普通的列表操作（如添加、删除、查找等），还支持双端队列的操作</li><li>双端队列（deque，全称“double-ended queue”）是一种允许从两端添加和删除元素的队列，意味着 <code>LinkedList</code> 可以作为栈（后进先出）和队列（先进先出）使用</li></ul></li><li><strong>可以包含任意元素</strong>：可以添加任意元素(元素可以重复)，包括 null</li><li><strong>线程不安全</strong>：没有实现同步</li></ul><h4 id="操作机制"><a href="#操作机制" class="headerlink" title="操作机制"></a>操作机制</h4><ul><li><strong>双向链表结构</strong>：LinkedList 底层维护了一个双向链表，允许向前或向后遍历</li><li><strong>首尾节点引用</strong>：LinkedList 中维护了<strong>两个属性 first 和 last 分别指向首节点和尾节点</strong>，是管理链表添加或删除元素时的关键</li><li><strong>节点结构</strong>：每个节点(Node 对象)里又维护了 prev,next,item 三个属性，其中通过 prev 指向前一个，通过 next 指向后一个节点 ，最终实现双向链表</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/Java%E9%9B%86%E5%90%88.assets/image-20240421162220695.png" alt="image-20240421162220695"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;E&gt; &#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="built_in">this</span>.item = element;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">        <span class="built_in">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>添加和删除元素</strong>：LinkedList 的元素的添加和删除，不是通过数组完成的，相对来说效率较高</li></ul><h4 id="LinkedList-VS-ArrayList"><a href="#LinkedList-VS-ArrayList" class="headerlink" title="LinkedList VS. ArrayList"></a>LinkedList VS. ArrayList</h4><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/Java%E9%9B%86%E5%90%88.assets/image-20240421161629995.png" alt="image-20240421161629995"></p><p>如何选择 ArrayList和ListedList：</p><ul><li>如果改查的操作多，选择ArrayList</li><li>如果增删的操作多，选择ListedList</li><li>一般在程序中，80-90% 都是查询，大部分情况下会选择ArrayList</li><li>在项目中，会<strong>根据业务灵活选择</strong>，可能一个模块用ArrayList，另一个用ListedList</li></ul><h4 id="LinkedList-底层-crud-方法-debug-分析"><a href="#LinkedList-底层-crud-方法-debug-分析" class="headerlink" title="LinkedList 底层 crud 方法 debug 分析"></a>LinkedList 底层 crud 方法 debug 分析</h4><ul><li><code>LinkedList</code> 的无参构造器创建了一个空的 <code>LinkedList</code>，因为元素是通过节点 (<code>Node</code>) 动态连接的。以下是在这个构造器中隐式初始化的成员：<ul><li>**<code>size</code>**：追踪 <code>LinkedList</code> 中元素的数量，初始值为 <code>0</code></li><li>**<code>first</code>**：指向链表中的第一个节点，初始值为 <code>null</code></li><li>**<code>last</code>**：指向链表中的最后一个节点，初始值为 <code>null</code></li></ul></li></ul><blockquote><p>这些属性是 <code>transient</code> 的，这意味着它们不是由序列化机制自动保存和恢复的，这主要是出于<strong>链表元素的序列化需要特殊处理的考虑</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; first;</span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; last;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedList</span><span class="params">()</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>实现双向链表添加元素的核心代码</strong>：<ul><li><strong>获取当前尾节点</strong>：将当前的尾节点引用存储在局部变量 <code>l</code> 中。这是链表中最后一个节点，如果链表为空，则 <code>l</code> 为 <code>null</code></li><li><strong>创建新节点</strong>：创建一个新的节点 <code>newNode</code>，其数据域为 <code>e</code>，<code>prev</code> 指针指向当前的尾节点 <code>l</code>（如果存在），<code>next</code> 指针为 <code>null</code>（因为它将成为新的尾节点）</li><li><strong>更新尾节点引用</strong>：将 <code>last</code> 引用更新为新创建的节点 <code>newNode</code>，这样 <code>newNode</code> 现在正式成为链表的尾节点</li><li><strong>更新头节点引用（如果需要）</strong>：如果 <code>l</code> 为 <code>null</code>，意味着链表之前是空的（没有节点），因此新节点也是链表的第一个节点。故将 <code>first</code> 引用指向 <code>newNode</code></li><li><strong>链接前一个尾节点到新节点</strong>：如果链表不为空（即 <code>l</code> 不是 <code>null</code>），将原来尾节点的 <code>next</code> 指针指向新节点 <code>newNode</code></li><li><strong>增加链表大小</strong></li><li><strong>更新修改计数</strong>：增加 <code>modCount</code>，这是用于迭代器的快速失败机制（fail-fast behavior），即在迭代过程中如果检测到结构性修改，会抛出 <code>ConcurrentModificationException</code></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 向 LinkedList 的末尾添加一个新元素 e</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">linkLast</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取当前尾节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="comment">// 创建新节点, 其数据域为 e，prev 指针指向当前的尾节点 l（如果存在），next 指针为 null（因为它将成为新的尾节点）</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(l, e, <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">// 更新尾节点引用, 将 last 引用更新为新创建的节点 newNode</span></span><br><span class="line">    last = newNode;</span><br><span class="line">    <span class="comment">// 如果 l 为 null，意味着链表之前是空的（没有节点），因此新节点也是链表的第一个节点, 故更新头节点引用</span></span><br><span class="line">    <span class="keyword">if</span> (l == <span class="literal">null</span>)</span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span>  <span class="comment">// 链接前一个尾节点到新节点</span></span><br><span class="line">        l.next = newNode;</span><br><span class="line">    size++;  <span class="comment">// 增加链表大小</span></span><br><span class="line">    modCount++;  <span class="comment">// 支持快速失败行为，确保集合在结构上的修改能够即时被迭代器感知，从而在发生并发修改时快速响应，抛出异常，避免迭代器行为不确定</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/Java%E9%9B%86%E5%90%88.assets/image-20240421193320578.png" alt="image-20240421193320578"></p><ul><li><strong>实现双向链表删除链表的第一个节点的核心代码</strong>：<ul><li><strong>获取和清除数据</strong>：<ul><li>存储第一个节点的值到局部变量 <code>element</code>。</li><li>将节点的 <code>item</code> 和 <code>next</code> 设置为 <code>null</code>，帮助垃圾收集器进行回收。</li></ul></li><li><strong>更新头部链接</strong>：<ul><li>将 <code>first</code> 更新为 <code>next</code>，如果 <code>next</code> 为 <code>null</code>（即原链表只有一个节点），则同时将 <code>last</code> 设置为 <code>null</code>。</li><li>如果 <code>next</code> 不是 <code>null</code>，更新 <code>next.prev</code> 为 <code>null</code>，断开它与原首节点的链接。</li></ul></li><li><strong>维护链表状态</strong>：<ul><li>减小 <code>size</code>。</li><li>增加 <code>modCount</code>，支持迭代器的快速失败行为。</li></ul></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> removeFirst();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">removeFirst</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 获取首节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="literal">null</span>)  <span class="comment">// 若是空链表则抛异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">    <span class="keyword">return</span> unlinkFirst(f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除链表的第一个节点</span></span><br><span class="line"><span class="keyword">private</span> E <span class="title function_">unlinkFirst</span><span class="params">(Node&lt;E&gt; f)</span> &#123;</span><br><span class="line">    <span class="comment">// assert f == first &amp;&amp; f != null;</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">E</span> <span class="variable">element</span> <span class="operator">=</span> f.item;  <span class="comment">// 获取节点存储的元素</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = f.next;  <span class="comment">// 获取节点的下一个节点引用</span></span><br><span class="line">    f.item = <span class="literal">null</span>;  <span class="comment">// 清除节点的数据项，帮助垃圾收集器回收</span></span><br><span class="line">    f.next = <span class="literal">null</span>;  <span class="comment">// 断开节点的下一个链接，也是为了垃圾回收</span></span><br><span class="line">    first = next;  <span class="comment">// 将头指针更新为下一个节点</span></span><br><span class="line">    <span class="keyword">if</span> (next == <span class="literal">null</span>)  <span class="comment">// 如果下一个节点不存在，说明链表只有一个节点</span></span><br><span class="line">        last = <span class="literal">null</span>;  <span class="comment">// 更新尾指针为 null</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        next.prev = <span class="literal">null</span>;  <span class="comment">// 否则，设置新的头节点的前一个节点为 null</span></span><br><span class="line">    size--;  <span class="comment">// 链表大小减 1</span></span><br><span class="line">    modCount++;  <span class="comment">// 修改计数增加，用于迭代器的快速失败机制</span></span><br><span class="line">    <span class="keyword">return</span> element;  <span class="comment">// 返回被删除的元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-Set"><a href="#5-Set" class="headerlink" title="5. Set"></a>5. Set</h2><h3 id="5-1-Set-接口基本介绍"><a href="#5-1-Set-接口基本介绍" class="headerlink" title="5.1 Set 接口基本介绍"></a>5.1 Set 接口基本介绍</h3><ul><li><p><strong>特点</strong>：</p><ul><li><p><strong>无序性</strong>：<code>Set</code> 集合中的元素没有固定的顺序，元素的存储位置由 <code>Set</code> 的实现方式决定。添加和移除元素的顺序不保证一致性，也就是说，迭代 <code>Set</code> 时元素的返回顺序不一定反映它们被添加的顺序</p></li><li><p><strong>唯一性</strong>：<code>Set</code> 不允许重复的元素。每个元素在 <code>Set</code> 中只能出现一次。如果尝试添加重复的元素，添加操作通常会被忽略</p></li><li><p><strong>有限的 <code>null</code> 支持</strong>：大多数 <code>Set</code> 实现允许至少一个 <code>null</code> 元素（如果允许的话），但添加多个 <code>null</code> 会被视为重复</p></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以 Set 接口的实现类 HashSet 为例</span></span><br><span class="line"><span class="comment">// 1. set 接口的实现类的对象(Set接口对象), 不能存放重复的元素, 可以添加一个 null</span></span><br><span class="line"><span class="comment">// 2. set 接口对象存放数据是无序(即添加的顺序和取出的顺序不一致, 但取出顺序每次固定)</span></span><br><span class="line"><span class="type">Set</span> <span class="variable">set</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>();</span><br><span class="line">set.add(<span class="string">&quot;john&quot;</span>);</span><br><span class="line">set.add(<span class="string">&quot;lucy&quot;</span>);</span><br><span class="line">set.add(<span class="string">&quot;john&quot;</span>);  <span class="comment">// 重复</span></span><br><span class="line">set.add(<span class="string">&quot;jack&quot;</span>);</span><br><span class="line">set.add(<span class="literal">null</span>);  <span class="comment">// 添加 null</span></span><br><span class="line">set.add(<span class="literal">null</span>);  <span class="comment">// 再次添加null</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出 set, 3 次输出的顺序都是固定的</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;set = &quot;</span> + set);  <span class="comment">// set = [null, john, lucy, jack]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>JDK 中的 Set 接口实现类</strong>：</p><ul><li><p><strong><code>HashSet</code><strong>：</strong>基于哈希表</strong>的 <code>Set</code> 实现，提供快速的查询速度，不保证顺序</p></li><li><p><strong><code>TreeSet</code><strong>：</strong>基于红黑树</strong>实现，元素会按照自然顺序或创建 <code>TreeSet</code> 时提供的比较器进行排序</p></li><li><p><strong><code>LinkedHashSet</code><strong>：类似于 <code>HashSet</code>，但维护了一个运行于所有条目的双重链接列表，</strong>保留了插入的顺序</strong></p></li><li><p>….</p></li></ul></li><li><p><strong>常用方法</strong>： 和 List 接口一样， Set 接口也是 Collection 的子接口，因此，常用方法和 Collection 接口一样</p></li></ul><h3 id="5-2-Set-接口的遍历方式"><a href="#5-2-Set-接口的遍历方式" class="headerlink" title="5.2 Set 接口的遍历方式"></a>5.2 Set 接口的遍历方式</h3><blockquote><p><code>Set</code> 集合的遍历方式与 <code>Collection</code> 接口的其他实现相同，因为 <code>Set</code> 是 <code>Collection</code> 接口的一个子接口</p></blockquote><ul><li><strong>使用迭代器</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方式1: 使用迭代器</span></span><br><span class="line"><span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> set.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;  <span class="comment">// 快捷键: itit</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">    System.out.println(<span class="string">&quot;obj = &quot;</span> + obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>增强 for 循环</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Object o : set) &#123;  <span class="comment">// 快捷键: set.for</span></span><br><span class="line">    System.out.println(<span class="string">&quot;o=&quot;</span> + o);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>不能使用</strong>索引的方式来获取</p></li><li><p><strong>补充：Java 8 及更高版本的流</strong></p><blockquote><p>在 Java 8 引入的流（Streams）API 是一种高效处理集合（如 <code>List</code>、<code>Set</code> 等）的方法，特别适用于对集合执行复杂的查询和转换操作。流 API 可以用来遍历、筛选、映射、归约以及更多其它操作 <code>List</code> 或任何其他类型的 <code>Collection</code></p></blockquote><ul><li><strong>简单遍历</strong>：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set.stream().forEach(System.out::println);</span><br></pre></td></tr></table></figure><ul><li><strong>更复杂的操作举例 List</strong>：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; items = List.of(<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;avocado&quot;</span>, <span class="string">&quot;cherry&quot;</span>, <span class="string">&quot;date&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用流过滤、转换并收集结果</span></span><br><span class="line">List&lt;String&gt; result = items.stream()</span><br><span class="line">    .filter(s -&gt; s.startsWith(<span class="string">&quot;a&quot;</span>))  <span class="comment">// 只选择以&quot;a&quot;开头的元素</span></span><br><span class="line">    .map(String::toUpperCase)        <span class="comment">// 将每个元素转换为大写</span></span><br><span class="line">    .sorted()                        <span class="comment">// 排序</span></span><br><span class="line">    .collect(Collectors.toList());   <span class="comment">// 收集为列表</span></span><br><span class="line"></span><br><span class="line">System.out.println(result);  <span class="comment">// 输出: [APPLE, AVOCADO]</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="5-3-Set-接口实现类-HashSet"><a href="#5-3-Set-接口实现类-HashSet" class="headerlink" title="5.3 Set 接口实现类-HashSet"></a>5.3 Set 接口实现类-HashSet</h3><h4 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h4><ul><li><strong>实现 Set 接口</strong>：<code>HashSet</code> 是 <code>Set</code> 接口的一个实现，提供了集合的基本操作，如添加、删除元素以及查询等，同时确保集合中的元素不重复</li><li><strong>底层使用 HashMap</strong>：<ul><li><code>HashSet</code> 内部实际上使用了一个 <code>HashMap</code> 来存储其元素，每个插入 <code>HashSet</code> 的元素都作为 <code>HashMap</code> 的键存储，而其值则使用一个固定的对象（通常是一个预定义的私有静态的 <code>final</code> 对象</li><li>使用 <code>HashMap</code> 支持使得 <code>HashSet</code> 在添加元素、删除元素和包含元素检查等操作上非常高效，时间复杂度为 O(1)</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">()</span> &#123;</span><br><span class="line">    map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>允许一个 null 值</strong>：<code>HashSet</code> 允许包含一个 <code>null</code> 元素，因为底层的 <code>HashMap</code> 允许其中一个键为 <code>null</code>。这对于某些需要表示特定场景的空值非常有用</li><li><strong>无序性</strong>：<ul><li><code>HashSet</code> 不保证集合中元素的顺序，元素的存储取决于它们的哈希码</li><li>当元素被添加到 <code>HashSet</code> 中时，其位置是根据哈希码计算得到的，这意味着<strong>元素的遍历顺序可能与添加顺序不同</strong></li></ul></li><li><strong>哈希冲突与重新哈希</strong>：当哈希表的负载因子达到一定程度（默认是 0.75）时，哈希表会进行扩容（通常扩容为原来的两倍），这个过程可能会改变现有元素的顺序</li><li><strong>不允许重复元素</strong>：<code>HashSet</code> 不允许重复元素。当尝试添加一个已存在的元素时，添加操作将不会改变集合，也不会抛出异常</li></ul><h4 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">HashSet</span> <span class="variable">set</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 在执行add方法后, 返回一个 boolean 值</span></span><br><span class="line"><span class="comment">// 2. 添加成功,返回 true, 否则返回 false</span></span><br><span class="line">System.out.println(set.add(<span class="string">&quot;john&quot;</span>));  <span class="comment">// T</span></span><br><span class="line">System.out.println(set.add(<span class="string">&quot;lucy&quot;</span>));  <span class="comment">// T</span></span><br><span class="line">System.out.println(set.add(<span class="string">&quot;john&quot;</span>));  <span class="comment">// F</span></span><br><span class="line">System.out.println(set.add(<span class="string">&quot;jack&quot;</span>));  <span class="comment">// T</span></span><br><span class="line">System.out.println(set.add(<span class="string">&quot;Rose&quot;</span>));  <span class="comment">// T</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 可以通过 remove 指定删除哪个对象</span></span><br><span class="line">set.remove(<span class="string">&quot;john&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;set = &quot;</span> + set);  <span class="comment">// 3个  set = [Rose, lucy, jack]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 重新实例化 set, 将 set 指向新的 HashSet, 原来的 HashSet 实例将失去引用</span></span><br><span class="line"><span class="comment">// 原来的 HashSet 实例被垃圾收集器回收（前提是没有其他引用指向它）</span></span><br><span class="line">set = <span class="keyword">new</span> <span class="title class_">HashSet</span>();</span><br><span class="line">System.out.println(<span class="string">&quot;set = &quot;</span> + set);  <span class="comment">// 0  set = []</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. Hashset 不能添加相同的元素/数据?</span></span><br><span class="line">set.add(<span class="string">&quot;lucy&quot;</span>);  <span class="comment">// 添加成功</span></span><br><span class="line">set.add(<span class="string">&quot;lucy&quot;</span>);  <span class="comment">// 加入不了</span></span><br><span class="line">set.add(<span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;tom&quot;</span>));  <span class="comment">// OK</span></span><br><span class="line">set.add(<span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;tom&quot;</span>));  <span class="comment">// Ok</span></span><br><span class="line">System.out.println(<span class="string">&quot;set = &quot;</span> + set);  <span class="comment">// set = [Dog&#123;name=&#x27;tom&#x27;&#125;, Dog&#123;name=&#x27;tom&#x27;&#125;, lucy]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 看源码, 即 add 到底发生了什么? =&gt; 底层机制</span></span><br><span class="line">set.add(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hhh&quot;</span>));  <span class="comment">// ok</span></span><br><span class="line">set.add(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hhh&quot;</span>));  <span class="comment">// 加入不了  set = [Dog&#123;name=&#x27;tom&#x27;&#125;, hhh, Dog&#123;name=&#x27;tom&#x27;&#125;, lucy]</span></span><br><span class="line"><span class="comment">// String 类重写了 equals() 和 hashCode() 方法</span></span><br><span class="line"><span class="comment">// String 的 hashCode() 方法确保所有内容相同的字符串对象返回相同的哈希码</span></span><br><span class="line"><span class="comment">// 而 equals() 方法确保只有当两个字符串对象的内容完全相同时才返回 true</span></span><br><span class="line"><span class="comment">// HashSet 使用这些方法来检查是否已经存在相等的字符串, 因此这次添加操作不会改变 set 的内容</span></span><br><span class="line">System.out.println(<span class="string">&quot;set = &quot;</span> + set);</span><br></pre></td></tr></table></figure><h4 id="模拟哈希表-数组-链表"><a href="#模拟哈希表-数组-链表" class="headerlink" title="模拟哈希表(数组+链表)"></a>模拟哈希表(数组+链表)</h4><ul><li><strong>HashSet 的底层是 HashMap，HashMap的底层是 数组+链表&#x2F;红黑树</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模拟一个 HashSet 的底层(其实也就是 HashMap 的底层结构)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 创建一个数组, 数组的类型是 Node[], 每个数组存放的元素可以理解为一个链表头</span></span><br><span class="line"><span class="comment">// 2. 有时也直接把 Node[] 数组称为 table 表</span></span><br><span class="line">Node[] table = <span class="keyword">new</span> <span class="title class_">Node</span>[<span class="number">16</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 创建结点,实现:</span></span><br><span class="line"><span class="comment">// [2]: john =&gt; jack =&gt; rose</span></span><br><span class="line"><span class="comment">// [3]: lucy</span></span><br><span class="line"><span class="type">Node</span> <span class="variable">john</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="string">&quot;john&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">table[<span class="number">2</span>] = john;</span><br><span class="line"></span><br><span class="line"><span class="type">Node</span> <span class="variable">jack</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="string">&quot;jack&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">john.next = jack;  <span class="comment">// 将 jack 结点挂载到 john</span></span><br><span class="line"></span><br><span class="line"><span class="type">Node</span> <span class="variable">rose</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="string">&quot;Rose&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">jack.next = rose;  <span class="comment">// 将 rose 结点挂载到 jack</span></span><br><span class="line"></span><br><span class="line"><span class="type">Node</span> <span class="variable">lucy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="string">&quot;lucy&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">table[<span class="number">3</span>] = lucy; <span class="comment">// 把 lucy 放到 table 表的索引为 3 的位置</span></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;table=&quot;</span> + table);</span><br></pre></td></tr></table></figure><h4 id="底层机制"><a href="#底层机制" class="headerlink" title="底层机制"></a>底层机制</h4><ul><li><strong>分析HashSet的添加元素底层是如何实现：hash() + equals()</strong><ul><li>HashSet 底层<strong>使用 HashMap 存储所有元素</strong>，在 HashSet 中添加一个元素实际上是将该元素作为键添加到内部的 HashMap 中</li><li>添加一个元素时，会得到 <strong>hash 值 -&gt; 索引值</strong></li><li><strong>处理哈希碰撞</strong>：找到存储数据表table，看这个索引位置是否已经存放了元素<ul><li>如果没有，直接将元素存储到该位置</li><li>如果有，调用 <code>equals()</code> 方法比较<ul><li>如果 <code>equals()</code> 返回 <code>true</code>，就放弃添加</li><li>如果 <code>equals()</code> 返回 <code>false</code>，则继续与链表中的下一个元素比较，直到找到相同的元素或链表结束</li></ul></li></ul></li><li><strong>链表与树化</strong>：<ul><li><strong>链表处理</strong>：如果一个索引位置上的冲突元素较多（但未达到树化阈值），则以链表形式存储</li><li>在 Java 8 及更高版本中，如果某个索引位置的链表长度 <code>&gt;= TREEIFY_THRESHOLD</code>（默认为8），并且整个 <code>HashMap</code> 的容量<code>&gt;= MIN_TREEIFY_CAPACITY</code>（默认为64），则这个链表会转化为红黑树，以提高搜索效率</li></ul></li><li><strong>添加成功与否</strong>：<ul><li>如果在整个链表或红黑树中没有找到相同的元素，则将新元素添加到链表的末尾或红黑树中</li><li><code>HashSet</code> 的 <code>add()</code> 方法返回一个 <code>boolean</code> 值，表示元素是否被添加。如果元素因为已存在而未被添加，则返回 <code>false4</code></li></ul></li></ul></li><li><strong>构造器</strong>：初始化一个 <code>HashSet</code> 实例时，内部实际上创建了一个 <code>HashMap</code> 来存储集合中的元素<ul><li><strong>默认负载因子</strong>：<code>HashMap</code> 默认的负载因子是 <code>0.75</code>，这意味着当 <code>HashMap</code> 的容量达到其容量的 75% 时，会自动扩容(重新调整内部数据结构的大小)</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HashSet.java 代码</span></span><br><span class="line"><span class="comment">// 构造器</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">()</span> &#123;</span><br><span class="line">    map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HashMap.java 代码</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">DEFAULT_LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong><code>HashSet</code>的<code>add</code> 方法</strong>：<code>HashSet</code> 添加元素实际上是调用内部 <code>HashMap</code> 的 <code>put</code> 方法，将元素 <code>e</code> 作为键存入。所有键共享同一个值 <code>PRESENT</code>，这只是一个占位符，没有实际意义</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// add 方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">PRESENT</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();  <span class="comment">// 方便让HashSet使用HashMap, 用一个Object作为 value 值进行占位</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> map.put(e, PRESENT)==<span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong><code>HashMap</code> 的 <code>put</code> 方法</strong>：<code>put</code> 方法首先计算键的哈希值，然后调用 <code>putVal</code> 方法处理实际的插入逻辑</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HashMap.java 代码</span></span><br><span class="line"><span class="comment">// 倒数第二个参数对应 putVal 方法的 onlyIfAbsent 参数, 决定了如果 key 已存在，是否要替换旧的值, false 表示如果发现 key 已存在，将替换旧值</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>计算哈希值(不等价于hashCode)<strong>：通过将对象的 <code>hashCode()</code> 结果与其自身右移 16 位的结果进行异或操作，从而</strong>减少高位和低位的冲突，改进了哈希碰撞的问题</strong>：(<code>h ^ (h &gt;&gt;&gt; 16)</code>)<ul><li><strong>异或</strong>：异1同0，用于混合原始哈希码的高位和低位，增加哈希码的随机性和均匀性</li><li>**无符号右移 (<code>&gt;&gt;&gt;</code>)**：将数值的二进制位向右移动指定的位数，右边超出的部分被丢弃，左边空出的位用 0 填充，用来混合哈希码，避免高位的信息在计算索引时被忽略</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// force step into 到 hash(key) 方法</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// String 类的 hashCode() 方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> hash; <span class="comment">// 默认为 0</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> hash;</span><br><span class="line">    <span class="comment">// 遍历字符串中的每个字符</span></span><br><span class="line">    <span class="comment">// 使用公式 h = 31 * h + val[i]; 计算哈希值</span></span><br><span class="line">    <span class="keyword">if</span> (h == <span class="number">0</span> &amp;&amp; value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">char</span> val[] = value;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 数字 31 被选择是因为它是一个奇质数，如果用更小的数字，容易造成哈希碰撞</span></span><br><span class="line">        <span class="comment">// 同时，计算 31*h 可以被 JVM 优化为 (h &lt;&lt; 5) - h，这是一次位移和一次减法，比乘法更快</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; value.length; i++) &#123;</span><br><span class="line">            h = <span class="number">31</span> * h + val[i];</span><br><span class="line">        &#125;</span><br><span class="line">        hash = h;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong><code>putVal</code> 方法</strong>：</p><ul><li><p><strong>寻找插入位置</strong>：首先检查是否需要扩容。如果对应的桶（数组位置）是空的，则直接插入新节点</p></li><li><p><strong>处理哈希碰撞</strong>：如果桶中已有元素，则通过链表或红黑树（当链表长度太长时转换为红黑树以优化搜索效率）处理碰撞</p><ul><li><strong>代码</strong>：既提高了性能（通过快速的引用比较），又保证了准确性（通过内容比较）<ul><li>引用比较 (<code>==</code>) 是一种<strong>非常快速的操作</strong>，比调用任何方法都要快，因为它直接比较内存地址。<strong>如果两个引用指向同一个对象，那么它们肯定相等</strong>，不需要进一步使用 <code>equals</code> 方法比较</li><li>即使两个对象的引用不同（它们位于内存中不同的位置），它们仍可能表示相同的数据。例如，两个不同的 <code>String</code> 对象可能包含相同的文本。通过 <code>equals</code> 方法，可以确保逻辑上相等的对象能够被正确识别</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">    ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">    e = p; </span><br></pre></td></tr></table></figure></li><li><p><strong>键的比较</strong>：使用 <code>equals</code> 方法检查键是否已存在。如果已存在，根据 <code>onlyIfAbsent</code> 参数决定是否更新值</p></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"><span class="keyword">transient</span> <span class="type">int</span> size;  <span class="comment">// 默认为 0</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">UNTREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">    Node(<span class="type">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="built_in">this</span>.hash = hash;</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line">Node&lt;K,V&gt; <span class="title function_">newNode</span><span class="params">(<span class="type">int</span> hash, K key, V value, Node&lt;K,V&gt; next)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(hash, key, value, next);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">afterNodeInsertion</span><span class="params">(<span class="type">boolean</span> evict)</span> &#123; &#125;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; p)</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// putVal()</span></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,</span></span><br><span class="line"><span class="params">               <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 定义辅助变量</span></span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, i;</span><br><span class="line">    <span class="comment">// 2. 检查哈希表是否为空或者尚未初始化</span></span><br><span class="line">    <span class="comment">// table 就是 HashMap 的一个数组, 类型是 Node[]</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)  <span class="comment">// 如果为空，则进行初始化或扩容</span></span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 计算插入v的位置并检查该位置是否已有元素存在</span></span><br><span class="line">    <span class="comment">// (1) 计算索引: i = (n - 1) &amp; hash, 使用位与运算 &amp; 来确定元素在表中的索引位置</span></span><br><span class="line">    <span class="comment">// (1.1) 因为 n 是 2 的幂，n - 1 的二进制表示将是一个全 1 的序列（例如，如果 n 是 16，n - 1 是 15，二进制是 1111）</span></span><br><span class="line">    <span class="comment">// (1.2) 意味着 (n - 1) &amp; hash 将使用 hash 的低位作为数组索引。这是一个常用技巧，用于替代模运算（hash % n），因为位运算比模运算更高效</span></span><br><span class="line">    <span class="comment">// (2) 访问数组并赋值给 p: p = tab[i]</span></span><br><span class="line">    <span class="comment">// (3) 判断条件 (p == null)</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line">        <span class="comment">// 3.1 如果没有节点，则直接插入新节点, value 对象是共享的</span></span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;  <span class="comment">// 3.2 如果该位置已经有节点存在，则处理哈希碰撞</span></span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">// 3.2.1 检查当前节点的哈希值和键是否与插入的键相同</span></span><br><span class="line">        <span class="comment">// (1) 先检查当前节点 p 的哈希值是否与待插入键 key 的哈希值相同</span></span><br><span class="line">        <span class="comment">// (2) 键的比较</span></span><br><span class="line">        <span class="comment">// (2.1) 首先，p.key 被赋值给变量 k</span></span><br><span class="line">        <span class="comment">// (2.2) 使用 == 操作符检查 k 和 key 是否为同一个对象的引用</span></span><br><span class="line">        <span class="comment">// (2.3) 如果 k 和 key 不是同一个引用，那么继续使用 equals 方法检查两者的内容是否相等, 有一个额外的空值检查 key != null, 避免抛出 NPE</span></span><br><span class="line">        <span class="comment">// (3) 条件成立，执行赋值 (e = p)</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;  <span class="comment">// 如果节点已存在，将其赋给 e 用于后续操作</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3.2.2 如果当前节点是树节点，则调用树节点的插入方法</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3.2.3 如果是链表，则遍历链表</span></span><br><span class="line">        <span class="keyword">else</span> &#123;  </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 如果到达链表末尾，插入新节点</span></span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                    <span class="comment">// 如果链表长度达到阈值，则尝试将当前链表转换为红黑树</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1因为从0开始计数</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果在链表中找到了相同哈希且键相等的节点，则停止搜索</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;  <span class="comment">// 如果找到相同的键，停止遍历</span></span><br><span class="line">                p = e;  <span class="comment">// 继续遍历链表</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3.2.4 如果找到了已存在的节点，根据参数决定是否更新其值</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123; </span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新修改次数</span></span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 如果大小超过阈值，则进行扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    <span class="comment">// 对于 ashMap 来说, 这个方法是个空方法</span></span><br><span class="line">    afterNoeInsertion(evict);  <span class="comment">// 钩子方法，用于 LinkedHashMap 后续处理</span></span><br><span class="line">    <span class="comment">// 钩子方法通常是在基类中预定义的方法，它们在默认情况下可能不做任何事（即可能是空方法），或者提供默认行为。派生类可以根据需要重写这些方法来提供特定的行为</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/Java%E9%9B%86%E5%90%88.assets/image-20240428211648961.png" alt="image-20240428211648961"></p><ul><li><p><strong><code>resize</code> 扩容方法</strong>：</p><ul><li><p><strong>初始化和条件检查</strong>：</p><ul><li><strong>保存旧数组</strong>：首先，旧数组 <code>oldTab</code> 被保存，用于之后的元素迁移。</li><li><strong>检查旧容量</strong>：获取旧数组的长度 <code>oldCap</code>。如果数组未初始化（即为 <code>null</code>），<code>oldCap</code> 设为 <code>0</code>。</li><li><strong>旧阈值</strong>：保存旧的扩容阈值 <code>oldThr</code>。</li></ul></li><li><p><strong>判断是否需要扩容</strong>：</p><ul><li><p><strong>达到最大容量</strong>：如果旧容量已经等于最大可能容量 <code>MAXIMUM_CAPACITY</code>（即 <code>1 &lt;&lt; 30</code>），将阈值设置为 <code>Integer.MAX_VALUE</code> 并直接返回旧表，不再扩容。</p></li><li><p><strong>一般扩容条件</strong>：如果旧容量小于最大容量且大于默认初始容量，新容量 <code>newCap</code> 设为旧容量的两倍，新阈值 <code>newThr</code> 也相应翻倍。</p></li></ul></li><li><p><strong>处理特殊初始化条件</strong>：</p><ul><li><p><strong>初次初始化</strong>：如果是首次初始化（即旧阈值大于 <code>0</code> 且旧容量为 <code>0</code>），直接使用旧阈值作为新容量。</p></li><li><p><strong>默认初始化</strong>：如果旧容量和旧阈值都是 <code>0</code>（未初始化状态），设置新容量为默认初始容量（<code>16</code>），计算新阈值为容量与默认负载因子（<code>0.75</code>）的乘积。</p></li></ul></li><li><p><strong>重新计算新阈值</strong>：</p><ul><li><strong>阈值计算</strong>：如果新阈值未设定（即 <code>newThr == 0</code>），根据新容量和负载因子计算新阈值。如果计算结果接近最大容量，直接将阈值设置为 <code>Integer.MAX_VALUE</code>。</li></ul></li><li><p><strong>创建新数组并设置新表</strong>：</p><ul><li><p><strong>新数组创建</strong>：基于新容量创建新的节点数组 <code>newTab</code>。</p></li><li><p><strong>更新哈希表</strong>：将 <code>HashMap</code> 的 <code>table</code> 引用更新为新数组。</p></li></ul></li><li><p><strong>重新散列旧元素</strong>：</p><ul><li>遍历旧数组：遍历每个索引位置的旧数组元素。<ul><li><strong>单节点直接移动</strong>：如果该位置只有一个节点，直接计算新位置并放入新数组。</li><li>处理树或链表：如果节点形成了链表或树：<ul><li><strong>树节点分割</strong>：对于树节点，执行分割操作，将节点根据当前的容量分散到新的索引位置。</li><li><strong>链表重分布</strong>：对于链表，节点被分为两组，一组索引位置不变，另一组移动到 <code>原索引 + oldCap</code> 的位置。<ul><li><strong>链表节点迁移</strong>：根据节点哈希值的高位决定分组。</li></ul></li></ul></li></ul></li></ul></li><li><p><strong>返回新数组</strong>：<strong>返回新的哈希表数组</strong> <code>newTab</code>，完成扩容和重新散列过程。</p></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> threshold;  <span class="comment">// 默认为 0</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAXIMUM_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">30</span>;  <span class="comment">// 2^30</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">4</span>;  <span class="comment">// 默认容量 16 </span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">DEFAULT_LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>;  <span class="comment">// 默认负载因子</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    <span class="comment">// 保存旧数组</span></span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="comment">// 旧数组的容量</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCap</span> <span class="operator">=</span> (oldTab == <span class="literal">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldThr</span> <span class="operator">=</span> threshold;  <span class="comment">// 旧阈值</span></span><br><span class="line">    <span class="type">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 如果旧容量大于 0</span></span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果旧容量已达到最大值</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            <span class="comment">// 更新阈值为 int 最大值，防止进一步扩容</span></span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果旧容量小于最大容量，将容量翻倍</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            <span class="comment">// 翻倍阈值</span></span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果旧容量为 0，但旧阈值大于 0，通常是初始情况</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) </span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;  <span class="comment">// 使用默认容量和默认负载因子            </span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        <span class="comment">// 默认阈值: 16*0.75=12</span></span><br><span class="line">        newThr = (<span class="type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果新阈值为 0, 重新计算新阈值</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> (<span class="type">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="type">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;  <span class="comment">// 更新阈值</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>[newCap];  <span class="comment">// 创建新数组</span></span><br><span class="line">    table = newTab;  <span class="comment">// 将新数组设为当前表</span></span><br><span class="line">    <span class="comment">// 重新散列旧数组中的所有元素到新数组</span></span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="literal">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="literal">null</span>;</span><br><span class="line">                <span class="comment">// 如果节点没有后续节点，直接重新定位</span></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="literal">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="comment">// 如果是树节点，执行树相关的分割</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="built_in">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// 重新链接扩展的节点</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="comment">// 根据哈希的高位决定是放在原位置还是新位置</span></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="literal">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="literal">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="literal">null</span>);</span><br><span class="line">                     <span class="comment">// 重新链接低位链表和高位链表</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="literal">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="literal">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;  <span class="comment">// 返回新的哈希表数组</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong><code>treeifyBin</code> 转红黑树方法</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="type">int</span> hash)</span> &#123;</span><br><span class="line">    <span class="type">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="comment">// 如果表为空或表的长度小于最小树化容量，进行扩容</span></span><br><span class="line">    <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">        resize();</span><br><span class="line">    <span class="comment">// 如果表不为空且长度大于等于最小树化容量</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; hd = <span class="literal">null</span>, tl = <span class="literal">null</span>;  <span class="comment">// hd 用于保存头节点，tl 用于保存尾节点</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">// 将普通节点转换为树节点</span></span><br><span class="line">            TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="literal">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (tl == <span class="literal">null</span>)</span><br><span class="line">                hd = p;  <span class="comment">// 如果尾节点为空，表示这是第一个节点，设置为头节点</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                p.prev = tl;  <span class="comment">// 设置当前节点的前一个节点为尾节点</span></span><br><span class="line">                tl.next = p;  <span class="comment">// 将尾节点的下一个节点设置为当前节点</span></span><br><span class="line">            &#125;</span><br><span class="line">            tl = p;  <span class="comment">// 更新尾节点为当前节点</span></span><br><span class="line">        &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);  <span class="comment">// 遍历链表中的所有节点</span></span><br><span class="line">        <span class="comment">// 如果头节点不为空，开始树化操作</span></span><br><span class="line">        <span class="keyword">if</span> ((tab[index] = hd) != <span class="literal">null</span>)</span><br><span class="line">            hd.treeify(tab);  <span class="comment">// 将链表转换为红黑树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>扩容机制的触发</strong>？<ul><li>一种是总的键值对数量<strong>超过</strong>了负载因子与当前容量的乘积所定义的<strong>阈值</strong><ul><li><strong>初始设置</strong>：<code>HashMap</code> 默认的初始容量是 16 (<code>DEFAULT_INITIAL_CAPACITY</code>), 负载因子是 0.75 (<code>DEFAULT_LOAD_FACTOR</code>)。</li><li><strong>计算阈值</strong>：阈值 (<code>threshold</code>) 是触发扩容的点，计算为 <code>容量 * 负载因子</code>。初始情况下，阈值是 <code>16 * 0.75 = 12</code>。</li><li><strong>扩容条件</strong>：每次向 <code>HashMap</code> 添加元素后，如果哈希表中的元素数量超过当前阈值，就会触发扩容。扩容通常将容量翻倍（例如从 16 增加到 32，阈值相应地从 12 增加到 <code>24</code>）。</li><li><strong>扩容过程</strong>：在扩容过程中，旧数组中的元素会被重新计算索引并移动到新的数组中，这个过程称为重新散列（rehashing）。</li></ul></li><li>另一种是<strong>单个哈希桶（链表或树）的结构因为太长</strong>而需要转换<ul><li><strong>链表长度阈值</strong>：如果 <code>HashMap</code> 中某个桶的链表长度达到 <code>TREEIFY_THRESHOLD</code>（默认为 8），则可能触发树化。但<strong>树化之前还有一层检查，即桶数组的总容量是否足够大</strong>。</li><li><strong>最小树化容量</strong>：树化发生之前，桶数组的容量必须达到 <code>MIN_TREEIFY_CAPACITY</code>（默认为 64）。这意味着如果容量小于这个值，即使链表长度达到了 8，系统也会选择先扩容而不是树化。</li><li><strong>先扩容还是先树化</strong>：如果在链表长度达到 8 时容量已经达到或超过了 64，将直接进行树化；如果容量还不足 64，则会先进行扩容，容量通常翻倍，这有助于分散哈希碰撞并可能避免立即树化。</li></ul></li></ul></li></ul><h4 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h4><ul><li>当一个对象作为哈希基础集合（如 <code>HashSet</code> 或 <code>HashMap</code>）的元素时，不仅该对象本身需要适当重写 <code>hashCode()</code> 和 <code>equals()</code> 方法，其<strong>内部属性对象</strong>（如果这些属性对等价性判断有影响）同样需要重写这些方法</li><li>eg. 当一个对象（如 <code>Emp</code>）的等价性判断依赖于另一个对象（如 <code>MyDate</code>）时，后者也必须正确实现 <code>hashCode()</code> 和 <code>equals()</code> 方法。这是因为前者的方法实现直接依赖于后者的等价性逻辑</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashSetPractice01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">HashSet</span> <span class="variable">hashSet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>();</span><br><span class="line">        hashSet.add(<span class="keyword">new</span> <span class="title class_">Emp</span>(<span class="string">&quot;111&quot;</span>, <span class="number">3000.0</span>, <span class="keyword">new</span> <span class="title class_">MyDate</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)));</span><br><span class="line">        hashSet.add(<span class="keyword">new</span> <span class="title class_">Emp</span>(<span class="string">&quot;111&quot;</span>, <span class="number">3000.0</span>, <span class="keyword">new</span> <span class="title class_">MyDate</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Object o : hashSet) &#123;</span><br><span class="line">            System.out.println(o);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyDate</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer year;</span><br><span class="line">    <span class="keyword">private</span> Integer month;</span><br><span class="line">    <span class="keyword">private</span> Integer day;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyDate</span><span class="params">(Integer year, Integer month, Integer day)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.year = year;</span><br><span class="line">        <span class="built_in">this</span>.month = month;</span><br><span class="line">        <span class="built_in">this</span>.day = day;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == o) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">MyDate</span> <span class="variable">myDate</span> <span class="operator">=</span> (MyDate) o;</span><br><span class="line">        <span class="keyword">return</span> Objects.equals(year, myDate.year) &amp;&amp; Objects.equals(month, myDate.month) &amp;&amp; Objects.equals(day, myDate.day);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(year, month, day);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Emp</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Double sal;</span><br><span class="line">    <span class="keyword">private</span> MyDate birthday;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Emp</span><span class="params">(String name, Double sal, MyDate birthday)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.sal = sal;</span><br><span class="line">        <span class="built_in">this</span>.birthday = birthday;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == o) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">Emp</span> <span class="variable">emp</span> <span class="operator">=</span> (Emp) o;</span><br><span class="line">        <span class="keyword">return</span> Objects.equals(name, emp.name) &amp;&amp; Objects.equals(birthday, emp.birthday);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(name, birthday);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-4-Set-接口实现类-LinkedHashSet"><a href="#5-4-Set-接口实现类-LinkedHashSet" class="headerlink" title="5.4 Set 接口实现类-LinkedHashSet"></a>5.4 Set 接口实现类-LinkedHashSet</h3><h4 id="基本介绍-2"><a href="#基本介绍-2" class="headerlink" title="基本介绍"></a>基本介绍</h4><ul><li><strong>继承关系</strong>：LinkedHashSet 是 HashSet 的子类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedHashSet</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">HashSet</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">Set</span>&lt;E&gt;, Cloneable, java.io.Serializable &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>底层由 LinkedHashMap 实现</strong>：LinkedHashSet 底层是一个 LinkedHashMap，内部结构包括一个<strong>哈希表（用于存储数据）和一个双向链表（用于维护插入顺序）</strong><ul><li>每个添加到 <code>LinkedHashMap</code> 中的元素都会被插入到双向链表的尾部</li></ul></li><li><strong>元素顺序</strong>：LinkedHashSet 根据元素 hashCode 来决定元素的存储位置，同时使用链表维护元素的次序，这使得元素看起来是以插入顺序保存的</li><li><strong>不允许重复元素</strong>：同 <code>HashSet</code>，<code>LinkedHashSet</code> 也是基于集合的性质，不允许添加重复的元素。它使用 <code>hashCode()</code> 和 <code>equals()</code> 方法来检测重复</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/Java%E9%9B%86%E5%90%88.assets/image-20240428213615027.png" alt="image-20240428213615027"></p><h4 id="底层机制-1"><a href="#底层机制-1" class="headerlink" title="底层机制"></a>底层机制</h4><ul><li><strong>数据结构</strong>：<code>LinkedHashSet</code> 内部实际上使用了 <code>LinkedHashMap</code> 来存储元素。<code>LinkedHashMap</code> 本质上是 <code>HashMap</code> 的一个子类，但它在每个节点中额外维护了两个指针，分别指向链表中的前一个和后一个节点</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/Java%E9%9B%86%E5%90%88.assets/image-20240429190650048.png" alt="image-20240429190650048"></p><ul><li><p><strong>节点结构</strong>：</p><ul><li>除了键值对信息外，每个节点还有 <code>prev</code>（前驱）和 <code>next</code>（后继）两个属性，用于链接前一个和后一个节点，形成一个双向链表</li><li>这个链表通过头指针 <code>head</code> 和尾指针 <code>tail</code> 维护，确保插入顺序</li></ul></li><li><p><strong>节点类型</strong>：</p><ul><li>添加第一次时，直接将 数组 table 扩容到 16 ,存放的结点类型是 <code>LinkedHashMap$Entry</code></li><li>数组 table 是 <code>HashMap$Node[]</code> 存放的元素&#x2F;数据是 <code>LinkedHashMap$Entry</code> 类型，(数组多态？)，</li><li><code>LinkedHashMap.Entry</code> 类继承了 <code>HashMap.Node</code> 类(静态内部类，因为是通过类名去访问的)，不仅存储键值对（即数据部分），还包括两个额外的指针：<code>before</code>, <code>after</code>，用于维护节点的插入顺序</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">HashMap</span>.Node&lt;K,V&gt; &#123;</span><br><span class="line">    Entry&lt;K,V&gt; before, after;</span><br><span class="line">    Entry(<span class="type">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="built_in">super</span>(hash, key, value, next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>添加元素</strong>：</p><blockquote><p>这里其实都类似，就是功能增强，增加的双指针没有破坏原来的结构，感觉就是多了一个有序的功能</p></blockquote><ul><li>当添加一个新元素时，首先计算该元素的哈希值，然后根据哈希值计算其在哈希表中的索引</li><li>如果元素是首次添加（即在哈希表中找不到对应的条目），该元素将被封装为一个新的节点，并添加到双向链表的末尾（如果已经存在，不添加［原则和hashset一样］）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tail.next＝ newElement;  <span class="comment">// 简单指定</span></span><br><span class="line">newElement.pre tail;</span><br><span class="line">tail newEelment;</span><br></pre></td></tr></table></figure></li><li><p><strong>遍历顺序</strong>：由于元素是按照添加顺序连续链接的，遍历 <code>LinkedHashSet</code> 时，可以通过从 <code>head</code> 开始，沿着 <code>next</code> 指针顺序遍历，确保遍历顺序与插入顺序一致</p></li></ul><h2 id="6-Map"><a href="#6-Map" class="headerlink" title="6. Map"></a>6. Map</h2><h3 id="6-1-Map-接口和常用方法"><a href="#6-1-Map-接口和常用方法" class="headerlink" title="6.1 Map 接口和常用方法"></a>6.1 Map 接口和常用方法</h3><blockquote><p>JDK8 的 Map 接口实现类的特点</p></blockquote><ul><li><strong>并列于 Collection</strong>：<code>Map</code> 接口是与 <code>Collection</code> 接口平行的一个独立接口。意味着 <code>Map</code> 和 <code>Collection</code> 处理的是不同类型的数据结构——<code>Map</code> 主要用于存储键值对，而 <code>Collection</code> 用于存储一组元素</li><li><strong>键值对存储</strong>：<code>Map</code> 存储的是键值对，每个键映射到一个特定的值。key 和 value 可以是任何引用类型的数据，封装到<code>HashMap$Node</code> 对象中，<code>HashMap$Node</code> 是 <code>HashMap</code> 中实现键值对存储的内部类，它封装了键（Key）和值（Value）</li></ul><blockquote><p>编译器使用 <code>$</code> 符号将外部类名和内部类名连接起来。例如，如果 <code>HashMap</code> 类中有一个名为 <code>Node</code> 的内部类，编译后的类名会是 <code>HashMap$Node</code></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;  <span class="comment">// HashMap$Node 实现了 Map$Entry</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>键（Key）的特性</strong>：</p><ul><li><strong>唯一性</strong>：每个键在 <code>Map</code> 中必须是唯一的。如果尝试插入一个已存在的键，其对应的值将被新的值替换（除非操作特别指定不这么做）</li><li><strong><code>null</code> 键</strong>：大多数 <code>Map</code> 实现（如 <code>HashMap</code>）允许有一个键为 <code>null</code> 的条目，这在使用时需要特别注意，因为不是所有的 <code>Map</code> 实现都支持 <code>null</code> 键（例如 <code>TreeMap</code> 默认不支持 <code>null</code> 键）</li></ul></li><li><p><strong>值（Value）的特性</strong>：<code>Map</code> 中的值可以重复，即不同的键可以映射到相同的值</p></li><li><p><strong>使用场景</strong>：</p><ul><li><p><strong>字符串键</strong>：<code>String</code> 类型是作为 <code>Map</code> 的键非常常见的选择，主要是因为其不变性和已经有效重写的 <code>hashCode()</code> 和 <code>equals()</code> 方法，这使得 <code>String</code> 作为键既安全又高效</p></li><li><p><strong>单向关联</strong>：每个键与一个值之间存在<strong>单向的一对一关系</strong>，通过键总能检索到一个确定的值，这是 <code>Map</code> 结构的核心特征</p></li></ul></li><li><p><strong>EntrySet、KeySet 和 ValueCollection</strong>：</p><ul><li>Map 中一对 k-v 最后是 <code>HashMap$Node node = newNode(hash, key, value, null)</code>，又因为Node 实现了 Entry 接口，有些书上也说一对 k-v 就是一个 Entry</li><li>为了方便 k-v  遍历，还会 创建 EntrySet 集合</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HashMap</span></span><br><span class="line"><span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br></pre></td></tr></table></figure><ul><li><strong>EntrySet</strong>：<ul><li><code>EntrySet</code> 是 <code>HashMap</code> 的一个视图，用于以 <code>Map.Entry</code> 对象的形式访问 <code>HashMap</code> 中的每一个键值对。每个 <code>Map.Entry</code> 实际上是 <code>HashMap</code> 内部节点 <code>Node</code> 的表示，它包含键和值的引用（地址）</li><li>遍历 <code>EntrySet</code> 时，实际上是在访问 <code>HashMap</code> 内部存储的每个节点，每个节点都是 <code>Map.Entry</code> 实例，它包含了键值对的信息</li></ul></li><li><strong>KeySet</strong>：<ul><li><code>KeySet</code> 也是 <code>HashMap</code> 的一个视图，它包含 <code>HashMap</code> 中所有的键。它是从 <code>EntrySet</code> 派生出来的，每个元素都是从 <code>EntrySet</code> 中的每个 <code>Entry</code>（即 <code>Node</code>）中提取的键</li><li>遍历 <code>KeySet</code> 或对其进行操作时，实际上是在间接操作那些存储在 <code>Node</code> 中的键</li></ul></li><li><strong>ValueCollection</strong>：<ul><li>类似地，<code>ValueCollection</code> 是 <code>HashMap</code> 中所有值的集合。它也是从 <code>EntrySet</code> 派生的，每个元素都是从 <code>EntrySet</code> 中的 <code>Entry</code>（即 <code>Node</code>）中提取的值</li><li><code>ValueCollection</code> 允许你遍历或查看所有值，但是和键不同，值是可以重复的</li></ul></li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/Java%E9%9B%86%E5%90%88.assets/image-20240430104936091.png" alt="image-20240430104936091"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个HashMap</span></span><br><span class="line">        HashMap&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向HashMap中添加一些键值对</span></span><br><span class="line">        map.put(<span class="string">&quot;apple&quot;</span>, <span class="number">10</span>);</span><br><span class="line">        map.put(<span class="string">&quot;banana&quot;</span>, <span class="number">20</span>);</span><br><span class="line">        map.put(<span class="string">&quot;orange&quot;</span>, <span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用entrySet()获取Map中的所有键值对</span></span><br><span class="line">        Set&lt;Map.Entry&lt;String, Integer&gt;&gt; entries = map.entrySet();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历entries集合</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : entries) &#123;</span><br><span class="line">            System.out.println(entry.getKey() + <span class="string">&quot; -&gt; &quot;</span> + entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>常用方法</strong>：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">    map.put(<span class="string">&quot;11&quot;</span>, <span class="keyword">new</span> <span class="title class_">Book</span>(<span class="string">&quot;&quot;</span>, <span class="number">100</span>));  <span class="comment">// OK</span></span><br><span class="line">    map.put(<span class="string">&quot;11&quot;</span>, <span class="string">&quot;22&quot;</span>);  <span class="comment">// 替换-&gt; 一会分析源码</span></span><br><span class="line">    map.put(<span class="string">&quot;33&quot;</span>, <span class="string">&quot;44&quot;</span>);  <span class="comment">// OK</span></span><br><span class="line">    map.put(<span class="string">&quot;55&quot;</span>, <span class="string">&quot;44&quot;</span>);  <span class="comment">// OK</span></span><br><span class="line">    map.put(<span class="string">&quot;66&quot;</span>, <span class="literal">null</span>);  <span class="comment">// OK</span></span><br><span class="line">    map.put(<span class="literal">null</span>, <span class="string">&quot;77&quot;</span>);  <span class="comment">// OK</span></span><br><span class="line">    map.put(<span class="string">&quot;88&quot;</span>, <span class="string">&quot;99&quot;</span>);  <span class="comment">// OK</span></span><br><span class="line">    map.put(<span class="string">&quot;hh&quot;</span>, <span class="string">&quot;ee&quot;</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;map = &quot;</span> + map);</span><br><span class="line">    <span class="comment">// map = &#123;11=22, 33=44, 55=44, 66=null, null=77, 88=99, hh=ee&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// remove: 根据键删除映射关系</span></span><br><span class="line">    map.remove(<span class="literal">null</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;map = &quot;</span> + map);</span><br><span class="line">    <span class="comment">// map = &#123;11=22, 33=44, 55=44, 66=null, 88=99, hh=ee&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// get: 根据键获取值</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">val</span> <span class="operator">=</span> map.get(<span class="string">&quot;88&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;val = &quot;</span> + val);  <span class="comment">// val = 99</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// size: 获取元素个数</span></span><br><span class="line">    System.out.println(<span class="string">&quot;k-v = &quot;</span> + map.size());  <span class="comment">// k-v = 6</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// isEmpty: 判断个数是否为 0</span></span><br><span class="line">    System.out.println(map.isEmpty());  <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// clear: 清除k-v</span></span><br><span class="line">    <span class="comment">// map.clear();</span></span><br><span class="line">    <span class="comment">// System.out.println(&quot;map = &quot; + map);  // map = &#123;&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// containsKey: 查找键是否存在</span></span><br><span class="line">    System.out.println(<span class="string">&quot;result = &quot;</span> + map.containsKey(<span class="string">&quot;hh&quot;</span>));  <span class="comment">// result = true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-2-Map-六大遍历方式"><a href="#6-2-Map-六大遍历方式" class="headerlink" title="6.2 Map 六大遍历方式"></a>6.2 Map 六大遍历方式</h3><blockquote><p>entrySet：获取所有的关系K-V</p><p>KeySet：获取所有的键</p><p>values：获取所有的值</p></blockquote><ul><li><p><strong>通过 <code>keySet()</code> 遍历键并获取对应的值</strong></p><ul><li><p><strong>增强 for 循环</strong>：直接遍历键集合，然后使用 <code>map.get(key)</code> 来获取每个键对应的值</p></li><li><p><strong>迭代器</strong>：使用迭代器来遍历键集合，同样使用 <code>map.get(key)</code> 获取值</p></li></ul></li><li><p><strong>通过 <code>values()</code> 遍历所有值</strong>：这种方法只关注值，不涉及键</p><ul><li><p><strong>增强 for 循环</strong>：直接遍历值集合</p></li><li><p><strong>迭代器</strong>：使用迭代器遍历值集合</p></li></ul></li><li><p><strong>通过 <code>entrySet()</code> 直接遍历键值对</strong>：</p><ul><li><p><strong>增强 for 循环</strong>：遍历 <code>Entry</code> 集合，可以直接使用 <code>Map.Entry</code> 接口的 <code>getKey()</code> 和 <code>getValue()</code> 方法访问键和值</p></li><li><p><strong>迭代器</strong>：使用迭代器遍历 <code>Entry</code> 集合，对于每个迭代出的对象，同样使用 <code>Map.Entry</code> 的方法来获取键和值</p></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一组: 先取出 所有的 Key, 通过 Key 取出对应的 Value</span></span><br><span class="line"><span class="type">Set</span> <span class="variable">keySet</span> <span class="operator">=</span> map.keySet();</span><br><span class="line"><span class="comment">// (1) 增强 for</span></span><br><span class="line">System.out.println(<span class="string">&quot;-----第一种方式-------&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (Object key : keySet) &#123;</span><br><span class="line">    System.out.println(key + <span class="string">&quot;-&quot;</span> + map.get(key));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// (2) 迭代器</span></span><br><span class="line">System.out.println(<span class="string">&quot;----第二种方式--------&quot;</span>);</span><br><span class="line"><span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> keySet.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">key</span> <span class="operator">=</span>  iterator.next();</span><br><span class="line">    System.out.println(key + <span class="string">&quot;-&quot;</span> + map.get(key));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二组: 把所有的 values 取出</span></span><br><span class="line"><span class="type">Collection</span> <span class="variable">values</span> <span class="operator">=</span> map.values();</span><br><span class="line"><span class="comment">// 这里可以使用所有的 Collections 使用的遍历方法</span></span><br><span class="line"><span class="comment">// (1) 增强 for</span></span><br><span class="line">System.out.println(<span class="string">&quot;---取出所有的value 增强for----&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (Object value : values) &#123;</span><br><span class="line">    System.out.println(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// (2) 迭代器</span></span><br><span class="line">System.out.println(<span class="string">&quot;---取出所有的value 迭代器----&quot;</span>);</span><br><span class="line"><span class="type">Iterator</span> <span class="variable">iterator2</span> <span class="operator">=</span> values.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator2.hasNext()) &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span>  iterator2.next();</span><br><span class="line">    System.out.println(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三组: 通过 EntrySet 来获取 k-v</span></span><br><span class="line"><span class="type">Set</span> <span class="variable">entrySet</span> <span class="operator">=</span> map.entrySet();  <span class="comment">// EntrySet&lt;Map.Entry&lt;K,V&gt;&gt;</span></span><br><span class="line"><span class="comment">// (1) 增强 for</span></span><br><span class="line">System.out.println(<span class="string">&quot;----使用 EntrySet 的 for 增强----&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (Object entry : entrySet) &#123;</span><br><span class="line">    <span class="comment">// 将 entry 转成 Map.Entry</span></span><br><span class="line">    Map.<span class="type">Entry</span> <span class="variable">m</span> <span class="operator">=</span> (Map.Entry) entry;</span><br><span class="line">    System.out.println(m.getKey() + <span class="string">&quot;-&quot;</span> + m.getValue());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// (2) 迭代器</span></span><br><span class="line">System.out.println(<span class="string">&quot;----使用 EntrySet 的 迭代器----&quot;</span>);</span><br><span class="line"><span class="type">Iterator</span> <span class="variable">iterator3</span> <span class="operator">=</span> entrySet.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator3.hasNext()) &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">entry</span> <span class="operator">=</span>  iterator3.next();</span><br><span class="line">    <span class="comment">// System.out.println(next.getClass());  // HashMap$Node -实现-&gt; Map.Entry (getKey,getValue), 后者提供了获取 k-v 的方法</span></span><br><span class="line">    <span class="comment">// 向下转型 Map.Entry</span></span><br><span class="line">    Map.<span class="type">Entry</span> <span class="variable">m</span> <span class="operator">=</span> (Map.Entry) entry;</span><br><span class="line">    System.out.println(m.getKey() + <span class="string">&quot;-&quot;</span> + m.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>使用 <code>forEach()</code> 方法（Java 8+）</strong>：使用 <code>forEach()</code> 方法和 Lambda 表达式来遍历 <code>Map</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">map.forEach((key, value) -&gt; &#123;</span><br><span class="line">    <span class="comment">// 处理键和值</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li><strong>注意</strong>：<ul><li>在遍历集合时尝试修改集合的结构（添加或删除元素）通常是不安全的，除非通过迭代器的 <code>remove()</code> 方法删除元素</li><li>修改集合中元素的内部状态（不是集合结构）通常是安全的，如更改对象的属性</li><li>增加对集合的任何操作，特别是在遍历过程中，都应该非常小心处理以避免运行时错误</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 练习</span></span><br><span class="line">Map&lt;Integer, Emp&gt; hashMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">hashMap.put(<span class="number">1</span>, <span class="keyword">new</span> <span class="title class_">Emp</span>(<span class="number">1</span>, <span class="string">&quot;h&quot;</span>, <span class="number">1.0</span>));</span><br><span class="line">hashMap.put(<span class="number">2</span>, <span class="keyword">new</span> <span class="title class_">Emp</span>(<span class="number">2</span>, <span class="string">&quot;hh&quot;</span>, <span class="number">2.0</span>));</span><br><span class="line">hashMap.put(<span class="number">3</span>, <span class="keyword">new</span> <span class="title class_">Emp</span>(<span class="number">3</span>, <span class="string">&quot;hhh&quot;</span>, <span class="number">3.0</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 增强 for keySet</span></span><br><span class="line">System.out.println(<span class="string">&quot;======使用增强for======&quot;</span>);</span><br><span class="line">Set&lt;Integer&gt; integers = hashMap.keySet();</span><br><span class="line"><span class="keyword">for</span> (Integer integer : integers) &#123;</span><br><span class="line">    <span class="keyword">if</span> (hashMap.get(integer).getSal() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        System.out.println(hashMap.get(integer));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代器 keySet</span></span><br><span class="line">System.out.println(<span class="string">&quot;=====使用迭代器=====&quot;</span>);</span><br><span class="line">Iterator&lt;Integer&gt; iteratorKey = integers.iterator();</span><br><span class="line"><span class="keyword">while</span> (iteratorKey.hasNext()) &#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">key</span> <span class="operator">=</span> iteratorKey.next();</span><br><span class="line">    <span class="keyword">if</span> (hashMap.get(key).getSal() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        System.out.println(hashMap.get(key));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 增强 for entrySet</span></span><br><span class="line">System.out.println(<span class="string">&quot;=====使用增强for=====&quot;</span>);</span><br><span class="line">Set&lt;Map.Entry&lt;Integer, Emp&gt;&gt; entries = hashMap.entrySet();</span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;Integer, Emp&gt; entry : entries) &#123;</span><br><span class="line">    <span class="keyword">if</span> (entry.getValue().getSal() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        System.out.println(entry.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代器 entrySet</span></span><br><span class="line">System.out.println(<span class="string">&quot;=====使用迭代器=====&quot;</span>);</span><br><span class="line">Iterator&lt;Map.Entry&lt;Integer, Emp&gt;&gt; iterator = entries.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    Map.Entry&lt;Integer, Emp&gt; entry = iterator.next();</span><br><span class="line">    <span class="keyword">if</span> (entry.getValue().getSal() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        System.out.println(entry.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-3-Map-接口实现类-HashMap"><a href="#6-3-Map-接口实现类-HashMap" class="headerlink" title="6.3 Map 接口实现类-HashMap"></a>6.3 Map 接口实现类-HashMap</h3><h4 id="基本介绍-3"><a href="#基本介绍-3" class="headerlink" title="基本介绍"></a>基本介绍</h4><ul><li><p>HashMap 是 Map 接口使用频率最高的实现类</p></li><li><p><strong>线程不安全</strong>：HashMap 没有实现同步</p></li></ul><h4 id="底层机制和源码"><a href="#底层机制和源码" class="headerlink" title="底层机制和源码"></a>底层机制和源码</h4><ul><li><strong>初始化和负载因子</strong>：<ul><li><strong>默认构造函数</strong>：在实例化 <code>HashMap</code> 时，内部数组 <code>table</code> 是 <code>null</code>。直到第一次插入元素时，才进行实际的内存分配</li><li><strong>负载因子</strong>：负载因子 <code>loadFactor</code> 默认为 <code>0.75</code>，这是空间和时间成本的折中选择。负载因子决定了 <code>HashMap</code> 扩容的时间点</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/Java%E9%9B%86%E5%90%88.assets/image-20240430144137292.png" alt="image-20240430144137292"></p><ul><li><p><strong>内部数组和节点</strong>：<code>HashMap</code> 使用 <code>Node</code> 类型的数组 <code>table</code> 来存储键值对。<code>Node</code> 是 <code>HashMap</code> 的一个内部静态类，每个 <code>Node</code> 对象包含一个键、一个值、一个哈希值和指向下一个节点的引用（链表结构）</p></li><li><p><strong>添加元素的处理</strong>：</p><ul><li><strong>索引计算</strong>：通过键的哈希值经过处理后确定在数组 <code>table</code> 中的索引位置</li><li><strong>无冲突时</strong>：如果计算得到的索引位置上没有元素，则直接添加</li><li><strong>有冲突时</strong>：如果位置上已有元素（链表头），则使用链地址法解决冲突：<ul><li>遍历链表，检查是否有相同的键：<ul><li>如果找到相同的键，则替换其值</li><li>如果未找到相同的键，根据链表的长度决定是添加到链表末尾还是树化</li></ul></li></ul></li></ul></li><li><p><strong>扩容与树化</strong>：</p><ul><li><p><strong>扩容</strong>：当 <code>HashMap</code> 的大小超过 <code>threshold</code>（容量 * 负载因子）时，进行扩容，通常是当前容量的两倍。在扩容时，元素需要重新计算索引并分配到新的数组中</p><ul><li>第一次添加，则需要扩容table容量为16，临界值（threshold）为12（16*0.75）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">else</span> &#123; </span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>[newCap];</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>以后再扩容，则需要扩容table容量为原来的的2倍（32），临界值为原来的2倍，即24，以此类推；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">        threshold = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">return</span> oldTab;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">             oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">        newThr = oldThr &lt;&lt; <span class="number">1</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>树化</strong>：在 Java 8 中，如果某个索引位置上的链表长度 &gt;&#x3D; <code>TREEIFY_THRESHOLD</code>（默认为 8），并且数组大小 &gt;&#x3D; <code>MIN_TREEIFY_CAPACITY</code>（默认为 64），则链表转换为红黑树，以改善查找效率</p></li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/Java%E9%9B%86%E5%90%88.assets/image-20240430143318938.png" alt="image-20240430143318938"></p><h3 id="6-4-Map-接口实现类-Hashtable"><a href="#6-4-Map-接口实现类-Hashtable" class="headerlink" title="6.4 Map 接口实现类-Hashtable"></a>6.4 Map 接口实现类-Hashtable</h3><h4 id="基本介绍-4"><a href="#基本介绍-4" class="headerlink" title="基本介绍"></a>基本介绍</h4><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/Java%E9%9B%86%E5%90%88.assets/image-20240430165920234.png" alt="image-20240430165920234"></p><ul><li><strong>键值对存储</strong>：<code>Hashtable</code> 是 Java 早期的一部分，用于存储键值对（K-V），每个键映射到一个特定的值。</li><li><strong>空值限制</strong>：在 <code>Hashtable</code> 中，键（Key）和值（Value）都不能为 <code>null</code>，尝试使用 <code>null</code> 作为键或值都会抛出 <code>NullPointerException</code></li><li><strong>线程安全</strong>：<code>Hashtable</code> 的每个方法几乎都是用 <code>synchronized</code> 关键字同步的，因此它是线程安全的，但这也导致了性能上的开销，其他使用方法基本上和 HashMap 一样</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hashtable</span>&lt;K,V&gt;</span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">Dictionary</span>&lt;K,V&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">Map</span>&lt;K,V&gt;, Cloneable, java.io.Serializable &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>逐渐被 <code>ConcurrentHashMap</code> 替代</strong>：<ul><li>尽管 <code>Hashtable</code> 是线程安全的，但它的一个主要缺点是它<strong>锁定整个集合来同步不同的方法调用</strong>，这可能导致严重的性能瓶颈</li><li>现代的替代品，如 <strong><code>ConcurrentHashMap</code>，提供了更高的并发性能，因为它使用分段锁</strong></li></ul></li></ul><h4 id="扩容机制"><a href="#扩容机制" class="headerlink" title="扩容机制"></a>扩容机制</h4><ul><li><strong>初始容量和负载因子</strong>：<code>Hashtable</code> 默认的初始容量是 11，而负载因子是 0.75。这意味着当 <code>Hashtable</code> 中的条目数量达到容量和负载因子乘积的结果时（大约是 8），<code>Hashtable</code> 会进行扩容</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Hashtable</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 默认构造函数创建一个初始容量为 11 和负载因子为 0.75 的 Hashtable</span></span><br><span class="line">    <span class="built_in">this</span>(<span class="number">11</span>, <span class="number">0.75f</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Hashtable</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal Load: &quot;</span>+loadFactor);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity==<span class="number">0</span>)</span><br><span class="line">        initialCapacity = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">this</span>.loadFactor = loadFactor;</span><br><span class="line">    table = <span class="keyword">new</span> <span class="title class_">Entry</span>&lt;?,?&gt;[initialCapacity];</span><br><span class="line">    <span class="comment">// 计算触发扩容的阈值，是初始容量与负载因子的乘积，但不超过 MAX_ARRAY_SIZE + 1</span></span><br><span class="line">    threshold = (<span class="type">int</span>)Math.min(initialCapacity * loadFactor, MAX_ARRAY_SIZE + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/Java%E9%9B%86%E5%90%88.assets/image-20240430155922235.png" alt="image-20240430155922235"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Hashtable 中的节点，存储每个键值对</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Entry&lt;K,V&gt; next;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>put 方法</strong>：<ul><li>使用 <code>synchronized</code> 关键字声明，确保在多线程环境中的线程安全</li><li>检查传入的 <code>value</code> 是否为 <code>null</code>，因为 <code>Hashtable</code> 不允许存储 <code>null</code> 值。如果 <code>value</code> 为 <code>null</code>，抛出 NPE</li><li>使用键的 <code>hashCode()</code> 方法计算哈希值，并通过与数组长度的取模操作得到数组索引</li><li>如果在链表中没有找到相同的键，调用 <code>addEntry</code> 方法将新的键值对添加到链表的头部</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="comment">// 确保值不为 null，Hashtable 不允许 null 值</span></span><br><span class="line">    <span class="keyword">if</span> (value == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取哈希表的引用</span></span><br><span class="line">    Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">    <span class="comment">// 计算键的哈希值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> key.hashCode();</span><br><span class="line">    <span class="comment">// 计算哈希值对应的索引，使用掩码 0x7FFFFFFF 确保索引为正数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">    <span class="comment">// 获取对应索引处的链表头节点</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    Entry&lt;K,V&gt; entry = (Entry&lt;K,V&gt;)tab[index];</span><br><span class="line">    <span class="comment">// 遍历链表，查找是否存在相同的键</span></span><br><span class="line">    <span class="keyword">for</span> (; entry != <span class="literal">null</span>; entry = entry.next) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((entry.hash == hash) &amp;&amp; entry.key.equals(key)) &#123;</span><br><span class="line">            <span class="comment">// 如果找到相同的键，则更新其值</span></span><br><span class="line">            <span class="type">V</span> <span class="variable">old</span> <span class="operator">=</span> entry.value;</span><br><span class="line">            entry.value = value;</span><br><span class="line">            <span class="comment">// 返回旧值</span></span><br><span class="line">            <span class="keyword">return</span> old;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果没有找到相同的键，添加新的键值对</span></span><br><span class="line">    addEntry(hash, key, value, index);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;  <span class="comment">// 插入新键值对时返回 null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>扩容过程</strong>：HashTable 用的头插，HashMap 用的尾插<ul><li><strong>添加新键值对（<code>addEntry()</code> 方法）</strong><ul><li>如果 <code>Hashtable</code> 中的元素数量达到了阈值（<code>threshold</code>），则触发 <code>rehash()</code> 方法进行扩容</li><li>扩容完成后，重新计算当前新元素键的哈希索引，以确定它在新表中的位置</li><li>在确定的索引位置，使用链表的头插法将新元素插入</li></ul></li><li><strong>执行扩容操作（<code>rehash()</code> 方法）</strong><ul><li>计算新容量</li><li>根据新的容量创建一个新的 <code>Entry</code> 数组并<strong>重新哈希旧元素</strong>，更新 <code>threshold</code> 为新容量与负载因子的乘积</li></ul></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// addEntry()</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addEntry</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">    modCount++;  <span class="comment">// 增加修改次数，用于迭代器快速失败行为</span></span><br><span class="line"></span><br><span class="line">    Entry&lt;?,?&gt; tab[] = table;  <span class="comment">// 获取当前哈希表的引用</span></span><br><span class="line">    <span class="keyword">if</span> (count &gt;= threshold) &#123;  <span class="comment">// 检查当前元素数量是否达到阈值</span></span><br><span class="line">        rehash();  <span class="comment">// 执行扩容和重新哈希</span></span><br><span class="line"></span><br><span class="line">        tab = table;  <span class="comment">// 重新获取扩容后的哈希表引用</span></span><br><span class="line">        hash = key.hashCode();  <span class="comment">// 重新计算键的哈希值，因为数组大小已改变</span></span><br><span class="line">        index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;  <span class="comment">// 根据新的哈希表大小重新计算索引</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;) tab[index];  <span class="comment">// 获取当前索引位置的头节点</span></span><br><span class="line">    tab[index] = <span class="keyword">new</span> <span class="title class_">Entry</span>&lt;&gt;(hash, key, value, e);  <span class="comment">// 创建新节点并将其插入链表头部（头插法）</span></span><br><span class="line">    count++;  <span class="comment">// 增加Hashtable的元素计数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// rehash()</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">rehash</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> table.length;</span><br><span class="line">    Entry&lt;?,?&gt;[] oldMap = table;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新容量是旧容量的两倍加一</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> (oldCapacity &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 如果新容量超过了 MAX_ARRAY_SIZE</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 检查旧容量是否已是最大</span></span><br><span class="line">        <span class="keyword">if</span> (oldCapacity == MAX_ARRAY_SIZE)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 不是则调整为最大容量</span></span><br><span class="line">        newCapacity = MAX_ARRAY_SIZE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建新的 Entry 数组以容纳更多元素</span></span><br><span class="line">    Entry&lt;?,?&gt;[] newMap = <span class="keyword">new</span> <span class="title class_">Entry</span>&lt;?,?&gt;[newCapacity];</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    threshold = (<span class="type">int</span>)Math.min(newCapacity * loadFactor, MAX_ARRAY_SIZE + <span class="number">1</span>);</span><br><span class="line">    table = newMap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历旧数组，将每个元素重新哈希到新数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> oldCapacity ; i-- &gt; <span class="number">0</span> ;) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; old = (Entry&lt;K,V&gt;)oldMap[i] ; old != <span class="literal">null</span> ; ) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; e = old;</span><br><span class="line">            old = old.next;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 使用元素的哈希值和新容量计算新索引</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (e.hash &amp; <span class="number">0x7FFFFFFF</span>) % newCapacity;</span><br><span class="line">            <span class="comment">// 将元素重新链接到新数组的相应位置</span></span><br><span class="line">            e.next = (Entry&lt;K,V&gt;)newMap[index];</span><br><span class="line">            newMap[index] = e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-5-Map-接口实现类-Properties"><a href="#6-5-Map-接口实现类-Properties" class="headerlink" title="6.5 Map 接口实现类-Properties"></a>6.5 Map 接口实现类-Properties</h3><h4 id="基本介绍-5"><a href="#基本介绍-5" class="headerlink" title="基本介绍"></a>基本介绍</h4><ul><li><strong>继承和实现</strong>：<code>Properties</code> 类继承自 <code>Hashtable</code>。因此，它本质上是一个 <code>Hashtable</code>，键和值不允许为 <code>null</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Properties</span> <span class="keyword">extends</span> <span class="title class_">Hashtable</span>&lt;Object,Object&gt; &#123;</span><br><span class="line"><span class="keyword">protected</span> Properties defaults;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Properties</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Properties</span><span class="params">(Properties defaults)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.defaults = defaults;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/Java%E9%9B%86%E5%90%88.assets/image-20240430171201601.png" alt="image-20240430171201601"></p><ul><li><p><strong>用途</strong>：<code>Properties</code> 主要用于管理配置数据，这些数据存储在键值对形式的属性文件（<code>.properties</code> 文件）中</p></li><li><p><strong>文件操作</strong>：<code>Properties</code> 提供了方便的方法来从文件加载数据 (<code>load()</code>) 和向文件写入数据 (<code>store()</code>)，使其非常适合读取和存储配置文件</p></li><li><p><strong>功能特点</strong>：</p><ul><li><strong>加载和存储</strong>：<ul><li><strong>加载（<code>load()</code> 方法）</strong>：可以从一个输入流（如文件输入流）中读取属性列表（键和元素对）。支持从 XML 和普通属性文件格式加载</li><li><strong>存储（<code>store()</code> 方法）</strong>：可以将 <code>Properties</code> 对象中的数据写入到输出流，同样支持 XML 和普通属性文件格式</li></ul></li><li><strong>与系统属性的交互</strong>：<ul><li><code>Properties</code> 类可以与系统属性直接交互，使用 <code>System.getProperties()</code> 获取当前系统属性</li></ul></li><li><strong>默认值机制</strong>：<ul><li><code>Properties</code> 可以指定一个包含默认值的 <code>Properties</code> 对象。如果主 <code>Properties</code> 对象中没有找到相应的键，那么将会搜索这个默认值 <code>Properties</code></li></ul></li></ul></li></ul><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 解读</span></span><br><span class="line">    <span class="comment">// 1. Properties 继承  Hashtable</span></span><br><span class="line">    <span class="comment">// 2. 可以通过 k-v 存放数据, key 和 value 不能为 null</span></span><br><span class="line">    <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">    <span class="comment">// 增加</span></span><br><span class="line">    <span class="comment">// properties.put(null, &quot;abc&quot;);  // 抛出 空指针异常</span></span><br><span class="line">    <span class="comment">// properties.put(&quot;abc&quot;, null);  // 抛出 空指针异常</span></span><br><span class="line">    properties.put(<span class="string">&quot;john&quot;</span>, <span class="number">100</span>);  <span class="comment">// k-v</span></span><br><span class="line">    properties.put(<span class="string">&quot;lucy&quot;</span>, <span class="number">100</span>);</span><br><span class="line">    properties.put(<span class="string">&quot;lic&quot;</span>, <span class="number">100</span>);</span><br><span class="line">    properties.put(<span class="string">&quot;lic&quot;</span>, <span class="number">88</span>);  <span class="comment">// 如果有相同的 key, value被替换</span></span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;properties=&quot;</span> + properties);</span><br><span class="line">    <span class="comment">// properties=&#123;john=100, lic=88, lucy=100&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找, 通过 key 获取对应值</span></span><br><span class="line">    <span class="comment">// get(Object key) 方法来自 Hashtable 类，它返回与指定键关联的值</span></span><br><span class="line">    <span class="comment">// 这个方法会返回任何类型的对象</span></span><br><span class="line">    System.out.println(properties.get(<span class="string">&quot;lic&quot;</span>));  <span class="comment">// 88</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// getProperty(String key) 方法是 Properties 类特有的，它只返回字符串类型的值</span></span><br><span class="line">    <span class="comment">// 如果值不是字符串，getProperty 方法将返回 null</span></span><br><span class="line">    System.out.println(properties.getProperty(<span class="string">&quot;lic&quot;</span>));  <span class="comment">// null</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除</span></span><br><span class="line">    properties.remove(<span class="string">&quot;lic&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;properties = &quot;</span> + properties);  <span class="comment">// properties = &#123;john=100, lucy=100&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改</span></span><br><span class="line">    properties.put(<span class="string">&quot;john&quot;</span>, <span class="string">&quot;约翰&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;properties = &quot;</span> + properties);  <span class="comment">// properties = &#123;john=约翰, lucy=100&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>使用 <code>Properties</code> 类加载和存储属性文件的示例</strong>：</p><ul><li><code>config.properties</code> 示例：</li></ul><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">username</span>=<span class="string">admin</span></span><br><span class="line"><span class="attr">password</span>=<span class="string">secret</span></span><br><span class="line"><span class="attr">database</span>=<span class="string">localhost</span></span><br><span class="line"><span class="attr">port</span>=<span class="string">3306</span></span><br></pre></td></tr></table></figure><ul><li>代码示例：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PropertiesExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Properties</span> <span class="variable">props</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 加载属性文件</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;config.properties&quot;</span>);</span><br><span class="line">        props.load(in);</span><br><span class="line">        in.close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取属性</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> props.getProperty(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Username: &quot;</span> + username);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 修改/添加属性</span></span><br><span class="line">        props.setProperty(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;newUsername&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 存储修改后的属性文件</span></span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;config.properties&quot;</span>);</span><br><span class="line">        props.store(out, <span class="string">&quot;Updated username&quot;</span>);</span><br><span class="line">        out.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="7-TreeSet-和-TreeMap-源码分析"><a href="#7-TreeSet-和-TreeMap-源码分析" class="headerlink" title="7. TreeSet 和 TreeMap 源码分析"></a>7. TreeSet 和 TreeMap 源码分析</h2><h3 id="7-1-TreeSet-分析"><a href="#7-1-TreeSet-分析" class="headerlink" title="7.1 TreeSet 分析"></a>7.1 TreeSet 分析</h3><ul><li><code>TreeSet</code> 是基于 <code>TreeMap</code> 实现的，它利用 <code>TreeMap</code> 来保持元素的有序性和唯一性。<code>TreeMap</code> 本质上是一个红黑树实现的排序映射表，<code>TreeMap</code> 有一个属性是 <code>comparator</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TreeMap.java</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Comparator&lt;? <span class="built_in">super</span> K&gt; comparator;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">TreeMap</span><span class="params">()</span> &#123;</span><br><span class="line">    comparator = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">TreeMap</span><span class="params">(Comparator&lt;? <span class="built_in">super</span> K&gt; comparator)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.comparator = comparator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>TreeSet 实现了 Set 接口，与 HashSet 最大的区别是可以排序</li></ul><blockquote><p><code>TreeSet</code> 继承自 <code>AbstractSet</code>，后者提供了 <code>Set</code> 接口的骨架实现；<code>TreeSet</code> 实现了 <code>NavigableSet</code> 接口，该接口扩展了 <code>SortedSet</code> 并提供导航方法</p></blockquote><ul><li><p><strong>构造函数</strong>：</p><ul><li><strong>无参构造器</strong>：使用无参构造器创建 <code>TreeSet</code> 时，默认情况下是基于自然排序的，需要存储在 <code>TreeSet</code> 中的元素实现 <code>Comparable</code> 接口</li></ul><blockquote><p>自然排序指的是基于元素自身的特性进行排序，而不需要外部指定排序规则</p><p>对于整数，自然排序就是按照数字大小进行排序；对于字符串，自然排序是按照字典顺序进行排序</p><p>对于字符串，String 类实现了 Comparable 接口，因此它支持自然排序。String 类的 compareTo 方法会按照字典顺序比较字符串的大小</p></blockquote><ul><li><strong>带比较器构造器</strong>：如果提供了一个比较器(传入了匿名内部类并指定排序规则)，<code>TreeSet</code> 会使用这个比较器来创建一个 <code>TreeMap</code>，允许对元素进行自定义排序</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TreeSet.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeSet</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractSet</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">NavigableSet</span>&lt;E&gt;, Cloneable, java.io.Serializable &#123;</span><br><span class="line">    <span class="comment">// TreeSet 的内部使用了一个 NavigableMap 来存储其元素, 元素作为键存储在此 Map 中</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> NavigableMap&lt;E,Object&gt; m;</span><br><span class="line">    <span class="comment">// 用于与 TreeSet 中的每个元素（作为键）关联, 方便利用 TreeMap 来实现 TreeSet</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">PRESENT</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 无参数构造器, 内部会创建一个基于自然排序的 TreeMap</span></span><br><span class="line">    <span class="comment">// 意味着元素需要具有可比性, 即元素类型 E 必须实现 Comparable 接口</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TreeSet</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(<span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;E,Object&gt;());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 允许用户提供一个自定义的比较器 Comparator 用于元素的排序</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TreeSet</span><span class="params">(Comparator&lt;? <span class="built_in">super</span> E&gt; comparator)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(<span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;(comparator));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Comparator 接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Comparator</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>代码示例</strong>：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TreeSet treeSet = new TreeSet();</span></span><br><span class="line"><span class="comment">// 创建一个 TreeSet 实例，提供自定义的 Comparator 比较器</span></span><br><span class="line"><span class="type">TreeSet</span> <span class="variable">treeSet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeSet</span>(<span class="keyword">new</span> <span class="title class_">Comparator</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object o1, Object o2)</span> &#123;</span><br><span class="line">        <span class="comment">// 调用 String 的 compareTo 方法进行字符串大小比较，若字符串内容完全相同，则不再添加</span></span><br><span class="line">        <span class="comment">// o2 - o1 是从大到小, 此处若想从小到大可直接利用 String 的自然排序(无参构造即可)</span></span><br><span class="line">        <span class="comment">// 从大到小也有使用有参构造的更加方便的写法: new TreeSet&lt;&gt;(Comparator.reverseOrder());</span></span><br><span class="line">        <span class="comment">// return ((String) o2).compareTo((String) o1);  // treeSet=[tom, sp, jack, abc, a]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将对象 o1 和 o2 强制类型转换为 String，然后按照它们的长度进行比较，从而实现自定义排序</span></span><br><span class="line">        <span class="comment">// 如果 o1 的长度小于 o2 的长度，返回负数；如果长度相等，返回 0；如果 o1 的长度大于 o2 的长度，返回正数</span></span><br><span class="line">        <span class="comment">// 返回 0 时，TreeSet 认为这两个元素相等，因此不会添加重复长度的元素</span></span><br><span class="line">        <span class="comment">// 此处 o1 - o2 为从短到长排序</span></span><br><span class="line">        <span class="keyword">return</span> ((String) o1).length() - ((String) o2).length();  <span class="comment">// treeSet=[a, sp, tom, jack]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以用 lambda 表达式简写为:</span></span><br><span class="line"><span class="comment">// TreeSet treeSet = new TreeSet(Comparator.comparingInt(o -&gt; ((String) o).length()));</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加数据</span></span><br><span class="line">treeSet.add(<span class="string">&quot;jack&quot;</span>);</span><br><span class="line">treeSet.add(<span class="string">&quot;tom&quot;</span>);  <span class="comment">// 3</span></span><br><span class="line">treeSet.add(<span class="string">&quot;sp&quot;</span>);</span><br><span class="line">treeSet.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">treeSet.add(<span class="string">&quot;abc&quot;</span>);  <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;treeSet=&quot;</span> + treeSet);</span><br></pre></td></tr></table></figure><ul><li><strong>String 类的 compareTo 方法</strong>：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(String anotherString)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取字符串的长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len1</span> <span class="operator">=</span> value.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len2</span> <span class="operator">=</span> anotherString.value.length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算两个字符串中长度较小的值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">lim</span> <span class="operator">=</span> Math.min(len1, len2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取字符串的字符数组</span></span><br><span class="line">        <span class="type">char</span> v1[] = value;</span><br><span class="line">        <span class="type">char</span> v2[] = anotherString.value;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 循环比较两个字符串的每个字符，直到其中一个字符串结束</span></span><br><span class="line">        <span class="keyword">while</span> (k &lt; lim) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c1</span> <span class="operator">=</span> v1[k];</span><br><span class="line">            <span class="type">char</span> <span class="variable">c2</span> <span class="operator">=</span> v2[k];</span><br><span class="line">            <span class="keyword">if</span> (c1 != c2) &#123;</span><br><span class="line">                <span class="comment">// 返回两个字符的差值，如果 c1 &lt; c2，结果为负，反之为正</span></span><br><span class="line">                <span class="keyword">return</span> c1 - c2;</span><br><span class="line">            &#125;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果所有比较的字符都相同，则比较字符串长度，返回长度差, 意味着较短的字符串被视为较小</span></span><br><span class="line">        <span class="keyword">return</span> len1 - len2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>带比较器构造器调用过程</strong>：<ul><li>构造器把传入的比较器对象，赋给了 <code>TreeSet</code> 底层的 <code>TreeMap</code> 的属性 <code>this.comparator</code></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TreeSet.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">TreeSet</span><span class="params">(Comparator&lt;? <span class="built_in">super</span> E&gt; comparator)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(<span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;(comparator));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// TreeMap.java</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Comparator&lt;? <span class="built_in">super</span> K&gt; comparator;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">TreeMap</span><span class="params">(Comparator&lt;? <span class="built_in">super</span> K&gt; comparator)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.comparator = comparator;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TreeSet.java 的 add 方法</span></span><br><span class="line"><span class="comment">// NavigableMap 接口继承了 SortedMap 接口, 后者又继承自 Map 接口, 这里 NavigableMap 实际使用的是 TreeMap 实例</span></span><br><span class="line"><span class="comment">// 使用接口类型声明一个变量时, 可以将任何实现了该接口的类的实例赋值给这个变量, 变量在编译时表现为接口类型，在运行时表现为实际对象的类型</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> NavigableMap&lt;E,Object&gt; m;</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> m.put(e, PRESENT)==<span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TreeMap.java 里的 put 方法</span></span><br><span class="line"><span class="comment">//  内部使用红黑树的数据结构来存储键值对</span></span><br><span class="line"><span class="comment">// 插入、删除和查找操作的最坏情况时间复杂度为 O(log n)</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    Entry&lt;K,V&gt; t = root;  <span class="comment">// 从根节点开始</span></span><br><span class="line">    <span class="keyword">if</span> (t == <span class="literal">null</span>) &#123;  <span class="comment">// 如果树为空</span></span><br><span class="line">        <span class="comment">// 用于确保在没有提供 Comparator 的情况下，键 key 是可比较的</span></span><br><span class="line">        compare(key, key);  <span class="comment">// 验证 key 是否可比较</span></span><br><span class="line">        <span class="comment">// 第一次添加,把 k-v 封装到 Entry 对象放入root</span></span><br><span class="line">        root = <span class="keyword">new</span> <span class="title class_">Entry</span>&lt;&gt;(key, value, <span class="literal">null</span>);  <span class="comment">// 创建新的根节点</span></span><br><span class="line">        size = <span class="number">1</span>;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> cmp;</span><br><span class="line">    Entry&lt;K,V&gt; parent;</span><br><span class="line">    <span class="comment">// 获取比较器</span></span><br><span class="line">    Comparator&lt;? <span class="built_in">super</span> K&gt; cpr = comparator;  </span><br><span class="line">    <span class="keyword">if</span> (cpr != <span class="literal">null</span>) &#123;  <span class="comment">// 如果使用自定义比较器</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            parent = t;</span><br><span class="line">            <span class="comment">// 使用比较器比较键, 动态绑定到匿名内部类的 compare 方法</span></span><br><span class="line">            cmp = cpr.compare(key, t.key); </span><br><span class="line">            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">                t = t.left;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">                t = t.right;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> t.setValue(value);</span><br><span class="line">        &#125; <span class="keyword">while</span> (t != <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 没有比较器，键必须是可比较的</span></span><br><span class="line">        <span class="keyword">if</span> (key == <span class="literal">null</span>)  <span class="comment">// 键不能为 null</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">        Comparable&lt;? <span class="built_in">super</span> K&gt; k = (Comparable&lt;? <span class="built_in">super</span> K&gt;) key;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            parent = t;</span><br><span class="line">            <span class="comment">// 使用键的自然顺序比较</span></span><br><span class="line">            cmp = k.compareTo(t.key);</span><br><span class="line">            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">                t = t.left;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">                t = t.right;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> t.setValue(value);</span><br><span class="line">        &#125; <span class="keyword">while</span> (t != <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建新节点</span></span><br><span class="line">    Entry&lt;K,V&gt; e = <span class="keyword">new</span> <span class="title class_">Entry</span>&lt;&gt;(key, value, parent);</span><br><span class="line">    <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">        parent.left = e;  <span class="comment">// 添加为左子节点</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        parent.right = e;  <span class="comment">// 添加为右子节点</span></span><br><span class="line">    fixAfterInsertion(e);  <span class="comment">// 调整树以保持平衡</span></span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查是否有自定义的比较器 (Comparator) 提供</span></span><br><span class="line"><span class="comment">// 如果 没有提供比较器 (comparator==null)，那么假设 k1 必须实现 Comparable 接口。它尝试将 k1 强制类型转换为 Comparable，然后使用 compareTo 方法比较 k1 和 k2</span></span><br><span class="line"><span class="comment">// 如果 k1 没有实现 Comparable 接口，这个类型转换会失败，抛出 ClassCastException</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object k1, Object k2)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> comparator==<span class="literal">null</span> ? ((Comparable&lt;? <span class="built_in">super</span> K&gt;)k1).compareTo((K)k2)</span><br><span class="line">        : comparator.compare((K)k1, (K)k2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-2-TreeMap-分析"><a href="#7-2-TreeMap-分析" class="headerlink" title="7.2 TreeMap 分析"></a>7.2 TreeMap 分析</h3><ul><li><code>TreeMap</code> 是一个基于红黑树的有序映射，支持<strong>按照键的自然顺序或者根据指定的 <code>Comparator</code> 进行排序</strong></li><li><strong>插入元素的逻辑</strong>：<ul><li>首先<strong>检查根节点是否为空</strong>，如果是，则简单地将<strong>新元素设置为根节点</strong>（第一次添加，把 k-v 封装到 Entry 对象，放入root）</li><li>如果<strong>根节点不为空，则使用比较器</strong>（如果存在）或键的自然顺序来找到适当的插入位置<ul><li>涉及在树中逐级向下搜索正确的插入点，直到找到空位置插入新节点</li><li>如果找到相同键的节点，则更新该节点的值</li></ul></li><li>插入新节点后，可能需要进行红黑树的调整操作以保持树的平衡</li></ul></li><li><strong>代码示例</strong>：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">TreeMap</span> <span class="variable">treeMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeMap</span>(<span class="keyword">new</span> <span class="title class_">Comparator</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object o1, Object o2)</span> &#123;</span><br><span class="line">        <span class="comment">//按照 K(String) 的长度大小排序</span></span><br><span class="line">        <span class="keyword">return</span> ((String) o2).length() - ((String) o1).length();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">treeMap.put(<span class="string">&quot;jack&quot;</span>, <span class="string">&quot;杰克&quot;</span>);</span><br><span class="line">treeMap.put(<span class="string">&quot;tom&quot;</span>, <span class="string">&quot;汤姆&quot;</span>);</span><br><span class="line">treeMap.put(<span class="string">&quot;kristina&quot;</span>, <span class="string">&quot;克瑞斯提诺&quot;</span>);</span><br><span class="line">treeMap.put(<span class="string">&quot;smith&quot;</span>, <span class="string">&quot;斯密斯&quot;</span>);</span><br><span class="line">treeMap.put(<span class="string">&quot;hhh&quot;</span>, <span class="string">&quot;hhh&quot;</span>);  <span class="comment">// 加入不了, 并且会覆盖前面 tom 键所对应的值</span></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;treemap=&quot;</span> + treeMap);</span><br><span class="line"><span class="comment">// treemap=&#123;kristina=克瑞斯提诺, smith=斯密斯, jack=杰克, tom=hhh&#125;</span></span><br></pre></td></tr></table></figure><h2 id="8-集合选型规则"><a href="#8-集合选型规则" class="headerlink" title="8. 集合选型规则"></a>8. 集合选型规则</h2><blockquote><p>开发中如何选择集合实现类？</p><p>主要取决于业务操作特点，然后根据集合实现类特性进行选择</p></blockquote><p><strong>判断存储的类型</strong></p><ul><li><p><strong>一组对象[单列]（使用 <code>Collection</code> 接口</strong>）</p><ul><li><p><strong>允许重复</strong>：</p><ul><li><strong><code>List</code> 接口</strong>：<ul><li><strong><code>ArrayList</code><strong>：适用于</strong>查找和修改操作频繁</strong>的场景（底层维护 Object 类型的可变数组）</li><li><strong><code>LinkedList</code><strong>：适合于</strong>增加和删除操作频繁</strong>的场景（底层维护一个双向链表）</li></ul></li></ul></li><li><p><strong>不允许重复</strong>：</p><blockquote><p>以下的无序指存取的顺序不一致，但是取出的顺序是固定一致的</p></blockquote><ul><li><code>Set</code> 接口：<ul><li><strong><code>HashSet</code><strong>：最常用的集合，提供快速访问，保持元素唯一，但元素是</strong>无序</strong>的。内部通过哈希表实现，包括数组、链表和红黑树（Java 8 及以上）</li><li><strong><code>TreeSet</code><strong>：当需要一个</strong>有序</strong>集合时选择，它根据元素的自然顺序或构造器提供的 <code>Comparator</code> 进行排序</li><li><strong><code>LinkedHashSet</code><strong>：</strong>维护元素插入顺序</strong>，性能略低于 <code>HashSet</code>，但迭代访问所有元素时有更高的性能（维护哈希表+双向链表）<ul><li>LinkedHashSet 底层是 LinkedHashMap；LinkedHashMap 的底层是 HashMap</li></ul></li></ul></li></ul></li></ul></li><li><p><strong>一组键值对[双列]（使用 <code>Map</code> 接口）</strong></p><ul><li><p><strong><code>HashMap</code><strong>：是最常用的 <code>Map</code> 实现，</strong>键无序</strong>，按键的哈希码存储数据（底层数组+链表&#x2F;红黑树）</p></li><li><p><strong><code>TreeMap</code><strong>：基于红黑树的 <code>Map</code> 实现，它根据键的自然</strong>排序</strong>或构造器提供的 <code>Comparator</code> 对键进行排序。适用于需要按自然顺序或特定顺序遍历键时</p></li><li><p><strong><code>LinkedHashMap</code><strong>：</strong>保持插入顺序</strong>，通常比 <code>HashMap</code> 慢一点，但在迭代访问时更快</p></li></ul></li><li><p><strong>特殊用途</strong></p><ul><li><strong><code>Properties</code><strong>：用于</strong>读取 <code>.properties</code> 文</strong>件，适用于配置数据的加载和存储。它是 <code>Hashtable</code> 的一个子类，其中键和值都是字符串</li></ul></li></ul><h2 id="9-Collections-工具类"><a href="#9-Collections-工具类" class="headerlink" title="9. Collections 工具类"></a>9. Collections 工具类</h2><h3 id="9-1-基本介绍"><a href="#9-1-基本介绍" class="headerlink" title="9.1 基本介绍"></a>9.1 基本介绍</h3><ul><li><code>Collections</code> 是 Java 中的一个工具类，专门用于操作集合，如 <code>Set</code>、<code>List</code> 和 <code>Map</code> 等</li><li>该类提供了多种静态方法，用于执行集合上的操作，如排序、查询、修改等</li></ul><h3 id="9-2-主要方法"><a href="#9-2-主要方法" class="headerlink" title="9.2 主要方法"></a>9.2 主要方法</h3><blockquote><p>static操作</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建ArrayList 集合, 用于测试</span></span><br><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">list.add(<span class="string">&quot;tom&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;smith&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;king&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;milan&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;tom&quot;</span>);</span><br></pre></td></tr></table></figure><ul><li><strong>排序和调整</strong>：<ul><li><code>reverse(List)</code>: 反转 <code>List</code> 中元素的顺序。</li><li><code>shuffle(List)</code>: 对 <code>List</code> 集合元素进行随机排序。</li><li><code>sort(List)</code>: 根据元素的自然顺序对指定 <code>List</code> 集合元素按升序排序。</li><li><code>sort(List, Comparator)</code>: 根据指定的 <code>Comparator</code> 定制的顺序对 <code>List</code> 集合元素进行排序。</li><li><code>swap(List, int, int)</code>: 将指定 <code>List</code> 集合中的 i 处元素和 j 处元素进行交换。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reverse(List): 反转 List 中元素的顺序</span></span><br><span class="line">Collections.reverse(list);</span><br><span class="line">System.out.println(<span class="string">&quot;list = &quot;</span> + list);  <span class="comment">// list = [tom, milan, king, smith, tom]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// shuffle(List): 对 List 集合元素进行随机排序</span></span><br><span class="line"><span class="comment">// for (int i = 0; i &lt; 5; i++) &#123;</span></span><br><span class="line"><span class="comment">//     Collections.shuffle(list);</span></span><br><span class="line"><span class="comment">//     System.out.println(&quot;list = &quot; + list);</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// sort(List): 根据元素的自然顺序对指定 List 集合元素按升序排序</span></span><br><span class="line">Collections.sort(list);</span><br><span class="line">System.out.println(<span class="string">&quot;=======自然排序后=========&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;list = &quot;</span> + list);  <span class="comment">// list = [king, milan, smith, tom, tom]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// sort(List，Comparator): 根据指定的 Comparator 产生的顺序对 List 集合元素进行排序</span></span><br><span class="line"><span class="comment">// 如: 按照字符串的长度大小排序, 传递匿名内部类</span></span><br><span class="line">Collections.sort(list, <span class="keyword">new</span> <span class="title class_">Comparator</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object o1, Object o2)</span> &#123;</span><br><span class="line">        <span class="comment">// 严谨些需要加入校验代码, 避免转型异常</span></span><br><span class="line">        <span class="comment">// 确保两个对象都是字符串类型</span></span><br><span class="line">        <span class="comment">// if (o1 instanceof String &amp;&amp; o2 instanceof String) &#123;</span></span><br><span class="line">        <span class="comment">//     // 正确的情况下，比较它们的长度</span></span><br><span class="line">        <span class="comment">//     return ((String) o2).length() - ((String) o1).length();  // 从长到短</span></span><br><span class="line">        <span class="comment">// &#125; else &#123;</span></span><br><span class="line">        <span class="comment">//     // 如果任一对象不是字符串，可以选择抛出异常或返回0</span></span><br><span class="line">        <span class="comment">//     // 抛出异常</span></span><br><span class="line">        <span class="comment">//     throw new IllegalArgumentException(&quot;Both objects must be strings&quot;);</span></span><br><span class="line">        <span class="comment">//     // 或者可以选择处理为相等，取决具体的业务逻辑</span></span><br><span class="line">        <span class="comment">//     // return 0;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="keyword">return</span> ((String) o2).length() - ((String) o1).length();  <span class="comment">// 从长到短</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(<span class="string">&quot;=======字符串长度大小排序后=========&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;list = &quot;</span> + list);  <span class="comment">// list = [milan, smith, king, tom, tom]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// swap(List，int， int): 将指定 list 集合中的 i 处元素和 j 处元素进行交换</span></span><br><span class="line">Collections.swap(list, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;=======交换后的情况=========&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;list = &quot;</span> + list);  <span class="comment">// list = [smith, milan, king, tom, tom]</span></span><br></pre></td></tr></table></figure><ul><li><strong>查找和统计</strong>：<ul><li><code>max(Collection)</code>: 根据元素的自然顺序，返回给定集合中的最大元素。</li><li><code>max(Collection, Comparator)</code>: 根据 <code>Comparator</code> 指定的顺序，返回给定集合中的最大元素。</li><li><code>min(Collection)</code>: 返回集合中的最小元素，根据自然排序。</li><li><code>min(Collection, Comparator)</code>: 根据指定的比较器返回集合中的最小元素。</li><li><code>frequency(Collection, Object)</code>: 返回指定集合中指定元素的出现次数。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Object max(Collection): 根据元素的自然顺序，返回给定集合中的最大元素</span></span><br><span class="line">System.out.println(<span class="string">&quot;自然顺序最大元素 = &quot;</span> + Collections.max(list));  <span class="comment">// 自然顺序最大元素 = tom</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Object max(Collection，Comparator): 根据 Comparator 指定的顺序, 返回给定集合中的最大元素</span></span><br><span class="line"><span class="comment">// 比如: 返回长度最大的元素</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">maxObject</span> <span class="operator">=</span> Collections.max(list, <span class="keyword">new</span> <span class="title class_">Comparator</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object o1, Object o2)</span> &#123;</span><br><span class="line">        <span class="comment">// 从短到长 ==&gt; 返回长度最大</span></span><br><span class="line">        <span class="keyword">return</span> ((String) o1).length() - ((String) o2).length();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从长到短 ==&gt; 返回长度最小</span></span><br><span class="line">        <span class="comment">// return ((String) o2).length() - ((String) o1).length();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(<span class="string">&quot;长度最大的元素 = &quot;</span> + maxObject);  <span class="comment">// 长度最大的元素 = smith</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面两个方法参考 max 即可</span></span><br><span class="line"><span class="comment">// Object min(Collection)</span></span><br><span class="line"><span class="comment">// Object min(Collection，Comparator)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// int frequency(Collection，Object): 返回指定集合中指定元素的出现次数</span></span><br><span class="line">System.out.println(<span class="string">&quot;tom 出现的次数 = &quot;</span> + Collections.frequency(list, <span class="string">&quot;tom&quot;</span>));  <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><ul><li><p><strong>复制和替换</strong>：</p><ul><li><p><code>copy(List dest, List src)</code>: 将 <code>src</code> 中的内容复制到 <code>dest</code> 中，执行的是浅复制(如果列表中的元素是对象，那么两个列表中的相应位置将指向同一个对象)。</p></li><li><p><code>replaceAll(List, Object oldVal, Object newVal)</code>: 使用新值替换 <code>List</code> 对象中所有的旧值。</p></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// void copy(List dest, List src): 将 src 中的内容复制到 dest 中</span></span><br><span class="line"><span class="type">ArrayList</span> <span class="variable">dest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line"><span class="comment">// 先给 dest 赋值, 大小和 list.size() 一样</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">    dest.add(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 拷贝, 将 list 内容复制到 dest 中</span></span><br><span class="line">Collections.copy(dest, list);</span><br><span class="line">System.out.println(<span class="string">&quot;dest = &quot;</span> + dest);  <span class="comment">// dest = [smith, milan, king, tom, tom]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// boolean replaceAll(List list, Object oldVal, Object newVal): 使用新值替换 List 对象的所有旧值</span></span><br><span class="line"><span class="comment">// 如果list中, 有 tom 就替换成 汤姆</span></span><br><span class="line">Collections.replaceAll(list, <span class="string">&quot;tom&quot;</span>, <span class="string">&quot;汤姆&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;list 替换后 = &quot;</span> + list);  <span class="comment">// list 替换后 = [smith, milan, king, 汤姆, 汤姆]</span></span><br></pre></td></tr></table></figure><h2 id="10-课后习题"><a href="#10-课后习题" class="headerlink" title="10. 课后习题"></a>10. 课后习题</h2><h3 id="10-1-Homework01"><a href="#10-1-Homework01" class="headerlink" title="10.1 Homework01"></a>10.1 Homework01</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Homework01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;News&gt; news = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        news.add(<span class="keyword">new</span> <span class="title class_">News</span>(<span class="string">&quot;news01xxxxxxxxxxxxxxxxxxxxxx&quot;</span>));</span><br><span class="line">        news.add(<span class="keyword">new</span> <span class="title class_">News</span>(<span class="string">&quot;news02&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 倒序遍历+截取字符串(这里截取前按理来说要判断下标题非 null)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> news.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (news.get(i).getTitle().length() &gt; <span class="number">15</span>) &#123;</span><br><span class="line">                System.out.println(news.get(i).getTitle().substring(<span class="number">0</span>, <span class="number">15</span>) + <span class="string">&quot;...&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(news.get(i).getTitle());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-2-Homework03"><a href="#10-2-Homework03" class="headerlink" title="10.2 Homework03"></a>10.2 Homework03</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Homework03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Map&lt;String, Integer&gt; emps = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        emps.put(<span class="string">&quot;aa&quot;</span>, <span class="number">650</span>);</span><br><span class="line">        emps.put(<span class="string">&quot;bb&quot;</span>, <span class="number">1200</span>);</span><br><span class="line">        emps.put(<span class="string">&quot;cc&quot;</span>, <span class="number">2900</span>);</span><br><span class="line"></span><br><span class="line">        Set&lt;Map.Entry&lt;String, Integer&gt;&gt; entries = emps.entrySet();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : entries) &#123;</span><br><span class="line">            <span class="keyword">if</span> (entry.getKey().equals(<span class="string">&quot;22&quot;</span>)) &#123;</span><br><span class="line">                entry.setValue(<span class="number">2600</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            entry.setValue(entry.getValue() + <span class="number">100</span>);</span><br><span class="line">            System.out.println(entry);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-3-Homework04"><a href="#10-3-Homework04" class="headerlink" title="10.3 Homework04"></a>10.3 Homework04</h3><p><strong>分析下 HashSet 和 TreeSet 分别如何去重？</strong></p><ul><li><p><strong>HashSet 去重</strong>：</p><ul><li><strong>计算哈希值</strong>：通过调用元素的 <code>hashCode()</code> 方法计算其哈希值。</li><li><strong>确定位置</strong>：使用哈希值来确定在哈希表（底层的数组）中的索引位置。</li><li><strong>冲突处理</strong>：如果该位置已经有元素存在，则通过 equals() 方法与现有元素逐个比较：<ul><li>如果 <code>equals()</code> 返回 <code>true</code>（表示找到相等的元素），则不将新元素添加到集合中。</li><li>如果 <code>equals()</code> 返回 <code>false</code>（即所有比较都不相等），则根据内部结构（如链表或红黑树）添加新元素以解决哈希冲突。</li></ul></li></ul></li><li><p><strong>TreeSet 去重</strong>：</p><ul><li>如果初始化时传入了 Comparator 匿名内部类对象，就使用实现的 compare 方法去重，如果方法返回0，就认为是相同的元素&#x2F;数据，就不添加</li><li>如果没有传入 Comparator 匿名对象，则以添加的对象实现的 Compareable 接口的 compareTo 方法去重</li></ul><blockquote><p><code>Comparable</code> 接口用于定义对象的自然排序方式。类实现此接口以表明其实例具有内在的排序顺序</p><p><code>Comparator</code> 接口用于定义一种外部的、可定制的排序策略。它允许开发者提供自定义的排序顺序</p></blockquote></li></ul><h3 id="10-4-Homework05"><a href="#10-4-Homework05" class="headerlink" title="10.4 Homework05"></a>10.4 Homework05</h3><ul><li><strong>下面代码运行会不会抛出异常，并从源码层面说明原因？［考察读源码＋接口编程＋动态绑定］</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">TreeSet</span> <span class="variable">treeSet</span> <span class="operator">=</span>  <span class="keyword">new</span> <span class="title class_">TreeSet</span>();</span><br><span class="line">treeSet.add(<span class="keyword">new</span> <span class="title class_">Person</span>());</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;&#125;;</span><br></pre></td></tr></table></figure><ul><li>代码在运行时<strong>会抛出异常</strong>，原因在于 <code>TreeSet</code> 的工作机制要求存储的元素必须具备可比较性，即元素应该实现 <code>Comparable</code> 接口。而 <code>Person</code> 类没有实现 <code>Comparable</code> 接口，当 <code>TreeSet</code> 尝试比较两个 <code>Person</code> 实例来确定其排序位置时，会因为找不到比较方法而抛出 <code>ClassCastException</code></li></ul><h3 id="10-5-Homework06-坑！"><a href="#10-5-Homework06-坑！" class="headerlink" title="10.5 Homework06-坑！"></a>10.5 Homework06-坑！</h3><p><strong>分析下面代码的输出</strong>：</p><ul><li><strong>前提</strong>：Person 类重写了基于 id 和 name 的 equals 和 hashCode 方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">HashSet&lt;Person&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">1001</span>, <span class="string">&quot;AA&quot;</span>);</span><br><span class="line"><span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">1002</span>, <span class="string">&quot;BB&quot;</span>);</span><br><span class="line"></span><br><span class="line">set.add(p1);</span><br><span class="line">set.add(p2);</span><br><span class="line"><span class="comment">// [Person&#123;id=&#x27;1002&#x27;, name=&#x27;BB&#x27;&#125;, Person&#123;id=&#x27;1001&#x27;, name=&#x27;AA&#x27;&#125;]</span></span><br><span class="line">System.out.println(set);</span><br><span class="line"></span><br><span class="line">p1.name = <span class="string">&quot;CC&quot;</span>;</span><br><span class="line"><span class="comment">// [Person&#123;id=&#x27;1002&#x27;, name=&#x27;BB&#x27;&#125;, Person&#123;id=&#x27;1001&#x27;, name=&#x27;CC&#x27;&#125;]</span></span><br><span class="line">System.out.println(set);</span><br><span class="line"></span><br><span class="line">set.remove(p1);</span><br><span class="line"><span class="comment">// [Person&#123;id=&#x27;1002&#x27;, name=&#x27;BB&#x27;&#125;, Person&#123;id=&#x27;1001&#x27;, name=&#x27;CC&#x27;&#125;]</span></span><br><span class="line">System.out.println(set);</span><br><span class="line"></span><br><span class="line">set.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">1001</span>, <span class="string">&quot;CC&quot;</span>));</span><br><span class="line"><span class="comment">// [Person&#123;id=&#x27;1002&#x27;, name=&#x27;BB&#x27;&#125;, Person&#123;id=&#x27;1001&#x27;, name=&#x27;CC&#x27;&#125;, Person&#123;id=&#x27;1001&#x27;, name=&#x27;CC&#x27;&#125;]</span></span><br><span class="line">System.out.println(set);</span><br><span class="line"></span><br><span class="line">set.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">1001</span>, <span class="string">&quot;AA&quot;</span>));</span><br><span class="line"><span class="comment">// [Person&#123;id=&#x27;1002&#x27;, name=&#x27;BB&#x27;&#125;, Person&#123;id=&#x27;1001&#x27;, name=&#x27;CC&#x27;&#125;,</span></span><br><span class="line"><span class="comment">// Person&#123;id=&#x27;1001&#x27;, name=&#x27;CC&#x27;&#125;, Person&#123;id=&#x27;1001&#x27;, name=&#x27;AA&#x27;&#125;]</span></span><br><span class="line">System.out.println(set);</span><br></pre></td></tr></table></figure><ul><li><p><strong>分析</strong>：</p><ul><li><strong>为什么 <code>remove</code> 没成功？</strong><ul><li>当 <code>p1</code> 被添加到 <code>HashSet</code> 时，它的哈希值是根据 <code>p1</code> 的 <code>id</code> 和 <code>name</code> 计算得到的。此时，<code>p1</code> 的状态是 <code>id=1001</code> 和 <code>name=AA</code></li><li>修改了 <code>p1</code> 的 <code>name</code> 属性为 <code>&quot;CC&quot;</code>。这改变了 <code>p1</code> 的内部状态，这意味着如果再次计算哈希值，将会得到一个不同的结果</li><li>使用 <code>set.remove(p1)</code> 时，<code>HashSet</code> 试图找到 <code>p1</code> 的哈希值对应的桶。但是，由于 <code>p1</code> 的哈希值已经因为内部状态改变而改变，所以 <code>remove</code> 方法可能无法找到正确的桶。如果找到了桶，其内的元素通过 <code>equals</code> 方法比较也可能失败，因为 <code>equals</code> 和 <code>hashCode</code> 都依赖于 <code>name</code>，而这已经被改变了</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/Java%E9%9B%86%E5%90%88.assets/image-20240501154923401.png" alt="image-20240501154923401"></p><ul><li><strong>为什么再次添加 <code>1001, &quot;CC&quot;</code> 和 <code>1001, &quot;AA&quot;</code> 都成功了？</strong><ul><li>由于 <code>p1</code> 的哈希值在其被修改后没有正确地更新（即哈希表中的位置不正确），因此再次添加同样的 <code>id</code> 和修改后的 <code>name</code> (<code>&quot;CC&quot;</code>) 时，会产生一个新的哈希值，并被存放在不同的位置。尽管 <code>p1</code> 的当前状态与新对象相同，但新对象会被视为不同的元素并被成功添加</li><li>添加一个新的 <code>Person(1001, &quot;AA&quot;)</code> 时，由于没有与此状态相同的 <code>Person</code> 对象在 <code>HashSet</code> 中（<code>p1</code> 的状态已经是 <code>1001, &quot;CC&quot;</code>），它同样被添加成功</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/Java%E9%9B%86%E5%90%88.assets/image-20240501155820692.png" alt="image-20240501155820692"></p></li><li><p><strong>根本原因</strong>：问题的根本原因是对象的可变性与 <code>HashSet</code> 的工作原理不兼容。当 <code>HashSet</code> 中的对象在添加后被修改，它的哈希值可能不再反映其在哈希表中的实际位置</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> collection </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RabbitMQ 入门</title>
      <link href="/2024/04/12/RabbitMQ%E5%85%A5%E9%97%A8/"/>
      <url>/2024/04/12/RabbitMQ%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h1><blockquote><p>学习笔记：<a href="https://www.bilibili.com/video/BV1cb4y1o7zz?p=2">02-什么是MQ_哔哩哔哩_bilibili</a></p></blockquote><h2 id="1-消息队列"><a href="#1-消息队列" class="headerlink" title="1. 消息队列"></a>1. 消息队列</h2><h3 id="1-1-MQ-相关概念"><a href="#1-1-MQ-相关概念" class="headerlink" title="1.1 MQ 相关概念"></a>1.1 MQ 相关概念</h3><h4 id="1-1-1-什么是-MQ"><a href="#1-1-1-什么是-MQ" class="headerlink" title="1.1.1 什么是 MQ"></a>1.1.1 什么是 MQ</h4><ul><li><p>MQ(message queue)，从字面意思上看，<strong>本质是个队列</strong>，FIFO 先入先出，只不过队列中存放的内容是 message 而已</p></li><li><p>还是一种<strong>跨进程的通信机制，用于上下游传递消息</strong>。在互联网架构中，MQ 是一种非常常见的上下游 “逻辑解耦+物理解耦” 的消息通信服务</p><blockquote><p>a 给 b 发消息，a 就是上游，b 就是下游</p></blockquote></li><li><p>使用了 MQ 之后，消息发送上游只需要依赖 MQ，不用依赖其他服务</p></li></ul><h4 id="1-1-2-为什么要用-MQ"><a href="#1-1-2-为什么要用-MQ" class="headerlink" title="1.1.2 为什么要用 MQ"></a>1.1.2 为什么要用 MQ</h4><blockquote><p>MQ 有三大功能：</p></blockquote><ul><li><p><strong>流量削峰</strong></p><ul><li>举例：<ul><li>如果订单系统最多能处理一万次订单，这个处理能力应付正常时段的下单时绰绰有余，正常时段我们下单一秒后就能返回结果</li><li>但是在高峰期，如果有两万次下单操作系统是处理不了的，只能限制订单超过一万后不允许用户下单</li><li><strong>使用消息队列做缓冲</strong>，我们可以取消这个限制，<strong>把一秒内下的订单分散成一段时间来处理</strong>，这时有些用户可能在下单十几秒后才能收到下单成功的操作，但是比不能下单的体验要好</li></ul></li><li>图示说明：</li></ul><p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/1696320183594.png" alt="1696320156974"></p></li><li><p><strong>应用解耦</strong></p><ul><li>举例：<ul><li>以电商应用为例，应用中有订单系统、库存系统、物流系统、支付系统</li><li>用户创建订单后，如果耦合调用库存系统、物流系统、支付系统，任何一个子系统出了故障，都会造成下单操作异常</li><li>当<strong>转变成基于消息队列的方式后，系统间调用的问题会减少很多</strong>，比如物流系统因为发生故障，需要几分钟来修复</li><li>在这几分钟的时间里，<strong>物流系统要处理的内存被缓存在消息队列中，用户的下单操作可以正常完成</strong></li><li>当物流系统恢复后，继续处理订单信息即可，中单用户感受不到物流系统的故障，提升系统的可用性</li></ul></li><li>图示说明：</li></ul><p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/1696320368051.png" alt="1696320368051"></p></li><li><p><strong>异步处理</strong></p><ul><li>举例：<ul><li>有些服务间调用是异步的，例如 A 调用 B，B 需要花费很长时间执行，但是 A 需要知道 B 什么时候可以执行完</li><li>以前一般有两种方式，A 过一段时间去调用 B 的查询 api 查询；或者 A 提供一个 callback api，B 执行完之后调用 api 通知 A 服务</li><li>这两种方式都不是很优雅，使用消息总线，可以很方便解决这个问题，<strong>A 调用 B 服务后，只需要监听 B 处理完成的消息，当 B 处理完成后，会发送一条消息给 MQ，MQ 会将此消息转发给 A 服务</strong></li><li>这样 A 服务既不用循环调用 B 的查询 api，也不用提供 callback api。同样 B 服务也不用做这些操作。A 服务还能及时的得到异步处理成功的消息</li></ul></li><li>图示说明：</li></ul><p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/1696320559421.png" alt="1696320559421"></p></li></ul><h4 id="1-1-3-MQ-的分类"><a href="#1-1-3-MQ-的分类" class="headerlink" title="1.1.3 MQ 的分类"></a>1.1.3 MQ 的分类</h4><ul><li><strong>ActiveMQ</strong><ul><li>优点：单机吞吐量万级，时效性 ms 级，可用性高，基于主从架构实现高可用性，消息可靠性方面：较低的概率丢失数据</li><li>缺点：官方社区现在对 ActiveMQ 5.x <strong>维护越来越少，高吞吐量场景较少使用</strong></li></ul></li><li><strong>Kafka</strong><ul><li>大数据的杀手锏，谈到大数据领域内的消息传输，则绕不开 Kafka，这款为<strong>大数据而生</strong>的消息中间件，以其<strong>百万级 TPS</strong> 的吞吐量名声大噪，在数据采集、传输、存储的过程中发挥着举足轻重的作用，</li><li>优点：<ul><li>性能卓越，单机写入 TPS 约在百万条&#x2F;秒，最大的优点，就是<strong>吞吐量高</strong>。时效性 ms 级，可用性非常高</li><li>kafka 是分布式的，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用</li><li>消费者采用 Pull 方式获取消息，消息有序，通过控制能够保证所有消息被消费且仅被消费一次</li><li>有优秀的第三方Kafka Web 管理界面 Kafka-Manager</li><li>在日志领域比较成熟，被多家公司和多个开源项目使用</li><li>功能支持：功能较为简单，主要支持简单的 MQ 功能，在大数据领域的实时计算以及<strong>日志采集</strong>被大规模使用</li></ul></li><li>缺点：Kafka 单机超过 64 个队列&#x2F;分区，Load 会发生明显的飙高现象，队列越多，load 越高，发送消息响应时间变长，使用短轮询方式，实时性取决于轮询间隔时间，消费失败不支持重试；支持消息顺序，但是一台代理宕机后，就会产生消息乱序，<strong>社区更新较慢</strong></li></ul></li><li><strong>RocketMQ</strong><ul><li>RocketMQ 出自阿里巴巴的开源产品，用 Java 语言实现，在设计时参考了 Kafka，并做出了自己的一些改进</li><li>优点：<strong>单机吞吐量十万级</strong>，可用性非常高，分布式架构,<strong>消息可以做到 0 丢失</strong>，MQ 功能较为完善，还是分布式的，扩展性好，<strong>支持 10 亿级别的消息堆积</strong>，不会因为堆积导致性能下降，源码是 java 我们可以自己阅读源码，定制自己公司的 MQ</li><li>缺点：<strong>支持的客户端语言不多</strong>，目前是 java 及 c++，其中 c++不成熟；社区活跃度一般，没有在 MQ 核心中去实现 JMS 等接口，有些系统要迁移需要修改大量代码</li></ul></li><li><strong>RabbitMQ</strong>：<a href="https://www.rabbitmq.com/news.html">https://www.rabbitmq.com/news.html</a> <ul><li>2007 年发布，是一个在 <strong>AMQP(高级消息队列协议)<strong>基础上完成的，可复用的企业消息系统，是</strong>当前最主流的消息中间件之一</strong></li><li>优点：由于 erlang 语言的<strong>高并发特性</strong>，性能较好；<strong>吞吐量到万级</strong>，MQ 功能比较完备,健壮、稳定、易用、跨平台、<strong>支持多种语言</strong> 如：Python、Ruby、.NET、Java、JMS、C、PHPActionScript等，支持 AJAX 文档齐全；开源提供的管理界面非常棒，用起来很好用，<strong>社区活跃度高</strong>；更新频率相当高</li><li>缺点：商业版需要收费，学习成本较高</li></ul></li></ul><h4 id="1-1-4-MQ-的选择"><a href="#1-1-4-MQ-的选择" class="headerlink" title="1.1.4 MQ 的选择"></a>1.1.4 MQ 的选择</h4><ul><li><p><strong>Kafka</strong></p><ul><li>Kafka 主要特点是基于 Pull 的模式来处理消息消费，追求高吞吐量，一开始的目的就是用于日志收集和传输</li><li>适合产生<strong>大量数据</strong>的互联网服务的数据收集业务。<strong>大型公司</strong>建议可以选用，如果有<strong>日志采集</strong>功能，肯定是首选 kafka 了</li></ul></li><li><p><strong>RocketMQ</strong></p><ul><li>天生为<strong>金融互联网</strong>领域而生，对于可靠性要求很高的场景，尤其是电商里面的订单扣款，以及业务削峰，在大量交易涌入时，后端可能无法及时处理的情况</li><li>RocketMQ 在稳定性上可能更值得信赖，这些业务场景在阿里双 11 已经经历了多次考验，如果你的业务有上述并发场景，建议可以选择 RocketMQ。</li></ul></li><li><p><strong>RabbitMQ</strong></p><ul><li>结合 erlang 语言本身的并发优势，性能好<strong>时效性微秒级</strong>，社区活跃度也比较高<strong>，管理界面用起来十分方便</strong></li><li><strong>如果你的数据量没有那么大</strong>，中小型公司优先选择功能比较完备的 RabbitMQ</li></ul></li></ul><h3 id="1-2-RabbitMQ"><a href="#1-2-RabbitMQ" class="headerlink" title="1.2 RabbitMQ"></a>1.2 RabbitMQ</h3><blockquote><p>RabbitMQ 是一个<strong>消息中间件</strong>：</p><p>它接受并转发消息，你可以把它当做一个快递站点，当你要发送一个包裹时，你把你的包裹放到快递站，快递员最终会把你的快递送到收件人那里，按照这种逻辑 RabbitMQ 是一个快递站，一个快递员帮你传递快件。</p><p>RabbitMQ 与快递站的主要区别在于，它不处理快件而是<strong>接收，存储和转发消息数据</strong></p></blockquote><h4 id="1-2-1-四大核心概念"><a href="#1-2-1-四大核心概念" class="headerlink" title="1.2.1 四大核心概念"></a>1.2.1 四大核心概念</h4><p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/1696322466173.png" alt="1696322466173"></p><ul><li><strong>生产者</strong><ul><li>产生数据发送消息的程序是生产者</li></ul></li><li><strong>交换机</strong><ul><li>交换机是 RabbitMQ 非常重要的一个部件，一方面<strong>它接收来自生产者的消息，另一方面它将消息推送到队列</strong>中</li><li>交换机必须确切知道如何处理它接收到的消息，是将这些消息推送到特定队列还是推送到多个队列，亦或者是把消息丢弃，这个得由交换机类型决定</li></ul></li><li><strong>队列</strong><ul><li>队列是 RabbitMQ 内部使用的一种数据结构，尽管消息流经 RabbitMQ 和应用程序，但它们只能存储在队列中</li><li>队列仅受主机的内存和磁盘限制的约束，本质上是一个大的消息缓冲区</li><li>许多生产者可以将消息发送到一个队列，许多消费者可以尝试从一个队列接收数据。这就是我们使用队列的方式</li></ul></li><li><strong>消费者</strong><ul><li>消费与接收具有相似的含义。消费者大多时候是一个等待接收消息的程序</li><li>请注意生产者，消费者和消息中间件很多时候并不在同一机器上，同一个应用程序既可以是生产者又是可以是消费者。</li></ul></li></ul><h4 id="1-2-3-RabbitMQ-核心部分"><a href="#1-2-3-RabbitMQ-核心部分" class="headerlink" title="1.2.3 RabbitMQ 核心部分"></a>1.2.3 RabbitMQ 核心部分</h4><blockquote><p>六大模式</p></blockquote><p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/1696322800780.png" alt="1696322800780"></p><h4 id="1-2-3-各个名词介绍"><a href="#1-2-3-各个名词介绍" class="headerlink" title="1.2.3 各个名词介绍"></a>1.2.3 各个名词介绍</h4><p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/1696322866484.png" alt="1696322866484"></p><ul><li><strong>Broker</strong>：接收和分发消息的应用，RabbitMQ Server就是Message Broker  (Broker:中间人、经济人)</li><li><strong>Virtual host</strong>：<ul><li>出于多租户和安全因素设计的，把 AMQP 的基本组件划分到一个虚拟的分组中，类似于网络中的 namespace 概念</li><li>当多个不同的用户使用同一个 RabbitMQ server 提供的服务时，可以划分出多个 vhost，每个用户在自己的 vhost 创建 exchange／queue 等</li></ul></li><li><strong>Connection</strong>：producer／consumer 和 broker 之间的 TCP 连接</li><li><strong>Channel</strong>：<ul><li>如果每一次访问 RabbitMQ 都建立一个 Connection，在消息量大的时候建立 TCPConnection 的开销将是巨大的，效率也较低</li><li>Channel 是在 connection 内部建立的逻辑连接，如果应用程序支持多线程，通常每个 thread 创建单独的 channel 进行通讯</li><li>AMQP method 包含了 channel id 帮助客户端和 message broker 识别 channel，所以 channel 之间是完全隔离的</li><li><strong>Channel 作为轻量级的Connection极大减少了操作系统建立 TCP connection 的开销</strong></li></ul></li><li><strong>Exchange</strong>：<ul><li>message 到达 broker 的第一站，根据分发规则，匹配查询表中的 routing key，分发消息到 queue 中去</li><li>常用的类型有：direct (point-to-point), topic (publish-subscribe) and fanout (multicast)</li></ul></li><li><strong>Queue</strong>：消息最终被送到这里等待 consumer 取走</li><li><strong>Binding</strong>：<strong>exchange 和 queue 之间的虚拟连接</strong>，binding 中可以包含 routing key，Binding 信息被保存到 exchange 中的查询表中，用于 message 的分发依据</li></ul><h4 id="1-2-4-安装"><a href="#1-2-4-安装" class="headerlink" title="1.2.4 安装"></a>1.2.4 安装</h4><blockquote><p><a href="https://blog.csdn.net/weixin_51560103/article/details/121492937">RabbitMQ安装教程（最新RabbitMQ安装，通用教程）_rabbitmq 安装教程-CSDN博客</a> </p><p><a href="https://blog.csdn.net/qq_45173404/article/details/116429302">RabbitMQ超详细安装教程（Linux）_rabbitmq安装-CSDN博客</a> </p><p>官网没看到 centos7 的，直接用课件里的下载吧，由于是基于 erlang 语言开发的，所以这个环境也得有</p></blockquote><ul><li><strong>官网地址</strong>：<code>https://www.rabbitmq.com/download.html</code></li></ul><p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/1696326762615.png" alt="1696326762615"></p><p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/1696326916721.png" alt="1696326916721"></p><ul><li><strong>安装文件(分别按照以下顺序安装)</strong></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh erlang-21.3-1.el7.x86_64.rpm  # 语言环境</span><br><span class="line">yum install socat -y  # 依赖包</span><br><span class="line">rpm -ivh rabbitmq-server-3.8.8-1.el7.noarch.rpm</span><br></pre></td></tr></table></figure><p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/1696327263436.png" alt="1696327263436"></p><p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/1696327336516.png" alt="1696327336516"></p><p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/1696327406332.png" alt="1696327406332"></p><ul><li><p><strong>常用命令(按照以下顺序执行)</strong> </p><ul><li><p>添加开机启动 RabbitMQ 服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chkconfig rabbitmq-server on</span><br></pre></td></tr></table></figure></li><li><p>启动服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/sbin/service rabbitmq-server start </span><br></pre></td></tr></table></figure></li><li><p>查看服务状态</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/sbin/service rabbitmq-server status</span><br></pre></td></tr></table></figure></li></ul><p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/1696327594120.png" alt="1696327594120"></p><ul><li>停止服务(选择执行)</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/sbin/service rabbitmq-server stop </span><br></pre></td></tr></table></figure><ul><li><strong>开启 web 管理插件</strong>(先停止服务再安装插件，安装完后再开启服务)</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmq-plugins enable rabbitmq_management</span><br></pre></td></tr></table></figure></li><li><p><strong>访问 web 页面的步骤</strong>：(前提是已经开启服务)</p><ul><li>查看防火墙状态</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl status firewalld</span><br></pre></td></tr></table></figure><ul><li>关闭防火墙</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop firewalld</span><br></pre></td></tr></table></figure><blockquote><p>除了直接关闭之外，刚学了 nginx，当时把80端口开放了，同理这里也可以把需要的端口开放即可，比如：<code>firewall-cmd --zone=public --add-port=15672/tcp --permanent</code></p><p>然后重启防火墙：<code>firewall-cmd --reload</code></p><p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/1696328294984.png" alt="1696328294984"></p><p>云服务器的话，还需要去官网控制台开下防火墙端口即可</p></blockquote><ul><li>访问页面：<code>192.168.3.195:15672</code></li></ul><blockquote><p>初始账号密码均为：<code>guest</code>，但是报错没有权限</p></blockquote><p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/1696328423232.png" alt="1696328423232"></p></li></ul><h4 id="1-2-5-添加用户并设置权限"><a href="#1-2-5-添加用户并设置权限" class="headerlink" title="1.2.5 添加用户并设置权限"></a>1.2.5 添加用户并设置权限</h4><ul><li><p><strong>添加一个新的用户</strong></p><ul><li>创建账号：<code>rabbitmqctl add_user admin 123</code></li></ul><blockquote><p>用户名为 admin，密码为 123</p></blockquote><ul><li>设置用户角色：<code>rabbitmqctl set_user_tags admin administrator</code></li><li>设置用户权限：<code>rabbitmqctl set_permissions -p &quot;/&quot; admin &quot;.*&quot; &quot;.*&quot; &quot;.*&quot;</code></li></ul><blockquote><p><code>set_permissions [-p &lt;vhostpath&gt;] &lt;user&gt; &lt;conf&gt; &lt;write&gt; &lt;read&gt;</code></p><p>用户 user_admin 具有&#x2F;vhost1 这个 virtual host 中所有资源的配置、写、读权限<br>    -  查看当前用户和角色：<code>rabbitmqctl list_users</code></p></blockquote></li></ul><p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/1696329829860.png" alt="1696329829860"></p><ul><li><strong>再次利用 admin 用户登录</strong></li></ul><p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/1696329911633.png" alt="1696329911633"></p><blockquote><p>可以看到当前的 vh 是 <code>/</code></p><p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/1696330008927.png" alt="1696330008927"></p></blockquote><ul><li><strong>重置命令</strong><ul><li>关闭应用的命令为：<code>rabbitmqctl stop_app</code></li><li>清除的命令为：<code>rabbitmqctl reset</code></li><li>重新启动命令为：<code>rabbitmqctl start_app</code></li></ul></li></ul><h2 id="2-Hello-World"><a href="#2-Hello-World" class="headerlink" title="2. Hello World"></a>2. Hello World</h2><blockquote><p>这一部分中，我们将用 Java 编写两个程序：发送单个消息的生产者和接收消息并打印出来的消费者；</p><p>在下图中，“ P”是我们的生产者，“ C”是我们的消费者。中间的框是一个队列-RabbitMQ 代表使用者保留的消息缓冲区</p><p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/1696330081432.png" alt="1696330081432"></p><p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/1696331108425.png" alt="1696331108425"></p></blockquote><h3 id="2-1-创建工程并添加依赖"><a href="#2-1-创建工程并添加依赖" class="headerlink" title="2.1 创建工程并添加依赖"></a>2.1 创建工程并添加依赖</h3><ul><li><strong>创建一个新的空工程</strong></li></ul><p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/1696330354476.png" alt="1696330354476"></p><p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/1696330513210.png" alt="1696330513210"></p><ul><li><strong>再创建一个新的maven模块</strong></li></ul><p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/1696330605542.png" alt="1696330605542"></p><p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/1696330703776.png" alt="1696330703776"></p><ul><li><strong>依赖</strong>：</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--指定 jdk 编译版本--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">source</span>&gt;</span>8<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">target</span>&gt;</span>8<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--rabbitmq 依赖客户端--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.rabbitmq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>amqp-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.8.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--操作文件流的一个依赖--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/1696330901573.png" alt="1696330901573"></p><h3 id="2-2-消息生产者"><a href="#2-2-消息生产者" class="headerlink" title="2.2 消息生产者"></a>2.2 消息生产者</h3><blockquote><p>连接超时的注意把防火墙关了！！或者再给防火墙开个端口：5672</p><p><code>firewall-cmd --zone=public --add-port=5672/tcp --permanent</code></p><p>然后重启防火墙：<code>firewall-cmd --reload</code></p></blockquote><ul><li><strong>代码</strong>：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 生产者: 发消息（发给队列）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Producer</span> &#123;</span><br><span class="line">    <span class="comment">// 队列名称 (快捷键 psf, 大写转换: ctrl+shift+U)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发消息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1. 创建一个连接工厂</span></span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 设置参数</span></span><br><span class="line">        <span class="comment">// 2.1 工厂 IP 连接 RabbitMQ 的队列</span></span><br><span class="line">        factory.setHost(<span class="string">&quot;192.168.3.196&quot;</span>);</span><br><span class="line">        <span class="comment">// 2.2 用户名</span></span><br><span class="line">        factory.setUsername(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        <span class="comment">// 2.3 密码</span></span><br><span class="line">        factory.setPassword(<span class="string">&quot;123&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 创建连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line">        <span class="comment">// 4. 通过连接创建信道</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 声明一个队列 参数:</span></span><br><span class="line">        <span class="comment">// (1)队列名称</span></span><br><span class="line">        <span class="comment">// (2)队列里的消息是否持久化(存在磁盘上), 默认情况(false)消息存储在内存中</span></span><br><span class="line">        <span class="comment">// (3)该队列是否只供一个消费者进行消费, 即是否进行消息的共享, true表示只供个消费者消费</span></span><br><span class="line">        <span class="comment">// (4)是否自动删除, 最后一个消费者端开连接后, 该队列是否自动删除, true表示自动删除</span></span><br><span class="line">        <span class="comment">// (5)其他参数</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6. 消息体</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7. 发消息 参数:</span></span><br><span class="line">        <span class="comment">// (1)表示发送到哪个交换机  这里暂时不考虑, 所以给了个空串</span></span><br><span class="line">        <span class="comment">// (2)路由的Key值是哪个  这里是队列名称</span></span><br><span class="line">        <span class="comment">// (3)其他参数信息</span></span><br><span class="line">        <span class="comment">// (4)发送消息的消息体 需要用二进制形式</span></span><br><span class="line">        channel.basicPublish(<span class="string">&quot;&quot;</span>, QUEUE_NAME, <span class="literal">null</span>, message.getBytes());</span><br><span class="line">        System.out.println(<span class="string">&quot;消息发送完毕&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>结果</strong>：</li></ul><p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/1696332830165.png" alt="1696332830165"></p><p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/1696332809480.png" alt="1696332809480"></p><p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/1696332790842.png" alt="1696332790842"></p><h3 id="2-3-消息消费者"><a href="#2-3-消息消费者" class="headerlink" title="2.3 消息消费者"></a>2.3 消息消费者</h3><ul><li><strong>代码</strong>：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 接收消息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer</span> &#123;</span><br><span class="line">    <span class="comment">// 队列名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接收消息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1. 创建连接工厂</span></span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 设置参数</span></span><br><span class="line">        <span class="comment">// 2.1 设置ip</span></span><br><span class="line">        factory.setHost(<span class="string">&quot;192.168.3.196&quot;</span>);</span><br><span class="line">        <span class="comment">// 2.2 设置用户名</span></span><br><span class="line">        factory.setUsername(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        <span class="comment">// 2.3 设置密码</span></span><br><span class="line">        factory.setPassword(<span class="string">&quot;123&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 创建连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line">        <span class="comment">// 4. 通过连接创建信道</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 声明回调接口（这里用 lambda 表达式声明）</span></span><br><span class="line">        <span class="comment">// 5.1 接收消息的回调:</span></span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, message) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(message.getBody()));</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 5.2 取消消息的回调:</span></span><br><span class="line">        <span class="type">CancelCallback</span> <span class="variable">cancelCallback</span> <span class="operator">=</span> (consumerTag) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;消费消息被中断&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6. 消费者消费消息 参数:</span></span><br><span class="line">        <span class="comment">// (1) queue: 消费哪个队列</span></span><br><span class="line">        <span class="comment">// (2) autoAck: 消费成功之后是否要自动应答  true代表自动应答 false代表手动应答</span></span><br><span class="line">        <span class="comment">// (3) deliverCallback: 当一个消息发送过来后的回调接口(也就是消费者成功消费的回调)</span></span><br><span class="line">        <span class="comment">// (4) cancelCallback: 消费者取消消费的回调</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME, <span class="literal">true</span>, deliverCallback, cancelCallback);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>结果</strong>：</li></ul><blockquote><p>注意这两都在运行</p><p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/1696334949148.png" alt="1696334949148"></p></blockquote><p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/1696334924600.png" alt="1696334924600"></p><p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/1696334983106.png" alt="1696334983106"></p><h2 id="3-Work-Queues"><a href="#3-Work-Queues" class="headerlink" title="3. Work Queues"></a>3. Work Queues</h2><blockquote><p>工作队列(又称任务队列)的主要思想是<strong>避免立即执行资源密集型任务，而不得不等待它完成</strong>，相反我们安排任务在之后执行，我们把任务封装为消息并将其发送到队列</p><p>在后台运行的工作进程将弹出任务并最终执行作业，<strong>当有多个工作线程时，这些工作线程将一起处理这些任务</strong></p></blockquote><p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/image-20240324193014618.png" alt="image-20240324193014618"></p><h3 id="3-1-轮询分发消息"><a href="#3-1-轮询分发消息" class="headerlink" title="3.1 轮询分发消息"></a>3.1 轮询分发消息</h3><p><strong>案例</strong>：启动两个工作线程，一个消息发送线程，观察工作线程如何工作</p><h4 id="3-1-1-抽取工具类"><a href="#3-1-1-抽取工具类" class="headerlink" title="3.1.1 抽取工具类"></a>3.1.1 抽取工具类</h4><ul><li>将创建 连接工厂 和 创建信道 作为公共部分抽取出来</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 连接工厂创建信道工具类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitMqUtils</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 得到一个连接的 channel</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Channel <span class="title function_">getChannel</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 创建一个连接工厂</span></span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置参数</span></span><br><span class="line">        factory.setHost(<span class="string">&quot;192.168.10.254&quot;</span>);</span><br><span class="line">        factory.setUsername(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        factory.setPassword(<span class="string">&quot;123&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过连接创建信道</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> channel;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-1-2-启动两个工作进程"><a href="#3-1-2-启动两个工作进程" class="headerlink" title="3.1.2 启动两个工作进程"></a>3.1.2 启动两个工作进程</h4><ul><li>先写消费者代码</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Worker01</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME=<span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtils.getChannel();</span><br><span class="line">        DeliverCallback deliverCallback=(consumerTag,delivery)-&gt;&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">receivedMessage</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody());</span><br><span class="line">            System.out.println(<span class="string">&quot;接收到消息:&quot;</span>+receivedMessage);</span><br><span class="line">        &#125;;</span><br><span class="line">        CancelCallback cancelCallback=(consumerTag)-&gt;&#123;</span><br><span class="line">            System.out.println(consumerTag+<span class="string">&quot;消费者取消消费接口回调逻辑&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(<span class="string">&quot;C2 消费者启动等待消费......&quot;</span>);</span><br><span class="line">        channel.basicConsume(QUEUE_NAME,<span class="literal">true</span>,deliverCallback,cancelCallback);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>利用 idea 设置，启动两次 代表 两个工作进程(消费者)</li></ul><p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/image-20240324195454613.png" alt="image-20240324195454613"></p><p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/image-20240324195905816.png" alt="image-20240324195905816"></p><h4 id="3-1-3-启动一个发送进程"><a href="#3-1-3-启动一个发送进程" class="headerlink" title="3.1.3 启动一个发送进程"></a>3.1.3 启动一个发送进程</h4><ul><li>编写生产者代码</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Task01</span> &#123;</span><br><span class="line">    <span class="comment">// 队列名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 发送大量消息</span></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtils.getChannel()) &#123;</span><br><span class="line">            <span class="comment">// 声明队列</span></span><br><span class="line">            channel.queueDeclare(QUEUE_NAME, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 从控制台当中接受信息</span></span><br><span class="line">            <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">            <span class="keyword">while</span> (scanner.hasNext()) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">                channel.basicPublish(<span class="string">&quot;&quot;</span>, QUEUE_NAME, <span class="literal">null</span>, message.getBytes());</span><br><span class="line">                System.out.println(<span class="string">&quot;发送消息完成:&quot;</span> + message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-1-4-结果"><a href="#3-1-4-结果" class="headerlink" title="3.1.4 结果"></a>3.1.4 结果</h4><p>通过程序执行发现生产者总共发送 4 个消息，消费者 1 和消费者 2 分别分得两个消息，并且是按照有序的一个接收一次消息</p><blockquote><p>谁接收到第一条消息都是正常的，只不过是必须是轮询的</p><p>C1 接收了 aa，那么 bb 必定是 C2 接收的</p></blockquote><p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/image-20240324200514301.png" alt="image-20240324200514301"></p><h3 id="3-2-消息应答"><a href="#3-2-消息应答" class="headerlink" title="3.2 消息应答"></a>3.2 消息应答</h3><h4 id="3-2-1-概念"><a href="#3-2-1-概念" class="headerlink" title="3.2.1 概念"></a>3.2.1 概念</h4><p>消费者完成一个任务可能需要一段时间，如果其中<strong>一个消费者处理一个长的任务并仅只完成了部分突然它挂掉了</strong>，会发生什么情况？ </p><p>RabbitMQ 一旦向消费者传递了一条消息，便立即将该消息标记为删除。在这种情况下，突然有个消费者挂掉了，我们将丢失正在处理的消息。以及后续发送给该消费这的消息，因为它无法接收到。</p><p><strong>为了保证消息在发送过程中不丢失</strong>，rabbitmq 引入<strong>消息应答机制</strong>，消息应答就是：<strong>消费者在接收到消息并且处理该消息之后，告诉 rabbitmq 它已经处理了，rabbitmq 可以把该消息删除了</strong> </p><p><strong>消息应答</strong>：</p><ul><li>自动应答  &#x3D;&#x3D;&gt; 并不完善</li><li>手动应答</li></ul><h4 id="3-2-2-自动应答"><a href="#3-2-2-自动应答" class="headerlink" title="3.2.2 自动应答"></a>3.2.2 自动应答</h4><blockquote><p>在自动应答模式下，一旦RabbitMQ将消息派发给消费者，它立即将该消息标记为确认</p></blockquote><ul><li>消息发送后立即被认为已经传送成功，这种模式需要在 <strong>高吞吐量和数据传输安全性方面做平衡</strong><ul><li>因为这种模式如果消息在接收到之前，消费者那边出现连接或者 channel 关闭，那么消息就丢失了</li><li>另一方面这种模式消费者那边可以传递过载的消息，<strong>没有对传递的消息数量进行限制</strong>，当然这样有可能使得消费者这边由于接收太多还来不及处理的消息，导致这些消息的积压，最终使得内存耗尽，最终这些消费者线程被操作系统杀死，</li><li><strong>所以这种模式仅适用在消费者可以高效并以某种速率能够处理这些消息的情况下使用</strong></li></ul></li></ul><h4 id="3-2-3-消息应答的方法"><a href="#3-2-3-消息应答的方法" class="headerlink" title="3.2.3 消息应答的方法"></a>3.2.3 消息应答的方法</h4><ul><li><strong>Channel.basicAck(用于肯定确认)</strong><ul><li>RabbitMQ 已知道该消息并且成功的处理消息，可以将其丢弃了</li><li>两个参数，<code>deliveryTag</code>（消息投递标签）和<code>multiple</code>（是否批量确认）</li></ul></li><li><strong>Channel.basicNack(用于否定确认)</strong><ul><li>支持批量否定确认（通过<code>multiple</code>参数）</li><li>除了<code>deliveryTag</code>和<code>multiple</code>参数，<code>basicNack</code>还有一个<code>requeue</code>参数<ul><li>如果<code>requeue</code>为<code>true</code>，RabbitMQ会将消息重新放回队列中</li><li>如果为<code>false</code>，则消息会被RabbitMQ丢弃或发送到死信队列（如果配置了的话）</li></ul></li></ul></li><li><strong>Channel.basicReject(用于否定确认)</strong><ul><li>与 Channel.basicNack 相比少一个参数 <code>multiple</code><ul><li><code>basicReject</code>有两个参数，<code>deliveryTag</code>和<code>requeue</code></li></ul></li><li>不处理该消息了直接拒绝，可以将其丢弃了</li></ul></li></ul><h4 id="3-2-4-Multiple-的解释"><a href="#3-2-4-Multiple-的解释" class="headerlink" title="3.2.4 Multiple 的解释"></a>3.2.4 Multiple 的解释</h4><p><strong>手动应答的好处是可以批量应答并且减少网络拥堵</strong></p><ul><li>multiple 的 true 和 false：<ul><li>true 代表批量应答 channel 上未应答的消息<ul><li>比如说 channel 上有传送 tag 的消息 5,6,7,8 </li><li>当前 tag 是 8 ，那么此时 5-8 的这些还未应答的消息都会被确认收到消息应答</li></ul></li><li>false 同上面相比<ul><li>只会应答 tag&#x3D;8 的消息 5,6,7 这三个消息依然不会被确认收到消息应答</li></ul></li></ul></li></ul><p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/image-20240324202504504.png" alt="image-20240324202504504"></p><h4 id="3-2-5-消息自动重新入队"><a href="#3-2-5-消息自动重新入队" class="headerlink" title="3.2.5 消息自动重新入队"></a>3.2.5 消息自动重新入队</h4><ul><li>当消费者接收到消息但由于某种原因无法处理时，可以选择让消息自动重新入队，这意味着消息会被放回队列中，等待再次被消费</li><li><strong>自动入队的工作原理</strong>：<ul><li><strong>未确认的消息</strong>：在手动应答模式下，如果消费者接收了一条消息但还没有对其进行确认（ack、nack或reject），那么在消费者连接断开时，这条消息会被RabbitMQ视为未确认的消息，并将其自动重新入队（通常会被放回队列的尾部）</li><li><strong>否定确认与重新入队</strong>：当使用<code>basicNack</code>或<code>basicReject</code>方法进行否定确认时，消费者可以指定是否要将消息重新入队。如果选择重新入队，该消息将再次成为队列中的一部分，可以被相同的消费者或其他消费者再次接收和处理</li></ul></li></ul><p>RabbitMQ 将了解到消息未完全处理，并将对其重新排队。如果此时其他消费者可以处理，它将很快将其重新分发给另一个消费者。</p><p>这样，即使某个消费者偶尔死亡，也可以确保不会丢失任何消息。</p><h4 id="3-2-6-消息手动应答代码"><a href="#3-2-6-消息手动应答代码" class="headerlink" title="3.2.6 消息手动应答代码"></a>3.2.6 消息手动应答代码</h4><p><strong>默认消息采用的是自动应答</strong>，所以我们要想实现消息消费过程中不丢失，需要把自动应答改为手动应答</p><p>消费者在之前代码的基础上增加修改代码：</p><ul><li>接收消息部分：改 autoAck 为 false 手动应答</li><li>消费者消费成功的回调函数中：增加代码表示是肯定的应答</li></ul><p>编写两个消费者代码：</p><ul><li>C1 等待接收消息处理的时间为 1 秒</li><li>C2 等待接收消息处理的时间为 30 秒</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Worker03</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 队列名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TASK_QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;ack_queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 通过工具类获取信道</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtils.getChannel();</span><br><span class="line">        System.out.println(<span class="string">&quot;C1 等待接收消息处理时间较短......&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接收消息</span></span><br><span class="line">        <span class="comment">// 消费者成功消费的回调</span></span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 睡眠 1s</span></span><br><span class="line">            SleepUtils.sleep(<span class="number">1</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">receivedMessage</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody());</span><br><span class="line">            System.out.println(<span class="string">&quot;接收到消息: &quot;</span> + receivedMessage);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 手动应答, 参数:</span></span><br><span class="line">            <span class="comment">// (1) 消息的标签</span></span><br><span class="line">            <span class="comment">// (2) 是否应该批量应答 ==&gt; 不应该, 否则容易出现消息丢失, 应处理一个应答一个</span></span><br><span class="line">            channel.basicAck(delivery.getEnvelope().getDeliveryTag(), <span class="literal">false</span>);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 消费者取消消费的回调</span></span><br><span class="line">        <span class="type">CancelCallback</span> <span class="variable">cancelCallback</span> <span class="operator">=</span> (consumerTag) -&gt; &#123;</span><br><span class="line">            System.out.println(consumerTag + <span class="string">&quot;消费者取消消费接口回调逻辑&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第二个参数 autoAck 为 true 为自动应答, 改为 false 后即为手动应答</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">autoAck</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        channel.basicConsume(TASK_QUEUE_NAME, autoAck, deliverCallback, cancelCallback);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>睡眠工具类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SleepUtils</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">(<span class="type">int</span> second)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>*second);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException _ignored) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-7-手动应答效果演示"><a href="#3-2-7-手动应答效果演示" class="headerlink" title="3.2.7 手动应答效果演示"></a>3.2.7 手动应答效果演示</h4><ul><li><strong>测试目标</strong>：验证 消息在手动应答时不会丢失，而是放回队列中重新消费<ul><li>先运行生产者(因为目前还没创建信道)，再运行两个消费者</li></ul></li><li>正常情况下消息发送方发送两个消息 C1 和 C2 分别接收到消息并进行处理</li></ul><p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/image-20240324211852173.png" alt="image-20240324211852173"></p><ul><li>在发送者发送消息 dd，发出消息之后的把 C2 消费者停掉，按理说该 C2 来处理该消息，但是由于它处理时间较长，在还未处理完</li><li>也就是说 C2 还没有执行 ack 代码的时候，C2 被停掉了，此时会看到消息被 C1 接收到了，说明消息 dd 被重新入队，然后分配给能处理消息的 C1 处理了</li></ul><p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/image-20240324211954960.png" alt="image-20240324211954960"></p><h3 id="3-3-RabbitMQ-持久化"><a href="#3-3-RabbitMQ-持久化" class="headerlink" title="3.3 RabbitMQ 持久化"></a>3.3 RabbitMQ 持久化</h3><h4 id="3-3-1-概念"><a href="#3-3-1-概念" class="headerlink" title="3.3.1 概念"></a>3.3.1 概念</h4><p>如何保障当 RabbitMQ 服务停掉以后消息生产者发送过来的消息不丢失。</p><p>默认情况下 RabbitMQ 退出或由于某种原因崩溃时，它忽视队列和消息。确保消息不会丢失需要做两件事：<strong>我们需要将队列和消息都标记为持久化</strong></p><h4 id="3-3-2-队列如何实现持久化"><a href="#3-3-2-队列如何实现持久化" class="headerlink" title="3.3.2 队列如何实现持久化"></a>3.3.2 队列如何实现持久化</h4><ul><li>之前我们创建的队列都是非持久化的，rabbitmq 如果重启，该队列就会被删除掉，如果要队列实现持久化 需要<strong>在声明队列的时候把 durable 参数设置为持久化</strong> （这样即使重启 rabbitmq 队列也依然存在）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第二个参数 false =&gt; true</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">durable</span> <span class="operator">=</span> <span class="literal">true</span>;  <span class="comment">// 需要进行持久化</span></span><br><span class="line">channel.queueDeclare(TASK_QUEUE_NAME, durable, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure><ul><li><strong>注意</strong>：如果之前声明的队列不是持久化的，<strong>需要把原先队列先删除，或者重新创建一个持久化的队列</strong>，不然就会出现错误<ul><li>先删：</li></ul></li></ul><p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/image-20240324213149448.png" alt="image-20240324213149448"></p><ul><li>出现了持久化标识：注意这表示队列持久化，而不是消息持久化</li></ul><p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/image-20240324212904947.png" alt="image-20240324212904947"></p><h4 id="3-3-3-消息实现持久化"><a href="#3-3-3-消息实现持久化" class="headerlink" title="3.3.3 消息实现持久化"></a>3.3.3 消息实现持久化</h4><ul><li>要想让消息实现持久化需要在消息<strong>生产者修改代码，<code>MessageProperties.PERSISTENT_TEXT_PLAIN</code> 添加文本持久化属性</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置生产者发送消息为持久化消息(要求保存到磁盘上), 不写就默认保存在内存中(会丢失)</span></span><br><span class="line">channel.basicPublish(<span class="string">&quot;&quot;</span>, TASK_QUEUE_NAME, MessageProperties.PERSISTENT_TEXT_PLAIN, message.getBytes());</span><br></pre></td></tr></table></figure><ul><li><p>将消息标记为持久化并不能完全保证不会丢失消息</p><ul><li>尽管它告诉 RabbitMQ 将消息保存到磁盘，但是这里依然存在<strong>当消息刚准备存储在磁盘的时候 但是还没有存储完，消息还在缓存的一个间隔点</strong>。</li><li>此时并没有真正写入磁盘。持久性保证并不强，但是对于简单任务队列而言，这已经绰绰有余了。</li></ul></li><li><p>如果需要<strong>更强有力的持久化策略，参考后边 8. 发布确认 章节</strong></p></li></ul><h4 id="3-3-4-不公平分发"><a href="#3-3-4-不公平分发" class="headerlink" title="3.3.4 不公平分发"></a>3.3.4 不公平分发</h4><ul><li><strong>默认情况下</strong>，RabbitMQ 分发消息采用的<strong>轮询分发</strong></li></ul><blockquote><p>如果所有消费者都能以相同的速率处理消息，轮询分发是一个公平且高效的策略</p></blockquote><ul><li>但是，如果某些消费者能够处理消息更快，而其他消费者处理得更慢，那么更快的消费者在完成工作后会空闲等待，因为RabbitMQ 仍然试图平等地分配消息给所有消费者</li><li>为了避免这种情况，我们可以<strong>通过设置较低的预取计数值来实现不公平分发</strong>，通常是1，意味着 RabbitMQ 一次只会向每个消费者发送一条消息，等待消费者处理完并发送ack之后，才会发送下一条消息。这样，更快的消费者能够更频繁地接收消息，而不是等待其他消费者处理完他们的消息</li><li>在两个<strong>消费者端</strong>，可以通过<code>basicQos</code>方法来设置预取计数值：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置不公平分发</span></span><br><span class="line"><span class="type">int</span> <span class="variable">prefetchCount</span> <span class="operator">=</span> <span class="number">1</span>;  <span class="comment">// 0 是公平分发, 1 是不公平分发</span></span><br><span class="line">channel.basicQos(prefetchCount);</span><br></pre></td></tr></table></figure><ul><li>意思就是如果这个任务我还没有处理完或者我还没有应答你，你先别分配给我，我目前只能处理一个任务</li><li>然后 rabbitmq 就会把该任务分配给没有那么忙的那个空闲消费者，当然如果所有的消费者都没有完成手上任务，队列还在不停的添加新任务，队列有可能就会遇到队列被撑满的情况，这个时候就只能添加新的 worker 或者改变其他存储任务的策略</li></ul><h4 id="3-3-5-预取值"><a href="#3-3-5-预取值" class="headerlink" title="3.3.5 预取值"></a>3.3.5 预取值</h4><blockquote><p>预取值控制着消息的流速以及如何基于消费者的能力来优化消息分发</p><p>主要目的是为了平衡各个消费者的负载，防止快速的消费者空闲，同时避免慢的消费者积累太多待处理的消息</p><p>告诉RabbitMQ不要同时给一个消费者发送超过设定数量的消息，除非这些消息已经被确认</p></blockquote><ul><li>异步消息发送意味着消息可以快速地发送给消费者，而不需要等待每条消息都被确认<ul><li>但这也可能导致一个快速的消费者接收到过多的消息，而来不及处理</li><li>通过设置预取值，RabbitMQ能够更智能地控制消息的流向，确保消费者能够以他们自己的速度处理消息。<strong>该值定义通道上允许的未确认消息的最大数量</strong>。一旦数量达到配置的数量，RabbitMQ 将停止在通道上传递更多消息，除非至少有一个未处理的消息被确认</li><li>例如，假设在通道上有未确认的消息 5、6、7，8，并且通道的预取计数设置为 4，此时 RabbitMQ 将不会在该通道上再传递任何消息，除非至少有一个未应答的消息被 ack。比方说 tag&#x3D;6 这个消息刚刚被确认 ACK，RabbitMQ 将会感知这个情况到并再发送一条消息</li></ul></li></ul><p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/image-20240324215642902.png" alt="image-20240324215642902"></p><ul><li>消息应答和 QoS 预取值对用户吞吐量有重大影响<ul><li>通常，增加预取将提高向消费者传递消息的速度。<strong>虽然自动应答传输消息速率是最佳的，但是，在这种情况下已传递但尚未处理的消息的数量也会增加，从而增加了消费者的</strong> <strong>RAM</strong> <strong>消耗</strong>(随机存取存储器)</li><li>应该小心使用具有无限预处理的自动确认模式或手动确认模式，消费者消费了大量的消息如果没有确认的话，会导致消费者连接节点的内存消耗变大</li><li>所以找到合适的预取值是一个反复试验的过程，<strong>不同的负载该值取值也不同</strong>，100 到 300 范围内的值通常可提供最佳的吞吐量，并且不会给消费者带来太大的风险</li><li>预取值为 1 是最保守的。当然这将使吞吐量变得很低，特别是消费者连接延迟很严重的情况下，特别是在消费者连接等待时间较长的环境中。对于大多数应用来说，稍微高一点的值将是最佳的</li></ul></li></ul><h2 id="4-发布确认"><a href="#4-发布确认" class="headerlink" title="4. 发布确认"></a>4. 发布确认</h2><h3 id="4-1-发布确认原理"><a href="#4-1-发布确认原理" class="headerlink" title="4.1 发布确认原理"></a>4.1 发布确认原理</h3><blockquote><p>发布确认（Publisher Confirms）机制是一种确保消息从生产者发送到 RabbitMQ 服务器的可靠方式</p><p>这种机制允许生产者知道其消息是否已成功到达目标队列</p></blockquote><p><strong>工作原理</strong>：</p><ul><li><strong>启用发布确认模式</strong>：生产者在通道上启用发布确认，启用后，该通道会进入发布确认模式。</li><li><strong>发送消息</strong>：生产者通过已启用发布确认的通道发送消息。发送消息时，<strong>生产者可以为每条消息指定一个唯一的标识符</strong>(从 1 开始)。</li><li><strong>等待确认</strong>：发送消息后，生产者等待来自RabbitMQ服务器的确认。服务器确认消息的两种方式：<ul><li><strong>确认（Ack）</strong>：如果<strong>消息被队列接受，RabbitMQ服务器会发送一个确认给生产者</strong>(包含消息的唯一 ID)，表明消息已被成功接收。</li><li><strong>未确认（Nack）</strong>：如果消息由于某些原因未能被队列接受，服务器会发送一个未确认给生产者，指出消息没有被成功处理。</li></ul></li><li><strong>处理确认</strong>：生产者根据收到的确认或未确认采取相应的行动。例如，如果收到未确认，生产者可能决定重新发送消息或记录错误。</li></ul><p>confirm 模式最大的好处在于他是异步的，一旦发布一条消息，<strong>生产者应用程序就可以在等信道返回确认的同时继续发送下一条消息</strong>，当消息最终得到确认之后，生产者应用便可以通过回调方法来处理该确认消息。</p><h3 id="4-2-发布确认策略"><a href="#4-2-发布确认策略" class="headerlink" title="4.2 发布确认策略"></a>4.2 发布确认策略</h3><blockquote><p>三种：单个确认、批量确认和异步确认</p></blockquote><h4 id="4-2-1-开启发布确认的方法"><a href="#4-2-1-开启发布确认的方法" class="headerlink" title="4.2.1 开启发布确认的方法"></a>4.2.1 开启发布确认的方法</h4><ul><li><p>发布确认<strong>默认是没有开启的</strong></p></li><li><p>如果要开启需要调用方法   <code>confirmSelect</code>，每当你要想使用发布确认，都需要在 channel 上调用该方法（<strong>获取了信道后开启发布确认</strong>）</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtils.getChannel();</span><br><span class="line">channel.confirmSelect();</span><br></pre></td></tr></table></figure><h4 id="4-2-2-单个确认发布"><a href="#4-2-2-单个确认发布" class="headerlink" title="4.2.2 单个确认发布"></a>4.2.2 单个确认发布</h4><ul><li>是一种<strong>同步确认发布</strong>的方式，也就是发布一个消息之后只有它被确认发布，后续的消息才能继续发布</li><li><code>waitForConfirmsOrDie(long)</code> 这个方法只有在消息被确认的时候才返回，如果在指定时间范围内这个消息没有被确认那么它将抛出异常。</li><li><strong>缺点</strong>：<strong>发布速度特别的慢</strong>，因为如果没有确认发布的消息就会阻塞所有后续消息的发布，这种方式<strong>最多提供每秒不超过数百条发布消息的吞吐量</strong>（对于某些应用程序来说这可能已经足够了）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 单个确认</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">publishMessageIndividually</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtils.getChannel()) &#123;</span><br><span class="line">        <span class="comment">// 队列名称 这里用 UUID 随机生成名称</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> UUID.randomUUID().toString();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 声明队列</span></span><br><span class="line">        channel.queueDeclare(queueName, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开启发布确认</span></span><br><span class="line">        channel.confirmSelect();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开始时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">begin</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 批量发消息</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; MESSAGE_COUNT; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> i + <span class="string">&quot;&quot;</span>;  <span class="comment">// 消息内容</span></span><br><span class="line">            <span class="comment">// 发消息</span></span><br><span class="line">            channel.basicPublish(<span class="string">&quot;&quot;</span>, queueName, <span class="literal">null</span>, message.getBytes());</span><br><span class="line">            <span class="comment">// 单个消息就马上进行发布确认</span></span><br><span class="line">            <span class="comment">// 服务端返回 false 或超时时间内未返回, 生产者可以消息重发</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> channel.waitForConfirms();</span><br><span class="line">            <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;消息发送成功&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 结束时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="comment">// 用时</span></span><br><span class="line">        System.out.println(<span class="string">&quot;发布&quot;</span> + MESSAGE_COUNT + <span class="string">&quot;个单独确认消息,耗时&quot;</span> + (end - begin) +</span><br><span class="line">                           <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-2-3-批量确认发布"><a href="#4-2-3-批量确认发布" class="headerlink" title="4.2.3 批量确认发布"></a>4.2.3 批量确认发布</h4><ul><li><p>与单个等待确认消息相比，<strong>先发布一批消息然后一起确认</strong>可以极大地<strong>提高吞吐量</strong></p></li><li><p><strong>缺点</strong>：当发生故障导致发布出现问题时，不知道是哪个消息出现问题了，我们必须将整个批处理保存在内存中，以记录重要的信息而后重新发布消息</p><ul><li>当然这种方案仍然是<strong>同步的</strong>，也一样阻塞消息的发布</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">publishMessageBatch</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtils.getChannel()) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> UUID.randomUUID().toString();</span><br><span class="line">        channel.queueDeclare(queueName, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="comment">// 开启发布确认</span></span><br><span class="line">        channel.confirmSelect();</span><br><span class="line">        <span class="comment">// 批量确认消息大小</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">batchSize</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        <span class="comment">// 未确认消息个数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">outstandingMessageCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 开始时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">begin</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="comment">// 批量发送消息, 批量发布确认</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; MESSAGE_COUNT; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> i + <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="comment">// 发消息</span></span><br><span class="line">            channel.basicPublish(<span class="string">&quot;&quot;</span>, queueName, <span class="literal">null</span>, message.getBytes());</span><br><span class="line">            outstandingMessageCount++;</span><br><span class="line">            <span class="comment">// 判断达到 100 条消息后, 批量确认一次</span></span><br><span class="line">            <span class="keyword">if</span> (outstandingMessageCount == batchSize) &#123;</span><br><span class="line">                channel.waitForConfirms();</span><br><span class="line">                outstandingMessageCount = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 为了确保还有剩余没有确认消息 再次确认</span></span><br><span class="line">        <span class="keyword">if</span> (outstandingMessageCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            channel.waitForConfirms();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;发布&quot;</span> + MESSAGE_COUNT + <span class="string">&quot;个批量确认消息,耗时&quot;</span> + (end - begin) +</span><br><span class="line">                           <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-2-4-异步确认发布"><a href="#4-2-4-异步确认发布" class="headerlink" title="4.2.4 异步确认发布"></a>4.2.4 异步确认发布</h4><ul><li>异步确认是一种高效的确认方式，无论是可靠性还是效率都很优秀，它是<strong>利用回调函数来达到消息可靠性传递</strong></li></ul><p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/image-20240329173344260.png" alt="image-20240329173344260"></p><ul><li><strong>如何处理异步未确认消息</strong> &#x3D;&#x3D;&gt; <strong>使用<code>ConcurrentSkipListMap</code>处理未确认消息</strong><ul><li><code>ConcurrentSkipListMap</code> 是 Java 并发包中的一种线程安全且排序的映射表<ul><li>内部使用跳表（Skip List）作为数据结构</li><li>跳表是一种概率性平衡的数据结构，通过多层索引来提高搜索、插入和删除操作的效率</li><li><code>ConcurrentSkipListMap</code> 提供了一种高效的并发访问和排序的映射结构</li></ul></li><li>用作<strong>发布线程和确认回调之间的桥梁</strong>(两个线程)，用于存储和传递未确认的消息<ul><li><strong>存储未确认消息</strong>：当生产者发送消息时，将该消息的标识（如消息ID或唯一标识符）和相关信息（如发送时间戳、重试次数等）存入<code>ConcurrentSkipListMap</code>。键可以是消息ID，值可以是包含消息详细信息和发送时间的对象</li><li><strong>访问和处理</strong>(移除已经确认的)：确认回调函数（即RabbitMQ向生产者确认消息时触发的回调）中，根据消息的标识（从确认通知中获得）查找<code>ConcurrentSkipListMap</code>中对应的条目，并将其移除。这表示消息已成功处理。对于识别出的超时未确认消息，可以执行重试逻辑，将消息重新发送</li></ul></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 3. 异步批量确认</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">publishMessageAsync</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtils.getChannel()) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> UUID.randomUUID().toString();</span><br><span class="line">        channel.queueDeclare(queueName, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="comment">// 开启发布确认</span></span><br><span class="line">        channel.confirmSelect();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 线程安全有序的一个map ConcurrentSkipListMap, 底层是跳表, 适用于高并发的情况</span></span><br><span class="line">        <span class="comment">// 1. 轻松的将序号与消息进行关联</span></span><br><span class="line">        <span class="comment">// 2. 轻松批量删除条目 只要给到序列号</span></span><br><span class="line">        <span class="comment">// 3. 支持并发访问</span></span><br><span class="line">        ConcurrentSkipListMap&lt;Long, String&gt; outstandingConfirms = <span class="keyword">new</span></span><br><span class="line">            <span class="title class_">ConcurrentSkipListMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 消息确认成功回调函数, 两个参数:</span></span><br><span class="line">        <span class="comment">// 1. 消息序列号</span></span><br><span class="line">        <span class="comment">// 2. true 可以确认小于等于当前序列号的消息</span></span><br><span class="line">        <span class="comment">//    false 确认当前序列号消息</span></span><br><span class="line">        <span class="type">ConfirmCallback</span> <span class="variable">ackCallback</span> <span class="operator">=</span> (sequenceNumber, multiple) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (multiple) &#123;  <span class="comment">// 如果是批量, 就批量移除</span></span><br><span class="line">                <span class="comment">// 返回的是小于等于当前序列号的未确认消息 是一个 map</span></span><br><span class="line">                ConcurrentNavigableMap&lt;Long, String&gt; confirmed =</span><br><span class="line">                    outstandingConfirms.headMap(sequenceNumber, <span class="literal">true</span>);</span><br><span class="line">                <span class="comment">// 清除该部分未确认消息</span></span><br><span class="line">                confirmed.clear();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 如果是单个确认</span></span><br><span class="line">                <span class="comment">// 只清除当前序列号的消息</span></span><br><span class="line">                outstandingConfirms.remove(sequenceNumber);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 消息确认失败回调函数</span></span><br><span class="line">        <span class="type">ConfirmCallback</span> <span class="variable">nackCallback</span> <span class="operator">=</span> (sequenceNumber, multiple) -&gt; &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> outstandingConfirms.get(sequenceNumber);</span><br><span class="line">            System.out.println(<span class="string">&quot;发布的消息&quot;</span> + message + <span class="string">&quot;未被确认，序列号&quot;</span> + sequenceNumber);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加一个异步确认的监听器 监听哪些消息成功了, 哪些消息失败了 两个参数:</span></span><br><span class="line">        <span class="comment">// 1. 确认收到消息的回调 ==&gt; 监听成功</span></span><br><span class="line">        <span class="comment">// 2. 未收到消息的回调  ==&gt; 监听失败, 不需要就写 null</span></span><br><span class="line">        channel.addConfirmListener(ackCallback, nackCallback);</span><br><span class="line">        <span class="comment">// 开始时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">begin</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 批量发送消息</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; MESSAGE_COUNT; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;消息&quot;</span> + i;</span><br><span class="line">            <span class="comment">// channel.getNextPublishSeqNo() 从信道中获取下一个消息的序列号</span></span><br><span class="line">            <span class="comment">// 通过序列号与消息体进行一个关联, 全部都是未确认的消息体</span></span><br><span class="line">            outstandingConfirms.put(channel.getNextPublishSeqNo(), message);</span><br><span class="line">            channel.basicPublish(<span class="string">&quot;&quot;</span>, queueName, <span class="literal">null</span>, message.getBytes());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;发布&quot;</span> + MESSAGE_COUNT + <span class="string">&quot;个异步确认消息,耗时&quot;</span> + (end - begin) +</span><br><span class="line">                           <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-2-5-以上-3-种发布确认速度对比"><a href="#4-2-5-以上-3-种发布确认速度对比" class="headerlink" title="4.2.5 以上 3 种发布确认速度对比"></a>4.2.5 以上 3 种发布确认速度对比</h4><ul><li><strong>单独发布消息</strong><ul><li>同步等待确认，简单，但吞吐量非常有限。</li></ul></li><li><strong>批量发布消息</strong><ul><li>批量同步等待确认，简单，合理的吞吐量，一旦出现问题但很难推断出是哪条消息出现了问题</li></ul></li><li><strong>异步处理</strong><ul><li>最佳性能和资源使用，在出现错误的情况下可以很好地控制，但是实现起来稍微难些</li></ul></li></ul><h2 id="5-交换机"><a href="#5-交换机" class="headerlink" title="5. 交换机"></a>5. 交换机</h2><ul><li><strong>工作队列模式</strong>：<ul><li>任务（消息）被分配给多个消费者中的一个。每个任务都恰好由一个消费者处理，这种模式适用于分布式任务处理场景，其中每个任务只需要被处理一次</li></ul></li><li><strong>发布&#x2F;订阅模式</strong>：<ul><li>消息不是被发送给单个消费者，而是被广播给所有订阅了该消息的消费者。这意味着发布的每条消息可以被多个消费者同时接收和处理</li><li>如，<strong>日志系统</strong>：<ul><li><strong>系统组成</strong>：示例中的日志系统由两部分组成：日志消息的生产者（发布者）和消费者（订阅者）。<ul><li><strong>生产者</strong>：负责发出日志消息。</li><li><strong>消费者</strong>：接收并处理日志消息。示例中有两个消费者：一个将日志消息保存到磁盘，另一个将消息打印到屏幕上。</li></ul></li><li><strong>消息广播</strong>：在这个系统中，生产者发出的日志消息会被广播给所有消费者。每个消费者都会接收到所有的日志消息，而<strong>不是像工作队列模式那样，一个消息只被一个消费者接收</strong></li></ul></li></ul></li></ul><h3 id="5-1-Exchanges"><a href="#5-1-Exchanges" class="headerlink" title="5.1 Exchanges"></a>5.1 Exchanges</h3><h4 id="5-1-1-概念"><a href="#5-1-1-概念" class="headerlink" title="5.1.1 概念"></a>5.1.1 概念</h4><ul><li>RabbitMQ 消息传递模型的<strong>核心思想</strong>：<strong>生产者生产的消息从不会直接发送到队列</strong><ul><li>实际上，通常生产者甚至都不知道这些消息传递传递到了哪些队列中</li><li>RabbitMQ中的消息传递模型通过<strong>引入交换机这一层，将生产者和队列解耦</strong>，提高了消息处理的灵活性和可扩展性</li><li><strong>生产者将消息发送到交换机，由交换机根据其类型和绑定规则决定消息的去向</strong>，这可以是一个队列、多个队列，或者在某些情况下，消息也可能被丢弃</li></ul></li></ul><p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/image-20240330161012976.png" alt="image-20240330161012976"></p><ul><li><p><strong>交换机（Exchange）的角色和工作机制</strong></p><ul><li><strong>交换机作为中介</strong>：一方面它接收来自生产者的消息，另一方面将它们推入队列。交换机是生产者和队列之间的中介</li><li><strong>处理规则由交换机类型决定</strong>：交换机根据自己的类型（如直接交换机、主题交换机、扇出交换机和头交换机）来决定如何处理接收到的消息。这包括：<ul><li><strong>放到特定的队列</strong>：根据规则，交换机可能将消息路由到一个或多个特定队列</li><li><strong>广播到多个队列</strong>：某些类型的交换机（如扇出交换机）会将消息发送到所有绑定到该交换机的队列</li><li><strong>丢弃消息</strong>：如果没有队列与交换机正确绑定，或者根据交换机的路由规则找不到合适的队列，消息可能会被丢弃</li></ul></li></ul></li><li><p>RabbitMQ 中常用的<strong>交换机类型</strong>：</p><ul><li><strong>直接</strong>(direct)  &#x3D;&#x3D;&gt; 一对一的消息分发</li><li><strong>扇出</strong>(fanout) &#x3D;&#x3D;&gt; <strong>发布订阅模式</strong></li><li><strong>主题</strong>(topic)  &#x3D;&#x3D;&gt; 根据消息的路由键和队列的绑定键之间的模式匹配来路由消息</li><li><strong>标题</strong>(headers)  &#x3D;&#x3D;&gt; 不咋用，根据消息内容而非路由键进行路由</li><li><strong>默认&#x2F;无名</strong>(default)</li></ul></li><li><p><strong>默认&#x2F;无名交换机</strong>：</p><ul><li>之前我们使用的就是默认交换，通过空字符串 <code>&quot;&quot;</code> 进行标识</li><li>第一个参数是交换机的名称，空字符串表示默认或无名交换机，直接将消息路由到与路由键同名的队列</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.basicPublish(<span class="string">&quot;&quot;</span>, queueName, <span class="literal">null</span>, message.getBytes());</span><br></pre></td></tr></table></figure><h3 id="5-2-临时队列"><a href="#5-2-临时队列" class="headerlink" title="5.2 临时队列"></a>5.2 临时队列</h3><ul><li><p>没有持久化的队列是临时队列，<strong>一旦我们断开了消费者的连</strong></p><p><strong>接，队列将被自动删除</strong></p></li><li><p><strong>创建临时队列</strong>的方式如下：RabbitMQ）会自动为其生成一个唯一的名称，避免命名冲突</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> channel.queueDeclare().getQueue();</span><br></pre></td></tr></table></figure><ul><li><strong>创建效果</strong>：</li></ul><p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/image-20240330164500891.png" alt="image-20240330164500891"></p><h3 id="5-3-绑定"><a href="#5-3-绑定" class="headerlink" title="5.3 绑定"></a>5.3 绑定</h3><ul><li><strong>绑定（Binding）</strong>是定义交换机和队列之间关系的桥梁<ul><li>绑定充当路由规则，<strong>指示交换机</strong>如何根据消息的属性（如路由键或其他属性）<strong>将消息路由到一个或多个特定的队列</strong></li></ul></li><li>绑定可以包括一个<strong>路由键</strong>（Routing Key），交换机会使用这个路由键按照绑定的规则来路由消息。路由键的使用和重要性取决于交换机的类型。<ul><li>对于<strong>直接交换机</strong>，消息被发送到路由键完全匹配的队列。</li><li>对于<strong>主题交换机</strong>，路由键可以包含通配符，实现更灵活的匹配。</li><li><strong>扇出交换机</strong>忽略路由键，广播消息到所有绑定的队列。</li><li><strong>头交换机</strong>根据消息头而非路由键进行匹配。</li></ul></li></ul><h3 id="5-4-Fanout"><a href="#5-4-Fanout" class="headerlink" title="5.4 Fanout"></a>5.4 Fanout</h3><ul><li>扇出交换机（Fanout Exchange）是RabbitMQ中实现发布-订阅模式的一种交换机类型，它能够将接收到的消息广播到所有绑定到该交换机的队列中<ul><li>将接收到的所有消息<strong>广播</strong>到它知道的所有队列中</li><li>系统中默认自带一些交换机类型，咱们也可以自己自定义</li></ul></li></ul><p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/image-20240330165644277.png" alt="image-20240330165644277"></p><ul><li><strong>代码实现</strong>：写两个消费者，一个生产者<ul><li>交换机的创建可以由生产者或消费者来完成</li><li>RabbitMQ <strong>允许你重复创建相同配置的交换机，后续创建操作会被静默忽略</strong>，简化了管理逻辑</li></ul></li><li><strong>消费者</strong>：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReceiveLogs01</span> &#123;</span><br><span class="line">    <span class="comment">// 交换机名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;logs&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtils.getChannel();  <span class="comment">// 建立信道</span></span><br><span class="line">        <span class="comment">// 创建交换机, 参数为交换机名称和类型</span></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">&quot;fanout&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 声明一个临时队列 队列的名称是随机的</span></span><br><span class="line">        <span class="comment">// 当消费者断开和该队列的连接时 队列自动删除</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> channel.queueDeclare().getQueue();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 绑定临时队列和交换机</span></span><br><span class="line">        <span class="comment">// 其中 routingKey(也称之为 binding key)为空字符串</span></span><br><span class="line">        channel.queueBind(queueName, EXCHANGE_NAME, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;等待接收消息,把接收到的消息打印在屏幕.....&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;控制台打印接收到的消息&quot;</span> + message);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接收消息</span></span><br><span class="line">        channel.basicConsume(queueName, <span class="literal">true</span>, deliverCallback, consumerTag -&gt; &#123;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>生产者</strong>：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmitLog</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;logs&quot;</span>;  <span class="comment">// 交换机名称</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtils.getChannel()) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 声明一个 交换机</span></span><br><span class="line">            <span class="comment">// 1. exchange 的名称</span></span><br><span class="line">            <span class="comment">// 2. exchange 的类型</span></span><br><span class="line">            channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">&quot;fanout&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">            System.out.println(<span class="string">&quot;请输入信息&quot;</span>);</span><br><span class="line">            <span class="keyword">while</span> (sc.hasNext()) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> sc.nextLine();</span><br><span class="line">                <span class="comment">// 发送消息</span></span><br><span class="line">                channel.basicPublish(EXCHANGE_NAME, <span class="string">&quot;&quot;</span>, <span class="literal">null</span>, message.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">                System.out.println(<span class="string">&quot;生产者发出消息&quot;</span> + message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>CentOS 连不上了，测不了，试了下面这个，虽然能进去，但还是报关闭连接的错误：<br><a href="https://cloud.tencent.com/developer/article/1722144">centOS7 桥接模式设置静态Ip的方法步骤-腾讯云开发者社区-腾讯云 (tencent.com)</a></p><p>用云服务器重新配了下环境，测了下，可以的，没毛病</p></blockquote><h3 id="5-5-Direct-exchange"><a href="#5-5-Direct-exchange" class="headerlink" title="5.5 Direct exchange"></a>5.5 Direct exchange</h3><ul><li><strong>扇出交换机 VS 直接&#x2F;路由交换机</strong><ul><li>扇出交换机<strong>忽略路由键(routing key)<strong>，当一条消息发送到扇出交换机时，它</strong>会将消息发送到所有与之绑定的队列</strong></li><li>直接交换机<strong>使用路由键(routing key)来路由消息</strong>，生产者在发送消息时会指定一个路由键，直接交换机<strong>根据这个路由键将消息路由到绑定时指定了相同路由键的队列</strong></li><li>如果需要将相同的消息广播给多个消费者，扇出交换机是合适的选择；如果需要根据某种标准（例如，消息类型或优先级等）将消息路由到特定的队列，直接交换机会更加适合</li></ul></li><li><strong>直接交换机的使用场景举例</strong>：<ul><li>构建日志系统时，如何根据日志的严重级别（例如错误、警告、信息）将消息分发到不同的队列</li><li>期望实现的功能是能够根据日志的级别（例如，仅将“错误”日志消息写入磁盘），以避免将警告或信息日志存储到磁盘中，从而节省磁盘空间</li></ul></li><li><strong>直接交换机工作原理</strong><ul><li>直接交换机根据发送到交换机的消息的路由键（routing key）和队列的绑定键（binding key）进行匹配，只将消息路由到完全匹配的队列</li><li>例如，假设有一个直接交换机X，它绑定了两个队列：队列Q1的绑定键为“orange”，而队列Q2的绑定键为“black”和“green” <strong>（一个队列可以绑多遍）</strong><ul><li>发送到交换机X，路由键为“orange”的消息将被路由到队列Q1</li><li>路由键为“black”或“green”的消息将被路由到队列Q2</li><li>其他不匹配的消息将被丢弃</li></ul></li></ul></li></ul><p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/image-20240330213930427.png" alt="image-20240330213930427"></p><ul><li><strong>多重绑定(类似扇出交换机)</strong><ul><li>当一个直接交换机绑定多个队列时，如果<strong>所有队列的绑定键都相同</strong>，那么尽管绑定类型是直接的，这种配置实际上会让交换机的行为类似于扇出交换机——<strong>相当于广播</strong>，因为所有绑定到该交换机的队列都会接收到相同的消息</li></ul></li></ul><p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/image-20240330214053865.png" alt="image-20240330214053865"></p><ul><li><strong>实战</strong>：</li></ul><p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/image-20240330214118580.png" alt="image-20240330214118580"></p><p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/image-20240331170351854.png" alt="image-20240331170351854"></p><ul><li><strong>消费者</strong><ul><li>写两个，这里就一个示例下</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReceiveLogsDirect02</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;direct_logs&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 获取信道</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtils.getChannel();</span><br><span class="line">        <span class="comment">// 声明直接交换机</span></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);</span><br><span class="line">        <span class="comment">// 声明队列</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> <span class="string">&quot;console&quot;</span>;</span><br><span class="line">        channel.queueDeclare(queueName, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="comment">// 绑定两个键</span></span><br><span class="line">        channel.queueBind(queueName, EXCHANGE_NAME, <span class="string">&quot;info&quot;</span>);</span><br><span class="line">        channel.queueBind(queueName, EXCHANGE_NAME, <span class="string">&quot;warning&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;等待接收消息.....&quot;</span>);</span><br><span class="line">        <span class="comment">// 接收消息的回调</span></span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot; 接收绑定键 :&quot;</span> + delivery.getEnvelope().getRoutingKey() + <span class="string">&quot;, 消息:&quot;</span> + message);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        channel.basicConsume(queueName, <span class="literal">true</span>, deliverCallback, consumerTag -&gt; &#123;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>生产者</strong><ul><li>生产者这边发送的消息是写死的，所以先运行消费者后再运行生产者</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmitLogDirect</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;direct_logs&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtils.getChannel()) &#123;</span><br><span class="line">            <span class="comment">// 声明一个直接交换机</span></span><br><span class="line">            channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建多个 bindingKey</span></span><br><span class="line">            Map&lt;String, String&gt; bindingKeyMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">            bindingKeyMap.put(<span class="string">&quot;info&quot;</span>, <span class="string">&quot;普通 info 信息&quot;</span>);</span><br><span class="line">            bindingKeyMap.put(<span class="string">&quot;warning&quot;</span>, <span class="string">&quot;警告 warning 信息&quot;</span>);</span><br><span class="line">            bindingKeyMap.put(<span class="string">&quot;error&quot;</span>, <span class="string">&quot;错误 error 信息&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// debug 没有消费这接收这个消息 所以就丢失了</span></span><br><span class="line">            bindingKeyMap.put(<span class="string">&quot;debug&quot;</span>, <span class="string">&quot;调试 debug 信息&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 生产者测试消息的发送, 发送消息和对应的路由键</span></span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; bindingKeyEntry : bindingKeyMap.entrySet()) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">bindingKey</span> <span class="operator">=</span> bindingKeyEntry.getKey();</span><br><span class="line">                <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> bindingKeyEntry.getValue();</span><br><span class="line">                channel.basicPublish(EXCHANGE_NAME, bindingKey, <span class="literal">null</span>,</span><br><span class="line">                                     message.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">                System.out.println(<span class="string">&quot;生产者发出消息:&quot;</span> + message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-6-Topics"><a href="#5-6-Topics" class="headerlink" title="5.6 Topics"></a>5.6 Topics</h3><h4 id="5-6-1-主题交换机的引入"><a href="#5-6-1-主题交换机的引入" class="headerlink" title="5.6.1 主题交换机的引入"></a>5.6.1 主题交换机的引入</h4><ul><li><strong>扇出交换机的局限</strong><ul><li><strong>扇出交换机</strong>广播所有接收到的消息到所有绑定的队列，没有路由逻辑，适用于简单的广播场景，但无法进行细粒度的消息路由</li></ul></li><li><strong>直接交换机的改进</strong><ul><li><strong>直接交换机</strong>允许根据消息的路由键和队列的绑定键进行精确匹配，从而实现有选择性地接收消息。这比扇出交换机提供了更高的灵活性，但它仍然有局限性，特别是当需求变得更复杂，需要基于多个条件进行消息路由时</li></ul></li><li><strong>主题交换机的引入</strong><ul><li><strong>主题交换机</strong>通过允许<strong>路由键和绑定键之间使用模式匹配</strong>来解决直接交换机的局限性。主题交换机使得可以根据多个标准灵活地路由消息，非常适合复杂的路由逻辑</li><li><strong>路由键的要求</strong>：发送到<strong>主题交换机的消息的路由键必须是由点号分隔的单词列表</strong>，例如：<code>stock.usd.nyse</code>。这提供了一种结构化的方式来指定消息的属性或类别</li><li><strong>替换符</strong>：允许进行更复杂的匹配逻辑<ul><li><code>*</code>（星号）：匹配路由键中的一个单词。</li><li><code>#</code>（井号）：匹配路由键中的零个或多个单词。</li></ul></li></ul></li><li><strong>示例</strong>：如果某个队列只想接收到以 <code>info.base</code> 为主题的日志消息，而另一个队列想接收所有以 <code>info</code> 开头的日志消息（无论是”info.base”还是”info.advantage”）使用主题交换机可以轻松实现这一需求<ul><li>例如，第一个队列可以使用绑定键 <code>&quot;info.base&quot;</code></li><li>而第二个队列可以使用绑定键 <code>&quot;info.#&quot;</code></li></ul></li></ul><h4 id="5-6-2-Topic-匹配案例"><a href="#5-6-2-Topic-匹配案例" class="headerlink" title="5.6.2 Topic 匹配案例"></a>5.6.2 Topic 匹配案例</h4><ul><li><p><strong>前提</strong>：</p><ul><li><p><strong>队列Q1</strong>：绑定键为<code>*.orange.*</code></p><ul><li>Q1 只接收包含三个单词，其中第二个单词是”orange”的消息</li></ul></li><li><p><strong>队列Q2</strong>：有两个绑定键，<code>*.*.rabbit</code>和<code>lazy.#</code></p><ul><li>Q2 将接收最后一个单词是”rabbit”的包含三个单词的消息，以及以”lazy”开头的任意长度的消息</li></ul></li></ul></li></ul><p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/image-20240331165905276.png" alt="image-20240331165905276"></p><ul><li><strong>案例</strong>：<ul><li><strong>quick.orange.rabbit</strong>：匹配Q1和Q2的绑定（因为它满足<code>*.orange.*</code>和<code>*.*.rabbit</code>），所以被两个队列接收。</li><li><strong>lazy.orange.elephant</strong>：同样匹配Q1和Q2的绑定（满足<code>*.orange.*</code>和<code>lazy.#</code>），被两个队列接收。</li><li><strong>quick.orange.fox</strong>：只匹配Q1的绑定（<code>*.orange.*</code>），只被Q1接收。</li><li><strong>lazy.brown.fox</strong>：只匹配Q2的<code>lazy.#</code>绑定，只被Q2接收。</li><li><strong>lazy.pink.rabbit</strong>：虽然同时满足Q2的两个绑定条件，但消息在队列中不会重复，所以它只被Q2接收一次。</li><li><strong>quick.brown.fox</strong>：不匹配任何绑定条件，被丢弃。</li><li><strong>quick.orange.male.rabbit</strong>：因为是四个单词，不满足任何队列的绑定条件，被丢弃。</li><li><strong>lazy.orange.male.rabbit</strong>：尽管是四个单词，但它满足Q2的<code>lazy.#</code>绑定条件，因此被Q2接收。</li></ul></li><li><strong>特殊情况</strong>：<ul><li><strong>全匹配（<code>#</code>）</strong>：如果一个队列的绑定键是<code>#</code>，那么这个队列会接收所有的消息，类似于扇出（fanout）交换机的行为。这种绑定键的设置使得队列成为一个”全订阅”者。</li><li><strong>直接匹配</strong>：如果一个队列的绑定键中不包含<code>#</code>和<code>*</code>，那么这个队列的绑定类型实际上就类似于直接（direct）交换机的行为。这意味着消息的路由键必须完全匹配绑定键，消息才会被路由到该队列。</li></ul></li></ul><p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/image-20240331185153187.png" alt="image-20240331185153187"></p><h4 id="5-6-3-代码实战"><a href="#5-6-3-代码实战" class="headerlink" title="5.6.3 代码实战"></a>5.6.3 代码实战</h4><blockquote><p>还是两个消费者Q1和Q2，一个生产者</p></blockquote><ul><li><strong>消费者</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReceiveLogsTopic02</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;topic_logs&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtils.getChannel();</span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">&quot;topic&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 声明 Q2 队列与绑定关系</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> <span class="string">&quot;Q2&quot;</span>;</span><br><span class="line">        channel.queueDeclare(queueName, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">        channel.queueBind(queueName, EXCHANGE_NAME, <span class="string">&quot;*.*.rabbit&quot;</span>);</span><br><span class="line">        channel.queueBind(queueName, EXCHANGE_NAME, <span class="string">&quot;lazy.#&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;等待接收消息.....&quot;</span>);</span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot; 接收队列 :&quot;</span> + queueName + <span class="string">&quot; 绑定键:&quot;</span> + delivery.getEnvelope().getRoutingKey()</span><br><span class="line">                               + <span class="string">&quot;, 消息:&quot;</span> + message);</span><br><span class="line">        &#125;;</span><br><span class="line">        channel.basicConsume(queueName, <span class="literal">true</span>, deliverCallback, consumerTag -&gt; &#123;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>生产者</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmitLogTopic</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;topic_logs&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtils.getChannel()) &#123;</span><br><span class="line">            <span class="comment">// 声明交换机</span></span><br><span class="line">            channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.TOPIC);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Q1--&gt;绑定的是</span></span><br><span class="line">            <span class="comment">// 中间带 orange 带 3 个单词的字符串(*.orange.*)</span></span><br><span class="line">            <span class="comment">// Q2--&gt;绑定的是</span></span><br><span class="line">            <span class="comment">// 最后一个单词是 rabbit 的 3 个单词(*.*.rabbit)</span></span><br><span class="line">            <span class="comment">// 第一个单词是 lazy 的多个单词(lazy.#)</span></span><br><span class="line">            Map&lt;String, String&gt; bindingKeyMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">            bindingKeyMap.put(<span class="string">&quot;quick.orange.rabbit&quot;</span>, <span class="string">&quot;被队列 Q1Q2 接收到&quot;</span>);</span><br><span class="line">            bindingKeyMap.put(<span class="string">&quot;lazy.orange.elephant&quot;</span>, <span class="string">&quot;被队列 Q1Q2 接收到&quot;</span>);</span><br><span class="line">            bindingKeyMap.put(<span class="string">&quot;quick.orange.fox&quot;</span>, <span class="string">&quot;被队列 Q1 接收到&quot;</span>);</span><br><span class="line">            bindingKeyMap.put(<span class="string">&quot;lazy.brown.fox&quot;</span>, <span class="string">&quot;被队列 Q2 接收到&quot;</span>);</span><br><span class="line">            bindingKeyMap.put(<span class="string">&quot;lazy.pink.rabbit&quot;</span>, <span class="string">&quot;虽然满足两个绑定但只被队列 Q2 接收一次&quot;</span>);</span><br><span class="line">            bindingKeyMap.put(<span class="string">&quot;quick.brown.fox&quot;</span>, <span class="string">&quot;不匹配任何绑定不会被任何队列接收到会被丢弃&quot;</span>);</span><br><span class="line">            bindingKeyMap.put(<span class="string">&quot;quick.orange.male.rabbit&quot;</span>, <span class="string">&quot;是四个单词不匹配任何绑定会被丢弃&quot;</span>);</span><br><span class="line">            bindingKeyMap.put(<span class="string">&quot;lazy.orange.male.rabbit&quot;</span>, <span class="string">&quot;是四个单词但匹配 Q2&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; bindingKeyEntry : bindingKeyMap.entrySet()) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">bindingKey</span> <span class="operator">=</span> bindingKeyEntry.getKey();</span><br><span class="line">                <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> bindingKeyEntry.getValue();</span><br><span class="line">                channel.basicPublish(EXCHANGE_NAME, bindingKey, <span class="literal">null</span>,</span><br><span class="line">                                     message.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">                System.out.println(<span class="string">&quot;生产者发出消息&quot;</span> + message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-死信队列"><a href="#6-死信队列" class="headerlink" title="6. 死信队列"></a>6. 死信队列</h2><h3 id="6-1-死信的概念和来源"><a href="#6-1-死信的概念和来源" class="headerlink" title="6.1 死信的概念和来源"></a>6.1 死信的概念和来源</h3><ul><li><p><strong>死信</strong>：无法被消费的消息，可能因为多种原因导致消息无法被正常处理，而死信队列就是用来收集这些无法处理的消息的特殊队列</p></li><li><p><strong>死信队列</strong>（DLQ, Dead Letter Queue）：用于处理无法被正常消费的消息</p></li><li><p><strong>死信的常见来源</strong>：</p><ul><li><strong>消息TTL过期</strong>：TTL（Time-To-Live），即消息的存活时间。如果一个消息在队列中的存活时间超过了它的TTL，它就会变成死信</li><li><strong>队列达到最大长度</strong>：如果队列已经达到了它的最大长度，新的消息就无法再添加到队列中。在这种情况下，如果队列配置了死信交换机和死信路由键，<strong>超出长度的消息会被发送到死信队列</strong></li><li><strong>消息被显式拒绝</strong>：当消费者通过<code>basic.reject</code>或<code>basic.nack</code>命令拒绝消息，并且设置<code>requeue=false</code>（不重新入队列）时，这个消息就会变成死信</li></ul></li><li><p><strong>应用场景</strong>：</p><ul><li><strong>保障业务的消息不丢失</strong>：比如订单处理系统，使用死信队列可以保证即使<strong>消费过程中发生异常，消息也不会丢失，而是被安全地移至死信队列中</strong>，后续可以对这些消息进行分析和再处理</li><li><strong>订单超时处理</strong>：在电商平台中，用户下单后可能存在未在规定时间内完成支付的情况。这时，可以通过<strong>设置消息的TTL来让未支付的订单消息过期，然后自动转移到死信队列中进行订单失效处理</strong></li></ul></li></ul><h3 id="6-2-死信实战"><a href="#6-2-死信实战" class="headerlink" title="6.2 死信实战"></a>6.2 死信实战</h3><blockquote><p>还是两个消费者，一个生产者</p><p>C1 代码需要声明两个交换机(包括死信交换机)，两个队列(包括死信队列)，还要涉及普通队列和死信交换机的捆绑问题</p><p>C2 只要接收死信队列的消息即可</p></blockquote><p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/image-20240331190302962.png" alt="image-20240331190302962"></p><h4 id="6-2-1-消息-TTL-过期"><a href="#6-2-1-消息-TTL-过期" class="headerlink" title="6.2.1 消息 TTL 过期"></a>6.2.1 消息 TTL 过期</h4><ul><li><strong>消费者1(启动之后关闭该消费者 模拟其接收不到消息)</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer01</span> &#123;</span><br><span class="line">    <span class="comment">// 普通交换机名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">NORMAL_EXCHANGE</span> <span class="operator">=</span> <span class="string">&quot;normal_exchange&quot;</span>;</span><br><span class="line">    <span class="comment">// 死信交换机名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEAD_EXCHANGE</span> <span class="operator">=</span> <span class="string">&quot;dead_exchange&quot;</span>;</span><br><span class="line">    <span class="comment">// 普通队列名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">NORMAL_QUEUE</span> <span class="operator">=</span> <span class="string">&quot;normal_queue&quot;</span>;</span><br><span class="line">    <span class="comment">// 死信队列名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEAD_QUEUE</span> <span class="operator">=</span> <span class="string">&quot;dead_queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtils.getChannel();</span><br><span class="line">        <span class="comment">// 声明死信和直接交换机 类型为 direct</span></span><br><span class="line">        channel.exchangeDeclare(NORMAL_EXCHANGE, BuiltinExchangeType.DIRECT);</span><br><span class="line">        channel.exchangeDeclare(DEAD_EXCHANGE, BuiltinExchangeType.DIRECT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 声明死信队列</span></span><br><span class="line">        channel.queueDeclare(DEAD_QUEUE, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="comment">// 死信队列绑定死信交换机与 routingKey</span></span><br><span class="line">        channel.queueBind(DEAD_QUEUE, DEAD_EXCHANGE, <span class="string">&quot;lisi&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 普通队列绑定死信队列的参数</span></span><br><span class="line">        Map&lt;String, Object&gt; params = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 可以由生产者指定过期时间 10s</span></span><br><span class="line">        <span class="comment">// params.put(&quot;x-message-ttl&quot;, 10000);</span></span><br><span class="line">        <span class="comment">// 参数1: 普通队列设置死信交换机 参数 key 是固定值</span></span><br><span class="line">        params.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, DEAD_EXCHANGE);</span><br><span class="line">        <span class="comment">// 参数2: 普通队列设置死信 routing-key 参数 key 是固定值</span></span><br><span class="line">        params.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>, <span class="string">&quot;lisi&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 声明普通队列</span></span><br><span class="line">        channel.queueDeclare(NORMAL_QUEUE, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, params);</span><br><span class="line">        <span class="comment">// 绑定到直接交换机与 routingKey</span></span><br><span class="line">        channel.queueBind(NORMAL_QUEUE, NORMAL_EXCHANGE, <span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;等待接收消息.....&quot;</span>);</span><br><span class="line">        <span class="comment">// 接收消息的回调</span></span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;Consumer01 接收到消息&quot;</span> + message);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 消费</span></span><br><span class="line">        channel.basicConsume(NORMAL_QUEUE, <span class="literal">true</span>, deliverCallback, consumerTag -&gt; &#123;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>普通交换机绑普通队列，死信交换机绑死信队列</p></blockquote><p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/image-20240331194218496.png" alt="image-20240331194218496"></p><ul><li><strong>生产者</strong>：设置过期时间 ttl<ul><li>在关闭了消费者后运行生产者，可以发现过了10秒后消息都到死信队列里了</li><li>然后再写个消费者2把死信队列里的消费掉即可，消费者2只用写个信道，然后接收死信队列消息即可</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Producer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">NORMAL_EXCHANGE</span> <span class="operator">=</span> <span class="string">&quot;normal_exchange&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtils.getChannel()) &#123;</span><br><span class="line">            <span class="comment">// 声明直接交换机</span></span><br><span class="line">            channel.exchangeDeclare(NORMAL_EXCHANGE, BuiltinExchangeType.DIRECT);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 设置消息的 TTL 时间  10s</span></span><br><span class="line">            AMQP.<span class="type">BasicProperties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AMQP</span>.BasicProperties()</span><br><span class="line">                .builder().expiration(<span class="string">&quot;10000&quot;</span>).build();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 该信息是用作演示队列个数限制</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; <span class="number">11</span>; i++) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;info&quot;</span> + i;</span><br><span class="line">                <span class="comment">// 设置 properties 参数</span></span><br><span class="line">                channel.basicPublish(NORMAL_EXCHANGE, <span class="string">&quot;zhangsan&quot;</span>, properties,</span><br><span class="line">                                     message.getBytes());</span><br><span class="line">                System.out.println(<span class="string">&quot;生产者发送消息:&quot;</span> + message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/image-20240331194650547.png" alt="image-20240331194650547"></p><h4 id="6-2-2-队列达到最大长度"><a href="#6-2-2-队列达到最大长度" class="headerlink" title="6.2.2 队列达到最大长度"></a>6.2.2 队列达到最大长度</h4><ul><li><p>队列达到最大长度后，<strong>超出长度的消息会被发送到死信队列</strong></p></li><li><p>修改代码：</p><ul><li>6.2.1 中，生产者代码中的 TTL 属性去掉，设置为 null</li><li>修改消费者1的代码，添加参数3：</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 普通队列绑定死信队列的参数</span></span><br><span class="line">Map&lt;String, Object&gt; params = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// 参数1: 普通队列设置死信交换机 参数 key 是固定值</span></span><br><span class="line">params.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, DEAD_EXCHANGE);</span><br><span class="line"><span class="comment">// 参数2: 普通队列设置死信 routing-key 参数 key 是固定值</span></span><br><span class="line">params.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>, <span class="string">&quot;lisi&quot;</span>);</span><br><span class="line"><span class="comment">// 参数3: 普通队列设置长度限制</span></span><br><span class="line">params.put(<span class="string">&quot;x-max-length&quot;</span>, <span class="number">6</span>);</span><br></pre></td></tr></table></figure><p><strong>注意测试时需要把原先普通队列删除，因为参数改变了</strong></p><ul><li>还是先运行消费者1，生成队列以及队列和死信交换机之间的关系，然后停止消费者1(为了看效果，让消息积压在队列中)，再运行生产者&#x3D;&#x3D;&gt;可以看到普通队列6个，死信里有4个</li></ul><p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/image-20240331200010021.png" alt="image-20240331200010021"></p><p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/image-20240331200144519.png" alt="image-20240331200144519"></p><ul><li>最后记得把消费者1和2都启动下，恢复初始状态方便后续测试</li></ul><h4 id="6-2-3-消息被拒"><a href="#6-2-3-消息被拒" class="headerlink" title="6.2.3 消息被拒"></a>6.2.3 消息被拒</h4><ul><li>修改代码：<ul><li>6.2.2 中消费者1添加的长度限制属性注释掉</li><li>设置消费者1拒绝消息，在接收回调的函数中设置<strong>拒绝</strong> <code>info5</code> <strong>消息，并且不允许放回普通队列</strong>，则只能进入死信队列</li><li>记得<strong>开启手动应答</strong>！因为自动应答只要队列发消息就算成功</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接收消息的回调</span></span><br><span class="line"><span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (message.equals(<span class="string">&quot;info5&quot;</span>)) &#123;  <span class="comment">// 拒绝 info5</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Consumer01 接收到消息&quot;</span> + message + <span class="string">&quot;并拒绝签收该消息&quot;</span>);</span><br><span class="line">        <span class="comment">// requeue 设置为 false 代表拒绝重新入队 该队列如果配置了死信交换机将发送到死信队列中</span></span><br><span class="line">        channel.basicReject(delivery.getEnvelope().getDeliveryTag(), <span class="literal">false</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Consumer01 接收到消息&quot;</span> + message);</span><br><span class="line">        channel.basicAck(delivery.getEnvelope().getDeliveryTag(), <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">autoAck</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">channel.basicConsume(NORMAL_QUEUE, autoAck, deliverCallback, consumerTag -&gt; &#123;&#125;);</span><br></pre></td></tr></table></figure><ul><li>在 web 界面删除普通队列后，重新运行消费者1，然后再运行生产者，可以看到死信队列1条（其他 9 条被普通队列消费了已经），可以看到那一条确实是 info5</li></ul><p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/image-20240331201928728.png" alt="image-20240331201928728"></p><ul><li>最后运行下消费者2，即可消费掉这条 info5</li></ul><h2 id="7-延迟队列"><a href="#7-延迟队列" class="headerlink" title="7. 延迟队列"></a>7. 延迟队列</h2><h3 id="7-1-延迟队列的概念和使用场景"><a href="#7-1-延迟队列的概念和使用场景" class="headerlink" title="7.1 延迟队列的概念和使用场景"></a>7.1 延迟队列的概念和使用场景</h3><ul><li><p><strong>延迟队列</strong>：核心特性是能够<strong>控制消息在队列中的停留时间，只有当指定的时间到达时，消息才会被消费者处理</strong></p><ul><li>适合于需要在特定时间执行任务的场景</li></ul></li><li><p><strong>使用场景</strong>：</p><ul><li><strong>订单支付超时处理</strong>：对于在线支付场景，订单如果在一定时间（如10分钟）内未支付，系统需要自动取消这些订单</li><li><strong>提醒功能</strong>：对于新注册用户或新开店铺，如果在一定时间内未进行某些操作（如三天内未登录、十天内未上传商品），系统可以自动发送提醒</li><li><strong>退款处理提醒</strong>：对用户发起的退款请求，如果在一定时间（如三天）内未处理，系统可以自动提醒运营人员进行处理</li><li><strong>会议通知</strong>：对于预定的会议，系统可以在会议开始前十分钟自动通知与会人员</li></ul></li><li><p><strong>延迟队列与轮询的对比</strong>：</p><ul><li><strong>性能和效率</strong>：当数据量大时，使用定时任务不断轮询数据库检查哪些任务需要被执行是低效且对数据库压力大的。尤其是在高并发场景下，轮询可能无法在短时间内完成所有任务的检查，且对系统资源消耗大</li><li><strong>时效性</strong>：延迟队列可以精确控制任务的执行时间，确保任务能够在预定时间点准确执行，而轮询机制可能因为间隔时间设置不当导致执行时间的不精确</li></ul></li><li><p><strong>实现延迟队列的方法</strong>：在RabbitMQ中，可以<strong>通过设置消息的TTL（Time-To-Live，生存时间）和使用死信交换机（DLX）组合来实现延迟队列</strong>。具体步骤如下：</p><ul><li><strong>设置消息TTL</strong>：为消息设置一个TTL，即该消息在队列中可以存活的最长时间</li><li><strong>配置死信交换机</strong>：当消息因为TTL过期或其他原因变成死信后，它会被发送到配置的死信交换机，进而路由到一个或多个指定的队列</li><li><strong>消费死信队列中的消息</strong>：<strong>设置消费者监听死信队列，一旦消息因TTL过期被路由到死信队列，消费者即可进行处理</strong></li></ul></li></ul><h3 id="7-2-整合-SpringBoot"><a href="#7-2-整合-SpringBoot" class="headerlink" title="7.2 整合 SpringBoot"></a>7.2 整合 SpringBoot</h3><h4 id="7-2-1-创建项目"><a href="#7-2-1-创建项目" class="headerlink" title="7.2.1 创建项目"></a>7.2.1 创建项目</h4><p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/image-20240407190827899.png" alt="image-20240407190827899"> </p><p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/image-20240407190945485.png" alt="image-20240407190945485"></p><p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/image-20240407191045720.png" alt="image-20240407191045720"></p><h4 id="7-2-2-RabbitMQ-依赖"><a href="#7-2-2-RabbitMQ-依赖" class="headerlink" title="7.2.2 RabbitMQ 依赖"></a>7.2.2 RabbitMQ 依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--RabbitMQ 依赖--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.47<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--RabbitMQ 测试依赖--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.amqp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-rabbit-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--swagger--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="7-2-3-修改配置文件"><a href="#7-2-3-修改配置文件" class="headerlink" title="7.2.3 修改配置文件"></a>7.2.3 修改配置文件</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">xxx.xx.xx.xxx</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">admin</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123</span></span><br></pre></td></tr></table></figure><h4 id="7-2-4-添加-Swagger-配置类"><a href="#7-2-4-添加-Swagger-配置类" class="headerlink" title="7.2.4 添加 Swagger 配置类"></a>7.2.4 添加 Swagger 配置类</h4><ul><li><code>config/SwaggerConfig.java</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SwaggerConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Docket <span class="title function_">webApiConfig</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Docket</span>(DocumentationType.SWAGGER_2)</span><br><span class="line">            .groupName(<span class="string">&quot;webApi&quot;</span>)</span><br><span class="line">            .apiInfo(webApiInfo())</span><br><span class="line">            .select()</span><br><span class="line">            .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ApiInfo <span class="title function_">webApiInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ApiInfoBuilder</span>()</span><br><span class="line">            .title(<span class="string">&quot;rabbitmq 接口文档&quot;</span>)</span><br><span class="line">            .description(<span class="string">&quot;本文档描述了 rabbitmq 微服务接口定义&quot;</span>)</span><br><span class="line">            .version(<span class="string">&quot;1.0&quot;</span>)</span><br><span class="line">            .contact(<span class="keyword">new</span> <span class="title class_">Contact</span>(<span class="string">&quot;thr&quot;</span>, <span class="string">&quot;http://thr.com&quot;</span>,</span><br><span class="line">                                 <span class="string">&quot;hhh@qq.com&quot;</span>))</span><br><span class="line">            .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-3-RabbitMQ-中的-TTL"><a href="#7-3-RabbitMQ-中的-TTL" class="headerlink" title="7.3 RabbitMQ 中的 TTL"></a>7.3 RabbitMQ 中的 TTL</h3><ul><li><p>RabbitMQ中的TTL（Time-To-Live，生存时间）是<strong>指消息或队列中所有消息的最大存活时间</strong>，单位为毫秒</p><ul><li>这个特性允许消息在一定时间内未被消费则自动过期，过期的消息会变成死信（Dead Letter）。<strong>通过利用TTL和死信队列，我们可以在RabbitMQ中实现延迟队列的功能</strong></li></ul></li><li><p><strong>设置TTL的两种方式</strong>：</p><ul><li><strong>消息级别的TTL</strong>：可以为每条消息单独设置TTL。这种方式提供了灵活性，允许不同的消息有不同的生存时间。</li><li><strong>队列级别的TTL</strong>：在创建队列时，通过设置<code>x-message-ttl</code>属性为整个队列中的所有消息指定统一的TTL。队列级别的TTL<strong>适用于那些消息生存时间一致的场景</strong></li></ul></li><li><p><strong>两种方式的区别</strong>：</p><ul><li><strong>过期处理</strong>：<ul><li>如果设置了<strong>队列级TTL，一旦消息过期，就会被队列自动丢弃</strong>（如果配置了死信交换机，则被发送到死信队列）</li><li>而对于<strong>消息级别的TTL，消息是否过期是在消息即将被消费之前判定的</strong>。这意味着，如果队列中有大量积压的消息，即使某些消息已经过期，它们也可能会在队列中存活更长的时间，<strong>直到接近被消费时才被丢弃</strong></li></ul></li><li><strong>立即过期的消息</strong>：如果将TTL设置为0，表示这些消息除非能够立即被消费，否则将被立即丢弃</li></ul></li><li><p><strong>实现延迟队列</strong>：</p><ul><li><strong>配置死信交换机</strong>：为需要实现延迟的队列配置死信交换机（DLX），并指定死信路由键。</li><li><strong>设置TTL</strong>：根据需要，为队列或消息设置TTL。当消息在队列中存活时间超过TTL后，它会变成死信。</li><li><strong>死信转移</strong>：变成死信后的消息会被自动发送到绑定到死信交换机的队列（即死信队列）中。</li><li><strong>消费死信队列</strong>：消费者监听死信队列，处理到期的延迟消息。这样，消息在延迟特定时间后才被消费，实现了延迟队列的功能。</li></ul></li></ul><h3 id="7-4-队列-TTL"><a href="#7-4-队列-TTL" class="headerlink" title="7.4 队列 TTL"></a>7.4 队列 TTL</h3><h4 id="7-4-1-案例"><a href="#7-4-1-案例" class="headerlink" title="7.4.1 案例"></a>7.4.1 案例</h4><p>创建两个队列 QA 和 QB，两者队列 TTL 分别设置为 10S 和 40S，然后在创建一个交换机 X 和死信交换机 Y，它们的类型都是 direct，创建一个死信队列 QD，它们的绑定关系如下：</p><p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/image-20240407195336713.png" alt="image-20240407195336713"></p><blockquote><p>需要声明 2 个交换机 X 和 Y(死信)，以及 3 个队列 QA、QB、QD(死信)，绑定 QA 和 QB 到 X 和 Y 上</p></blockquote><h4 id="7-4-2-配置文件类代码"><a href="#7-4-2-配置文件类代码" class="headerlink" title="7.4.2 配置文件类代码"></a>7.4.2 配置文件类代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * TTL 队列 配置文件类代码</span></span><br><span class="line"><span class="comment"> * 需要声明 2 个交换机 X 和 Y(死信), 以及 3 个队列 QA、QB、QD(死信)</span></span><br><span class="line"><span class="comment"> * 绑定 QA 和 QB 到 X 和 Y 上</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TtlQueueConfig</span> &#123;</span><br><span class="line">    <span class="comment">// 普通交换机和普通队列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">X_EXCHANGE</span> <span class="operator">=</span> <span class="string">&quot;X&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_A</span> <span class="operator">=</span> <span class="string">&quot;QA&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_B</span> <span class="operator">=</span> <span class="string">&quot;QB&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 死信交换机和死信队列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">Y_DEAD_LETTER_EXCHANGE</span> <span class="operator">=</span> <span class="string">&quot;Y&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEAD_LETTER_QUEUE</span> <span class="operator">=</span> <span class="string">&quot;QD&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册两个直接交换机的 bean, 使得其他组件如消息生产者和消费者可以通过自动装配机制使用这些交换机</span></span><br><span class="line">    <span class="comment">// 声明 X 交换机, bean 名称在注入的时候有用</span></span><br><span class="line">    <span class="meta">@Bean(&quot;xExchange&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> DirectExchange <span class="title function_">xExchange</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DirectExchange</span>(X_EXCHANGE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明 xExchange</span></span><br><span class="line">    <span class="meta">@Bean(&quot;yExchange&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> DirectExchange <span class="title function_">yExchange</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DirectExchange</span>(Y_DEAD_LETTER_EXCHANGE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明队列 A ttl 为 10s 并绑定到对应的死信交换机</span></span><br><span class="line">    <span class="meta">@Bean(&quot;queueA&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">queueA</span><span class="params">()</span> &#123;</span><br><span class="line">        Map&lt;String, Object&gt; args = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">// 声明当前队列绑定的死信交换机</span></span><br><span class="line">        args.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, Y_DEAD_LETTER_EXCHANGE);</span><br><span class="line">        <span class="comment">// 声明当前队列的死信路由 key</span></span><br><span class="line">        args.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>, <span class="string">&quot;YD&quot;</span>);</span><br><span class="line">        <span class="comment">// 声明队列的 TTL</span></span><br><span class="line">        args.put(<span class="string">&quot;x-message-ttl&quot;</span>, <span class="number">10000</span>);</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(QUEUE_A).withArguments(args).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明队列 A 绑定 X 交换机</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">queueABindingX</span><span class="params">(<span class="meta">@Qualifier(&quot;queueA&quot;)</span> Queue queueA,</span></span><br><span class="line"><span class="params">                                  <span class="meta">@Qualifier(&quot;xExchange&quot;)</span> DirectExchange xExchange)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queueA).to(xExchange).with(<span class="string">&quot;XA&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明队列 B ttl 为 40s 并绑定到对应的死信交换机</span></span><br><span class="line">    <span class="meta">@Bean(&quot;queueB&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">queueB</span><span class="params">()</span> &#123;</span><br><span class="line">        Map&lt;String, Object&gt; args = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">// 声明当前队列绑定的死信交换机</span></span><br><span class="line">        args.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, Y_DEAD_LETTER_EXCHANGE);</span><br><span class="line">        <span class="comment">// 声明当前队列的死信路由 key</span></span><br><span class="line">        args.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>, <span class="string">&quot;YD&quot;</span>);</span><br><span class="line">        <span class="comment">// 声明队列的 TTL</span></span><br><span class="line">        args.put(<span class="string">&quot;x-message-ttl&quot;</span>, <span class="number">40000</span>);</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(QUEUE_B).withArguments(args).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明队列 B 绑定 X 交换机</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">queueBBindingX</span><span class="params">(<span class="meta">@Qualifier(&quot;queueB&quot;)</span> Queue queue1B,</span></span><br><span class="line"><span class="params">                                  <span class="meta">@Qualifier(&quot;xExchange&quot;)</span> DirectExchange xExchange)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue1B).to(xExchange).with(<span class="string">&quot;XB&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明死信队列 QD</span></span><br><span class="line">    <span class="meta">@Bean(&quot;queueD&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">queueD</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(DEAD_LETTER_QUEUE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明死信队列 QD 绑定关系</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">deadLetterBindingQDY</span><span class="params">(<span class="meta">@Qualifier(&quot;queueD&quot;)</span> Queue queueD,</span></span><br><span class="line"><span class="params">                                        <span class="meta">@Qualifier(&quot;yExchange&quot;)</span> DirectExchange yExchange)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queueD).to(yExchange).with(<span class="string">&quot;YD&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-4-3-消息生产者代码"><a href="#7-4-3-消息生产者代码" class="headerlink" title="7.4.3 消息生产者代码"></a>7.4.3 消息生产者代码</h4><ul><li><code>controller/SendMsgController</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 发送延迟消息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/ttl&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SendMsgController</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发消息</span></span><br><span class="line"><span class="comment">     * http://localhost:8080/ttl/sendMsg?msg=hhh</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msg 消息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/sendMsg&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMsg</span><span class="params">(<span class="meta">@RequestParam</span> String msg)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;当前时间: &#123;&#125;, 发送一条信息给两个 TTL 队列: &#123;&#125;&quot;</span>,</span><br><span class="line">                 <span class="keyword">new</span> <span class="title class_">Date</span>().toString(), msg);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送消息, 指定交换机和绑定键以及消息内容</span></span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">&quot;X&quot;</span>, <span class="string">&quot;XA&quot;</span>, <span class="string">&quot;消息来自 ttl 为 10s&quot;</span> + msg);</span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">&quot;X&quot;</span>, <span class="string">&quot;XB&quot;</span>, <span class="string">&quot;消息来自 ttl 为 40s&quot;</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-4-4-消息消费者代码"><a href="#7-4-4-消息消费者代码" class="headerlink" title="7.4.4 消息消费者代码"></a>7.4.4 消息消费者代码</h4><ul><li><code>consumer/DeadLetterQueueConsumer</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 队列 TTL 消费者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadLetterQueueConsumer</span> &#123;</span><br><span class="line">    <span class="comment">// 接受消息(监听)</span></span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;QD&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveD</span><span class="params">(Message message, Channel channel)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody());  <span class="comment">// 获取消息体</span></span><br><span class="line">        log.info(<span class="string">&quot;当前时间: &#123;&#125;, 收到死信队列的消息: &#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>().toString(), msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-4-5-启动测试"><a href="#7-4-5-启动测试" class="headerlink" title="7.4.5 启动测试"></a>7.4.5 启动测试</h4><ul><li><strong>报错</strong>：SpringBoot 项目集成了 springfox。将SpringBoot更新到2.6.0后，应用程序无法启动并抛出异常</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.context.ApplicationContextException: Failed to start bean &#x27;documentationPluginsBootstrapper&#x27;; nested exception is java.lang.NullPointerException</span><br></pre></td></tr></table></figure><ul><li><strong>解决</strong>：除了将 SpringBoot 降级到 2.5.7 外，还可以在 yaml 文件里添加配置如下：</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">mvc:</span></span><br><span class="line">    <span class="attr">pathmatch:</span></span><br><span class="line">      <span class="attr">matching-strategy:</span> <span class="string">ANT_PATH_MATCHER</span></span><br></pre></td></tr></table></figure><ul><li>访问：<code>http://localhost:8080/ttl/sendMsg?msg=hhh</code> 即可，过一段时间就能从死信队列里获取到消息<ul><li>第一条消息在 10S 后变成了死信消息，然后被消费者消费掉，第二条消息在 40S 之后变成了死信消息，然后被消费掉，这样一个延时队列就打造完成了</li></ul></li></ul><p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/image-20240407205712499.png" alt="image-20240407205712499"></p><h3 id="7-5-延迟队列优化"><a href="#7-5-延迟队列优化" class="headerlink" title="7.5 延迟队列优化"></a>7.5 延迟队列优化</h3><blockquote><p>如果像 7.4 这样使用，则<strong>每增加一个新的时间需求，就要新增一个队列</strong>，这里只有 10S 和 40S 两个时间选项，如果需要一个小时后处理，那么就需要增加 TTL 为一个小时的队列，如果是预定会议室然后提前通知这样的场景，岂不是要增加无数个队列才能满足需求？</p></blockquote><h4 id="7-5-1-优化案例"><a href="#7-5-1-优化案例" class="headerlink" title="7.5.1 优化案例"></a>7.5.1 优化案例</h4><blockquote><p>允许生产者在发送每条消息时动态指定延迟时间。消息在延迟期满后才会被路由到绑定的队列中，消费者随后可以处理这些消息</p></blockquote><ul><li>在 7.4.1 的基础上<strong>新增一个队列 QC</strong>，绑定关系如下，该队列<strong>不设置 TTL 时间</strong></li></ul><p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/image-20240407210828320.png" alt="image-20240407210828320"></p><h4 id="7-5-2-配置文件类代码"><a href="#7-5-2-配置文件类代码" class="headerlink" title="7.5.2 配置文件类代码"></a>7.5.2 配置文件类代码</h4><ul><li>增加 QC</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TtlQueueConfig</span> &#123;</span><br><span class="line">    <span class="comment">// 新增普通队列 QC</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_C</span> <span class="operator">=</span> <span class="string">&quot;QC&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明队列 C 并绑定到对应的死信交换机</span></span><br><span class="line">    <span class="meta">@Bean(&quot;queueC&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">queueC</span><span class="params">()</span> &#123;</span><br><span class="line">        Map&lt;String, Object&gt; args = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">// 声明当前队列绑定的死信交换机</span></span><br><span class="line">        args.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, Y_DEAD_LETTER_EXCHANGE);</span><br><span class="line">        <span class="comment">// 声明当前队列的死信路由 key</span></span><br><span class="line">        args.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>, <span class="string">&quot;YD&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(QUEUE_A).withArguments(args).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明队列 C 绑定 X 交换机</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">queueCBindingX</span><span class="params">(<span class="meta">@Qualifier(&quot;queueC&quot;)</span> Queue queueC,</span></span><br><span class="line"><span class="params">                                  <span class="meta">@Qualifier(&quot;xExchange&quot;)</span> DirectExchange xExchange)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queueC).to(xExchange).with(<span class="string">&quot;XC&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-5-3-消息生产者代码"><a href="#7-5-3-消息生产者代码" class="headerlink" title="7.5.3 消息生产者代码"></a>7.5.3 消息生产者代码</h4><ul><li><code>convertAndSend</code>方法的最后一个参数是一个<code>MessagePostProcessor</code>，它允许在消息发送前修改消息<ul><li>在这个<code>MessagePostProcessor</code>内部，可以设置消息的TTL为<code>ttlTime</code>，消息就会带有一个TTL属性，并且如果消息在TTL时间内未被消费，它将成为死信（前提是配置了相应的死信交换机和队列）</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发消息, 设置 TTL</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/sendExpirationMsg&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMsg</span><span class="params">(<span class="meta">@RequestParam</span> String msg, <span class="meta">@RequestParam</span> String ttlTime)</span> &#123;</span><br><span class="line">    log.info(<span class="string">&quot;当前时间: &#123;&#125;, 发送一条时长 &#123;&#125; 毫秒 TTL 信息给队列 QC: &#123;&#125;&quot;</span>,</span><br><span class="line">             <span class="keyword">new</span> <span class="title class_">Date</span>().toString(), ttlTime, msg);</span><br><span class="line"></span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="string">&quot;X&quot;</span>, <span class="string">&quot;XC&quot;</span>, msg, message -&gt; &#123;</span><br><span class="line">        <span class="comment">// 设置发送消息的延迟时长</span></span><br><span class="line">        message.getMessageProperties().setExpiration(ttlTime);</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-5-4-启动测试"><a href="#7-5-4-启动测试" class="headerlink" title="7.5.4 启动测试"></a>7.5.4 启动测试</h4><ul><li><code>http://localhost:8080/sendExpirationMsg?msg=hello&amp;ttlTime=10000</code></li></ul><p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/image-20240407213653456.png" alt="image-20240407213653456"></p><h4 id="7-5-6-存在问题-基于死信的延迟队列"><a href="#7-5-6-存在问题-基于死信的延迟队列" class="headerlink" title="7.5.6 存在问题(基于死信的延迟队列)"></a>7.5.6 存在问题(基于死信的延迟队列)</h4><ul><li>如果使用在消息属性上设置 TTL 的方式，<strong>消息可能并不会按时“死亡“</strong>，因为 <strong>RabbitMQ</strong> <strong>只会检查第一个消息是否过期</strong>，如果过期则丢到死信队列，<strong>如果第一个消息的延时时长很长，而第二个消息的延时时长很短，第二个消息并不会优先得到执行</strong></li><li><strong>RabbitMQ的TTL检查机制</strong>：RabbitMQ 在处理带有 TTL 的消息时，只会检查队列头部（即第一个消息）是否已经过期。如果头部的消息还没有到达它的 TTL，那么 RabbitMQ 不会继续检查后面的消息。这意味着，只有当头部消息过期并被移除后，RabbitMQ 才会检查下一个消息是否过期</li></ul><p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/image-20240407222340941.png" alt="image-20240407222340941"></p><ul><li>使用死信队列实现延迟队列时，需要通过消息TTL和死信交换机配置，消息到期后转入死信队列，存在检查顺序限制，可能导致消息延迟处理<ul><li>而使用延迟消息交换机插件，可直接在消息上设置延迟时间，插件负责延时后递送，操作更直接灵活，无需死信队列间接实现，解决了消息延迟处理的顺序问题</li></ul></li></ul><h3 id="7-6-RabbitMQ-插件实现延迟队列"><a href="#7-6-RabbitMQ-插件实现延迟队列" class="headerlink" title="7.6 RabbitMQ 插件实现延迟队列"></a>7.6 RabbitMQ 插件实现延迟队列</h3><p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/image-20240407222601585.png" alt="image-20240407222601585"></p><h4 id="7-6-1-安装延时队列插件"><a href="#7-6-1-安装延时队列插件" class="headerlink" title="7.6.1 安装延时队列插件"></a>7.6.1 安装延时队列插件</h4><ul><li><strong>官网</strong>：<a href="https://www.rabbitmq.com/community-plugins">https://www.rabbitmq.com/community-plugins</a></li><li><strong>下载</strong>：<a href="https://github.com/rabbitmq/rabbitmq-delayed-message-exchange/releases">https://github.com/rabbitmq/rabbitmq-delayed-message-exchange/releases</a><ul><li>我载了 3.8.9 版本的到云服务器的 opt 目录下，发现自己已经有 3.8.0 版本了，不慌，直接用 3.8.9 试下（官网说 3.8.9 已经替代 3.8.x 了）</li></ul></li><li>下载 <strong>rabbitmq_delayed_message_exchange</strong> 插件，解压放到 RabbitMQ 的插件目录</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp rabbitmq_delayed_message_exchange-3.8.9-0199d11c.ez /usr/lib/rabbitmq/lib/rabbitmq_server-3.8.8/plugins</span><br></pre></td></tr></table></figure><p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/image-20240407220927691.png" alt="image-20240407220927691"></p><ul><li>进入 RabbitMQ 的安装目录下的 plgins 目录，执行命令让该<strong>插件生效</strong></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/lib/rabbitmq/lib/rabbitmq_server-3.8.8/plugins</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">插件生效</span></span><br><span class="line">rabbitmq-plugins enable rabbitmq_delayed_message_exchange</span><br></pre></td></tr></table></figure><p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/image-20240407221120860.png" alt="image-20240407221120860"></p><ul><li><strong>重启 RabbitMQ</strong>：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart rabbitmq-server.service</span><br></pre></td></tr></table></figure><ul><li><strong>验证</strong>：安装成功后，web 页面新增交换机，类型会多一个延迟消息的选项，由交换机来延迟</li></ul><p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/image-20240407221525820.png" alt="image-20240407221525820"></p><h4 id="7-6-2-案例"><a href="#7-6-2-案例" class="headerlink" title="7.6.2 案例"></a>7.6.2 案例</h4><blockquote><p>安装了延迟消息交换机插件后，就可以直接使用这个插件来实现消息的延迟发送，而不再需要通过死信队列的方式来实现延迟队列了</p></blockquote><p>新增一个队列 delayed.queue，一个自定义交换机 delayed.exchange，绑定关系如下：</p><ul><li>生产者 -&gt; 延迟交换机 -&gt; 普通队列 -&gt; 消费者</li></ul><p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/image-20240407222649600.png" alt="image-20240407222649600"></p><h4 id="7-6-3-配置文件类代码"><a href="#7-6-3-配置文件类代码" class="headerlink" title="7.6.3 配置文件类代码"></a>7.6.3 配置文件类代码</h4><ul><li>需要声明交换机、队列以及它们之间的绑定键<ul><li>在<strong>声明交换机的时候，设置交换机是延迟类型的</strong></li><li><code>@Qualifier</code>注解用于指定自动装配（autowiring）时应注入哪个具体的bean，当有多个相同类型的bean可供选择时，<code>@Qualifier(&quot;beanName&quot;)</code>可以帮助指定注入哪一个</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DelayedQueueConfig</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DELAYED_QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;delayed.queue&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DELAYED_EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;delayed.exchange&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DELAYED_ROUTING_KEY</span> <span class="operator">=</span> <span class="string">&quot;delayed.routingkey&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明队列</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">delayedQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(DELAYED_QUEUE_NAME);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明自定义交换机 这里定义的是一个延迟交换机</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> CustomExchange <span class="title function_">delayedExchange</span><span class="params">()</span> &#123;</span><br><span class="line">        Map&lt;String, Object&gt; args = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 自定义交换机的类型</span></span><br><span class="line">        args.put(<span class="string">&quot;x-delayed-type&quot;</span>, <span class="string">&quot;direct&quot;</span>);</span><br><span class="line">        <span class="comment">// 参数: 名称、类型、持久化标识、自动删除标识、参数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CustomExchange</span>(DELAYED_EXCHANGE_NAME, <span class="string">&quot;x-delayed-message&quot;</span>,</span><br><span class="line">                                  <span class="literal">true</span>, <span class="literal">false</span>, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingDelayedQueue</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="meta">@Qualifier(&quot;delayedQueue&quot;)</span> Queue queue,</span></span><br><span class="line"><span class="params">        <span class="meta">@Qualifier(&quot;delayedExchange&quot;)</span> CustomExchange</span></span><br><span class="line"><span class="params">        delayedExchange)</span> &#123;  <span class="comment">// 这里@Qualifier()中就是方法名(默认的自定义名), 指定自动装配时应注入哪个具体的 bean</span></span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue).to(delayedExchange)</span><br><span class="line">            .with(DELAYED_ROUTING_KEY).noargs();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-6-4-消息生产者代码"><a href="#7-6-4-消息生产者代码" class="headerlink" title="7.6.4 消息生产者代码"></a>7.6.4 消息生产者代码</h4><ul><li><strong>延迟时间</strong> <code>delayTime</code>：是指消息从被发送到实际被投递到目标队列之间的等待时间</li><li><strong>存活时间</strong> <code>TTL</code>：是指消息一旦到达目标队列后能在队列中存活的最大时间如果消息在这段TTL时间内没有被消费，那么它会被移除或转移到死信队列</li></ul><p>简而言之，延迟时间控制消息发送到队列的延迟，而TTL控制消息在队列中的存活时间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 发消息, 基于插件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> msg  消息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> delayTime 延迟时间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/sendDelayMsg&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMsg</span><span class="params">(<span class="meta">@RequestParam</span> String msg, <span class="meta">@RequestParam</span> Integer delayTime)</span> &#123;</span><br><span class="line">    log.info(<span class="string">&quot;当前时间: &#123;&#125;, 发送一条时长 &#123;&#125; 毫秒 信息给延迟队列 QC: &#123;&#125;&quot;</span>,</span><br><span class="line">             <span class="keyword">new</span> <span class="title class_">Date</span>().toString(), delayTime, msg);</span><br><span class="line"></span><br><span class="line">    rabbitTemplate.convertAndSend(DelayedQueueConfig.DELAYED_EXCHANGE_NAME,</span><br><span class="line">                                  DelayedQueueConfig.DELAYED_ROUTING_KEY, msg, message -&gt; &#123;</span><br><span class="line">                                      <span class="comment">// 设置发送消息的延迟时长</span></span><br><span class="line">                                      message.getMessageProperties().setDelay(delayTime);</span><br><span class="line">                                      <span class="keyword">return</span> message;</span><br><span class="line">                                  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-6-5-消息消费者代码"><a href="#7-6-5-消息消费者代码" class="headerlink" title="7.6.5 消息消费者代码"></a>7.6.5 消息消费者代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 消息消费者</span></span><br><span class="line"><span class="comment"> * 基于插件的延迟队列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DelayQueueConsumer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DELAYED_QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;delayed.queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编写 rabbit 监听类</span></span><br><span class="line">    <span class="meta">@RabbitListener(queues = DELAYED_QUEUE_NAME)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveDelayedQueue</span><span class="params">(Message message)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody());</span><br><span class="line">        log.info(<span class="string">&quot;当前时间：&#123;&#125;,收到延时队列的消息：&#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>().toString(), msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-6-6-测试"><a href="#7-6-6-测试" class="headerlink" title="7.6.6 测试"></a>7.6.6 测试</h4><ul><li><code>http://localhost:8080/ttl/sendDelayMsg?msg=hhh&amp;delayTime=20000</code></li><li><code>http://localhost:8080/ttl/sendDelayMsg?msg=eee&amp;delayTime=2000</code></li></ul><p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/image-20240408222411992.png" alt="image-20240408222411992"></p><h3 id="7-7-总结"><a href="#7-7-总结" class="headerlink" title="7.7 总结"></a>7.7 总结</h3><ul><li>延时队列在需要延时处理的场景下非常有用，使用 RabbitMQ 来实现延时队列可以很好的利用 RabbitMQ 的特性，如：消息可靠发送、消息可靠投递、<strong>死信队列来保障消息至少被消费一次以及未被正确处理的消息不会被丢弃</strong>。另外，通过 RabbitMQ 集群的特性，可以很好的解决单点故障问题，不会因为单个节点挂掉导致延时队列不可用或者消息丢失</li><li>延时队列还有很多其它选择，比如利用 Java 的 DelayQueue，利用 Redis 的 zset，利用 Quartz 或者利用 kafka 的时间轮，这些方式各有特点，看需要适用的场景</li></ul><p>延迟队列在RabbitMQ中可以通过两种主要方式实现：基于死信队列和基于插件。</p><ul><li><strong>基于死信队列</strong>：通过设置消息的TTL或队列长度限制，使<strong>消息在条件触发时转入死信队列</strong>，从而实现延迟效果。这种方法依赖于消息到期或队列状态改变，需要额外配置死信交换机和队列。</li><li><strong>基于插件</strong>：使用RabbitMQ的延迟消息交换机插件，直接在消息属性上设置延迟时间，使<strong>消息在指定时间后才被路由到目标队列</strong>。这种方式更直接，不依赖TTL导致的间接转移，适合需要精确控制延迟时间的场景。</li></ul><p>消息延迟的实现机制和处理顺序的影响：</p><ul><li><strong>基于死信队列</strong>：RabbitMQ只检查队列头部的消息是否过期。如果头部消息没有过期，即使后续消息已经到了过期时间，也不会被立即处理，直到它们移动到队列头部。这就可能导致即使设置了不同的TTL，消息处理也会受到队列头部消息状态的影响。</li><li><strong>基于插件</strong>：<strong>每条消息的延迟是独立处理的，当消息的延迟时间到了，它就会被立即投递，不受队列中其他消息状态的影响</strong>。这样，即使后续消息的延迟时间较短，也能按预期时间被处理，不会因为队列中其他消息的状态而延误。</li></ul><h2 id="8-发布确认高级"><a href="#8-发布确认高级" class="headerlink" title="8. 发布确认高级"></a>8. 发布确认高级</h2><p>从 3.3.3 处埋的坑，之前 4.发布确认 中，发送消息后，生产者等待来自RabbitMQ服务器的确认，但是如果服务器宕机了呢？</p><blockquote><p>之前我们的前提是假设RabbitMQ服务器是可达的，能够接收消息并返回确认或否认，如果RabbitMQ服务器不可用，生产者尝试发送的消息将无法到达RabbitMQ，这时候就需要一个额外的机制来确保消息不会丢失</p></blockquote><ul><li><p>在生产环境中由于一些不明原因，导致 RabbitMQ 重启，<strong>在 RabbitMQ 重启期间生产者消息投递失败，导致消息丢失，需要手动处理和恢复</strong></p></li><li><p>如何才能进行 RabbitMQ 的消息可靠投递呢？特别是在这样比较极端的情况，RabbitMQ 集群不可用的时候，无法投递的消息该如何处理呢？</p></li></ul><h3 id="8-1-发布确认-SpringBoot-版本"><a href="#8-1-发布确认-SpringBoot-版本" class="headerlink" title="8.1 发布确认 SpringBoot 版本"></a>8.1 发布确认 SpringBoot 版本</h3><p>考虑两种情况：</p><ul><li><strong>交换机接收不到消息</strong>：这种情况通常发生在消息从生产者发送到 RabbitMQ 时，由于RabbitMQ服务器宕机、网络问题或其他原因导致消息无法到达交换机。</li><li><strong>队列接收不到消息</strong>：即使消息成功到达了交换机，但因为某些原因（如队列不存在，或者路由规则导致消息无法路由到任何队列）消息不能被正确路由到目标队列。</li></ul><blockquote><p>8.1.6 将分析第一种情况</p><p>8.2 将分析第二种情况</p></blockquote><h4 id="8-1-1-确认机制方案"><a href="#8-1-1-确认机制方案" class="headerlink" title="8.1.1 确认机制方案"></a>8.1.1 确认机制方案</h4><ul><li>在生产者端实现一个消息缓存机制，来暂存那些因RabbitMQ不可用而无法发送的消息</li><li>生产者发送消息到直接交换机，一旦 mq 宕机了，或者生产者接收不到消息了，需要对消息进行缓存处理</li></ul><p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/image-20240409213649226.png" alt="image-20240409213649226"></p><h4 id="8-1-2-示例"><a href="#8-1-2-示例" class="headerlink" title="8.1.2 示例"></a>8.1.2 示例</h4><ul><li>用 SpringBoot 实现 4.发布确认 的代码</li></ul><p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/image-20240409214011083.png" alt="image-20240409214011083"></p><h4 id="8-1-3-配置文件和配置类"><a href="#8-1-3-配置文件和配置类" class="headerlink" title="8.1.3 配置文件和配置类"></a>8.1.3 配置文件和配置类</h4><ul><li><strong>配置文件添加一行</strong>：取值设置为 <code>correlated</code><ul><li>**<code>none</code>**：禁用发布确认机制。</li><li>**<code>correlated</code>**：启用发布确认，当需要明确知道每条消息是否成功到达RabbitMQ时使用。这种模式允许将每个消息的确认与其发送操作相关联，通过<code>CorrelationData</code>对象的使用，可以知道具体是哪条消息收到了确认或未被确认。</li><li>**<code>simple</code>**：启用发布确认，但不需要<code>CorrelationData</code>对象</li></ul></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">publisher-confirm-type:</span> <span class="string">correlated</span></span><br></pre></td></tr></table></figure><ul><li><strong>配置交换机和队列</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfirmConfig</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">CONFIRM_EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;confirm.exchange&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">CONFIRM_QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;confirm.queue&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">CONFIRM_ROUTING_KEY</span> <span class="operator">=</span> <span class="string">&quot;key1&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明交换机</span></span><br><span class="line">    <span class="meta">@Bean(&quot;confirmExchange&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> DirectExchange <span class="title function_">confirmExchange</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DirectExchange</span>(CONFIRM_EXCHANGE_NAME);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明确认队列</span></span><br><span class="line">    <span class="meta">@Bean(&quot;confirmQueue&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">confirmQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(CONFIRM_QUEUE_NAME).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明确认队列绑定关系</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">queueBinding</span><span class="params">(<span class="meta">@Qualifier(&quot;confirmQueue&quot;)</span> Queue queue,</span></span><br><span class="line"><span class="params">                                <span class="meta">@Qualifier(&quot;confirmExchange&quot;)</span> DirectExchange exchange)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue).to(exchange).with(CONFIRM_ROUTING_KEY);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-1-4-消息生产者"><a href="#8-1-4-消息生产者" class="headerlink" title="8.1.4 消息生产者"></a>8.1.4 消息生产者</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/confirm&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProducerController</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/sendMsg&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMsg</span><span class="params">(<span class="meta">@RequestParam</span> String msg)</span> &#123;</span><br><span class="line">        <span class="comment">// 指定消息 id 为 1</span></span><br><span class="line">        <span class="type">CorrelationData</span> <span class="variable">correlationData1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CorrelationData</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        rabbitTemplate.convertAndSend(ConfirmConfig.CONFIRM_EXCHANGE_NAME,</span><br><span class="line">                                      ConfirmConfig.CONFIRM_ROUTING_KEY, msg + <span class="string">&quot;key1&quot;</span>, correlationData1);</span><br><span class="line">        log.info(<span class="string">&quot;发消息内容: &#123;&#125;&quot;</span>, msg + <span class="string">&quot;key1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 指定消息 id 为 2 ==&gt; 绑定键错误</span></span><br><span class="line">        <span class="type">CorrelationData</span> <span class="variable">correlationData2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CorrelationData</span>(<span class="string">&quot;2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        rabbitTemplate.convertAndSend(ConfirmConfig.CONFIRM_EXCHANGE_NAME,</span><br><span class="line">                                      ConfirmConfig.CONFIRM_ROUTING_KEY + <span class="string">&quot;2&quot;</span>, msg + <span class="string">&quot;key12&quot;</span>, correlationData2);</span><br><span class="line">        log.info(<span class="string">&quot;发消息内容: &#123;&#125;&quot;</span>, msg + <span class="string">&quot;key12&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-1-5-回调接口"><a href="#8-1-5-回调接口" class="headerlink" title="8.1.5 回调接口"></a>8.1.5 回调接口</h4><ul><li><p><strong>使用<code>@PostConstruct</code>进行初始化</strong></p><ul><li><p>使用<code>@PostConstruct</code>注解的<code>init</code>方法确保了只有在<code>MyCallBack</code>类实例化并<code>RabbitTemplate</code>注入完成后，才设置确认回调。这样可以避免在<code>RabbitTemplate</code>完全配置前误调用回调方法的风险</p></li><li><p><code>setConfirmCallback(this)</code>的调用设置了当前实例（<code>MyCallBack</code>）作为消息确认的回调处理器。这意味着每当消息被发送到RabbitMQ服务器，并且服务器对消息进行了处理（无论是接受还是拒绝），都会调用实例的<code>confirm</code>方法。</p></li></ul></li><li><p><code>CorrelationData</code>  对象是在发送消息时由消息生产者创建并传递的</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCallBack</span> <span class="keyword">implements</span> <span class="title class_">RabbitTemplate</span>.ConfirmCallback &#123;</span><br><span class="line">    <span class="comment">// 注入</span></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类内部接口, 容器内也要有内部接口的实例</span></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        rabbitTemplate.setConfirmCallback(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交换机确认回调方法</span></span><br><span class="line"><span class="comment">     * 发消息 交换机接收到了 回调</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> correlationData 保存回调消息的 ID 及相关信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ack             交换机收到消息 =&gt; true, 没收到 =&gt; false</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cause           成功没有原因 null, 失败就是失败的原因</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">confirm</span><span class="params">(CorrelationData correlationData, <span class="type">boolean</span> ack, String cause)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> correlationData != <span class="literal">null</span> ? correlationData.getId() : <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (ack) &#123;  <span class="comment">// 成功</span></span><br><span class="line">            log.info(<span class="string">&quot;交换机已经收到 id 为:&#123;&#125;的消息&quot;</span>, id);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 失败</span></span><br><span class="line">            log.info(<span class="string">&quot;交换机还未收到 id 为:&#123;&#125;消息,由于原因:&#123;&#125;&quot;</span>, id, cause);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-1-5-消息消费者"><a href="#8-1-5-消息消费者" class="headerlink" title="8.1.5 消息消费者"></a>8.1.5 消息消费者</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer</span> &#123;</span><br><span class="line">    <span class="meta">@RabbitListener(queues = ConfirmConfig.CONFIRM_QUEUE_NAME)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveConfirmMsg</span><span class="params">(Message message)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody());</span><br><span class="line">        log.info(<span class="string">&quot;接受到队列 confirm.queue 消息: &#123;&#125;&quot;</span>, msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-1-6-测试"><a href="#8-1-6-测试" class="headerlink" title="8.1.6 测试"></a>8.1.6 测试</h4><ul><li><code>http://localhost:8080/confirm/sendMsg?msg=hhh</code></li></ul><p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/image-20240412135800282.png" alt="image-20240412135800282"></p><ul><li><strong>考虑到交换机接收不到消息</strong>的情况，测试下<ul><li>在生产者代码里修改交换机的名字为不存在的交换机，然后发送消息</li><li>可以看到会回显失败和失败的原因</li></ul></li></ul><p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/image-20240412141332905.png" alt="image-20240412141332905"></p><ul><li><strong>考虑到队列接收不到消息</strong>的情况，测试下<ul><li>在生产者代码里增加一个绑定键为错误的消息进行发送</li><li>可以看到<strong>接收不到失败的回调</strong>，消费者(队列)只收到了一个消息，另一个没收到，但是它也没有应答，也没有确认，因为底层默认把<strong>消息丢失</strong>了</li><li>具体解决看 8.2</li></ul></li></ul><p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/image-20240412141703506.png" alt="image-20240412141703506"></p><h3 id="8-2-回退消息"><a href="#8-2-回退消息" class="headerlink" title="8.2 回退消息"></a>8.2 回退消息</h3><p>在 RabbitMQ 中，当<strong>消息无法被路由到任何队列时（即没有匹配的绑定键）</strong>，默认情况下，这条消息会被交换机丢弃，而生产者不会得到任何通知。这种情况可能会导致数据丢失，特别是在生产者假设消息已成功发送的场景下</p><h4 id="8-2-1-Mandatory-参数"><a href="#8-2-1-Mandatory-参数" class="headerlink" title="8.2.1 Mandatory 参数"></a>8.2.1 Mandatory 参数</h4><p>当设置了<code>mandatory</code>参数后，如果消息在到达交换机后无法路由到任何队列，<strong>交换机不会静默丢弃这条消息。相反，消息会被返回给生产者</strong>。这个过程通常称为消息回退</p><h4 id="8-2-2-配置文件"><a href="#8-2-2-配置文件" class="headerlink" title="8.2.2 配置文件"></a>8.2.2 配置文件</h4><ul><li>在配置文件 yaml 里<strong>开启发布退回的配置</strong>：<ul><li><code>publisher-returns: true</code> 在Spring Boot配置中确实起到了类似AMQP的<code>mandatory</code>标志的作用</li><li>确保配置了<code>ReturnCallback</code>回调接口来处理退回的消息</li></ul></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">publisher-returns:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h4 id="8-2-3-回调接口"><a href="#8-2-3-回调接口" class="headerlink" title="8.2.3 回调接口"></a>8.2.3 回调接口</h4><ul><li>在 8.1.5 的回调接口代码上添加回退接口的实现：<code>RabbitTemplate.ReturnsCallback</code><ul><li>注意也要注入改接口</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">    rabbitTemplate.setConfirmCallback(<span class="built_in">this</span>);</span><br><span class="line">    rabbitTemplate.setReturnsCallback(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当消息无法路由到任何队列时调用</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> returned 封装了退回消息的详细信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">returnedMessage</span><span class="params">(ReturnedMessage returned)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(returned.getMessage().getBody());</span><br><span class="line"></span><br><span class="line">    log.error(<span class="string">&quot;消息 &#123;&#125; 被交换机 &#123;&#125; 退回, 退回原因: &#123;&#125;, 路由 key: &#123;&#125;&quot;</span>,</span><br><span class="line">              message,</span><br><span class="line">              returned.getExchange(),</span><br><span class="line">              returned.getReplyText(),</span><br><span class="line">              returned.getRoutingKey());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-2-4-测试"><a href="#8-2-4-测试" class="headerlink" title="8.2.4 测试"></a>8.2.4 测试</h4><ul><li>可以看到消息被回退了，还有回退的原因，保障即使消息发不到队列，消息也不丢失</li></ul><p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/image-20240412143809373.png" alt="image-20240412143809373"></p><h3 id="8-3-备份交换机"><a href="#8-3-备份交换机" class="headerlink" title="8.3 备份交换机"></a>8.3 备份交换机</h3><blockquote><p>前面在设置死信队列的部分提到可以为队列设置死信交换机来存储那些处理失败的消息，可是这些<strong>不可路由消息根本没有机会进入到队列，因此无法使用死信队列来保存消息</strong></p></blockquote><p><strong>备份交换机</strong>可以理解为某个主交换机的“备胎”。当一条消息发送到主交换机，但找不到任何合适的队列匹配时（即消息无法路由），这条消息将会被发送到配置的备份交换机。这样的机制确保消息在无法正常路由时不会被丢弃，而是有另一条路径可以走。</p><ul><li><p><strong>使用场景</strong>：</p><ul><li><p><strong>错误处理和日志记录</strong>：通过备份交换机，无法路由的消息可以被统一收集和记录，用于后续的错误处理或者生成警报。</p></li><li><p><strong>系统可靠性增强</strong>：在高可靠性需求的系统中，备份交换机提供了一个简单的方法来保证消息至少在某个地方被处理，即使它们无法被正常的业务逻辑处理。</p></li></ul></li><li><p>备份交换机通常设置为<code>Fanout</code>类型，这是因为<code>Fanout</code>交换机会将接收到的所有消息广播到所有绑定的队列，确保无法路由的消息不会丢失。下面是如何配置备份交换机的步骤：</p><ul><li><p><strong>声明备份交换机</strong>：首先，需要声明一个<code>Fanout</code>类型的备份交换机。</p></li><li><p><strong>配置主交换机</strong>：在声明主交换机时，设置一个额外的参数<code>alternate-exchange</code>，指向备份交换机。</p></li><li><p><strong>绑定队列</strong>：至少需要为备份交换机绑定一个队列，以确保从备份交换机接收消息。</p></li></ul></li></ul><h4 id="8-3-1-示例"><a href="#8-3-1-示例" class="headerlink" title="8.3.1 示例"></a>8.3.1 示例</h4><ul><li>增加备份交换机、备份队列和报警队列<ul><li>备份交换机设置为扇出类型，会广播消息到所有绑定的队列，可以实现备份和报警的功能</li></ul></li></ul><p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/image-20240412154643543.png" alt="image-20240412154643543"></p><h4 id="8-3-2-修改配置类"><a href="#8-3-2-修改配置类" class="headerlink" title="8.3.2 修改配置类"></a>8.3.2 修改配置类</h4><ul><li><strong>设置原先的确认交换机的备份交换机</strong></li><li><strong>增加扇出类型的备份交换机</strong>，并分别和备份队列以及报警队列进行绑定</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明直接交换机, 并声明它的备份交换机</span></span><br><span class="line"><span class="meta">@Bean(&quot;confirmExchange&quot;)</span></span><br><span class="line"><span class="keyword">public</span> DirectExchange <span class="title function_">confirmExchange</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ExchangeBuilder.directExchange(CONFIRM_EXCHANGE_NAME)</span><br><span class="line">        .durable(<span class="literal">true</span>)</span><br><span class="line">        .withArgument(<span class="string">&quot;alternate-exchange&quot;</span>, BACKUP_EXCHANGE_NAME)</span><br><span class="line">        .build();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 备份交换机-扇出类型的</span></span><br><span class="line"><span class="meta">@Bean(&quot;backupExchange&quot;)</span></span><br><span class="line"><span class="keyword">public</span> FanoutExchange <span class="title function_">backupExchange</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FanoutExchange</span>(BACKUP_EXCHANGE_NAME);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 备份队列</span></span><br><span class="line"><span class="meta">@Bean(&quot;backupQueue&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Queue <span class="title function_">backupQueue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> QueueBuilder.durable(BACKUP_QUEUE_NAME).build();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 备份队列</span></span><br><span class="line"><span class="meta">@Bean(&quot;warningQueue&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Queue <span class="title function_">warningQueue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> QueueBuilder.durable(WARNING_QUEUE_NAME).build();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 绑定</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Binding <span class="title function_">backupQueueBindingBackExchange</span><span class="params">(<span class="meta">@Qualifier(&quot;backupQueue&quot;)</span> Queue backupQueue,</span></span><br><span class="line"><span class="params">                                              <span class="meta">@Qualifier(&quot;backupExchange&quot;)</span> FanoutExchange backupExchange)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> BindingBuilder.bind(backupQueue).to(backupExchange);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Binding <span class="title function_">warningQueueBindingBackExchange</span><span class="params">(<span class="meta">@Qualifier(&quot;warningQueue&quot;)</span> Queue warningQueue,</span></span><br><span class="line"><span class="params">                                               <span class="meta">@Qualifier(&quot;backupExchange&quot;)</span> FanoutExchange backupExchange)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> BindingBuilder.bind(warningQueue).to(backupExchange);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-3-3-报警消费者"><a href="#8-3-3-报警消费者" class="headerlink" title="8.3.3 报警消费者"></a>8.3.3 报警消费者</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WarningConsumer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(queues = ConfirmConfig.WARNING_QUEUE_NAME)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveWarningMsg</span><span class="params">(Message message)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody());</span><br><span class="line">        log.error(<span class="string">&quot;报警发现不可路由消息：&#123;&#125;&quot;</span>, msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-3-4-测试"><a href="#8-3-4-测试" class="headerlink" title="8.3.4 测试"></a>8.3.4 测试</h4><ul><li>先在 web 界面删除之前的确认交换机，因为我们修改了其绑定属性，不然会报错</li></ul><p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/image-20240412161545389.png" alt="image-20240412161545389"></p><ul><li>从结果也可以说明，在我们<strong>同时设置了回退消息和备份交换机的两种机制下，备份交换机的优先级更高些</strong></li></ul><h2 id="9-其他知识点"><a href="#9-其他知识点" class="headerlink" title="9. 其他知识点"></a>9. 其他知识点</h2><h3 id="9-1-幂等性"><a href="#9-1-幂等性" class="headerlink" title="9.1 幂等性"></a>9.1 幂等性</h3><h4 id="9-1-1-概念"><a href="#9-1-1-概念" class="headerlink" title="9.1.1 概念"></a>9.1.1 概念</h4><p>幂等性意味着<strong>执行多次和执行一次的效果完全相同</strong>。在业务操作如支付中，用户可能因为网络延迟等问题多次点击支付按钮，导致多次扣款。确保操作的幂等性可以防止这种情况，即使操作多次执行，也只有一次有效果生效。</p><h4 id="9-1-2-消息重复消费"><a href="#9-1-2-消息重复消费" class="headerlink" title="9.1.2 消息重复消费"></a>9.1.2 消息重复消费</h4><p>消费者在消费 MQ 中的消息时，MQ 已把消息发送给消费者，消费者在给 MQ 返回 ack 时网络中断，故 MQ 未收到确认信息，该条消息会重新发给其他的消费者，或者在网络重连后再次发送给该消费者，但实际上该消费者已成功消费了该条消息，造成消费者消费了重复的消息。</p><h4 id="9-1-3-解决思路"><a href="#9-1-3-解决思路" class="headerlink" title="9.1.3 解决思路"></a>9.1.3 解决思路</h4><p>解决消息队列中的幂等性问题通常涉及到<strong>确保每条消息只被处理一次，即使它被多次接收</strong>。实现这一点的方法包括：</p><ul><li><strong>使用全局唯一ID</strong>：每条消息都有一个全局唯一标识，消费者处理消息前先检查该消息ID是否已被处理。</li><li><strong>时间戳、UUID或业务ID</strong>：使用这些唯一标识来标记每个消息或事务。</li></ul><h4 id="9-1-4-消费端的幂等性保障"><a href="#9-1-4-消费端的幂等性保障" class="headerlink" title="9.1.4 消费端的幂等性保障"></a>9.1.4 消费端的幂等性保障</h4><p>保障消息消费端的幂等性是通过确保每条消息只触发一次业务处理逻辑实现的。主流方法包括：</p><ul><li><strong>唯一ID + 指纹码机制</strong>：结合消息内容或特定字段（如时间戳、用户ID等）生成一个指纹码，通过数据库主键去重或查询来防止重复处理。<ul><li>指纹码通常是根据消息内容或业务场景特征生成的一个唯一标识符。这个机制的实现通常依赖于数据库的能力来快速检查和插入这些唯一标识，确保操作的原子性和唯一性。这种方法的优点是实现简单，缺点是在高并发场景下可能会遇到数据库性能瓶颈。</li></ul></li><li><strong>数据库事务和锁</strong>：利用数据库的事务和锁机制来确保操作只被成功执行一次。 &#x3D;&#x3D;&gt; 推荐<ul><li><strong>Redis的<code>SETNX</code>命令（</strong>set if not exists）提供了一个天然的<strong>原子操作，可以用来实现幂等性</strong>。这个命令只有在键不存在时才设置键的值，如果键已存在，命令不做任何操作。这样，可以利用Redis来记录每个消息或操作的唯一标识，并确保重复的消息或操作不会被处理。</li></ul></li></ul><h3 id="9-2-优先级队列"><a href="#9-2-优先级队列" class="headerlink" title="9.2 优先级队列"></a>9.2 优先级队列</h3><h4 id="9-2-1-使用场景"><a href="#9-2-1-使用场景" class="headerlink" title="9.2.1 使用场景"></a>9.2.1 使用场景</h4><ul><li><p><strong>场景</strong>：</p><ul><li><p>在电商平台中，例如天猫，订单支付提醒功能，即当用户在预定时间内未完成支付时，系统会自动发送提醒短信。</p></li><li><p>对于不同级别的商家，如苹果或小米（被认为是大客户），他们的订单应当被优先处理，因为这些客户为平台带来较高的利润。</p></li></ul></li><li><p><strong>问题</strong>：传统使用Redis实现的后端系统通过List结构支持的是基本的队列功能，无法处理复杂的优先级逻辑。当订单量大增时，需要一种机制来区分处理订单的优先级。</p></li><li><p><strong>解决方案</strong>：使用RabbitMQ的优先级队列功能来优化系统。这允许系统根据客户的重要性赋予订单不同的优先级，从而确保重要客户的订单可以得到更快的处理。</p></li></ul><h4 id="9-2-2-如何添加优先级"><a href="#9-2-2-如何添加优先级" class="headerlink" title="9.2.2 如何添加优先级"></a>9.2.2 如何添加优先级</h4><ul><li><p><strong>设置队列的最大优先级 最大可以设置到255官网推荐 1-10 如果设置太高比较吃内存和 CPU</strong></p></li><li><p>要让队列实现优先级有如下步骤：</p><ul><li><p>队列需要设置为优先级队列，消息需要设置消息的优先级</p></li><li><p><strong>消费者需要等待消息已经发送到队列中才去消费，因为这样才有机会对消息进行排序</strong></p></li></ul></li><li><p><strong>两种方式添加队列的优先级</strong>：</p><ul><li><strong>控制台页面添加</strong>：</li></ul><p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/image-20240412184641755.png" alt="image-20240412184641755"></p><ul><li><strong>代码方式添加</strong>：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Object&gt; params = <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">params.put(<span class="string">&quot;x-max-priority&quot;</span>, <span class="number">10</span>);</span><br><span class="line">channel.queueDeclare(<span class="string">&quot;hello&quot;</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, params);</span><br></pre></td></tr></table></figure></li><li><p><strong>消息设置优先级</strong>：</p><ul><li>注意消息的优先级数值需要在队列设置的优先级数值范围内，不能超过</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AMQP.<span class="type">BasicProperties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> </span><br><span class="line">    <span class="title class_">AMQP</span>.BasicProperties().builder().priority(<span class="number">5</span>).build();</span><br></pre></td></tr></table></figure><h4 id="9-2-3-实战"><a href="#9-2-3-实战" class="headerlink" title="9.2.3 实战"></a>9.2.3 实战</h4><ul><li>消息生产者：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Producer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME=<span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtils.getChannel();) &#123;</span><br><span class="line">            <span class="comment">// 给消息赋予一个 priority 属性</span></span><br><span class="line">            AMQP.<span class="type">BasicProperties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> </span><br><span class="line">                <span class="title class_">AMQP</span>.BasicProperties().builder().priority(<span class="number">5</span>).build();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;<span class="number">11</span>; i++) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;info&quot;</span>+i;</span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">5</span>)&#123;</span><br><span class="line">                    channel.basicPublish(<span class="string">&quot;&quot;</span>, QUEUE_NAME, properties, message.getBytes());</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    channel.basicPublish(<span class="string">&quot;&quot;</span>, QUEUE_NAME, <span class="literal">null</span>, message.getBytes());</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;发送消息完成:&quot;</span> + message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>消息消费者</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME=<span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtils.getChannel();</span><br><span class="line">        <span class="comment">//设置队列的最大优先级 最大可以设置到 255 官网推荐 1-10 如果设置太高比较吃内存和 CPU</span></span><br><span class="line">        Map&lt;String, Object&gt; params = <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        params.put(<span class="string">&quot;x-max-priority&quot;</span>, <span class="number">10</span>);</span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, params);</span><br><span class="line">        System.out.println(<span class="string">&quot;消费者启动等待消费......&quot;</span>);</span><br><span class="line">        DeliverCallback deliverCallback=(consumerTag, delivery)-&gt;&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">receivedMessage</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody());</span><br><span class="line">            System.out.println(<span class="string">&quot;接收到消息:&quot;</span>+receivedMessage);</span><br><span class="line">        &#125;;</span><br><span class="line">        channel.basicConsume(QUEUE_NAME,<span class="literal">true</span>,deliverCallback,(consumerTag)-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;消费者无法消费消息时调用，如队列被删除&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-3-惰性队列"><a href="#9-3-惰性队列" class="headerlink" title="9.3 惰性队列"></a>9.3 惰性队列</h3><h4 id="9-3-1-使用场景"><a href="#9-3-1-使用场景" class="headerlink" title="9.3.1 使用场景"></a>9.3.1 使用场景</h4><blockquote><p>默认情况 &#x3D;&#x3D;&gt; 消息保存在<strong>内存</strong></p><p><strong>惰性队列 &#x3D;&#x3D;&gt; 消息保存在磁盘</strong></p></blockquote><ul><li>惰性队列的设计旨在支持长队列的管理，<strong>允许存储大量消息而不对系统性能造成显著影响</strong><ul><li>当消费者由于各种各样的原因(比如消费者下线、宕机亦或者是由于维护而关闭等)而致使长时间内不能消费消息造成堆积时，惰性队列就很有必要了</li></ul></li><li><strong>问题解决</strong>：<ul><li>在默认队列行为中，RabbitMQ尽可能将消息保留在内存中，以便快速传递给消费者。然而，这种模式在消息量大时会导致内存压力增大，系统可能需要执行耗时的内存到磁盘的数据交换操作，进而影响队列性能。</li><li>惰性队列通过将消息直接存储到磁盘来解决这一问题，<strong>只有当消息需要被消费时，才加载到内存中。这极大地减少了内存的使用，使得RabbitMQ能够处理更长的队列</strong>。</li></ul></li></ul><h4 id="9-3-2-两种模式"><a href="#9-3-2-两种模式" class="headerlink" title="9.3.2 两种模式"></a>9.3.2 两种模式</h4><ul><li><p>**默认模式 <code>default</code>**：RabbitMQ的传统行为，消息尽可能保留在内存中，以便快速处理。适用于消息量不大，或需要极速处理的场景。</p></li><li><p>**惰性模式 <code>lazy</code>**：消息直接写入磁盘，仅在需要时加载到内存中，极大减轻了内存的压力，适用于处理大量或长队列的消息。</p></li><li><p><strong>设置方式</strong>：</p><ul><li><p>可以在队列声明时通过 <code>x-queue-mode</code> 参数设置，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Object&gt; args = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">args.put(<span class="string">&quot;x-queue-mode&quot;</span>, <span class="string">&quot;lazy&quot;</span>);</span><br><span class="line">channel.queueDeclare(<span class="string">&quot;myqueue&quot;</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, args);</span><br></pre></td></tr></table></figure></li><li><p>也可以通过Policy（策略）设置，<strong>策略设置具有比声明时更高的优先级</strong></p></li><li><p>已存在的队列需要先删除后再以新模式重新声明</p></li></ul></li></ul><p><img src="/../img/RabbitMQ%E5%85%A5%E9%97%A8.assets/image-20240412190534258.png" alt="image-20240412190534258"></p><ul><li>惰性队列大幅减少了内存使用，从而降低了因内存不足而导致的性能问题。这使得RabbitMQ服务器能够在资源有限的环境下更加稳定地运行，尤其<strong>适合消息生产速度远大于消费速度的场景</strong></li></ul><h2 id="10-RabbitMQ-集群"><a href="#10-RabbitMQ-集群" class="headerlink" title="10. RabbitMQ 集群"></a>10. RabbitMQ 集群</h2><h3 id="10-1-clustering"><a href="#10-1-clustering" class="headerlink" title="10.1 clustering"></a>10.1 clustering</h3><p><strong>背景</strong>：单机RabbitMQ服务器在面对内存崩溃、电力故障或硬件故障等问题时容易出现服务中断，这在<strong>高可用性</strong>要求的生产环境中是不可接受的。</p><p><strong>需求提升</strong>：随着业务规模的扩大，如需处理每秒达10万条消息的场景，单台服务器的处理能力明显不足，且高性能服务器成本过高。</p><p><strong>解决方案</strong>：构建RabbitMQ集群，分散负载和增强冗余，以提高系统的可靠性和消息吞吐量。</p><h3 id="10-2-镜像队列"><a href="#10-2-镜像队列" class="headerlink" title="10.2 镜像队列"></a>10.2 镜像队列</h3><p><strong>问题</strong>：单个Broker节点的故障可以导致服务不可用和消息丢失，尽管消息持久化到磁盘可以减少数据丢失，但不足以处理节点故障引起的问题。</p><p><strong>解决方案</strong>：通过使用镜像队列，<strong>将队列的副本存储在集群的其他节点上，确保主节点故障时可以无缝切换到镜像节点。</strong></p>]]></content>
      
      
      <categories>
          
          <category> MQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RabbitMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>awk 编程</title>
      <link href="/2023/11/18/Awk/"/>
      <url>/2023/11/18/Awk/</url>
      
        <content type="html"><![CDATA[<h1 id="使用-awk-编写-shell-脚本"><a href="#使用-awk-编写-shell-脚本" class="headerlink" title="使用 awk 编写 shell 脚本"></a>使用 awk 编写 shell 脚本</h1><ul><li>awk 是一个强大的 Linux 命令，有强大的文本格式化的能力</li><li>三剑客：<ul><li>grep：擅长单纯的查找或匹配文本内容</li><li>awk：更适合编辑、处理匹配到的文本内容</li><li>sed：更适合格式化文本内容，对文本进行复杂处理</li></ul></li></ul><h2 id="1-awk-基础"><a href="#1-awk-基础" class="headerlink" title="1. awk 基础"></a>1. awk 基础</h2><ul><li><p>awk 语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">awk [option] &#x27;pattern[action]&#x27; file ...</span><br><span class="line">awk   参数     &#x27;条件动作&#x27;        文件</span><br></pre></td></tr></table></figure></li><li><p>Action 指的是动作，awk 擅长文本格式化，且输出格式化后的结果，因此最常用的动作就是 print</p><ul><li>条件动作举例：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;print $0&#125;  # 把每行都打印出来, 等同于 &#123;print&#125;</span><br><span class="line">&#123;print $1&#125;  # 把每行的第一列打印出来(默认以空格为列的分隔符)</span><br><span class="line">&#123;print $NF&#125;  # 每行的最后一列[倒数第二列可以写成$(NF-1)]</span><br><span class="line">&#123;print $1,$4,$5&#125;  # 打印多列(中间加上逗号是为了空格分割)</span><br></pre></td></tr></table></figure></li><li><p>awk 是按行处理文件，一行处理完毕，处理下一行，根据用户指定的分隔符去工作，没有指定则默认空格</p></li><li><p>awk 分隔符有两种：</p><ul><li>输入分隔符，awk 默认是空格，空白字符，英文是 file separator，变量名是 FS</li><li>输出分隔符，output field separator，简称 OFS，默认也是空格</li></ul></li></ul><h2 id="2-文本格式化"><a href="#2-文本格式化" class="headerlink" title="2. 文本格式化"></a>2. 文本格式化</h2><h3 id="2-1-awk-内置变量"><a href="#2-1-awk-内置变量" class="headerlink" title="2.1 awk 内置变量"></a>2.1 awk 内置变量</h3><table><thead><tr><th align="center">内置变量</th><th align="center">解释</th></tr></thead><tbody><tr><td align="center">$n</td><td align="center">指定分隔符后，当前记录的第n个字段</td></tr><tr><td align="center">$0</td><td align="center">完整的输入记录</td></tr><tr><td align="center">FS</td><td align="center">字段分隔符，默认是空格</td></tr><tr><td align="center">NF(Number of fields)</td><td align="center">分割后，当前行一共有多少个字段(几列?)</td></tr><tr><td align="center">NR(Number of records)</td><td align="center">当前记录数，行数</td></tr><tr><td align="center">FILENAME</td><td align="center">当前文件名</td></tr><tr><td align="center">可用 man 手册查看</td><td align="center">man awk</td></tr></tbody></table><h3 id="2-2-自动定义输出内容"><a href="#2-2-自动定义输出内容" class="headerlink" title="2.2 自动定义输出内容"></a>2.2 自动定义输出内容</h3><ul><li><strong>awk，必须外层单引号，内存双引号</strong></li><li>内置变量 <code>$1、$2</code> 都不得添加双引号，否则会识别为文本，尽量别加引号<ul><li>如：<code>awk &#39;&#123;print &quot;第一列: &quot;$1, &quot;第二列: &quot;$3&#125;&#39; hello.txt</code></li><li>如(将 ipconfig 里的 eth0 段的ip输出)：<code>ipconfig eth0 | awk &#39;NR==2&#123;print $0&#125;&#39;</code></li></ul></li></ul><h3 id="2-3-awk-参数"><a href="#2-3-awk-参数" class="headerlink" title="2.3 awk 参数"></a>2.3 awk 参数</h3><table><thead><tr><th align="center">参数</th><th align="center">解释</th></tr></thead><tbody><tr><td align="center">-F</td><td align="center">指定分割字段符</td></tr><tr><td align="center">-v</td><td align="center">定义或修改一个 awk 内部的变量</td></tr><tr><td align="center">-f</td><td align="center">从脚本文件中读取 awk 命令</td></tr></tbody></table><ul><li>举例(指定冒号作为分隔符)：<ul><li><code>awk -F &quot;:&quot; &#39;&#123;print $1&#125;&#39; hello.txt</code></li><li>也可以用 -v 修改 FS 参数：<code>awk -v FS=&quot;:&quot; &#39;&#123;print $1,$NF&#125;&#39; hello.txt</code></li><li>还可以修改输出分隔符：<code>awk -v OFS=&quot;\t&quot; &#39;&#123;print $1,$NF&#125;&#39; hello.txt</code></li></ul></li></ul><h3 id="2-4-显示文件第5行"><a href="#2-4-显示文件第5行" class="headerlink" title="2.4 显示文件第5行"></a>2.4 显示文件第5行</h3><ul><li><code>NR</code> 在 awk 中表示行号，<code>NR==5</code> 表示行号是 5 的那一行<ul><li>举例：找到第五行和第六行的内容并打印：<code>awk &#39;NR==5, NR==6&#123;print $0&#125;&#39; hello.txt</code></li><li>看行号2-5的内容：<code>awk &#39;NR==2, NR==5&#39; hello.txt</code></li><li>打印行号37-40的内容同时显示行号：<code>awk &#39;NR==37, NR==40&#123;print NR,$0&#125;&#39; hello.txt</code></li></ul></li></ul><h2 id="3-awk-模式-pattern"><a href="#3-awk-模式-pattern" class="headerlink" title="3. awk 模式 pattern"></a>3. awk 模式 pattern</h2><ul><li>特殊的 pattern：<code>BEGIN</code> 和 <code>END</code><ul><li><code>BEGIN</code> 模式是处理文本之前需要执行的操作</li><li><code>END</code> 模式是处理完所有行之后执行的操作</li></ul></li><li>比如：<ul><li><code>awk BEGIN&#123;print &quot;hhh&quot;&#125; hello.txt</code></li><li><code>awk &#39;BEGIN&#123;print &quot;处理文本之前&quot;&#125;&#123;print $0&#125;END&#123;print &quot;所有文本处理完毕&quot;&#125;&#39; hello.txt</code></li></ul></li></ul><h2 id="4-awk-与正则表达式"><a href="#4-awk-与正则表达式" class="headerlink" title="4. awk 与正则表达式"></a>4. awk 与正则表达式</h2><ul><li>主要与 pattern模式(条件)结合使用<ul><li>不指定模式，awk每一行都会执行对应的动作</li><li>指定了模式，只有被模式匹配到的、符合条件的行才会执行动作</li></ul></li><li>awk 使用正则语法：<ul><li><code>awk &#39;/正则表达式/动作&#39; /etc/passwd</code></li><li>awk 命令使用正则表达式，必须把正则放入 <code>//</code> 双斜杠中，匹配到结果后执行动作 <code>&#123;print $0&#125;</code>，打印整行信息</li></ul></li><li>比如：<ul><li>输出以 <code>games</code> 开头的行：<code>awk &#39;/^games/&#123;print $0&#125;&#39; hello.txt</code></li><li>输出符合上面条件的行的第一列和最后一列(分隔符为冒号)：<code>awk -F &quot;:&quot; &#39;/^games/&#123;print $0, $NF&#125;&#39; hello.txt</code></li></ul></li></ul><h2 id="5-awk-案例"><a href="#5-awk-案例" class="headerlink" title="5. awk 案例"></a>5. awk 案例</h2><h3 id="5-1-插入新字段和格式化空白"><a href="#5-1-插入新字段和格式化空白" class="headerlink" title="5.1 插入新字段和格式化空白"></a>5.1 插入新字段和格式化空白</h3><ul><li>在 <code>a b c d</code> 的 <code>b</code> 后面插入 3 个字段 <code>e f g</code></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo a b c d | awk &#x27;&#123;$2=$2&quot; e f g&quot;;print&#125;&#x27;</span><br></pre></td></tr></table></figure><ul><li>移除每行的前缀、后缀空白，并将各部分左对齐</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;BEGIN&#123;OFS=&quot;\t&quot;&#125;&#123;$1=$1;print&#125;&#x27; a.txt</span><br></pre></td></tr></table></figure><h3 id="5-2-筛选-IPV4-地址"><a href="#5-2-筛选-IPV4-地址" class="headerlink" title="5.2 筛选 IPV4 地址"></a>5.2 筛选 IPV4 地址</h3><ul><li>从 ifconfig 命令的结果中筛选出除了 lo 网卡外的所有 IPv4 地址</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">法一：正则匹配开头为inet 且第二列不以 127 开头</span></span><br><span class="line">ifconfig | awk &#x27;/inet / &amp;&amp; !($2 ~ /^127/)&#123;print $2&#125;&#x27;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">按段落读取</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">法二：一次性读取一段，可以修改输入的行分隔符为<span class="string">&quot;&quot;</span></span></span><br><span class="line">ifconfig | awk &#x27;BEGIN&#123;RS=&quot;&quot;&#125;!/lo/&#123;print $6&#125;&#x27;</span><br></pre></td></tr></table></figure><h3 id="5-3-读取-ini-配置文件中的某段"><a href="#5-3-读取-ini-配置文件中的某段" class="headerlink" title="5.3 读取 .ini 配置文件中的某段"></a>5.3 读取 .ini 配置文件中的某段</h3><blockquote><p>读取 mysql 段</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">匹配包含 [mysql] 的，但是可读性较差</span></span><br><span class="line">/\[mysql\]/&#123;&#125;  # 使用反斜线转义一下中括号</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">对于能够确定的字符串，可用index去搜索</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">搜索到的话，返回索引位；搜索不到返回0</span></span><br><span class="line"><span class="meta prompt_">index($</span><span class="language-bash">0, <span class="string">&quot;[mysql]&quot;</span>) &#123;</span></span><br><span class="line">    print   # 输出符合条件的那一行</span><br><span class="line">    while( (getline var) &gt; 0 ) &#123;</span><br><span class="line">        if (var ~ /\[.*\]/) &#123;  # 如果匹配到格式形如 [..] 的，就停止</span><br><span class="line">             exit</span><br><span class="line">        &#125;</span><br><span class="line">        print var</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">getline 返回值:</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">&gt;0 表示已经读取到数据</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">=0 表示遇到结尾 EOF，也就表示没有读取到东西</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">&lt;0 表示读取报错</span></span><br></pre></td></tr></table></figure><h3 id="5-4-根据某字段去重"><a href="#5-4-根据某字段去重" class="headerlink" title="5.4 根据某字段去重"></a>5.4 根据某字段去重</h3><blockquote><p>对出现的次数进行判断？</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">以问号为分隔符</span></span><br><span class="line">awk -F &quot;?&quot; &#x27;&#123;</span><br><span class="line"><span class="meta prompt_">arr[$</span><span class="language-bash">2]++;<span class="keyword">if</span>(arr[<span class="variable">$2</span>]==1)&#123;<span class="built_in">print</span>&#125;</span></span><br><span class="line">&#125;&#x27; 1.txt</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">可以更加简短</span></span><br><span class="line">awk -F &quot;?&quot; &#x27;&#123;</span><br><span class="line">!arr[$2]++&#123;print&#125;  # 后置++返回加之前的数, 所以如果加之前为0, 就打印</span><br><span class="line">&#125;&#x27; 1.txt</span><br></pre></td></tr></table></figure><h3 id="5-5-次数统计"><a href="#5-5-次数统计" class="headerlink" title="5.5 次数统计"></a>5.5 次数统计</h3><blockquote><p>需要用到数组</p></blockquote><ul><li>统计单词出现次数</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;&#123;arr[$0]++&#125;END&#123;for(i in arr)&#123;print arr[i], i&#125;&#x27; 1.txt</span><br></pre></td></tr></table></figure><ul><li>统计 TCP 链接状态数量</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -tnap 2&gt;/dev/null | awk &#x27;/^tcp/&#123;arr[$6]++&#125;END&#123;for(i in arr)&#123;print arr[i], i&#125;&#125;&#x27; </span><br></pre></td></tr></table></figure><ul><li>统计日志中各IP访问非200状态码的次数，结合 sort 和 head 命令显示前十个最多的</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;$8!=200&#123;arr[$1]++&#125;END&#123;for(i in arr)&#123;print arr[i], i&#125;&#x27; access.log | sort -k1nr | head -n 10 </span><br></pre></td></tr></table></figure><ul><li>统计每个 URL 的独立访问 IP 有多少个 (去重)，并且要为每个 URL 保存一个对应的文件：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">BEGIN &#123;</span><br><span class="line">    FS=&quot;|&quot;  # 指定字段分隔符</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">SEPSUB \034 真正保存时以 <span class="variable">$1</span>\034<span class="variable">$2</span> 保存</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果是第一次出现(类似联合主键)</span></span><br><span class="line">    if (!arr[$1, $2]++) &#123;  # awk 中的数组是关联数组, 它的索引全是字符串</span><br><span class="line">    arr1[$1]++ </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">END &#123;</span><br><span class="line">for(i in arr1) &#123;</span><br><span class="line">        print i, arr1[i] &gt; (i&quot;.txt&quot;)</span><br><span class="line">&#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-课后作业"><a href="#6-课后作业" class="headerlink" title="6. 课后作业"></a>6. 课后作业</h2><h3 id="6-1-需求"><a href="#6-1-需求" class="headerlink" title="6.1 需求"></a>6.1 需求</h3><p>使用 awk 编程编写 shell 脚本，需要有函数式、管道式、流水线编程的思想，具体要求如下：</p><ul><li><p>现有 <code>auth.log</code> 日志文件，日志文件格式如下，要求统计登录出错的记录</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Sep 20 06:25:01 iZbp1amwnz2vqj9ehdtgjvZ CRON[6905]: pam_unix(cron:session): session closed for user root</span><br><span class="line">Sep 20 06:35:01 iZbp1amwnz2vqj9ehdtgjvZ CRON[7029]: pam_unix(cron:session): session opened for user root by (uid=0)</span><br><span class="line">Sep 20 06:35:01 iZbp1amwnz2vqj9ehdtgjvZ CRON[7029]: pam_unix(cron:session): session closed for user root</span><br><span class="line">Sep 20 06:45:01 iZbp1amwnz2vqj9ehdtgjvZ CRON[7034]: pam_unix(cron:session): session opened for user root by (uid=0)</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">Sep 26 19:07:15 iZbp1amwnz2vqj9ehdtgjvZ sshd[18760]: error: Could not load host key: /etc/ssh/ssh_host_ed25519_key</span><br><span class="line">Sep 26 19:07:28 iZbp1amwnz2vqj9ehdtgjvZ sshd[18760]: Invalid user administrator from 95.10.179.8 port 28508</span><br><span class="line">Sep 26 19:07:29 iZbp1amwnz2vqj9ehdtgjvZ sshd[18760]: pam_unix(sshd:auth): check pass; user unknown</span><br><span class="line">Sep 26 19:07:29 iZbp1amwnz2vqj9ehdtgjvZ sshd[18760]: pam_unix(sshd:auth): authentication failure; logname= uid=0 euid=0 tty=ssh ruser= rhost=95.10.179.8</span><br><span class="line">Sep 26 19:07:31 iZbp1amwnz2vqj9ehdtgjvZ sshd[18760]: Failed password for invalid user administrator from 95.10.179.8 port 28508 ssh2</span><br><span class="line">Sep 26 19:07:32 iZbp1amwnz2vqj9ehdtgjvZ sshd[18760]: Connection closed by invalid user administrator 95.10.179.8 port 28508 [preauth]</span><br><span class="line">Sep 26 19:15:02 iZbp1amwnz2vqj9ehdtgjvZ CRON[18764]: pam_unix(cron:session): session opened for user root by (uid=0)</span><br><span class="line">Sep 26 19:15:02 iZbp1amwnz2vqj9ehdtgjvZ CRON[18764]: pam_unix(cron:session): session closed for user root</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li><li><p>对上述 log 文件进行分析，然后编写 shell 脚本，使用 awk 编程，先读取日志文件，然后将出错的记录以下面的格式写入<code>/usr/local/log/error.md</code> 文件中</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="section">### 2021-9-26 19:07:15 [18760]</span></span><br><span class="line"><span class="section">#### sshd</span></span><br><span class="line"><span class="strong">**error:**</span> Could not load host key: /etc/ssh/ssh<span class="emphasis">_host_</span>ed25519<span class="emphasis">_key</span></span><br><span class="line"><span class="emphasis"><span class="strong">**pam_unix(sshd:auth):**</span> check pass; user user unknown</span></span><br><span class="line"><span class="emphasis"><span class="strong">**pam_unix(sshd:auth):**</span> authentication failure; logname= uid=0 euid=0 tty=ssh ruser= rhost=95.10.179.8 port 28508</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">Invalid user administrator from 95.10.1</span></span><br><span class="line"><span class="emphasis">Failed password for invalid user administrator from 95.10.179.8 port 28508 ssh2</span></span><br><span class="line"><span class="emphasis">Connection closed by invalid user administrator 95.10.179.8 port 28508 [preauth]</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">### 2021-9-26 19:15:02 [18764]</span></span><br><span class="line"><span class="emphasis">#### CRON</span></span><br><span class="line"><span class="emphasis"><span class="strong">**pam_unix(cron:session):**</span> session opened for user root by (uid=0)</span></span><br><span class="line"><span class="emphasis"><span class="strong">**pam_unix(cron:session):**</span> session closed for user root</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="6-2-实现思路"><a href="#6-2-实现思路" class="headerlink" title="6.2 实现思路"></a>6.2 实现思路</h3><ul><li><strong>准备工作</strong>：<ul><li>定义日志文件路径，确保日志目录存在</li></ul></li><li><strong>处理日志文件</strong>：<ul><li>使用 <code>awk</code> 处理 <code>auth.log</code> 文件，按进程 ID 分类记录错误信息</li><li>在 <code>BEGIN</code> 块中，初始化全局变量、获取当前年份、以及初始化一些变量</li><li>在每一行的处理中，解析进程信息、过滤不需要的行、按照进程 ID 分类记录错误信息</li><li>在 <code>END</code> 块中，处理最后一个进程 ID 的错误信息</li></ul></li><li><strong>输出错误信息</strong>：<ul><li>错误信息会按照进程 ID 分类记录在 <code>/usr/local/log/error.md</code> 文件中</li></ul></li></ul><h3 id="6-3-代码实现"><a href="#6-3-代码实现" class="headerlink" title="6.3 代码实现"></a>6.3 代码实现</h3><ul><li><p><code>count.sh</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">LOG_FILE=<span class="string">&quot;/usr/local/log/error.md&quot;</span>  <span class="comment"># 日志文件名作为常量</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="comment"># 检查日志目录是否存在，不存在则创建</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">mkdir</span> -p <span class="string">&quot;<span class="subst">$(dirname <span class="string">&quot;<span class="variable">$LOG_FILE</span>&quot;</span>)</span>&quot;</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="comment"># 检查日志文件是否存在，存在则清空，不存在则创建</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="keyword">if</span> [ -e <span class="string">&quot;<span class="variable">$LOG_FILE</span>&quot;</span> ]; <span class="keyword">then</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">    <span class="literal">true</span> &gt; <span class="string">&quot;<span class="variable">$LOG_FILE</span>&quot;</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="keyword">else</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">    <span class="built_in">touch</span> <span class="string">&quot;<span class="variable">$LOG_FILE</span>&quot;</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="keyword">fi</span></span></span><br><span class="line"></span><br><span class="line">LOG_FILE=&quot;/usr/local/log/error.md&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">确保日志目录存在，不存在则创建</span></span><br><span class="line">mkdir -p &quot;$(dirname &quot;$LOG_FILE&quot;)&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">清空日志文件，如果不存在则创建</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"><span class="string">&quot;<span class="variable">$LOG_FILE</span>&quot;</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用 awk 处理 auth.log 文件</span></span><br><span class="line">awk -v log_file=&quot;$LOG_FILE&quot; &#x27;</span><br><span class="line">BEGIN &#123;</span><br><span class="line">    # 全局变量的定义</span><br><span class="line">    prev_process_id = &quot;&quot;</span><br><span class="line">    has_colon = 0  # 初始化 has_colon</span><br><span class="line">    </span><br><span class="line">    # 获取系统当前年份</span><br><span class="line">    cmd = &quot;date +%Y&quot;</span><br><span class="line">    cmd | getline year</span><br><span class="line">    close(cmd)</span><br><span class="line"></span><br><span class="line">    # 初始化 error_data 为空字符串</span><br><span class="line">    error_data = &quot;&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    # 获取当前行的进程id号</span><br><span class="line">    parseProcessInfo($5)</span><br><span class="line">    process_name = process_info[1]</span><br><span class="line">    process_id = process_info[2]</span><br><span class="line"></span><br><span class="line">    # 过滤掉不是错误信息的行</span><br><span class="line">    if (process_name ~ /(vsftpd|systemd-logind)/) &#123;</span><br><span class="line">        next</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    # 如果当前行的进程id号不等于上一行的进程id号或上一行的进程号为空</span><br><span class="line">    if (process_id != prev_process_id || prev_process_id == &quot;&quot;) &#123;</span><br><span class="line">        # 打印上一进程号的错误信息</span><br><span class="line">        printErrorData(prev_process_id)</span><br><span class="line">        # 清空数组</span><br><span class="line">        delete error_array</span><br><span class="line"></span><br><span class="line">        if (prev_process_id != &quot;&quot;) &#123;</span><br><span class="line">            print &quot;\n\n&quot; &gt;&gt; log_file</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        # 记录当前的进程id号为 prev_process_id</span><br><span class="line">        prev_process_id = process_id</span><br><span class="line"></span><br><span class="line">        # 获取时间并打印, 同时打印进程id, 格式为 ### 2021-9-26 19:07:15 [process_id]</span><br><span class="line">        formatted_datetime = getFormattedDateTime($1, $2, $3)</span><br><span class="line">        print &quot;###&quot;, formatted_datetime, &quot;[&quot; process_id &quot;]&quot; &gt;&gt; log_file</span><br><span class="line">        print &quot;####&quot;, process_name &gt;&gt; log_file</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    # 解析当前行的错误信息并输出到缓存</span><br><span class="line">    error_data = parseErrorInfo($6)</span><br><span class="line">    for (i = 7; i &lt;= NF; i++) &#123;</span><br><span class="line">        error_data = error_data &quot; &quot; $i</span><br><span class="line">    &#125;</span><br><span class="line">    # 存储到数组</span><br><span class="line">    error_array[has_colon] = error_array[has_colon] error_data &quot;\n&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">END &#123;</span><br><span class="line">    # 打印最后一个进程号的错误信息</span><br><span class="line">    printErrorData(prev_process_id)</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取格式化的日期和时间</span></span><br><span class="line">function getFormattedDateTime(month, day, time) &#123;</span><br><span class="line">    month_number = (index(&quot;JanFebMarAprMayJunJulAugSepOctNovDec&quot;, month) + 2) / 3</span><br><span class="line">    return year&quot;-&quot;month_number&quot;-&quot;day&quot; &quot;time</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取并解析进程名和进程<span class="built_in">id</span></span></span><br><span class="line">function parseProcessInfo(process_data,   arr) &#123;</span><br><span class="line">    split(process_data, arr, &quot;[&quot;)</span><br><span class="line">    if (length(arr) &gt; 1) &#123;</span><br><span class="line">        gsub(&quot;]:&quot;, &quot;&quot;, arr[2])</span><br><span class="line">        process_info[1] = arr[1]</span><br><span class="line">        process_info[2] = arr[2]</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        process_info[1] = process_data</span><br><span class="line">        process_info[2] = &quot;&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">解析错误信息</span></span><br><span class="line">function parseErrorInfo(error_column) &#123;</span><br><span class="line">    has_colon = (substr(error_column, length(error_column), 1) == &quot;:&quot;)</span><br><span class="line">    return has_colon ? &quot;**&quot; error_column &quot;**&quot; : error_column</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打印错误信息</span></span><br><span class="line">function printErrorData(process_id) &#123;</span><br><span class="line">    if (process_id != &quot;&quot;) &#123;</span><br><span class="line">        # 输出标识为1的错误信息</span><br><span class="line">        print error_array[1] &gt;&gt; log_file</span><br><span class="line"></span><br><span class="line">         # 检查是否有标识为0的错误信息</span><br><span class="line">        if (error_array[0] != &quot;&quot;) &#123;</span><br><span class="line">            # 输出空行</span><br><span class="line">            print &quot;&quot; &gt;&gt; log_file</span><br><span class="line">            # 输出标识为0的错误信息</span><br><span class="line">            print error_array[0] &gt;&gt; log_file</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x27; auth.log</span><br></pre></td></tr></table></figure></li><li><p>运行命令如下:</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">给脚本赋予执行权限</span></span><br><span class="line">chmod u+x count.sh</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">运行脚本</span></span><br><span class="line">sudo ./count.sh</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> awk </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis 基础</title>
      <link href="/2023/11/18/Redis%E5%9F%BA%E7%A1%80/"/>
      <url>/2023/11/18/Redis%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis-基础篇"><a href="#Redis-基础篇" class="headerlink" title="Redis 基础篇"></a>Redis 基础篇</h1><blockquote><p>NoSql 数据库</p></blockquote><h2 id="1-入门"><a href="#1-入门" class="headerlink" title="1. 入门"></a>1. 入门</h2><h3 id="1-1-NoSQL"><a href="#1-1-NoSQL" class="headerlink" title="1.1 NoSQL"></a>1.1 NoSQL</h3><blockquote><p>SQL 和 NoSQL</p><p><strong>关系型数据库 和 非关系型数据库</strong></p><p>区别：</p><p><img src="/../img/redis%E5%85%A5%E9%97%A8.assets/1689181370218.png" alt="1689181370218"></p></blockquote><p>（1）<strong>结构化和非结构化</strong></p><ul><li>SQL关系型数据库是结构化数据，每一张表都有严格的约束信息：字段名、字段数据类型、字段约束等等信息，插入的数据必须遵守这些约束</li><li>NoSql对数据库格式没有严格约束，往往形式松散，自由。可以是key-value,可以是文档，或者图格式</li></ul><p>（2）<strong>关联和非关联</strong></p><ul><li><p>关系型：</p><p><img src="/../img/redis%E5%85%A5%E9%97%A8.assets/1689181273477.png" alt="1689181273477"></p></li><li><p>非关系型</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  id<span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">  name<span class="punctuation">:</span> <span class="string">&quot;张三&quot;</span><span class="punctuation">,</span></span><br><span class="line">  orders<span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">       id<span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">       item<span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"> id<span class="punctuation">:</span> <span class="number">10</span><span class="punctuation">,</span> title<span class="punctuation">:</span> <span class="string">&quot;荣耀6&quot;</span><span class="punctuation">,</span> price<span class="punctuation">:</span> <span class="number">4999</span></span><br><span class="line">       <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">       id<span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">       item<span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"> id<span class="punctuation">:</span> <span class="number">20</span><span class="punctuation">,</span> title<span class="punctuation">:</span> <span class="string">&quot;小米11&quot;</span><span class="punctuation">,</span> price<span class="punctuation">:</span> <span class="number">3999</span></span><br><span class="line">      </span><br><span class="line">       <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li></ul><p>（3）<strong>查询方式</strong></p><p><img src="/../img/redis%E5%85%A5%E9%97%A8.assets/1689181323406.png" alt="1689181323406"></p><p>（4）<strong>事务</strong></p><ul><li>传统关系型数据库能满足事务ACID的原则 ，而非关系型数据库往往不支持事务，或者不能严格保证ACID的特性，只能实现基本的一致性。</li></ul><h3 id="1-2-Redis-安装-尚硅谷"><a href="#1-2-Redis-安装-尚硅谷" class="headerlink" title="1.2 Redis 安装-尚硅谷"></a>1.2 Redis 安装-尚硅谷</h3><blockquote><p>此处主要参考尚硅谷的教程：</p><p><a href="https://www.bilibili.com/video/BV13R4y1v7sP?p=10&spm_id_from=pageDriver&vd_source=ce97d263f08af76fc25ff49de530fe92">10_redis安装和坑排除_哔哩哔哩_bilibili</a> </p></blockquote><h4 id="1-2-1-安装"><a href="#1-2-1-安装" class="headerlink" title="1.2.1 安装"></a>1.2.1 安装</h4><ul><li>Redis是基于C编写，所以需要先安装Redis所需的gcc依赖，可以用 <code>gcc -v</code> 进行查看验证</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y gcc </span><br></pre></td></tr></table></figure><p><img src="/../img/redis%E5%85%A5%E9%97%A8.assets/1691222953181.png" alt="1691222953181"></p><ul><li>官网下载链接：<a href="https://redis.io/download/">Download | Redis</a> </li><li>这里我用的 xftp7 上传到虚拟机的 <code>/opt</code> 目录下，在该目录下进行解压缩</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf redis-7.0.12.tar.gz</span><br></pre></td></tr></table></figure><p><img src="/../img/redis%E5%85%A5%E9%97%A8.assets/1695350918966.png" alt="1695350918966"></p><p><img src="/../img/redis%E5%85%A5%E9%97%A8.assets/1695351527333.png" alt="1695351527333"></p><ul><li>进入 <code>/opt/redis-7.0.12</code> 目录下</li></ul><p><img src="/../img/redis%E5%85%A5%E9%97%A8.assets/1695350999649.png" alt="1695350999649"></p><ul><li>执行 make 命令进行编译安装，出现如下即安装成功</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><p><img src="/../img/redis%E5%85%A5%E9%97%A8.assets/1695351328595.png" alt="1695351328595"></p><ul><li>查看默认安装目录：<code>usr/local/bin</code>，其类似于windows系统的 <code>C:\Program Files</code>，因为能帮我们直接配置到 path 里</li></ul><p><img src="/../img/redis%E5%85%A5%E9%97%A8.assets/1695351654713.png" alt="1695351654713"></p><blockquote><p>redis-benchmark：性能测试工具，服务启动后运行该命令，看看自己本子性能如何</p><p>redis-check-aof：修复有问题的 AOF 文件，rdb 和 aof 后面讲</p><p>redis-check-rdb：修复有问题的 dump.rdb 文件</p><p><strong>redis-cli：客户端，操作入口</strong></p><p>redis-sentinel：redis 集群使用</p><p><strong>redis-server：Redis 服务器启动命令</strong></p></blockquote><h4 id="1-2-2-备份并修改配置文件"><a href="#1-2-2-备份并修改配置文件" class="headerlink" title="1.2.2 备份并修改配置文件"></a>1.2.2 备份并修改配置文件</h4><ul><li>在 <code>/opt/redis-7.0.12</code>  目录下，先<strong>备份</strong>以下自带的配置文件到新建的 <code>/myredis</code> 文件夹(<strong>该文件夹在根目录下</strong>)下，不要在原件上改，然后再修改拷贝的 <code>redis7.conf</code> 做初始化设置</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir /myredis</span><br><span class="line">cp redis.conf /myredis/redis7.conf</span><br></pre></td></tr></table></figure><p><img src="/../img/redis%E5%85%A5%E9%97%A8.assets/1695353692381.png" alt="1695353692381"></p><ul><li><p>修改 <code>/myredis</code> 目录下 <code>redis.conf</code> 配置文件做初始化设置，<strong>配置完记得重启</strong>！</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /myredis</span><br><span class="line">vim redis7.conf</span><br></pre></td></tr></table></figure><ul><li>默认 daemonize no 改为 daemonize yes</li></ul><p><img src="/../img/redis%E5%85%A5%E9%97%A8.assets/1695359496997.png" alt="1695359496997"></p><ul><li>默认 protected-mode yes 改为 protected-mode no</li></ul><p><img src="/../img/redis%E5%85%A5%E9%97%A8.assets/1695359731730.png" alt="1695359731730"></p><ul><li>默认 bind 127.0.0.1 改为 直接注释掉(默认的只能访问本机IP)，否则影响远程连接</li></ul><p><img src="/../img/redis%E5%85%A5%E9%97%A8.assets/1695359794655.png" alt="1695359794655"></p><ul><li>添加 redis 密码 改为 requirepass 你自己设置的密码</li></ul><p><img src="/../img/redis%E5%85%A5%E9%97%A8.assets/1695359933541.png" alt="1695359933541"></p><ul><li>最后输入 <code>:wq!</code> 保存并退出</li></ul><blockquote><p>补充：Vim 的一些用法</p><p><img src="/../img/redis%E5%85%A5%E9%97%A8.assets/1695359427097.png" alt="1695359427097"></p></blockquote></li></ul><h4 id="1-2-3-启动并连接服务"><a href="#1-2-3-启动并连接服务" class="headerlink" title="1.2.3 启动并连接服务"></a>1.2.3 启动并连接服务</h4><ul><li><p><strong>启动服务</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis-server /myredis/redis7.conf</span><br><span class="line">ps -ef | grep redis | grep -v grep</span><br></pre></td></tr></table></figure><p><img src="/../img/redis%E5%85%A5%E9%97%A8.assets/1695360200129.png" alt="1695360200129"></p><blockquote><p>端口 6379 被占用，说明后台启动成功</p><p>ps 用于查看进程</p></blockquote></li><li><p><strong>连接服务</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -a thr -p 6379</span><br><span class="line">ps -ef | grep redis | grep -v grep</span><br></pre></td></tr></table></figure><p><img src="/../img/redis%E5%85%A5%E9%97%A8.assets/1695360294356.png" alt="1695360294356"></p><p><img src="/../img/redis%E5%85%A5%E9%97%A8.assets/1695360393425.png" alt="1695360393425"></p><blockquote><p>在 127.0.0.1:6370 窗口下，执行 <code>ping</code>，若结果为 <code>pong</code> 则表示连接成功</p><p><img src="/../img/redis%E5%85%A5%E9%97%A8.assets/1695360472722.png" alt="1695360472722"></p><p><img src="/../img/redis%E5%85%A5%E9%97%A8.assets/1695360521774.png" alt="1695360521774"></p></blockquote></li><li><p><strong>补充</strong></p><ul><li><p>退出连接：<code>quit</code></p><p><img src="/../img/redis%E5%85%A5%E9%97%A8.assets/1695360614134.png" alt="1695360614134"></p></li><li><p>若连接时不想看见警告，可用：<code>redis-cli -a thr -p 6379 2&gt;/dev/nul</code></p><blockquote><p>该操作是将警告重定向至linux的黑洞文件</p></blockquote></li><li><p>若想开机自启，则跳转到 1.3.3</p></li></ul></li></ul><h4 id="1-2-4-测试-hello-world"><a href="#1-2-4-测试-hello-world" class="headerlink" title="1.2.4 测试 hello world"></a>1.2.4 测试 hello world</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set k1 helloworld</span><br><span class="line">get k1</span><br></pre></td></tr></table></figure><p><img src="/../img/redis%E5%85%A5%E9%97%A8.assets/1695361038813.png" alt="1695361038813"></p><h4 id="1-2-5-关闭-redis"><a href="#1-2-5-关闭-redis" class="headerlink" title="1.2.5 关闭 redis"></a>1.2.5 关闭 redis</h4><ul><li>如果已经在 redis 服务器里，就直接用 <code>shutdown</code> 即可，可用 <code>lsof -i:6379</code> 验证</li></ul><p><img src="/../img/redis%E5%85%A5%E9%97%A8.assets/1695361220609.png" alt="1695361220609"></p><p><img src="/../img/redis%E5%85%A5%E9%97%A8.assets/1695361266946.png" alt="1695361266946"></p><ul><li><strong>单实例关闭</strong></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -a thr shutdown</span><br></pre></td></tr></table></figure><p><img src="/../img/redis%E5%85%A5%E9%97%A8.assets/1695361371095.png" alt="1695361371095"></p><ul><li><strong>多实例关闭</strong>，指定端口关闭</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -p 6379 shutdown</span><br></pre></td></tr></table></figure><h4 id="1-2-6-卸载-redis"><a href="#1-2-6-卸载-redis" class="headerlink" title="1.2.6 卸载 redis"></a>1.2.6 卸载 redis</h4><ul><li>先停止 redis-server 服务</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -a thr shutdown</span><br></pre></td></tr></table></figure><ul><li>删除 &#x2F;usr&#x2F;local&#x2F;lib 目录下与 redis 相关的文件</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ls -l /usr/local/bin/redis-*</span><br><span class="line">rm -rf /usr/local/bin/redis-*</span><br></pre></td></tr></table></figure><h3 id="1-3-Redis-安装启动-黑马"><a href="#1-3-Redis-安装启动-黑马" class="headerlink" title="1.3 Redis 安装启动-黑马"></a>1.3 Redis 安装启动-黑马</h3><blockquote><p><a href="https://www.bilibili.com/video/BV1cr4y1671t?p=5&vd_source=ce97d263f08af76fc25ff49de530fe92">基础篇-04.初识Redis-安装Redis及启动的三种方式_哔哩哔哩_bilibili</a> </p></blockquote><blockquote><p>redis的启动方式有很多种，例如：</p><ul><li>默认启动</li><li>指定配置启动</li><li>开机自启</li></ul></blockquote><h4 id="1-3-1-默认启动"><a href="#1-3-1-默认启动" class="headerlink" title="1.3.1 默认启动"></a>1.3.1 默认启动</h4><ul><li>安装完成后，在任意目录输入 <code>redis-server</code> 命令即可启动 Redis：</li></ul><p><img src="/../img/redis%E5%85%A5%E9%97%A8.assets/1695362425115.png" alt="1695362425115"></p><ul><li>这种启动属于<strong>前台启动</strong>，会阻塞整个会话窗口，需要重开一个窗口才可以进行连接，窗口关闭或者按下 <code>CTRL + C</code> 则Redis停止，<strong>不推荐</strong>使用。</li></ul><h4 id="1-3-2-指定配置启动"><a href="#1-3-2-指定配置启动" class="headerlink" title="1.3.2 指定配置启动"></a>1.3.2 指定配置启动</h4><ul><li>如果要让Redis以<strong>后台</strong>方式启动，则必须修改Redis配置文件，就在我们之前解压的redis安装包下，叫redis.conf</li><li>先备份：<code>cp redis.conf redis.conf.bck</code></li></ul><p><img src="/../img/redis%E5%85%A5%E9%97%A8.assets/1695363322243.png" alt="1695363322243"></p><ul><li>然后修改redis.conf文件中的一些配置：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">允许访问的地址，默认是127.0.0.1，会导致只能在本地访问。修改为0.0.0.0则可以在任意IP访问，生产环境不要设置为0.0.0.0</span></span><br><span class="line">bind 0.0.0.0</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">守护进程，修改为<span class="built_in">yes</span>后即可后台运行</span></span><br><span class="line">daemonize yes </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">密码，设置后访问Redis必须输入密码</span></span><br><span class="line">requirepass thr</span><br></pre></td></tr></table></figure><ul><li>Redis的其它常见配置：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">监听的端口</span></span><br><span class="line">port 6379</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">工作目录，默认是当前目录，也就是运行redis-server时的命令，日志、持久化等文件会保存在这个目录</span></span><br><span class="line">dir .</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">数据库数量，设置为1，代表只使用1个库，默认有16个库，编号0~15</span></span><br><span class="line">databases 1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置redis能够使用的最大内存</span></span><br><span class="line">maxmemory 512mb</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">日志文件，默认为空，不记录日志，可以指定日志文件名</span></span><br><span class="line">logfile &quot;redis.log&quot;</span><br></pre></td></tr></table></figure><ul><li>启动Redis：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入redis安装目录</span> </span><br><span class="line">cd /usr/local/src/redis-6.2.6</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动</span></span><br><span class="line">redis-server redis.conf</span><br></pre></td></tr></table></figure><ul><li>停止服务：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">利用redis-cli来执行 shutdown 命令，即可停止 Redis 服务，</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">因为之前配置了密码，因此需要通过 -u 来指定密码</span></span><br><span class="line">redis-cli -u 123321 shutdown</span><br></pre></td></tr></table></figure><h4 id="1-3-3-开机自启"><a href="#1-3-3-开机自启" class="headerlink" title="1.3.3 开机自启"></a>1.3.3 开机自启</h4><blockquote><p>这个地方需要跟着做一下</p></blockquote><ul><li>首先，新建一个系统服务文件：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/systemd/system/redis.service</span><br></pre></td></tr></table></figure><ul><li>内容如下：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=redis-server</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=forking</span><br><span class="line">ExecStart=/usr/local/bin/redis-server /usr/local/src/redis-6.2.6/redis.conf</span><br><span class="line">PrivateTmp=true</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><blockquote><p>重点在这一行，<code>ExecStart=/usr/local/bin/redis-server /usr/local/src/redis-6.2.6/redis.conf</code></p><p>前者是安装目录不变，后者需改成配置文件所在位置(由于我是根据尚硅谷的教程做的，所以配置文件所在位置为 <code>/myredis/redis7.conf</code>)</p><p><img src="/../img/redis%E5%85%A5%E9%97%A8.assets/1695363918452.png" alt="1695363918452"></p></blockquote><ul><li>然后重载系统服务：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload</span><br></pre></td></tr></table></figure><ul><li>现在，我们可以用下面这组命令来操作redis了：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动</span></span><br><span class="line">systemctl start redis</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">停止</span></span><br><span class="line">systemctl stop redis</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重启</span></span><br><span class="line">systemctl restart redis</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看状态</span></span><br><span class="line">systemctl status redis</span><br></pre></td></tr></table></figure><p><img src="/../img/redis%E5%85%A5%E9%97%A8.assets/1695364136785.png" alt="1695364136785"></p><ul><li>执行下面的命令，可以让redis开机自启：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable redis</span><br></pre></td></tr></table></figure><blockquote><p>可以通过 <code>ps -ef | grep redis | grep -v grep</code> 查看是否开启 redis</p><p><img src="/../img/redis%E5%85%A5%E9%97%A8.assets/1695364274819.png" alt="1695364274819"></p></blockquote><h3 id="1-4-Redis-客户端"><a href="#1-4-Redis-客户端" class="headerlink" title="1.4 Redis 客户端"></a>1.4 Redis 客户端</h3><blockquote><p>安装完成Redis，我们就可以操作Redis，实现数据的CRUD了。这需要用到Redis客户端，包括：</p><ul><li>命令行客户端</li><li>图形化桌面客户端</li><li>编程客户端</li></ul></blockquote><h4 id="1-4-1-命令行客户端"><a href="#1-4-1-命令行客户端" class="headerlink" title="1.4.1 命令行客户端"></a>1.4.1 命令行客户端</h4><blockquote><p>这个在 1.2.3 有详细图解</p></blockquote><ul><li>Redis安装完成后就自带了命令行客户端：<code>redis-cli</code>，使用方式如下：</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli [options] [commonds]</span><br></pre></td></tr></table></figure><ul><li>其中常见的options有：<ul><li><code>-h 127.0.0.1</code>：指定要连接的redis节点的IP地址，默认是127.0.0.1</li><li><code>-p 6379</code>：指定要连接的redis节点的端口，默认是6379</li><li><code>-a 123321</code>：指定redis的访问密码</li></ul></li><li>其中的commonds就是Redis的操作命令，例如：<ul><li><code>ping</code>：与redis服务端做心跳测试，服务端正常会返回<code>pong</code></li><li>不指定commond时，会进入<code>redis-cli</code>的交互控制台：</li></ul></li></ul><h4 id="1-4-2-图形化桌面客户端"><a href="#1-4-2-图形化桌面客户端" class="headerlink" title="1.4.2 图形化桌面客户端"></a>1.4.2 图形化桌面客户端</h4><ul><li><p>GitHub上的大神编写了Redis的图形化桌面客户端，地址：</p><p><a href="https://github.com/uglide/RedisDesktopManager">https://github.com/uglide/RedisDesktopManager</a></p><ul><li><p>不过该仓库提供的是RedisDesktopManager的源码，并未提供windows安装包</p></li><li><p>在下面这个仓库可以找到安装包：</p><p><a href="https://github.com/lework/RedisDesktopManager-Windows/releases">https://github.com/lework/RedisDesktopManager-Windows/releases</a></p></li></ul></li></ul><p><img src="/../img/redis%E5%85%A5%E9%97%A8.assets/1695364974771.png" alt="1695364974771"></p><ul><li>下载安装即可，然后点击连接 redis 服务器</li></ul><p><img src="/../img/redis%E5%85%A5%E9%97%A8.assets/1695365387638.png" alt="1695365346988"></p><ul><li>连不上，尝试<strong>关闭防火墙</strong>后成功连接</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">systemctl status firewalld  # 查看防火墙状态</span><br><span class="line">systemctl stop firewalld  # 关闭防火墙</span><br><span class="line">systemctl start firewalld  # 启动防火墙</span><br><span class="line">systemctl restart firewalld  # 重启防火墙（先停止，再启动） </span><br></pre></td></tr></table></figure><p><img src="/../img/redis%E5%85%A5%E9%97%A8.assets/1695366089558.png" alt="1695366089558"></p><p><img src="/../img/redis%E5%85%A5%E9%97%A8.assets/1695366106875.png" alt="1695366106875"></p><blockquote><p>一共有0-15共16个库</p></blockquote><h4 id="1-4-3-测试一下"><a href="#1-4-3-测试一下" class="headerlink" title="1.4.3 测试一下"></a>1.4.3 测试一下</h4><ul><li>命令行客户端</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -a thr  # 先进入命令行客户端</span><br><span class="line">set name thr  # 添加一个键值对(默认添加在0号库)</span><br><span class="line">set age 20  # 再添加一个键值对</span><br><span class="line">select 0  # 进入0号库</span><br><span class="line">get name  # 获取键为 name 的值</span><br></pre></td></tr></table></figure><p><img src="/../img/redis%E5%85%A5%E9%97%A8.assets/1695366260657.png" alt="1695366260657"></p><ul><li><p>图形化客户端</p><ul><li>可以看到刚刚添加的数据</li></ul><p><img src="/../img/redis%E5%85%A5%E9%97%A8.assets/1695366449724.png" alt="1695366449724"></p><ul><li>手动在图形化界面也可添加</li></ul><p><img src="/../img/redis%E5%85%A5%E9%97%A8.assets/1695366506729.png" alt="1695366506729"></p><ul><li>同时在命令行中也可以查到</li></ul><p><img src="/../img/redis%E5%85%A5%E9%97%A8.assets/1695366538405.png" alt="1695366538405"></p></li></ul><h2 id="2-Redis-常见命令"><a href="#2-Redis-常见命令" class="headerlink" title="2. Redis 常见命令"></a>2. Redis 常见命令</h2><blockquote><p>官方文档里的常见命令：<a href="https://redis.io/commands/">Commands | Redis</a> ，可以分组查找相关的命令</p><p>也可在命令行里用 <code>help @xxx</code> 进行查找，如，<code>help @string</code></p></blockquote><h3 id="2-1-Redis-数据结构介绍"><a href="#2-1-Redis-数据结构介绍" class="headerlink" title="2.1 Redis 数据结构介绍"></a>2.1 Redis 数据结构介绍</h3><ul><li>Redis 是 <strong>key-value键值对</strong> 的数据库，一般 key 是 String，不过value 数据结构是多种多样的，下面的前五种是比较常见的数据结构：</li></ul><p><img src="/../img/redis%E5%85%A5%E9%97%A8.assets/1695367282765.png" alt="1695367173429"></p><h3 id="2-2-Redis-通用命令"><a href="#2-2-Redis-通用命令" class="headerlink" title="2.2 Redis 通用命令"></a>2.2 Redis 通用命令</h3><blockquote><p>在命令行中可以用 <code>help @generic</code> 查询</p><p>通过 <code>help [command]</code> 也可以查看一个命令的具体用法</p><p>官方文档上还会有使用案例：</p><p><img src="/../img/redis%E5%85%A5%E9%97%A8.assets/1695368153849.png" alt="1695368153849"></p></blockquote><p>通用命令是<strong>每种数据类型都可以使用的命令</strong>，常见的有： </p><ul><li><p><strong>keys</strong>：查看符合模板的所有key， 类似模糊查询，效率不高，<strong>不建议生产环境设备上使用</strong> </p><ul><li><code>*</code> 代表 0-多个任意字符 </li><li><code>?</code> 代表一个任意字符</li></ul><p><img src="/../img/redis%E5%85%A5%E9%97%A8.assets/1695367936260.png" alt="1695367936260"></p><p><img src="/../img/redis%E5%85%A5%E9%97%A8.assets/1695368303501.png" alt="1695368236909"></p></li><li><p><strong>del</strong>：删除一个指定的key，可以传多个参数代表删多个key</p><p><img src="/../img/redis%E5%85%A5%E9%97%A8.assets/1695368385111.png" alt="1695368385111"></p><p><img src="/../img/redis%E5%85%A5%E9%97%A8.assets/1695368589510.png" alt="1695368444527"></p></li><li><p><strong>exists</strong>：判断key是否存在</p><p><img src="/../img/redis%E5%85%A5%E9%97%A8.assets/1695368617917.png" alt="1695368617917"></p><p><img src="/../img/redis%E5%85%A5%E9%97%A8.assets/1695368667406.png" alt="1695368667406"></p></li><li><p><strong>expire</strong>：给一个key设置有效期，有效期到期时该key会被自动删除，单位秒，可以节省内存空间，经常配合 <code>ttl</code> 使用</p><blockquote><p>因为 redis 是基于内存存储的，不及时清理的话内存可能会占满，业务中比如：短信验证码保留五分钟</p></blockquote><p><img src="/../img/redis%E5%85%A5%E9%97%A8.assets/1695368891911.png" alt="1695368891911"></p><p><img src="/../img/redis%E5%85%A5%E9%97%A8.assets/1695368950225.png" alt="1695368950225"></p></li><li><p><strong>ttl</strong>：查看一个key的剩余有效期 <code>ttl key</code> </p><ul><li>返回结果：<code>-2</code> 代表过期或者没有该key，<code>-1</code> 代表有效期永久</li></ul><p><img src="/../img/redis%E5%85%A5%E9%97%A8.assets/1695369025613.png" alt="1695369025613"></p></li></ul><h3 id="2-3-String-类型"><a href="#2-3-String-类型" class="headerlink" title="2.3 String 类型"></a>2.3 String 类型</h3><h4 id="2-3-1-基本介绍"><a href="#2-3-1-基本介绍" class="headerlink" title="2.3.1 基本介绍"></a>2.3.1 基本介绍</h4><ul><li>String 类型，也是字符串类型，是Redis中最简单的存储类型。其 value 是字符串，不过根据<strong>字符串的格式不同，又可以分为3类：</strong><ul><li>String：<strong>普通字符串</strong></li><li>int：<strong>整数类型</strong>，可以做自增、自减操作</li><li>float：<strong>浮点类型</strong>，可以做自增、自减操作</li></ul></li></ul><p><img src="/../img/redis%E5%85%A5%E9%97%A8.assets/1695369173059.png" alt="1695369173059"></p><blockquote><p>不管是哪种格式，底层都是<strong>字节数组形式</strong>存储，只不过是编码方式不同。字符串类型的最大空间不能超过521m</p></blockquote><h4 id="2-3-2-常见命令"><a href="#2-3-2-常见命令" class="headerlink" title="2.3.2 常见命令"></a>2.3.2 常见命令</h4><ul><li><strong>set</strong>：添加或者修改已存在的一个 String 类型的键值对</li><li><strong>get</strong>：根据 key 获取 String 类型的 value</li><li><strong>mset</strong>：批量添加多个 String 类型的键值对</li><li><strong>mget</strong>：根据多个 key 获取多个 String 类型的 value</li></ul><p><img src="/../img/redis%E5%85%A5%E9%97%A8.assets/1695369505279.png" alt="1695369505279"></p><ul><li><p><strong>incr</strong>：让一个整型的 key 自增1</p></li><li><p><strong>incrby</strong>：让一个整型的 key 自增并指定步长，例如 <code>incrby num 2</code>， 让num值自增2</p></li><li><p><strong>incrbyfloat</strong>：让一个浮点类型的数字自增并指定步长</p></li></ul><p><img src="/../img/redis%E5%85%A5%E9%97%A8.assets/1695370044430.png" alt="1695369907767"></p><ul><li><p><strong>setnx</strong>：添加一个 String 类型的键值对，前提是 key 不存在，否则不执行（也就是只有新增效果）</p><blockquote><p>跟 <code>set xxx xxx nx</code> 效果一样，如 <code>set name thr nx</code></p></blockquote></li><li><p><strong>setex</strong>：添加一个 String 类型的键值对，并指定有效期</p></li></ul><p><img src="/../img/redis%E5%85%A5%E9%97%A8.assets/1695370447619.png" alt="1695370447619"></p><h3 id="补充：Key-的层级格式"><a href="#补充：Key-的层级格式" class="headerlink" title="补充：Key 的层级格式"></a>补充：Key 的层级格式</h3><p>Q：Redis没有类似MySQL中Table的概念，我们该如何<strong>区分不同类型的key</strong> 呢？</p><ul><li>例如，需要存储用户、商品信息到redis，有一个用户id是1，有一个商品id恰好也是1</li></ul><p><img src="/../img/redis%E5%85%A5%E9%97%A8.assets/1695370678474.png" alt="1695370678474"></p><ul><li>测试一下：</li></ul><p><img src="/../img/redis%E5%85%A5%E9%97%A8.assets/1695371135855.png" alt="1695371135855"></p><p><img src="/../img/redis%E5%85%A5%E9%97%A8.assets/1695371180765.png" alt="1695371180765"></p><p>###2.4 Hash 类型</p><h4 id="2-4-1-基本介绍"><a href="#2-4-1-基本介绍" class="headerlink" title="2.4.1 基本介绍"></a>2.4.1 基本介绍</h4><ul><li><p>Hash 类型，也叫<strong>散列</strong>，其 value 是一个<strong>无序字典</strong>，类似于Java中的 HashMap 结构</p></li><li><p>String 结构是将对象<strong>序列化为JSON字符串后存储，当需要修改对象某个字段时很不方便</strong>：</p><p><img src="/../img/redis%E5%85%A5%E9%97%A8.assets/1695371633662.png" alt="1695371633662"></p></li><li><p>Hash结构可以将对象中的每个字段独立存储，可以<strong>针对单个字段做CRUD</strong>： </p><p><img src="/../img/redis%E5%85%A5%E9%97%A8.assets/1695371659931.png" alt="1695371659931"></p></li></ul><h4 id="2-4-2-常见命令"><a href="#2-4-2-常见命令" class="headerlink" title="2.4.2 常见命令"></a>2.4.2 常见命令</h4><ul><li><strong>HSET key field value</strong>：添加或者修改 hash 类型 key 的 field 的值</li><li><strong>HGET key field</strong>：获取一个 hash 类型 key 的 field 的值</li><li><strong>HMSET</strong>：批量添加多个 hash 类型 key 的 field 的值</li><li><strong>HMGET</strong>：批量获取多个 hash 类型 key 的 field 的值</li></ul><p><img src="/../img/redis%E5%85%A5%E9%97%A8.assets/1695372680274.png" alt="1695372680274"></p><p><img src="/../img/redis%E5%85%A5%E9%97%A8.assets/1695372409033.png" alt="1695372409033"></p><ul><li><p><strong>HGETALL</strong>：获取一个 hash 类型的 key 中的所有的 field 和value</p></li><li><p><strong>HKEYS</strong>：获取一个 hash 类型的 key 中的所有的 field</p></li><li><p><strong>HVALS</strong>：获取一个hash类型key中所有的value 就像Java中values</p></li></ul><p><img src="/../img/redis%E5%85%A5%E9%97%A8.assets/1695372816971.png" alt="1695372816971"></p><ul><li><strong>HINCRBY</strong>：让一个 hash 类型 key 的字段值自增并指定步长</li></ul><p><img src="/../img/redis%E5%85%A5%E9%97%A8.assets/1695372938291.png" alt="1695372938291"></p><ul><li><strong>HSETNX</strong>：<strong>添加</strong>一个 hash 类型的 key 的 field 值，<strong>前提是这个 field 不存在</strong>，否则不执行</li></ul><p><img src="/../img/redis%E5%85%A5%E9%97%A8.assets/1695373016912.png" alt="1695373016912"></p><h3 id="2-5-List-类型"><a href="#2-5-List-类型" class="headerlink" title="2.5 List 类型"></a>2.5 List 类型</h3><h4 id="2-5-1-基本介绍"><a href="#2-5-1-基本介绍" class="headerlink" title="2.5.1 基本介绍"></a>2.5.1 基本介绍</h4><ul><li>List 类型<strong>与 Java 中的 LinkedList类似</strong>，可以看做是一个<strong>双向链表</strong>结构，既<strong>可以支持正向检索和也可以支持反向检索</strong></li><li>特征也与 LinkedList 类似：<ul><li>有序</li><li>元素可以重复</li><li>插入和删除快</li><li>查询速度一般</li></ul></li><li>常用来存储一个有序数据，例如：<strong>朋友圈点赞列表，评论列表</strong>等</li></ul><p><img src="/../img/redis%E5%85%A5%E9%97%A8.assets/1695373325551.png" alt="1695373325551"></p><h4 id="2-5-2-常见命令"><a href="#2-5-2-常见命令" class="headerlink" title="2.5.2 常见命令"></a>2.5.2 常见命令</h4><ul><li><strong>LPUSH key element …</strong> ：向列表左侧插入一个或多个元素</li><li><strong>LPOP key</strong>：移除并返回列表左侧的第一个元素，没有则返回nil</li><li><strong>RPUSH key element …</strong> ：向列表右侧插入一个或多个元素</li><li><strong>RPOP key</strong>：移除并返回列表右侧的第一个元素</li><li><strong>LRANGE key star end</strong>：返回一段角标范围内的所有元素</li><li><strong>BLPOP和BRPOP</strong>：与LPOP和RPOP类似，只不过<strong>在没有元素时等待指定时间，而不是直接返回nil</strong></li></ul><p><img src="/../img/redis%E5%85%A5%E9%97%A8.assets/1695377415136.png" alt="1695377415136"></p><p><img src="/../img/redis%E5%85%A5%E9%97%A8.assets/1695377137688.png" alt="1695377137688"></p><h4 id="2-5-3-思考题"><a href="#2-5-3-思考题" class="headerlink" title="2.5.3 思考题"></a>2.5.3 思考题</h4><ul><li>如何利用List结构模拟一个栈？ <ul><li>入口和出口在同一边</li></ul></li><li>如何利用List结构模拟一个队列？ <ul><li>入口和出口在不同边</li></ul></li><li>如何利用List结构模拟一个阻塞队列？ <ul><li>入口和出口在不同边</li><li>出队时采用BLPOP或BRPOP</li></ul></li></ul><h3 id="2-6-Set-类型"><a href="#2-6-Set-类型" class="headerlink" title="2.6 Set 类型"></a>2.6 Set 类型</h3><h4 id="2-6-1-基本介绍"><a href="#2-6-1-基本介绍" class="headerlink" title="2.6.1 基本介绍"></a>2.6.1 基本介绍</h4><ul><li>Set 结构<strong>与 Java 中的 HashSet 类似</strong>，可以看做是一个value为 null 的HashMap</li><li>因为也是一个hash表，因此具备与HashSet类似的特征：<ul><li>无序</li><li>元素不可重复</li><li><strong>查找快</strong></li><li>支持交集、并集、差集等功能</li></ul></li><li>应用场景：<strong>共同好友</strong></li></ul><h4 id="2-6-2-常见命令"><a href="#2-6-2-常见命令" class="headerlink" title="2.6.2 常见命令"></a>2.6.2 常见命令</h4><ul><li><strong>SADD key member …</strong> ：向set中添加一个或多个元素</li><li><strong>SREM key member …</strong> ：移除set中的指定元素</li><li><strong>SCARD key</strong>： 返回set中元素的个数</li><li><strong>SISMEMBER key member</strong>：判断一个元素是否存在于set中</li><li><strong>SMEMBERS</strong>：获取set中的所有元素</li></ul><p><img src="/../img/redis%E5%85%A5%E9%97%A8.assets/1695377849941.png" alt="1695377849941"></p><p><img src="/../img/redis%E5%85%A5%E9%97%A8.assets/1695377780836.png" alt="1695377780836"></p><ul><li><strong>SINTER key1 key2 …</strong> ：求key1与key2的交集</li><li><strong>SDIFF key1 key2……</strong>：求key1与key2的差集</li><li><strong>SUNION key1 key2…</strong>：求key1和key2并集和</li></ul><p><img src="/../img/redis%E5%85%A5%E9%97%A8.assets/1695377948875.png" alt="1695377948875"></p><h4 id="2-6-3-Set-命令的练习"><a href="#2-6-3-Set-命令的练习" class="headerlink" title="2.6.3 Set 命令的练习"></a>2.6.3 Set 命令的练习</h4><ul><li>用 set 集合存储下列数据：</li></ul><p><img src="/../img/redis%E5%85%A5%E9%97%A8.assets/1695378167332.png" alt="1695378012736"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sadd zs ls wangwu zhaoliu</span><br><span class="line">sadd ls wangwu mazi ergou</span><br></pre></td></tr></table></figure><ul><li>用 set 命令实现下列功能</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">scard zs  # 计算张三的好友有几人</span><br><span class="line">sinter zs ls  # 计算张三和李四有哪些共同好友</span><br><span class="line">sdiff zs ls  # 查询哪些是张三但不是李四的好友</span><br><span class="line">sunion zs ls  # 查询张三和李四的好友总共有哪些人</span><br><span class="line">sismember zs ls  # 判断李四是否是张三的好友</span><br><span class="line">sismember ls zs  # 判断张三是否是李四的好友 </span><br><span class="line">srem zs ls  # 将李四从张三的好友里移除</span><br></pre></td></tr></table></figure><h3 id="2-7-SortedSet-类型"><a href="#2-7-SortedSet-类型" class="headerlink" title="2.7 SortedSet 类型"></a>2.7 SortedSet 类型</h3><h4 id="2-7-1-基本介绍"><a href="#2-7-1-基本介绍" class="headerlink" title="2.7.1 基本介绍"></a>2.7.1 基本介绍</h4><ul><li>SortedSet 是一个可排序的 set 集合，<strong>与 Java 中的TreeSet有些类似</strong>，但底层数据结构却差别很大</li><li>SortedSet中的每一个元素都带有一个score属性，可以基于score属性对元素排序，<strong>底层的实现是一个跳表（SkipList）加 hash 表</strong><ul><li>可排序</li><li>元素不重复</li><li><strong>查询速度快</strong>(因为有哈希表)</li></ul></li><li>因为 SortedSet 的可排序特性，经常被用来实现<strong>排行榜</strong>这样的功能</li></ul><h4 id="2-7-2-常见命令"><a href="#2-7-2-常见命令" class="headerlink" title="2.7.2 常见命令"></a>2.7.2 常见命令</h4><ul><li><strong>ZADD key score member</strong>：添加一个或多个元素到sorted set ，如果已经存在则更新其score值</li><li><strong>ZREM key member</strong>：删除sorted set中的一个指定元素</li><li><strong>ZSCORE key member</strong>：获取sorted set中的指定元素的score值</li><li><strong>ZRANK key member</strong>：获取sorted set 中的指定元素的排名</li><li><strong>ZCARD key</strong>：获取sorted set中的元素个数</li><li><strong>ZCOUNT key min max</strong>：统计score值在给定范围内的所有元素的个数</li><li><strong>ZINCRBY key increment member</strong>：让sorted set中的指定元素自增，步长为指定的increment值</li><li><strong>ZRANGE key min max</strong>：按照score排序后，获取指定排名范围内的元素</li><li><strong>ZRANGEBYSCORE key min max</strong>：按照score排序后，获取指定score范围内的元素</li><li><strong>ZDIFF、ZINTER、ZUNION</strong>：求差集、交集、并集</li></ul><p>注意：所有的排名默认都是升序，如果要降序则在命令的Z后面添加REV即可，例如：</p><ul><li><strong>升序</strong>获取sorted set 中的指定元素的排名：<code>ZRANK key member</code></li><li><strong>降序</strong>获取sorted set 中的指定元素的排名：<code>ZREVRANK key memeber</code></li></ul><h4 id="2-7-3-SortedSet-命令的练习"><a href="#2-7-3-SortedSet-命令的练习" class="headerlink" title="2.7.3 SortedSet 命令的练习"></a>2.7.3 SortedSet 命令的练习</h4><ul><li>将下列学生得分存入 redis 的 SortedSet 中：</li></ul><p><img src="/../img/redis%E5%85%A5%E9%97%A8.assets/1695379109599.png" alt="1695379109599"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zadd stus 85 jack 89 Lucy 82 Rose 95 Tom 78 Jerry 92 Amy 76 Miles</span><br></pre></td></tr></table></figure><p><img src="/../img/redis%E5%85%A5%E9%97%A8.assets/1695379258090.png" alt="1695379258090"></p><ul><li>并实现下列功能：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">zrem stus Tom  # 删除 Tom 同学</span><br><span class="line">zscore stus Amy  # 获取 Amy 同学的分数</span><br><span class="line">zrank stus Rose  # 获取 Rose 同学的排名(排名从0开始算)</span><br><span class="line">zcount stus 0 80  # 查询 80 分以下的同学的个数(查数量)</span><br><span class="line">zincrby stus 2 Amy  # 给 Amy 同学加2分</span><br><span class="line">zrevrange stus 0 2  # 查出成绩前三名的同学(注意是倒序查)</span><br><span class="line">zrangebyscore stus 0 80  # 查出成绩 80 分以下的所有同学(查具体的元素)</span><br></pre></td></tr></table></figure><h2 id="3-Redis-的-Java-客户端"><a href="#3-Redis-的-Java-客户端" class="headerlink" title="3. Redis 的 Java 客户端"></a>3. Redis 的 Java 客户端</h2><blockquote><p>在Redis官网中提供了各种语言的客户端，地址：</p><p><a href="https://redis.io/clients/">Get started using Redis clients | Redis</a> </p><p>其推荐 Java 使用的有：<a href="https://redis.io/docs/clients/java/">Java guide | Redis</a> </p></blockquote><h3 id="3-1-客户端对比"><a href="#3-1-客户端对比" class="headerlink" title="3.1 客户端对比"></a>3.1 客户端对比</h3><p><img src="/../img/redis%E5%85%A5%E9%97%A8.assets/1695380417163.png" alt="1695380417163"></p><h3 id="3-2-Jedis"><a href="#3-2-Jedis" class="headerlink" title="3.2 Jedis"></a>3.2 Jedis</h3><blockquote><p>Jedis 的官网地址：<a href="https://github.com/redis/jedis">https://github.com/redis/jedis</a></p></blockquote><h4 id="3-2-1-快速入门"><a href="#3-2-1-快速入门" class="headerlink" title="3.2.1 快速入门"></a>3.2.1 快速入门</h4><ul><li><strong>先新建一个 maven 工程</strong></li></ul><p><img src="/../img/redis%E5%85%A5%E9%97%A8.assets/1695441717499.png" alt="1695441717499"></p><p><img src="/../img/redis%E5%85%A5%E9%97%A8.assets/1695381155370.png" alt="1695381155370"></p><ul><li><strong>引入依赖</strong></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- jedis --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.8.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 单元测试 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.jupiter<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-jupiter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.7.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="/../img/redis%E5%85%A5%E9%97%A8.assets/1695381242709.png" alt="1695381242709"></p><ul><li><strong>建立连接</strong></li></ul><blockquote><p>在 test 包下新建一个类，JedisTest</p><p><img src="/../img/redis%E5%85%A5%E9%97%A8.assets/1695382494024.png" alt="1695382494024"></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Jedis jedis;</span><br><span class="line"></span><br><span class="line"><span class="meta">@BeforeEach</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">setUp</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 1. 建立连接, 注意改成自己虚拟机的ip地址</span></span><br><span class="line">    jedis = <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;192.168.3.185&quot;</span>,<span class="number">6379</span>);</span><br><span class="line">    <span class="comment">// 2. 设置密码</span></span><br><span class="line">    jedis.auth(<span class="string">&quot;thr&quot;</span>);</span><br><span class="line">    <span class="comment">// 3. 选择库</span></span><br><span class="line">    jedis.select(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>测试</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试 string</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testString</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 插入数据，方法名就是 redis 的命令名称</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> jedis.set(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;小明&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;result= &quot;</span> + result);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取数据(快捷方式.var)</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> jedis.get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;name= &quot;</span> + name);  <span class="comment">// 快捷键 soutv</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试 hash</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testHash</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 插入 hash 数据</span></span><br><span class="line">    jedis.hset(<span class="string">&quot;user:1&quot;</span>, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;Jack&quot;</span>);</span><br><span class="line">    jedis.hset(<span class="string">&quot;user:1&quot;</span>, <span class="string">&quot;age&quot;</span>, <span class="string">&quot;21&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取数据</span></span><br><span class="line">    Map&lt;String, String&gt; map = jedis.hgetAll(<span class="string">&quot;user:1&quot;</span>);</span><br><span class="line">    System.out.println(map);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>释放资源</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AfterEach</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">tearDown</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">    <span class="keyword">if</span>(jedis != <span class="literal">null</span>)&#123;</span><br><span class="line">        jedis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>成功结果</li></ul><p><img src="/../img/redis%E5%85%A5%E9%97%A8.assets/1695383557879.png" alt="1695383541679"></p><p><img src="/../img/redis%E5%85%A5%E9%97%A8.assets/1695441495504.png" alt="1695441495504"></p><blockquote><p>总结：Jedis 使用的步骤：</p><ul><li>引入依赖</li><li>创建 Jedis 对象，引入连接（需要 ip 地址、端口号、密码等）</li><li>使用 Jedis ，方法名和 Redis 命令一致</li><li>释放资源</li></ul></blockquote><h4 id="3-2-2-Jedis-线程池"><a href="#3-2-2-Jedis-线程池" class="headerlink" title="3.2.2 Jedis 线程池"></a>3.2.2 Jedis 线程池</h4><p>Jedis 本身是<strong>线程不安全</strong>的，并且频繁的创建和销毁连接会有性能损耗，因此我们推荐大家<strong>使用 Jedis 连接池代替 Jedis 的直接连接</strong>：</p><ul><li>创建工具类 <code>JedisConnectionFactory</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.JedisPool;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.JedisPoolConfig;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JedisConnectionFactory</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> JedisPool JedisPool;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span>  &#123;</span><br><span class="line">        <span class="comment">// 配置连接池</span></span><br><span class="line">        <span class="type">JedisPoolConfig</span> <span class="variable">poolConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JedisPoolConfig</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最大连接数</span></span><br><span class="line">        poolConfig.setMaxTotal(<span class="number">8</span>);</span><br><span class="line">        <span class="comment">// 最大空闲连接数</span></span><br><span class="line">        poolConfig.setMaxIdle(<span class="number">8</span>);</span><br><span class="line">        <span class="comment">// 最小空闲连接</span></span><br><span class="line">        poolConfig.setMinIdle(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 最长等待时间 ms</span></span><br><span class="line">        poolConfig.setMaxWaitMillis(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建连接池对象</span></span><br><span class="line">        JedisPool = <span class="keyword">new</span> <span class="title class_">JedisPool</span>(poolConfig,</span><br><span class="line">                <span class="string">&quot;192.168.3.185&quot;</span>, <span class="number">6379</span>, <span class="number">1000</span>, <span class="string">&quot;thr&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Jedis <span class="title function_">getJedis</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> JedisPool.getResource();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>代码说明：</strong></p><ul><li>1）<strong>JedisConnectionFacotry</strong>：工厂设计模式是实际开发中非常常用的一种设计模式，我们可以使用工厂，去降低代的耦合，比如Spring中的Bean的创建，就用到了工厂设计模式</li><li>2）<strong>静态代码块</strong>：随着类的加载而加载，确保只能执行一次，我们在加载当前工厂类的时候，就可以执行static的操作完成对连接池的初始化</li><li>3）最后提供返回连接池中连接的方法.</li></ul></blockquote><ul><li>修改之前的测试类，重新测试，成功</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jedis = JedisConnectionFactory.getJedis();</span><br></pre></td></tr></table></figure><p><img src="/../img/redis%E5%85%A5%E9%97%A8.assets/1695442811145.png" alt="1695442811145"></p><blockquote><p><strong>代码说明：</strong></p><ul><li>我们在完成了使用工厂设计模式来完成代码的编写后，我们可以<strong>通过工厂来获得连接，不用去new对象</strong>，减低耦合，且使用的还是连接池对象</li><li>当我们使用连接池后，当我们关闭连接其实并不是关闭，而是将 Jedis 归还给连接池</li></ul></blockquote><h3 id="3-3-SpringDataRedis-重点"><a href="#3-3-SpringDataRedis-重点" class="headerlink" title="3.3 SpringDataRedis(重点)"></a>3.3 SpringDataRedis(重点)</h3><h4 id="3-3-1-基本介绍"><a href="#3-3-1-基本介绍" class="headerlink" title="3.3.1 基本介绍"></a>3.3.1 基本介绍</h4><p><strong>SpringData 是 Spring 中数据操作的模块</strong>，包含对各种数据库的集成，其中<strong>对 Redis 的集成模块就叫做 SpringDataRedis</strong>，官网地址：<a href="https://spring.io/projects/spring-data-redis">https://spring.io/projects/spring-data-redis</a></p><ul><li>提供了对不同Redis客户端的整合（Lettuce和Jedis）</li><li>提供了<strong>RedisTemplate统一API来操作Redis</strong></li><li>支持Redis的发布订阅模型</li><li>支持Redis哨兵和Redis集群</li><li>支持基于Lettuce的响应式编程(Lettuce之前是在es那里有)</li><li>支持基于JDK.JSON.字符串.Spring对象的数据序列化及反序列化</li><li>支持基于Redis的JDKCollection实现</li></ul><p><img src="/../img/redis%E5%85%A5%E9%97%A8.assets/1695443407565.png" alt="1695443407565"></p><h4 id="3-3-2-快速入门"><a href="#3-3-2-快速入门" class="headerlink" title="3.3.2 快速入门"></a>3.3.2 快速入门</h4><blockquote><p>SpringBoot 已经提供了对 SpringDataRedis 的支持，使用非常简单，所以我们先创建一个 SpringBoot 项目：</p><p><img src="/../img/redis%E5%85%A5%E9%97%A8.assets/1695443673871.png" alt="1695443673871"></p><p><img src="/../img/redis%E5%85%A5%E9%97%A8.assets/1695443718891.png" alt="1695443718891"></p><p><img src="/../img/redis%E5%85%A5%E9%97%A8.assets/1695443736688.png" alt="1695443736688"></p></blockquote><ul><li><strong>引入依赖</strong></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--Redis依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--连接池依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-pool2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><strong>配置文件</strong></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.3</span><span class="number">.185</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">thr</span></span><br><span class="line">    <span class="attr">database:</span> <span class="number">0</span></span><br><span class="line">    <span class="attr">lettuce:</span></span><br><span class="line">      <span class="attr">pool:</span></span><br><span class="line">        <span class="attr">max-active:</span> <span class="number">8</span> <span class="comment">#最大连接数</span></span><br><span class="line">        <span class="attr">max-idle:</span> <span class="number">8</span> <span class="comment">#最大空闲连接</span></span><br><span class="line">        <span class="attr">min-idle:</span> <span class="number">0</span> <span class="comment">#最小空闲连接</span></span><br><span class="line">        <span class="attr">max-wait:</span> <span class="number">100</span> <span class="comment">#连接等待时间</span></span><br></pre></td></tr></table></figure><blockquote><p>这个地方的 pool 咱们选择的是 lettuce 而不是 jedis，因为 spring 默认引入的是 lettuce，如果要用 jedis 还需要自己引下依赖</p><p><img src="/../img/redis%E5%85%A5%E9%97%A8.assets/1695444387182.png" alt="1695444387182"></p></blockquote><ul><li><strong>注入 RedisTemplate，编写测试类</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SpringdataredisDemoApplicationTests</span> &#123;</span><br><span class="line">    <span class="comment">// 注入 RedisTemplate</span></span><br><span class="line">    <span class="comment">// 自动装配爆红的话将注解 @Autowired 改成 @Resource 或者 @Autowired(required = false)</span></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 写一条 string 数据</span></span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;thr&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取 string 数据</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">name</span> <span class="operator">=</span> redisTemplate.opsForValue().get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;name = &quot;</span> + name);  <span class="comment">// name = thr</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>成功结果</strong></li></ul><p><img src="/../img/redis%E5%85%A5%E9%97%A8.assets/1695444912647.png" alt="1695444912647"></p><blockquote><p><strong>总结</strong>：SpringDataRedis 的使用步骤</p><ul><li>引入依赖</li><li>在 yaml 文件里配置 Redis 信息</li><li>注入 RedisTemplate</li></ul></blockquote><h4 id="3-3-3-RedisTemplate-的-RedisSerializer"><a href="#3-3-3-RedisTemplate-的-RedisSerializer" class="headerlink" title="3.3.3 RedisTemplate 的 RedisSerializer"></a>3.3.3 RedisTemplate 的 RedisSerializer</h4><ul><li><p>Q：根据前面的快速入门，我们去图形化界面做验证检查的时候会发现一些问题：多了一个这样的 key：<code>\xac\xed\x00\x05t\x00\x04name</code></p><blockquote><p>原因在序列化？前面使用的 <code>redisTemplate.opsForValue().set(&quot;name&quot;, &quot;thr&quot;);</code> 这里面 redisTemplate 的 set 方法，操作的参数并不是字符串，而是 <code>Object</code> 类型，<strong>接收任何类型的对象，并将其转成 redis 可以 处理的字节</strong>，所以我们存进去的 <code>name</code> 和 <code>thr</code> 就被当成 java 对象了，而<strong>默认的序列化器是 jdk 的序列化器</strong>，得到的结果就是如下这样：</p></blockquote><p><img src="/../img/redis%E5%85%A5%E9%97%A8.assets/1695445303647.png" alt="1695445303647"></p><p><img src="/../img/redis%E5%85%A5%E9%97%A8.assets/1695446187379.png" alt="1695446187379"></p></li><li><p><strong>缺点</strong></p><ul><li>可读性差</li><li>内存占用较大</li></ul></li><li><p><strong>解决办法</strong>：不用默认的方法</p><ul><li>快捷键 <code>ctrl + H</code> 打开类层级关系模板</li></ul><p><img src="/../img/redis%E5%85%A5%E9%97%A8.assets/1695446493818.png" alt="1695446493818"></p><ul><li>所以我们可以自定义 RedisTemplate 的序列化方式来解决这个问题</li></ul></li><li><p><strong>详细解决过程</strong>：</p><ul><li>编写配置类：<code>RedisConfig</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfig</span> &#123;</span><br><span class="line">    <span class="comment">// springboot 会帮我们自动创建工厂, 我们只要注入下就行</span></span><br><span class="line">    <span class="comment">// 此处 形参名爆红 需要降低 springboot 的版本</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory connectionFactory)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建 RedisTemplate 对象</span></span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置连接工厂</span></span><br><span class="line">        template.setConnectionFactory(connectionFactory);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建 JSON 序列化工具</span></span><br><span class="line">        <span class="type">GenericJackson2JsonRedisSerializer</span> <span class="variable">jsonRedisSerializer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericJackson2JsonRedisSerializer</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置 key 的序列化</span></span><br><span class="line">        template.setKeySerializer(RedisSerializer.string());</span><br><span class="line">        template.setHashKeySerializer(RedisSerializer.string());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置 value 的序列化</span></span><br><span class="line">        template.setValueSerializer(jsonRedisSerializer);</span><br><span class="line">        template.setHashValueSerializer(jsonRedisSerializer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回</span></span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>引入 Jackson 依赖</li></ul><blockquote><p>因为这里我们没有用到 springmvc 所以需要引入下这个依赖，平常开发中 springmvc 会自带这个依赖</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Jackson依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>修改测试类：加个泛型即可</li></ul><p><img src="/../img/redis%E5%85%A5%E9%97%A8.assets/1695447344514.png" alt="1695447344514"></p><ul><li>成功</li></ul><p><img src="/../img/redis%E5%85%A5%E9%97%A8.assets/1695447615550.png" alt="1695447615550"></p></li><li><p><strong>尝试写入对象</strong></p><ul><li>先创建一个实体类：<code>User</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>然后编写测试方法：存储 user 对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testSavaUser</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 写入数据</span></span><br><span class="line">    redisTemplate.opsForValue().set(<span class="string">&quot;user:100&quot;</span>, <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;hhh&quot;</span>, <span class="number">21</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取数据</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">o</span> <span class="operator">=</span> (User) redisTemplate.opsForValue().get(<span class="string">&quot;user:100&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;o = &quot;</span> + o);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>查看图形化界面验证结果：</li></ul><p><img src="/../img/redis%E5%85%A5%E9%97%A8.assets/1695448067814.png" alt="1695448067814"></p></li></ul><h4 id="3-3-4-StringRedisTemplate"><a href="#3-3-4-StringRedisTemplate" class="headerlink" title="3.3.4 StringRedisTemplate"></a>3.3.4 StringRedisTemplate</h4><ul><li><strong>问题</strong>：尽管 Json 的自动序列化方式可以满足我们的需求，但仍然存在一些问题，为了在反序列化时知道对象的类型，<strong>JSON 序列化器会将类的 class 类型写入 json 结果中，存入 Redis，会带来额外的内存开销</strong>，如上 3.3.3 的结果</li><li><strong>解决</strong>：因此为了节省内存空间，我们并不会使用 JSON 序列化器来处理value，而是统一使用 String 序列化器，要求只能存储 String 类型的 key 和 value。当需要存储 Java 对象时，<strong>手动完成对象的序列化和反序列化</strong></li></ul><p><img src="/../img/redis%E5%85%A5%E9%97%A8.assets/1695448480856.png" alt="1695448480856"></p><blockquote><p><strong>String 默认提供了一个 StringRedisTemplate 类</strong>，他的key和value的序列化默认就是String方式，省去了定义redisTemplate 过程 </p><p><img src="/../img/redis%E5%85%A5%E9%97%A8.assets/1695448590148.png" alt="1695448590148"></p></blockquote><ul><li><p><strong>具体实现</strong>：</p><ul><li>新建测试类：<code>SpringdataredisStringApplicationTests</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SpringdataredisStringApplicationTests</span> &#123;</span><br><span class="line">    <span class="comment">// 注入 StringRedisTemplate</span></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 写一条 string 数据</span></span><br><span class="line">        stringRedisTemplate.opsForValue().set(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;thr&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取 string 数据</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">name</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;name = &quot;</span> + name);  <span class="comment">// name = thr</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// json 的序列化工具, 也可以用 fastjson</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ObjectMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testSavaUser</span><span class="params">()</span> <span class="keyword">throws</span> JsonProcessingException &#123;</span><br><span class="line">        <span class="comment">// 创建对象</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;thr&quot;</span>, <span class="number">21</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 手动序列化</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> mapper.writeValueAsString(user);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 写入数据</span></span><br><span class="line">        stringRedisTemplate.opsForValue().set(<span class="string">&quot;user:200&quot;</span>, json);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取数据</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">jsonUser</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(<span class="string">&quot;user:200&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 手动反序列化</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> mapper.readValue(jsonUser, User.class);</span><br><span class="line">        System.out.println(<span class="string">&quot;user1 = &quot;</span> + user1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>成功结果：</li></ul><p><img src="/../img/redis%E5%85%A5%E9%97%A8.assets/1695449143031.png" alt="1695449143031"></p><p><img src="/../img/redis%E5%85%A5%E9%97%A8.assets/1695449157968.png" alt="1695449157968"></p></li></ul><h4 id="3-3-5-总结：RedisTemplate-的两种序列化实践方案"><a href="#3-3-5-总结：RedisTemplate-的两种序列化实践方案" class="headerlink" title="3.3.5 总结：RedisTemplate 的两种序列化实践方案"></a>3.3.5 总结：RedisTemplate 的两种序列化实践方案</h4><ul><li><strong>自定义 RedisTemplate</strong><ul><li>修改RedisTemplate的序列化器为GenericJackson2JsonRedisSerializer</li></ul></li><li><strong>使用 StringRedisTemplate</strong> <ul><li>写入Redis时，手动把对象序列化为Json</li><li>读取Redis时，手动把读取到的Json反序列化为对象</li></ul></li></ul><h4 id="3-3-6-补充：RedisTemplate-操作-Hash-类型"><a href="#3-3-6-补充：RedisTemplate-操作-Hash-类型" class="headerlink" title="3.3.6 补充：RedisTemplate 操作 Hash 类型"></a>3.3.6 补充：RedisTemplate 操作 Hash 类型</h4><ul><li><strong>编写测试方法</strong>：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testHash</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 存入数据</span></span><br><span class="line">    stringRedisTemplate.opsForHash().put(<span class="string">&quot;user:400&quot;</span>, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;thr&quot;</span>);</span><br><span class="line">    stringRedisTemplate.opsForHash().put(<span class="string">&quot;user:400&quot;</span>, <span class="string">&quot;age&quot;</span>, <span class="string">&quot;21&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取数据, 此处用 entries 方法获取所有键值对拼接的 map</span></span><br><span class="line">    Map&lt;Object, Object&gt; entries = stringRedisTemplate.opsForHash().entries(<span class="string">&quot;user:400&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;entries = &quot;</span> + entries);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>成功结果</strong>：</li></ul><p><img src="/../img/redis%E5%85%A5%E9%97%A8.assets/1695449600304.png" alt="1695449600304"></p><p><img src="/../img/redis%E5%85%A5%E9%97%A8.assets/1695449585760.png" alt="1695449585760"></p>]]></content>
      
      
      <categories>
          
          <category> DataBase </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>爬虫</title>
      <link href="/2023/10/14/Spider/"/>
      <url>/2023/10/14/Spider/</url>
      
        <content type="html"><![CDATA[<h1 id="爬虫"><a href="#爬虫" class="headerlink" title="爬虫"></a>爬虫</h1><h2 id="1-相关概念介绍"><a href="#1-相关概念介绍" class="headerlink" title="1. 相关概念介绍"></a>1. 相关概念介绍</h2><ul><li><strong>解释1</strong>：通过一个程序，根据 Url 进行爬取网页，获取有用的信息</li><li><strong>解释2</strong>：使用程序模拟浏览器，去向服务器发送请求，获取响应信息</li></ul><h3 id="1-1-爬虫核心？"><a href="#1-1-爬虫核心？" class="headerlink" title="1.1 爬虫核心？"></a>1.1 爬虫核心？</h3><ul><li><strong>爬取网页</strong></li><li><strong>解析数据</strong>(重点)</li><li>难点：爬虫与反爬虫之间的博弈</li></ul><h3 id="1-2-爬虫的用途"><a href="#1-2-爬虫的用途" class="headerlink" title="1.2 爬虫的用途"></a>1.2 爬虫的用途</h3><ul><li>数据分析&#x2F;人工数据集</li><li>社交软件冷启动</li><li>舆情监控</li><li>竞争对手监控</li></ul><h3 id="1-3-爬虫分类"><a href="#1-3-爬虫分类" class="headerlink" title="1.3 爬虫分类"></a>1.3 爬虫分类</h3><ul><li><strong>通用爬虫</strong>(不学)<ul><li>功能：访问网页-&gt;抓取数据-&gt;数据存储-&gt;数据除了-&gt;提供检索服务</li><li>实例：百度、google等搜索引擎</li><li>缺点：<ul><li>抓取的数据大多是无用的</li><li>不能根据用户的需求来精准获取数据</li></ul></li></ul></li><li><strong>聚焦爬虫</strong><ul><li>功能：根据需求，实现爬虫程序，抓取需要的数据</li><li>设计思路：<ul><li>确定要爬取的url</li><li>模拟浏览器通过 http 协议访问 url，获取服务器返回的 html 代码</li><li>解析 html 字符串</li></ul></li></ul></li><li><strong>增量式爬虫</strong><ul><li>检测网站中的数据更新情况，只会抓取网站中最新更新出来的数据</li></ul></li></ul><h3 id="1-4-反爬手段"><a href="#1-4-反爬手段" class="headerlink" title="1.4 反爬手段"></a>1.4 反爬手段</h3><ul><li>User-Agent：<ul><li>简称 UA，是一个特殊的字符串头，能识别客户使用的操作系统及版本、CPU 类型、浏览器语言、插件等等</li></ul></li><li>代理 IP</li><li>验证码访问</li><li>动态加载网页<ul><li>网站返回的是 js 数据，并不是真实的网页数据</li></ul></li><li>数据加密</li></ul><h2 id="2-urllib-库使用"><a href="#2-urllib-库使用" class="headerlink" title="2. urllib 库使用"></a>2. urllib 库使用</h2><h3 id="2-1-基本使用"><a href="#2-1-基本使用" class="headerlink" title="2.1 基本使用"></a>2.1 基本使用</h3><blockquote><p>python 本身自带，不需要安装</p></blockquote><ul><li><code>urllib.request.rulopen()</code> 模拟浏览器向服务器发送请求<ul><li>response 服务器返回的数据</li><li>response 的数据类型是 HttpResponse</li></ul></li><li>字节–&gt;字符串<ul><li>解码decode</li></ul></li><li>字符串–&gt;字节<ul><li>编码encode</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 urllib 获取百度首页的源码</span></span><br><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 定义一个 url: 就是你要访问的地址</span></span><br><span class="line">url = <span class="string">&#x27;https://www.baidu.com&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 模拟浏览器向服务器发送请求</span></span><br><span class="line">response = urllib.request.urlopen(url)  <span class="comment"># 打开网址并获取响应</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 获取响应中的页面源码</span></span><br><span class="line"><span class="comment"># read 方法返回的是字节形式的二进制数据</span></span><br><span class="line"><span class="comment"># 要将二进制的数据转换为字符串</span></span><br><span class="line"><span class="comment"># 解码: 二进制--&gt;字符串  编码的格式?</span></span><br><span class="line">content = response.read().decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 打印数据</span></span><br><span class="line"><span class="built_in">print</span>(content)</span><br></pre></td></tr></table></figure><h3 id="2-2-一个类型，六个方法"><a href="#2-2-一个类型，六个方法" class="headerlink" title="2.2 一个类型，六个方法"></a>2.2 一个类型，六个方法</h3><ul><li><strong>response 是 HTTPResponse 类型</strong></li><li><strong>方法</strong><ul><li>read()        <ul><li>字节形式读取二进制 扩展：rede(5)返回前几个字节</li></ul></li><li>readline()  读取一行</li><li>readlines() 一行一行读取 直至结束</li><li>getcode()  获取状态吗</li><li>geturl()      获取url</li><li>getheaders() 获取headers</li></ul></li><li>代码：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 定义一个 url: 就是你要访问的地址</span></span><br><span class="line">url = <span class="string">&#x27;https://www.baidu.com&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 模拟浏览器向服务器发送请求</span></span><br><span class="line">response = urllib.request.urlopen(url)  <span class="comment"># 打开网址并获取响应</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 一个类型和六个方法</span></span><br><span class="line"><span class="comment"># response 是 HTTPResponse 类型</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(response))  <span class="comment"># &lt;class &#x27;http.client.HTTPResponse&#x27;&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.1 按照一个字节一个字节去读</span></span><br><span class="line"><span class="comment"># content = response.read()</span></span><br><span class="line"><span class="comment"># content = response.read(5)  # 返回 5 个字节</span></span><br><span class="line"><span class="comment"># print(content)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.2 读取一行</span></span><br><span class="line"><span class="comment"># content = response.readline()</span></span><br><span class="line"><span class="comment"># print(content)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.3 一行一行读, 直到读完, 但都还是字节</span></span><br><span class="line"><span class="comment"># content = response.readlines()</span></span><br><span class="line"><span class="comment"># print(content)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.4 返回状态吗 200为成功</span></span><br><span class="line"><span class="built_in">print</span>(response.getcode())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.5 返回你所访问的 url 地址</span></span><br><span class="line"><span class="built_in">print</span>(response.geturl())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.6 返回状态信息</span></span><br><span class="line"><span class="built_in">print</span>(response.getheaders())</span><br></pre></td></tr></table></figure><h3 id="2-3-下载"><a href="#2-3-下载" class="headerlink" title="2.3 下载"></a>2.3 下载</h3><ul><li>方法：<code>urlretrieve</code></li><li>使用：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 下载网页</span></span><br><span class="line">url_page = <span class="string">&#x27;http://www.baidu.com&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># urlretrieve 的参数, url 代表下载的路径, filename 代表下载保存的文件的名字</span></span><br><span class="line">urllib.request.urlretrieve(url_page, <span class="string">&#x27;baidu.html&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 下载图片</span></span><br><span class="line">url_img = <span class="string">&#x27;https://tse1-mm.cn.bing.net/th/id/OIP-C.Z7jHpg5FBaGIu8DETlUVrgAAAA?w=282&amp;h=159&amp;c=7&amp;r=0&amp;o=5&amp;dpr=1.3&amp;pid=1.7&#x27;</span></span><br><span class="line">urllib.request.urlretrieve(url=url_img, filename=<span class="string">&#x27;1999.png&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 下载视频 b站的貌似不行, 换个别的吧</span></span><br><span class="line">url_video = <span class="string">&#x27;https://www.bilibili.com/97a65886-83e4-4445-a64b-e089da359f0e&quot;&#x27;</span></span><br><span class="line">urllib.request.urlretrieve(url_video, <span class="string">&#x27;1999.mp4&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="2-4-请求对象的定制"><a href="#2-4-请求对象的定制" class="headerlink" title="2.4 请求对象的定制"></a>2.4 请求对象的定制</h3><ul><li>爬虫是模拟浏览器向服务器发送请求的过程，定制对象(UA)是一种反爬虫的手段，需要使用headers定制操作系统<ul><li><strong>请求对象的定制是为了解决反爬的第一种手段</strong></li></ul></li><li>找到 baidu 的 UA：<ul><li><code>User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/116.0.0.0 Safari/537.36 Edg/116.0.1938.69 </code></li></ul></li></ul><p><img src="/../img/Spider%E5%85%A5%E9%97%A8.assets/1695954812553.png" alt="1695954812553"></p><ul><li><strong>语法</strong>：<code>request = urllib.request.Request()</code></li><li><strong>代码实现</strong>：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;https://www.baidu.com&#x27;</span>  <span class="comment"># 注意这里变成 https 了, 之后会遇到反爬UA, 返回数据不完整</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># url 的组成</span></span><br><span class="line"><span class="comment"># 协议(http/https) 主机(域名/ip地址) 端口号(80/443) 路径 参数 锚点(#)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 把 UA 写作一个字典形式</span></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/116.0.0.0 Safari/537.36 Edg/116.0.1938.69&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 因为 urlopen 方法中不能存储字典, 所有 headers 不能传递进去</span></span><br><span class="line"><span class="comment"># 所以进行请求对象的定制</span></span><br><span class="line"><span class="comment"># 注意：因为参数顺序的问题, 不能直接写 url 和 headers, 中间还有一个 data, 所以我们需要关键字传参</span></span><br><span class="line">request = urllib.request.Request(url=url, headers=headers)</span><br><span class="line"><span class="comment"># 传入请求对象</span></span><br><span class="line">response = urllib.request.urlopen(request)  <span class="comment"># 成功</span></span><br><span class="line">content = response.read().decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(content)</span><br></pre></td></tr></table></figure><h3 id="2-5-编解码"><a href="#2-5-编解码" class="headerlink" title="2.5 编解码"></a>2.5 编解码</h3><blockquote><p>大一统编码：Unicode 编码</p><p>所以粘贴过来的url会变成这样<code>https://www.baidu.com/s?wd=%E5%91%A8%E6%9D%B0%E4%BC%A6 </code></p><p><img src="/../img/Spider%E5%85%A5%E9%97%A8.assets/1695955894782.png" alt="1695955894782"></p></blockquote><h4 id="2-5-1-get-请求的-quote-方法"><a href="#2-5-1-get-请求的-quote-方法" class="headerlink" title="2.5.1 get 请求的 quote 方法"></a>2.5.1 get 请求的 quote 方法</h4><blockquote><p>把中文转换成unicode编码，不常用</p></blockquote><ul><li><strong>用法</strong>：<code>name = urllib.parse.quote(&#39;周杰伦&#39;)</code></li><li><strong>代码</strong>：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># https://www.baidu.com/s?wd=%E5%91%A8%E6%9D%B0%E4%BC%A6</span></span><br><span class="line"><span class="comment"># 需求: 获取 https://www.baidu.com/s?wd=周杰伦 的网页源码</span></span><br><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"><span class="keyword">import</span> urllib.parse</span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;https://www.baidu.com/s?wd=&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 请求对象的定制是为了解决反爬的第一种手段</span></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/116.0.0.0 Safari/537.36 Edg/116.0.1938.69&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将周杰伦三个字变成 unicode 编码的格式</span></span><br><span class="line"><span class="comment"># 需要依赖于 urllib.parse</span></span><br><span class="line">name = urllib.parse.quote(<span class="string">&#x27;周杰伦&#x27;</span>)</span><br><span class="line">url = url + name</span><br><span class="line"><span class="built_in">print</span>(url)</span><br><span class="line"></span><br><span class="line">request = urllib.request.Request(url=url, headers=headers)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 模拟浏览器向服务器发送请求</span></span><br><span class="line">response = urllib.request.urlopen(request)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取响应的内容</span></span><br><span class="line">content = response.read().decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印数据</span></span><br><span class="line"><span class="built_in">print</span>(content)  <span class="comment"># 出现了安全验证, 应该是又被反爬了</span></span><br></pre></td></tr></table></figure><h4 id="2-5-2-get-请求的-urlencode-方法"><a href="#2-5-2-get-请求的-urlencode-方法" class="headerlink" title="2.5.2 get 请求的 urlencode 方法"></a>2.5.2 get 请求的 urlencode 方法</h4><blockquote><p>适用于多个参数的情况之下，直接定义为一个字典形式 </p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">base_url = <span class="string">&#x27;https://www.baidu.com/s?&#x27;</span></span><br><span class="line">data = &#123;</span><br><span class="line">    <span class="string">&#x27;wd&#x27;</span>: <span class="string">&#x27;周杰伦&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;sex&#x27;</span>: <span class="string">&#x27;男&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">new_data = urllib.parse.urlencode(data)</span><br><span class="line"><span class="built_in">print</span>(new_data)  <span class="comment"># wd=%E5%91%A8%E6%9D%B0%E4%BC%A6&amp;sex=%E7%94%B7</span></span><br><span class="line">url = base_url + new_data  <span class="comment"># 请求资源路径</span></span><br><span class="line"><span class="built_in">print</span>(url)</span><br></pre></td></tr></table></figure><h4 id="2-5-3-post-请求方式"><a href="#2-5-3-post-请求方式" class="headerlink" title="2.5.3 post 请求方式"></a>2.5.3 post 请求方式</h4><blockquote><p>注意：<strong>post请求的参数必须进行编码</strong>，编码之后必须调用 encode 方法  <code>data = urllib.parse.urlencode(data).encode(&#39;utf-8&#39;)</code></p><p>POST的请求<strong>参数是不会拼接在url后面的，而是需要放在请求对象定制的参数中</strong></p></blockquote><ul><li><p><strong>难点</strong>：找谁到底是你要的那个接口</p><blockquote><p>举例：百度翻译  <code>https://fanyi.baidu.com/sug</code></p><p><img src="/../img/Spider%E5%85%A5%E9%97%A8.assets/1695958780399.png" alt="1695958780399"></p></blockquote></li><li><p><strong>代码实例</strong>：</p><ul><li>案例1：百度翻译</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># post 请求百度翻译</span></span><br><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"><span class="keyword">import</span> urllib.parse</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 请求地址</span></span><br><span class="line">url = <span class="string">&#x27;https://fanyi.baidu.com/sug&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 请求头</span></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/116.0.0.0 Safari/537.36 Edg/116.0.1938.69&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 请求参数</span></span><br><span class="line">data = &#123;</span><br><span class="line">    <span class="string">&#x27;kw&#x27;</span>: <span class="string">&#x27;spider&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># post 请求的参数, 必须要进行编码</span></span><br><span class="line">data = urllib.parse.urlencode(data).encode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(data)  <span class="comment"># kw=spider</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 定制请求对象 post 的请求参数是不会拼接在 url 后面的, 而是需要放在请求对象定制的参数中</span></span><br><span class="line">request = urllib.request.Request(url=url, data=data, headers=headers)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. 模拟浏览器向服务器发送请求</span></span><br><span class="line">response = urllib.request.urlopen(request)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 6. 获取响应的数据</span></span><br><span class="line">content = response.read().decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(content))  <span class="comment"># &lt;class &#x27;str&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(content)  <span class="comment"># &quot;data&quot;:[&#123;&quot;k&quot;:&quot;spider&quot;,&quot;v&quot;:&quot;n. \u8718\u86db; \u661f\u5f62\u8f6e\uff0c\u5341\u5b57\u53c9;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 7. 字符串变成 json 对象, 这回就显示中文了</span></span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line">obj = json.loads(content)</span><br><span class="line"><span class="built_in">print</span>(obj)  <span class="comment"># &#x27;data&#x27;: [&#123;&#x27;k&#x27;: &#x27;spider&#x27;, &#x27;v&#x27;: &#x27;n. 蜘蛛; 星形轮，十字叉; 带柄三脚平底锅; 三脚架&#x27;&#125;,</span></span><br></pre></td></tr></table></figure><ul><li>案例2：百度详细翻译</li></ul><blockquote><p>利用 pytharm 快速加引号，但是 url 格式注意下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(.*?):(.*)</span><br><span class="line"><span class="string">&#x27;$1&#x27;</span>:<span class="string">&#x27;$2&#x27;</span>,</span><br></pre></td></tr></table></figure><p><img src="/../img/Spider%E5%85%A5%E9%97%A8.assets/1695964161361.png" alt="1695964161361"></p><p><img src="/../img/Spider%E5%85%A5%E9%97%A8.assets/1695964878773.png" alt="1695964878773"></p><p>遇到反爬，起决定性因素的是请求头中的 cookie，成功：</p><p><img src="/../img/Spider%E5%85%A5%E9%97%A8.assets/1695964918990.png" alt="1695964918990"></p></blockquote><p><img src="/../img/Spider%E5%85%A5%E9%97%A8.assets/1695960152654.png" alt="1695960152654"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 百度翻译之详细翻译 注意反爬</span></span><br><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"><span class="keyword">import</span> urllib.parse</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 请求地址</span></span><br><span class="line">url = <span class="string">&#x27;https://fanyi.baidu.com/v2transapi?from=en&amp;to=zh&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 请求头</span></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="comment"># &#x27;Accept&#x27;: &#x27;*/*&#x27;,</span></span><br><span class="line">    <span class="comment"># # &#x27;Accept-Encoding&#x27;: &#x27; gzip, deflate, br&#x27;,  # 注释掉这句！</span></span><br><span class="line">    <span class="comment"># &#x27;Accept-Language&#x27;: &#x27;zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6&#x27;,</span></span><br><span class="line">    <span class="comment"># &#x27;Acs-Token&#x27;: &#x27;1695964467309_1695964468063_peDcqkvq6A8T3njv+K77v+KamobkMqSWfpCUJMKQYP/ChyN7W5OvAUIqMV/L2SbPjVfqcMkmR/Ns0/GUOysOeuMeG8t7YLflz8mpoHl1TFwSBWl3iAEg3+VU319melR/J9jHmt0EDdvCJn8EwNHDjWrd1Yis56PZXw2vUdC63L+f16WlARKCXxbTJrvQw5f1qssf+Z/itK3AReRKR+dAOnGWtvdbeU0DKt/HyfFwUKsnenFKcO0c0oMyRFi9/fnCXLy+HEaech+ZzZfB1oyInuQj9G9JJmbq2Qxx2WoOQYSQ4xiNlGNHgzJ8uGFwNLYNbJ6bxTGszkogMnHgYR1luX2o4CBhr+HddUEayDiT3CRsdNoXV4wFIQ13A8+JN1qHeSkpOz3+vGmEuSYnTObE+8CfSkkMUoMAvL/133QQDLpXDPsI1T0eEWNMBue+0EX6yahJB4MSd2iTKVXtlZtdkKHudQ0BfETC7EjMZh+MfIMSaHDV4vWeexbcc0rOI4PFWmwyoZIanp4rOr4LWg0y2d160OC2YNsG+WqsQa7YeHY=&#x27;,</span></span><br><span class="line">    <span class="comment"># &#x27;Cache-Control&#x27;: &#x27;no-cache&#x27;,</span></span><br><span class="line">    <span class="comment"># &#x27;Connection&#x27;: &#x27;keep-alive&#x27;,</span></span><br><span class="line">    <span class="comment"># &#x27;Content-Length&#x27;: &#x27;133&#x27;,</span></span><br><span class="line">    <span class="comment"># &#x27;Content-Type&#x27;: &#x27;application/x-www-form-urlencoded; charset=UTF-8&#x27;,</span></span><br><span class="line">    <span class="string">&#x27;Cookie&#x27;</span>: <span class="string">&#x27;BDUSS=E5yeFZUSFRyTUxzUEhVbXhzUkZOV3lyeDlGLUMyVWFranBDNlRiV21tTWlnRDVrSVFBQUFBJCQAAAAAAAAAAAEAAAB~ymGB06O7qGNhbzAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACLzFmQi8xZkT; BDUSS_BFESS=E5yeFZUSFRyTUxzUEhVbXhzUkZOV3lyeDlGLUMyVWFranBDNlRiV21tTWlnRDVrSVFBQUFBJCQAAAAAAAAAAAEAAAB~ymGB06O7qGNhbzAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACLzFmQi8xZkT; BIDUPSID=B26B49048A0C9099B1456DF64F0279FF; PSTM=1684546051; BAIDUID=C70948D5D545EED0115F390D9D6C8143:SL=0:NR=10:FG=1; BDORZ=B490B5EBF6F3CD402E515D22BCDA1598; BDRCVFR[feWj1Vr5u3D]=I67x6TjHwwYf0; delPer=0; PSINO=5; BAIDUID_BFESS=C70948D5D545EED0115F390D9D6C8143:SL=0:NR=10:FG=1; BA_HECTOR=ag01ag2g8k2hak81242k81001ihcet51p; ZFY=Y15oe:ADDl8fuenODkzShBnht8X9gotT2rS2ZtSq05IQ:C; H_PS_PSSID=39323_39353_39399_39396_39407_39097_39412_39436_39358_39308_39375_39233_39406_26350_39219_22158_39427; APPGUIDE_10_6_5=1; REALTIME_TRANS_SWITCH=1; FANYI_WORD_SWITCH=1; HISTORY_SWITCH=1; SOUND_SPD_SWITCH=1; SOUND_PREFER_SWITCH=1; Hm_lvt_64ecd82404c51e03dc91cb9e8c025574=1695958547; Hm_lpvt_64ecd82404c51e03dc91cb9e8c025574=1695964467; ab_sr=1.0.1_YTgxNjM4NjQ5Y2FjMmFjMjNmMjZhNDE1NjEwN2YxNmUyNTc0OGY1OGI3ZjMxOGFhMTJlNjBjMTM0NTc0YTI4OWVlNDIyZTUwZmIyNGYzZDdmYWIyZjQ3Y2Y2ZDc0YjVjMzcxM2MzMGVhNmE5OTZlYjA2ZjgyZTg4NTJhZThlYTJjZGE0MzBmYjRhZmUwMDBmYzU3NWU0YjY5YmFjYWQ1YmE1OGRkNzhiNGQ3Y2MwOWE4NTFlOTcxOTMxMjNlYzFl&#x27;</span>,</span><br><span class="line">    <span class="comment"># &#x27;Host&#x27;: &#x27;fanyi.baidu.com&#x27;,</span></span><br><span class="line">    <span class="comment"># &#x27;Origin&#x27;: &#x27;https://fanyi.baidu.com&#x27;,</span></span><br><span class="line">    <span class="comment"># &#x27;Pragma&#x27;: &#x27;no-cache&#x27;,</span></span><br><span class="line">    <span class="comment"># &#x27;Referer&#x27;: &#x27;https://fanyi.baidu.com/?aldtype=16047&#x27;,</span></span><br><span class="line">    <span class="comment"># &#x27;Sec-Ch-Ua&#x27;: &#x27;&quot;Chromium&quot;;v=&quot;116&quot;, &quot;Not)A;Brand&quot;;v=&quot;24&quot;, &quot;Microsoft Edge&quot;;v=&quot;116&quot;&#x27;,</span></span><br><span class="line">    <span class="comment"># &#x27;Sec-Ch-Ua-Mobile&#x27;: &#x27;?0&#x27;,</span></span><br><span class="line">    <span class="comment"># &#x27;Sec-Ch-Ua-Platform&#x27;: &#x27;&quot;Windows&quot;&#x27;,</span></span><br><span class="line">    <span class="comment"># &#x27;Sec-Fetch-Dest&#x27;: &#x27;empty&#x27;,</span></span><br><span class="line">    <span class="comment"># &#x27;Sec-Fetch-Mode&#x27;: &#x27;cors&#x27;,</span></span><br><span class="line">    <span class="comment"># &#x27;Sec-Fetch-Site&#x27;: &#x27;same-origin&#x27;,</span></span><br><span class="line">    <span class="comment"># &#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/116.0.0.0 Safari/537.36 Edg/116.0.1938.69&#x27;,</span></span><br><span class="line">    <span class="comment"># &#x27;X-Requested-With&#x27;: &#x27;XMLHttpRequest&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 请求参数</span></span><br><span class="line">data = &#123;</span><br><span class="line">    <span class="string">&#x27;from&#x27;</span>: <span class="string">&#x27;en&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;to&#x27;</span>: <span class="string">&#x27;zh&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;query&#x27;</span>: <span class="string">&#x27;math&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;transtype&#x27;</span>: <span class="string">&#x27;realtime&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;simple_means_flag&#x27;</span>: <span class="string">&#x27;3&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;sign&#x27;</span>: <span class="string">&#x27;965097.678616&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;token&#x27;</span>: <span class="string">&#x27;e98f8f014d0905b8705c2da2366e9207&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;domain&#x27;</span>: <span class="string">&#x27;common&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;ts&#x27;</span>: <span class="string">&#x27;1695960046487&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 编码</span></span><br><span class="line">data = urllib.parse.urlencode(data).encode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 请求对象定制</span></span><br><span class="line">request = urllib.request.Request(url, data, headers)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. 模拟浏览器向服务器发送请求</span></span><br><span class="line">response = urllib.request.urlopen(request)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 6. 获取响应的数据</span></span><br><span class="line">content = response.read().decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">obj = json.loads(content)</span><br><span class="line"><span class="built_in">print</span>(obj)</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-6-Ajax-请求"><a href="#2-6-Ajax-请求" class="headerlink" title="2.6 Ajax 请求"></a>2.6 Ajax 请求</h3><h4 id="2-6-1-get-请求"><a href="#2-6-1-get-请求" class="headerlink" title="2.6.1 get 请求"></a>2.6.1 get 请求</h4><p>案例：豆瓣电影：<a href="https://movie.douban.com/typerank?type_name=%E5%8A%A8%E4%BD%9C&type=5&interval_id=100:90&action=">豆瓣电影分类排行榜 - 动作片 (douban.com)</a> </p><ul><li><strong>先抓接口</strong>，到底谁才是第一页的数据</li></ul><blockquote><p>第一页共 20 个电影，这个接口刚好返回了 0-19 的每个电影的详细信息</p></blockquote><p><img src="/../img/Spider%E5%85%A5%E9%97%A8.assets/1695965455172.png" alt="1695965455172"></p><ul><li><strong>查看标头</strong>，发现是get请求</li></ul><p><img src="/../img/Spider%E5%85%A5%E9%97%A8.assets/1695965528954.png" alt="1695965528954"></p><ul><li><p><strong>代码编写</strong>：</p><ul><li>获取豆瓣电影第一页的数据</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># get 请求</span></span><br><span class="line"><span class="comment"># 获取豆瓣电影第一页的数据, 并且保存起来</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;https://movie.douban.com/j/chart/top_list?type=5&amp;interval_id=100%3A90&amp;action=&amp;start=0&amp;limit=20&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 请求头</span></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/116.0.0.0 Safari/537.36 Edg/116.0.1938.69&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 请求对象的定制</span></span><br><span class="line">request = urllib.request.Request(url=url, headers=headers)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 获取响应数据</span></span><br><span class="line">response = urllib.request.urlopen(request)</span><br><span class="line">content = response.read().decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(content)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 下载数据到本地 文件相关知识</span></span><br><span class="line"><span class="comment"># open 方法默认使用 gbk 编码, 要想保存中文就需要指定编码为 utf-8</span></span><br><span class="line">fp = <span class="built_in">open</span>(<span class="string">&#x27;douban.json&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">fp.write(content)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 上面两句也可这么写</span></span><br><span class="line"><span class="comment"># with open(&#x27;douban1.json&#x27;, &#x27;w&#x27;, encoding=&#x27;utf-8&#x27;) as fp:</span></span><br><span class="line"><span class="comment">#     fp.write(content)</span></span><br></pre></td></tr></table></figure><ul><li>获取豆瓣电影前十页的数据</li></ul><blockquote><p>难点：接口的寻找：</p><p><code>https://movie.douban.com/j/chart/top_list?type=5&amp;interval_id=100%3A90&amp;action=&amp;start=0&amp;limit=20</code>  &#x3D;&#x3D;&gt; 第一页</p><p><code>https://movie.douban.com/j/chart/top_list?type=5&amp;interval_id=100%3A90&amp;action=&amp;start=20&amp;limit=20</code>  &#x3D;&#x3D;&gt; 第二页</p><p>找规律，可得：<code>start (page-1)*20</code></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># https://movie.douban.com/j/chart/top_list?type=5&amp;interval_id=100%3A90&amp;action=&amp;start=0&amp;limit=20</span></span><br><span class="line"><span class="comment"># https://movie.douban.com/j/chart/top_list?type=5&amp;interval_id=100%3A90&amp;action=&amp;start=20&amp;limit=20</span></span><br><span class="line"><span class="comment"># https://movie.douban.com/j/chart/top_list?type=5&amp;interval_id=100%3A90&amp;action=&amp;start=40&amp;limit=20</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># page    1   2   3   4</span></span><br><span class="line"><span class="comment"># start   0   20  40  60</span></span><br><span class="line"><span class="comment"># 规律：start (page-1)*20</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载豆瓣电影前10页的数据</span></span><br><span class="line"><span class="comment"># 1.请求对象的定制</span></span><br><span class="line"><span class="comment"># 2.获取响应的数据</span></span><br><span class="line"><span class="comment"># 3.下载数据到本地</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"><span class="keyword">import</span> urllib.parse</span><br><span class="line"></span><br><span class="line"><span class="comment"># 封装函数实现</span></span><br><span class="line"><span class="comment"># 1. 请求对象的定制</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">creat_request</span>(<span class="params">page</span>):</span><br><span class="line">    <span class="comment"># 每页的 url 不同</span></span><br><span class="line">    base_url = <span class="string">&quot;https://movie.douban.com/j/chart/top_list?type=5&amp;interval_id=100%3A90&amp;action=&amp;&quot;</span></span><br><span class="line"></span><br><span class="line">    data = &#123;</span><br><span class="line">        <span class="string">&#x27;start&#x27;</span>: (page - <span class="number">1</span>) * <span class="number">20</span>,</span><br><span class="line">        <span class="string">&#x27;limit&#x27;</span>: <span class="number">20</span></span><br><span class="line">    &#125;</span><br><span class="line">    data = urllib.parse.urlencode(data)  <span class="comment"># get 请求后面就不用加 encode() 了</span></span><br><span class="line"></span><br><span class="line">    url = base_url + data</span><br><span class="line">    <span class="built_in">print</span>(url)</span><br><span class="line"></span><br><span class="line">    headers = &#123;</span><br><span class="line">        <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/116.0.0.0 Safari/537.36 Edg/116.0.1938.69&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    request = urllib.request.Request(url=url, headers=headers)</span><br><span class="line">    <span class="keyword">return</span> request</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.获取响应的数据</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_content</span>(<span class="params">request</span>):</span><br><span class="line">    response = urllib.request.urlopen(request)</span><br><span class="line">    content = response.read().decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> content</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.下载数据到本地</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">down_load</span>(<span class="params">page, content</span>):</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;douban_&#x27;</span> + <span class="built_in">str</span>(page) + <span class="string">&#x27;.json&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> fp:</span><br><span class="line">        fp.write(content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 程序的入口</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    start_page = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;请输入起始的页码: &#x27;</span>))</span><br><span class="line">    end_page = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;请输入结束的页码: &#x27;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 遍历</span></span><br><span class="line">    <span class="keyword">for</span> page <span class="keyword">in</span> <span class="built_in">range</span>(start_page, end_page + <span class="number">1</span>):</span><br><span class="line">        <span class="comment"># 每一页都有自己的请求对象的定制</span></span><br><span class="line">        request = creat_request(page)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 获取响应数据</span></span><br><span class="line">        content = get_content(request)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 下载数据</span></span><br><span class="line">        down_load(page, content)</span><br></pre></td></tr></table></figure></li></ul><h4 id="2-6-2-post-请求"><a href="#2-6-2-post-请求" class="headerlink" title="2.6.2 post 请求"></a>2.6.2 post 请求</h4><p>案例：KFC 官网：<a href="http://www.kfc.com.cn/kfccda/storelist/index.aspx">肯德基餐厅信息查询 (kfc.com.cn)</a> </p><ul><li>找<strong>接口</strong><ul><li>请求地址: <code>http://www.kfc.com.cn/kfccda/ashx/GetStoreList.ashx?op=cname</code></li></ul></li></ul><p><img src="/../img/Spider%E5%85%A5%E9%97%A8.assets/1695967907333.png" alt="1695967907333"></p><ul><li>找<strong>请求参数</strong></li></ul><p><img src="/../img/Spider%E5%85%A5%E9%97%A8.assets/1695969364799.png" alt="1695969364799"></p><ul><li><strong>代码实现</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第一页</span></span><br><span class="line"><span class="comment"># 请求地址: http://www.kfc.com.cn/kfccda/ashx/GetStoreList.ashx?op=cname</span></span><br><span class="line"><span class="comment"># cname: 北京</span></span><br><span class="line"><span class="comment"># pid:</span></span><br><span class="line"><span class="comment"># pageIndex: 1</span></span><br><span class="line"><span class="comment"># pageSize: 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二页</span></span><br><span class="line"><span class="comment"># 请求地址: http://www.kfc.com.cn/kfccda/ashx/GetStoreList.ashx?op=cname</span></span><br><span class="line"><span class="comment"># cname: 北京</span></span><br><span class="line"><span class="comment"># pid:</span></span><br><span class="line"><span class="comment"># pageIndex: 2</span></span><br><span class="line"><span class="comment"># pageSize: 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 实现前十页数据的获取</span></span><br><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"><span class="keyword">import</span> urllib.parse</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 请求对象的定制</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">creat_request</span>(<span class="params">page</span>):</span><br><span class="line">    <span class="comment"># 每页的 url 不同</span></span><br><span class="line">    base_url = <span class="string">&#x27;http://www.kfc.com.cn/kfccda/ashx/GetStoreList.ashx?op=cname&#x27;</span></span><br><span class="line"></span><br><span class="line">    data = &#123;</span><br><span class="line">        <span class="string">&#x27;cname&#x27;</span>: <span class="string">&#x27;北京&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;pid&#x27;</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;pageIndex&#x27;</span>: page,</span><br><span class="line">        <span class="string">&#x27;pageSize&#x27;</span>: <span class="string">&#x27;10&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    data = urllib.parse.urlencode(data).encode(<span class="string">&#x27;utf-8&#x27;</span>)  <span class="comment"># 编码 encode</span></span><br><span class="line"></span><br><span class="line">    headers = &#123;</span><br><span class="line">        <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/116.0.0.0 Safari/537.36 Edg/116.0.1938.69&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    request = urllib.request.Request(url=base_url, headers=headers, data=data)</span><br><span class="line">    <span class="keyword">return</span> request</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.获取响应的数据</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_content</span>(<span class="params">request</span>):</span><br><span class="line">    response = urllib.request.urlopen(request)</span><br><span class="line">    content = response.read().decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> content</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.下载数据到本地</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">down_load</span>(<span class="params">page, content</span>):</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;kfc_&#x27;</span> + <span class="built_in">str</span>(page) + <span class="string">&#x27;.json&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> fp:</span><br><span class="line">        fp.write(content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    start_page = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;请输入起始的页码: &#x27;</span>))</span><br><span class="line">    end_page = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;请输入结束的页码: &#x27;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 循环遍历</span></span><br><span class="line">    <span class="keyword">for</span> page <span class="keyword">in</span> <span class="built_in">range</span>(start_page, end_page + <span class="number">1</span>):</span><br><span class="line">        <span class="comment"># 请求对象的定制</span></span><br><span class="line">        request = creat_request(page)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 获取网页数据</span></span><br><span class="line">        content = get_content(request)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 下载数据</span></span><br><span class="line">        down_load(page, content)</span><br></pre></td></tr></table></figure><h3 id="2-7-URLError-HTTPError"><a href="#2-7-URLError-HTTPError" class="headerlink" title="2.7 URLError\HTTPError"></a>2.7 URLError\HTTPError</h3><ul><li>HTTPError 类是 URLError 类的子类</li><li>导入的包 <code>urllib.error.HTTPError</code>，<code>urllib.error.URLError</code></li><li>通过 urllib 发送请求的时候又可能会发送失败，这时候若想让代码更加健壮，<strong>可以通过 try-except 进行异常捕获</strong></li><li><strong>代码示例</strong>：CSDN：<code>https://blog.csdn.net/qq_48108092/article/details/126097408</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># https://blog.csdn.net/qq_48108092/article/details/126097408</span></span><br><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"><span class="keyword">import</span> urllib.error</span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;https://blog.csdn.net/qq_48108092/article/details/126097408&#x27;</span></span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/116.0.0.0 Safari/537.36 Edg/116.0.1938.69&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    request = urllib.request.Request(url=url, headers=headers)</span><br><span class="line">    response = urllib.request.urlopen(request)</span><br><span class="line">    content = response.read().decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(content)</span><br><span class="line"><span class="keyword">except</span> urllib.error.HTTPError:  <span class="comment"># 假设写错url, 就会报这个错</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;系统正在升级...&#x27;</span>)</span><br><span class="line"><span class="keyword">except</span> urllib.error.URLError:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;我都说了, 系统正在升级...&#x27;</span>)  <span class="comment"># url 根本不存在?</span></span><br></pre></td></tr></table></figure><h3 id="2-8-cookie-登录"><a href="#2-8-cookie-登录" class="headerlink" title="2.8 cookie 登录"></a>2.8 cookie 登录</h3><blockquote><p>适用场景：数据采集的时候，需要绕过登录，然后进入到某个页面</p></blockquote><ul><li>个人信息页面是 utf-8, 但是还是报错编码错误, 因为没有进入到个人信息页面, 而是跳转到了登陆页面，那么登录页面不是 utf-8 所以报错</li><li>什么情况下访问不成功?<ul><li>因为请求头的信息不够, 所以不成功</li><li><strong>如果有登录之后的 cookie, 那么我们就可以携带着 cookie 进入到登录后的任何页面</strong></li><li>请求头中还有个参数 <code>&#39;referer&#39;: &#39;https://weibo.cn/&#39;</code> <ul><li>这个可以用于判断当前路径是不是由上一个路径进来的, 一般情况下是做<strong>图片的防盗链</strong>的</li></ul></li></ul></li></ul><h3 id="2-9-Handler-处理器"><a href="#2-9-Handler-处理器" class="headerlink" title="2.9 Handler 处理器"></a>2.9 Handler 处理器</h3><ul><li>不能定制请求头：<code>urllib.request.urlopen(url)</code></li><li>可以定制请求头：<code>urllib.request.Request(url,headers,data)</code></li><li><strong>定制更高级的请求头：Handler</strong><ul><li>动态 cookie 和 代理不能使用请求对象的定制</li></ul></li><li><strong>基本使用</strong>：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 需求: 使用 handler 访问百度, 获取网页源码</span></span><br><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;http://www.baidu.com&#x27;</span></span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/116.0.0.0 Safari/537.36 Edg/116.0.1938.69&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">request = urllib.request.Request(url=url, headers=headers)</span><br><span class="line"></span><br><span class="line"><span class="comment"># handler build_opener open</span></span><br><span class="line"><span class="comment"># 1. 获取 handler 对象</span></span><br><span class="line">handler = urllib.request.HTTPHandler()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 通过 handler 获取 opener 对象</span></span><br><span class="line">opener = urllib.request.build_opener(handler)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 调用 open 方法</span></span><br><span class="line">response = opener.<span class="built_in">open</span>(request)</span><br><span class="line"></span><br><span class="line">content = response.read().decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(content)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-10-代理服务器"><a href="#2-10-代理服务器" class="headerlink" title="2.10 代理服务器"></a>2.10 代理服务器</h3><ul><li>代理<strong>常用功能</strong>：<ul><li>突破自身ip访问限制，访问国外站点</li><li>访问一些单位或团体内部资源<ul><li>某大学FTP（前提是该代理地址在该资源的允许访问范围之内），使用教育网内地址免费代理服务器，就可以用于对教育网开房的各类FTP下载上传，以及各类资料查询共享等服务</li></ul></li><li>提高访问速度 <ul><li>扩展：通常代理服务器都设置一个较大的硬盘缓冲区，当有外界的信息通过时，同时也将其保存到缓冲区中，当其他用户再访问相同的信息时，则直接由缓冲区取出信息，传给用户，以提高访问速度</li></ul></li><li>隐藏真实ip</li></ul></li><li><strong>代码配置代理</strong>：</li></ul><blockquote><p>创建Reuqest对象</p><p>创建ProxyHandler对象</p><p>用handler对象创建opener对象</p><p>使用opener.open函数发送请求</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;https://www.baidu.com/s?wd=ip&#x27;</span></span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/116.0.0.0 Safari/537.36 Edg/116.0.1938.69&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Cookie&#x27;</span>: <span class="string">&#x27;BDUSS=E5yeFZUSFRyTUxzUEhVbXhzUkZOV3lyeDlGLUMyVWFranBDNlRiV21tTWlnRDVrSVFBQUFBJCQAAAAAAAAAAAEAAAB~ymGB06O7qGNhbzAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACLzFmQi8xZkT; BDUSS_BFESS=E5yeFZUSFRyTUxzUEhVbXhzUkZOV3lyeDlGLUMyVWFranBDNlRiV21tTWlnRDVrSVFBQUFBJCQAAAAAAAAAAAEAAAB~ymGB06O7qGNhbzAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACLzFmQi8xZkT; BIDUPSID=B26B49048A0C9099B1456DF64F0279FF; PSTM=1684546051; BAIDUID=C70948D5D545EED0115F390D9D6C8143:SL=0:NR=10:FG=1; BD_UPN=12314753; BDORZ=B490B5EBF6F3CD402E515D22BCDA1598; BDRCVFR[feWj1Vr5u3D]=I67x6TjHwwYf0; delPer=0; BD_CK_SAM=1; PSINO=5; BAIDUID_BFESS=C70948D5D545EED0115F390D9D6C8143:SL=0:NR=10:FG=1; BA_HECTOR=ag01ag2g8k2hak81242k81001ihcet51p; ZFY=Y15oe:ADDl8fuenODkzShBnht8X9gotT2rS2ZtSq05IQ:C; B64_BOT=1; sug=3; sugstore=0; ORIGIN=2; bdime=21111; ab_sr=1.0.1_MWIwMmYyMmFmM2YxN2QyZGJjMTQ4YTRlNDU5NDBhY2YzNDY0OGIyNDFjZDcyOGIxNjBlNzZlZTIwYWUxMTk3MjBkNTMxMDhjOTU3ZmRmOWNlZDA3MjEwMjg1MzZlMzZkMmEyNWIzMjUxNWVlODE1YjRhOTAyYzllZTgzZDk0Yzc1MDg0YWE5ZTRlOWJkYzk1Yjg5N2M4ZTk3NDRjNWQ3MmNlOGI1ZGIyNGMxMzkzZDY4ZWQyNTA1MWIxZjZkOGEy; RT=&quot;z=1&amp;dm=baidu.com&amp;si=bee5a4dd-dfb0-43a8-8226-878c0904dd53&amp;ss=ln47d4cw&amp;sl=0&amp;tt=0&amp;bcn=https%3A%2F%2Ffclog.baidu.com%2Flog%2Fweirwood%3Ftype%3Dperf&amp;ul=1xd&amp;hd=1xx&quot;; H_PS_PSSID=39323_39353_39399_39396_39407_39097_39412_39436_39358_39308_39375_39233_39406_26350_39219_22158_39427; COOKIE_SESSION=0_0_0_0_1_0_1_0_0_0_0_0_0_0_3_0_1695967725_0_1695967722%7C1%230_0_1695967722%7C1&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 请求对象定制</span></span><br><span class="line">request = urllib.request.Request(url=url, headers=headers)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 模拟浏览器访问服务器</span></span><br><span class="line"><span class="comment"># response=urllib.request.urlopen(request)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用代理 ip 进行访问, 以字典形式存在</span></span><br><span class="line">proxies = &#123;</span><br><span class="line">    <span class="string">&#x27;http&#x27;</span>: <span class="string">&#x27;221.4.241.198:9091&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># handler build_opener open</span></span><br><span class="line">handler = urllib.request.ProxyHandler(proxies=proxies)</span><br><span class="line">opener = urllib.request.build_opener(handler)</span><br><span class="line">response = opener.<span class="built_in">open</span>(request)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获得响应信息</span></span><br><span class="line">content = response.read().decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存本地</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;proxy.html&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> fp:</span><br><span class="line">    fp.write(content)</span><br></pre></td></tr></table></figure><h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><blockquote><p>之前在urlib的学习中，我们能将网页的网页源码爬取下来。但是我们我们仅仅需要其中的部分数据，此时就需要引入新的概念——解析。</p><p>目前使用最多的解析方法包括xpath、JsonPath、BeautifulSoup等。</p><p>参考：<a href="https://blog.csdn.net/m0_60146935/article/details/132137743">Python爬虫的解析（学习于b站尚硅谷）_知乎云烟的博客-CSDN博客</a>  </p></blockquote><h2 id="1-xpath"><a href="#1-xpath" class="headerlink" title="1. xpath"></a>1. xpath</h2><h3 id="1-1-xpath-插件安装"><a href="#1-1-xpath-插件安装" class="headerlink" title="1.1 xpath 插件安装"></a>1.1 xpath 插件安装</h3><ul><li><p>如果是在 <strong>google 浏览器上</strong></p><ul><li>就直接将网盘里的 xpath.zip 拖到扩展程序里面</li></ul><p><img src="/../img/Spider%E5%85%A5%E9%97%A8.assets/1695974655310.png" alt="1695974655310"></p><p><img src="/../img/Spider%E5%85%A5%E9%97%A8.assets/1695974736550.png" alt="1695974736550"></p><ul><li>然后打开任意一个网页，按住快捷键 <code>ctrl+shift+x</code> 即可出现调试工具</li></ul><p><img src="/../img/Spider%E5%85%A5%E9%97%A8.assets/1695974754513.png" alt="1695974754513"></p></li><li><p>如果是在 <strong>edge 浏览器上</strong>，参考教程：<a href="https://blog.csdn.net/qq_59153970/article/details/125252748">在Edge中使用Xpath——更改快捷键_edge xpath_鹤行川.的博客-CSDN博客</a> </p><ul><li><p>由于Xpath的快捷键 <code>Ctrl+Shift+X</code> 已经被一个叫做Web选择的功能占用（这个功能可以复制不让复制的页面内容！！震惊，才知道！），所以先下载下来修改快捷键后的 xpath 版本</p><p><img src="/../img/Spider%E5%85%A5%E9%97%A8.assets/1695975202488.png" alt="1695975202488"></p></li><li><p>然后打开 edge 的扩展功能，同时开启<strong>开发人员模式</strong>，解压后拖入即可，使用快捷键 <code>ctrl+alt+X</code> 即可打开调试窗口，注意插件的文件不要乱移位置</p><p><img src="/../img/Spider%E5%85%A5%E9%97%A8.assets/1695975389083.png" alt="1695975389083"></p><p><img src="/../img/Spider%E5%85%A5%E9%97%A8.assets/1695985804035.png" alt="1695985804035"></p></li></ul></li></ul><h3 id="1-2-xpath-基本使用"><a href="#1-2-xpath-基本使用" class="headerlink" title="1.2 xpath 基本使用"></a>1.2 xpath 基本使用</h3><h4 id="1-2-1-lxml-库的安装"><a href="#1-2-1-lxml-库的安装" class="headerlink" title="1.2.1 lxml 库的安装"></a>1.2.1 lxml 库的安装</h4><ul><li><p>还需要安装一个库 <code>lxml</code> 才能用：</p><p><code>pip install lxml -i https://pypi.douban.com/simple</code></p></li><li><p>这个库的<strong>安装路径需要在你目前项目所用的 python 解释器的目录下边</strong></p></li></ul><p><img src="/../img/Spider%E5%85%A5%E9%97%A8.assets/1695975654857.png" alt="1695975654857"></p><ul><li>输入命令进行安装</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd Scripts</span><br><span class="line">pip install lxml</span><br></pre></td></tr></table></figure><p><img src="/../img/Spider%E5%85%A5%E9%97%A8.assets/1695975901027.png" alt="1695975901027"></p><p><img src="/../img/Spider%E5%85%A5%E9%97%A8.assets/1695976053768.png" alt="1695976053768"></p><ul><li>导入验证：<code>from lxml import etree</code></li></ul><h4 id="1-2-2-xpath-解析"><a href="#1-2-2-xpath-解析" class="headerlink" title="1.2.2 xpath 解析"></a>1.2.2 xpath 解析</h4><ul><li><strong>解析什么</strong>？<ul><li>本地文件<ul><li><code>etree.parse(&#39;XX.html&#39;) </code></li></ul></li><li><strong>服务器响应的数据</strong><ul><li><code>etree.HTML(response.read().decode(&#39;utf‐8&#39;)</code></li><li>实际这种情况用的多</li></ul></li></ul></li><li>xpath <strong>基本语法</strong>：</li></ul><p><img src="/../img/Spider%E5%85%A5%E9%97%A8.assets/1695976852724.png" alt="1695976852724"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"></span><br><span class="line"><span class="comment"># xpath 解析</span></span><br><span class="line"><span class="comment"># 1. 本地文件  etree.parse(&#x27;XX.html&#x27;)</span></span><br><span class="line"><span class="comment"># 2. 服务器响应的数据 etree.HTML(response.read().decode(&#x27;utf‐8&#x27;) 实际这种情况用的多</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. xpath 解析本地文件</span></span><br><span class="line">tree = etree.parse(<span class="string">&#x27;01_xpath.html&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 补充: xpath 语法</span></span><br><span class="line"><span class="comment"># (1) tree.xpath(&#x27;xpath路径&#x27;)  `//`代表子孙, `/`代表孙子</span></span><br><span class="line"><span class="comment"># eg1. 查找 ul 下面的 li</span></span><br><span class="line">li_list = tree.xpath(<span class="string">&#x27;//body/ul/li&#x27;</span>)  <span class="comment"># 此处也可以写 //body//li</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(li_list))  <span class="comment"># 判断列表的长度</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># (2) 谓词查询 `//div[@id]`  `//div[@id=&quot;maincontent&quot;]`</span></span><br><span class="line"><span class="comment"># eg2.1 查找所有有 id 属性的 li 标签</span></span><br><span class="line"><span class="comment"># test() 可用于获取标签中的内容</span></span><br><span class="line">li_list = tree.xpath(<span class="string">&#x27;//ul/li[@id]/text()&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(li_list)  <span class="comment"># [&#x27;北京&#x27;, &#x27;上海&#x27;]</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(li_list))  <span class="comment"># 2</span></span><br><span class="line"><span class="comment"># eg2.2 查找id为l1的li标签, 注意引号的问题</span></span><br><span class="line">li_list = tree.xpath(<span class="string">&#x27;//ul/li[@id=&quot;l1&quot;]/text()&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(li_list)  <span class="comment"># [&#x27;北京&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># (3) 属性查询</span></span><br><span class="line"><span class="comment"># eg3. 查找id为l1的li标签的class的属性值</span></span><br><span class="line">li = tree.xpath(<span class="string">&#x27;//ul/li[@id=&quot;l1&quot;]/@class&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># (4) 模糊查询（用的不多）</span></span><br><span class="line"><span class="comment"># eg4.1 查询id中包含l的li标签</span></span><br><span class="line">li_list = tree.xpath(<span class="string">&#x27;//ul/li[contains(@id, &quot;l&quot;)]/text()&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(li_list)  <span class="comment"># [&#x27;北京&#x27;, &#x27;上海&#x27;]</span></span><br><span class="line"><span class="comment"># eg4.2 查询id的值以c开头的li标签</span></span><br><span class="line">li_list = tree.xpath(<span class="string">&#x27;//ul/li[starts-with(@id, &quot;c&quot;)]/text()&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="1-3-获取百度页面的-百度一下-四个字"><a href="#1-3-获取百度页面的-百度一下-四个字" class="headerlink" title="1.3 获取百度页面的 百度一下 四个字"></a>1.3 获取百度页面的 百度一下 四个字</h3><ul><li>先获取页面的源码，找到 <code>百度一下</code> 四个字的所在位置</li></ul><p><code>&lt;span class=&quot;s_btn_wr&quot;&gt;&lt;input type=&quot;submit&quot; id=&quot;su&quot; value=&quot;百度一下&quot; class=&quot;bg s_btn&quot;&gt;</code></p><p><img src="/../img/Spider%E5%85%A5%E9%97%A8.assets/1695978716209.png" alt="1695978716209"></p><ul><li>用xpath插件进行调试，可以找到合适的获得我们想要的数据的路径</li></ul><p><img src="/../img/Spider%E5%85%A5%E9%97%A8.assets/1695979216574.png" alt="1695979216574"></p><ul><li><strong>代码实现</strong>：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 获取网页的源码</span></span><br><span class="line"><span class="comment"># 2. 解析  解析的是服务器响应的文件, 用 etree.HTML()</span></span><br><span class="line"><span class="comment"># 3. 打印</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 获取网页源码</span></span><br><span class="line">url = <span class="string">&#x27;https://www.baidu.com/&#x27;</span></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/116.0.0.0 Safari/537.36 Edg/116.0.1938.69&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Cookie&#x27;</span>: <span class="string">&#x27;BDUSS=E5yeFZUSFRyTUxzUEhVbXhzUkZOV3lyeDlGLUMyVWFranBDNlRiV21tTWlnRDVrSVFBQUFBJCQAAAAAAAAAAAEAAAB~ymGB06O7qGNhbzAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACLzFmQi8xZkT; BDUSS_BFESS=E5yeFZUSFRyTUxzUEhVbXhzUkZOV3lyeDlGLUMyVWFranBDNlRiV21tTWlnRDVrSVFBQUFBJCQAAAAAAAAAAAEAAAB~ymGB06O7qGNhbzAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACLzFmQi8xZkT; BIDUPSID=B26B49048A0C9099B1456DF64F0279FF; PSTM=1684546051; BAIDUID=C70948D5D545EED0115F390D9D6C8143:SL=0:NR=10:FG=1; BD_UPN=12314753; BDORZ=B490B5EBF6F3CD402E515D22BCDA1598; BDRCVFR[feWj1Vr5u3D]=I67x6TjHwwYf0; delPer=0; BD_CK_SAM=1; PSINO=5; BAIDUID_BFESS=C70948D5D545EED0115F390D9D6C8143:SL=0:NR=10:FG=1; BA_HECTOR=ag01ag2g8k2hak81242k81001ihcet51p; B64_BOT=1; sug=3; sugstore=0; ORIGIN=2; bdime=21111; RT=&quot;z=1&amp;dm=baidu.com&amp;si=bee5a4dd-dfb0-43a8-8226-878c0904dd53&amp;ss=ln47d4cw&amp;sl=0&amp;tt=0&amp;bcn=https%3A%2F%2Ffclog.baidu.com%2Flog%2Fweirwood%3Ftype%3Dperf&amp;ul=1xd&amp;hd=1xx&quot;; COOKIE_SESSION=0_0_0_0_1_0_1_0_0_0_0_0_0_0_3_0_1695967725_0_1695967722%7C1%230_0_1695967722%7C1; ZFY=jKLYva:AwW:AlQpwrTh6Gt4SREDbR7NGeps2ei6L3zLXg:C; H_PS_PSSID=39323_39353_39399_39396_39407_39097_39412_39436_39358_39308_39375_39233_39406_26350_39219_22158_39427; baikeVisitId=50aa753e-979e-40e9-b6dc-b1730a994990; ab_sr=1.0.1_MDJlMTU2MDk2ZWFlYTMyNmQ2Njc5OWJjYzIwOGJjZDE2MjUwOWQyOTMxMDc5N2I2ZmJhZjczMjkyZjg5YzQ0MjAxYzUyZGEwZDU5MGY5NmZmNmMzZDgwNDkwOGQ5YTBmNTg2MGQ5ZjE0ZWVkNmUxMjUzZGY3NDU4MzZhYTU3NjMzYmVmOTg1NzZkNTQ4OTJkZjlhNThkZjAxNzExMTBjOTAxODlmODI3Nzg3ZGQwNGVkMzc1M2JkOWI5NTNlNmQ2&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 1.1 请求对象的定制</span></span><br><span class="line">request = urllib.request.Request(url=url, headers=headers)</span><br><span class="line"><span class="comment"># 1.2 模拟浏览器访问服务器</span></span><br><span class="line">response = urllib.request.urlopen(request)</span><br><span class="line"><span class="comment"># 1.3 获取网页源码</span></span><br><span class="line">content = response.read().decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"><span class="comment"># print(content)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 解析网页源码, 获取我们想要的数据</span></span><br><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.1 解析服务器响应的文件</span></span><br><span class="line">tree = etree.HTML(content)</span><br><span class="line"><span class="comment"># 2.2 获取想要的数据 用那个xpath插件调试寻找正确的路径 xpath的返回值是一个列表类型的数据, 所以加上[0], 即可得到纯正的四个大字</span></span><br><span class="line">result = tree.xpath(<span class="string">&#x27;//input[@id=&quot;su&quot;]/@value&#x27;</span>)[<span class="number">0</span>]  <span class="comment"># 百度一下</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure><h3 id="1-4-站长素材-含懒加载、如何下载其中的高清图"><a href="#1-4-站长素材-含懒加载、如何下载其中的高清图" class="headerlink" title="1.4 站长素材(含懒加载、如何下载其中的高清图)"></a>1.4 站长素材(含懒加载、如何下载其中的高清图)</h3><ul><li><p>网址：<code>https://sc.chinaz.com/</code></p></li><li><p>xpath 调试获取图片的地址和alt值，但是这里好像返回的和页面中的不太一样，最后输出的结果为空，还是直接打印出 content 之后用 ctrl+F 查找吧</p><p><img src="/../img/Spider%E5%85%A5%E9%97%A8.assets/1695984242783.png" alt="1695984242783"></p><p><img src="/../img/Spider%E5%85%A5%E9%97%A8.assets/1695984267881.png" alt="1695984267881"></p></li></ul><p><code>//div[@class=&#39;item masonry-brick&#39;]/img/@data-original</code></p><p><img src="/../img/Spider%E5%85%A5%E9%97%A8.assets/1695983936153.png" alt="1695983936153"></p><p><code>//div[@class=&#39;item masonry-brick&#39;]/img/@alt</code></p><p><img src="/../img/Spider%E5%85%A5%E9%97%A8.assets/1695983993986.png" alt="1695983993986"></p><ul><li><strong>代码实现</strong>：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 请求对象的定制</span></span><br><span class="line"><span class="comment"># 2. 获取网页源码</span></span><br><span class="line"><span class="comment"># 3. 下载</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 需求: 下载前十页的图片</span></span><br><span class="line"><span class="comment"># 第一页的地址</span></span><br><span class="line"><span class="comment"># https://sc.chinaz.com/tupian/taikongkexuetupian.html</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二页的地址</span></span><br><span class="line"><span class="comment"># https://sc.chinaz.com/tupian/taikongkexuetupian_2.html</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 分析: 除了第一页和其他页不一样, 其他页的末尾都是 _page</span></span><br><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 请求对象的定制</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">creat_request</span>(<span class="params">page</span>):</span><br><span class="line">    <span class="keyword">if</span> page == <span class="number">1</span>:</span><br><span class="line">        url = <span class="string">&#x27;https://sc.chinaz.com/tupian/taikongkexuetupian.html&#x27;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 每页的 url 不同</span></span><br><span class="line">        url = <span class="string">&#x27;https://sc.chinaz.com/tupian/taikongkexuetupian_&#x27;</span> + <span class="built_in">str</span>(page) + <span class="string">&#x27;.html&#x27;</span></span><br><span class="line">    <span class="built_in">print</span>(url)</span><br><span class="line"></span><br><span class="line">    headers = &#123;</span><br><span class="line">        <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/116.0.0.0 Safari/537.36 Edg/116.0.1938.69&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    request = urllib.request.Request(url=url, headers=headers)</span><br><span class="line">    <span class="keyword">return</span> request</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.获取网页的源码</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_content</span>(<span class="params">request</span>):</span><br><span class="line">    response = urllib.request.urlopen(request)</span><br><span class="line">    content = response.read().decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    <span class="comment"># print(content)</span></span><br><span class="line">    <span class="keyword">return</span> content</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.下载数据到本地</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">down_load</span>(<span class="params">content</span>):</span><br><span class="line">    <span class="comment"># 下载图片, 需要图片地址(在网页源码中获取)和文件的名字(在 alt 中获取)</span></span><br><span class="line">    <span class="comment"># 那么就需要用到 xpath 进行解析</span></span><br><span class="line">    tree = etree.HTML(content)</span><br><span class="line">    <span class="comment"># 获取 alt 属性</span></span><br><span class="line">    name_list = tree.xpath(<span class="string">&#x27;//div[@class=&quot;item&quot;]/img/@alt&#x27;</span>)</span><br><span class="line">    <span class="comment"># 获取图片地址, 此处注意有的设计图片的网站会进行懒加载, 原先属性名可能是src2,需要等待你滑倒那个位置才会变成src,所以要用src2去获取</span></span><br><span class="line">    src_list = tree.xpath(<span class="string">&#x27;//div[@class=&quot;item&quot;]/img/@data-original&#x27;</span>)</span><br><span class="line">    <span class="comment"># print(len(src_list))  # 40</span></span><br><span class="line">    <span class="comment"># print(len(name_list))  # 40</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 遍历下载每一张图片</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(name_list)):</span><br><span class="line">        name = name_list[i]</span><br><span class="line">        src = src_list[i]</span><br><span class="line">        <span class="comment"># print(name, src)  # 冬日唯美星空图片 //scpic2.chinaz.net/files/default/imgs/2023-03-01/0b5c5cf3cc6bb41d_s.jpg</span></span><br><span class="line">        <span class="comment"># 注意返回的地址前面省略了 https: 需要补上才可以下载</span></span><br><span class="line">        url = <span class="string">&#x27;https:&#x27;</span> + src</span><br><span class="line">        <span class="built_in">print</span>(name, url)</span><br><span class="line"></span><br><span class="line">        urllib.request.urlretrieve(url, filename=<span class="string">&#x27;./img/&#x27;</span> + name + <span class="string">&#x27;.jpg&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    start_page = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;请输入起始的页码: &#x27;</span>))</span><br><span class="line">    end_page = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;请输入结束的页码: &#x27;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 遍历</span></span><br><span class="line">    <span class="keyword">for</span> page <span class="keyword">in</span> <span class="built_in">range</span>(start_page, end_page + <span class="number">1</span>):</span><br><span class="line">        <span class="comment"># 1. 请求对象的定制</span></span><br><span class="line">        request = creat_request(page)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 2. 获取网页的源码</span></span><br><span class="line">        content = get_content(request)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 下载数据</span></span><br><span class="line">        down_load(content)</span><br></pre></td></tr></table></figure><h2 id="2-JsonPath"><a href="#2-JsonPath" class="headerlink" title="2. JsonPath"></a>2. JsonPath</h2><blockquote><p>JsonPath 适用于<strong>解析网页源码的返回值为Json数据的网站</strong></p><p>比如打开“淘票票”：<code>https://dianying.taobao.com/</code>，按F12 打开检查，点到网络。然后点击“淘票票”中的城市，会得到一个网络包，发现它是一个Json数据。后面我们将爬取该数据包存储的淘票票支持的城市 </p></blockquote><h3 id="2-1-基本介绍"><a href="#2-1-基本介绍" class="headerlink" title="2.1 基本介绍"></a>2.1 基本介绍</h3><h4 id="2-1-1-安装及使用"><a href="#2-1-1-安装及使用" class="headerlink" title="2.1.1 安装及使用"></a>2.1.1 安装及使用</h4><blockquote><p>jsonpath <strong>只能解析本地文件，不能解析服务器响应的文件</strong></p></blockquote><ul><li>pip 安装：<code>pip install jsonpath</code></li></ul><p><img src="/../img/Spider%E5%85%A5%E9%97%A8.assets/1695985926957.png" alt="1695985926957"></p><ul><li>jsonpath 的使用：<ul><li>导入 <code>import jsonpath</code></li><li><code>obj = json.load(open(&#39;json文件&#39;, &#39;r&#39;, encoding=&#39;utf-8&#39;))</code></li><li><code>ret = jsonpath.jsonpath(obj, &#39;jsonpath语法&#39;)</code></li></ul></li></ul><h4 id="2-1-2-基本语法-与-xpath-对比"><a href="#2-1-2-基本语法-与-xpath-对比" class="headerlink" title="2.1.2 基本语法(与 xpath 对比)"></a>2.1.2 基本语法(与 xpath 对比)</h4><blockquote><p>参考：<a href="https://blog.csdn.net/luxideyao/article/details/77802389">JSONPath-简单入门-CSDN博客</a> </p></blockquote><p><img src="/../img/Spider%E5%85%A5%E9%97%A8.assets/1695985322714.png" alt="1695985322714"></p><h4 id="2-1-3-基本使用"><a href="#2-1-3-基本使用" class="headerlink" title="2.1.3 基本使用"></a>2.1.3 基本使用</h4><ul><li>已知有如下的json文件</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;store&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;book&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="punctuation">&#123;</span> <span class="attr">&quot;category&quot;</span><span class="punctuation">:</span> <span class="string">&quot;reference&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;author&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Nigel Rees&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Sayings of the Century&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;price&quot;</span><span class="punctuation">:</span> <span class="number">8.95</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="punctuation">&#123;</span> <span class="attr">&quot;category&quot;</span><span class="punctuation">:</span> <span class="string">&quot;fiction&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;author&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Evelyn Waugh&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Sword of Honour&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;price&quot;</span><span class="punctuation">:</span> <span class="number">12.99</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="punctuation">&#123;</span> <span class="attr">&quot;category&quot;</span><span class="punctuation">:</span> <span class="string">&quot;fiction&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;author&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Herman Melville&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Moby Dick&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;isbn&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0-553-21311-3&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;price&quot;</span><span class="punctuation">:</span> <span class="number">8.99</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="punctuation">&#123;</span> <span class="attr">&quot;category&quot;</span><span class="punctuation">:</span> <span class="string">&quot;fiction&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;author&quot;</span><span class="punctuation">:</span> <span class="string">&quot;J. R. R. Tolkien&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="string">&quot;The Lord of the Rings&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;isbn&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0-395-19395-8&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;price&quot;</span><span class="punctuation">:</span> <span class="number">22.99</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;bicycle&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;color&quot;</span><span class="punctuation">:</span> <span class="string">&quot;red&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;price&quot;</span><span class="punctuation">:</span> <span class="number">19.95</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><ul><li>用jsonpath代码实现爬取数据：</li></ul><p><img src="/../img/Spider%E5%85%A5%E9%97%A8.assets/1695986122236.png" alt="1695986122236"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> jsonpath</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取本地的 json 文件</span></span><br><span class="line">obj = json.load(<span class="built_in">open</span>(<span class="string">&#x27;04_jsonpath_store.json&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(obj)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 爬取书店所有书的作者, 如果只要特定的第几本书, 可以这样写, 如第一本书: &#x27;$.store.book[0].author&#x27;</span></span><br><span class="line">author_list = jsonpath.jsonpath(obj, <span class="string">&#x27;$.store.book[*].author&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(author_list)  <span class="comment"># [&#x27;Nigel Rees&#x27;, &#x27;Evelyn Waugh&#x27;, &#x27;Herman Melville&#x27;, &#x27;J. R. R. Tolkien&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 所有的作者</span></span><br><span class="line">author_list = jsonpath.jsonpath(obj, <span class="string">&#x27;$..author&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(author_list)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. store 下面的所有的元素</span></span><br><span class="line">tag_list = jsonpath.jsonpath(obj, <span class="string">&#x27;$.store.*&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(tag_list)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. store 里面所有东西的 price</span></span><br><span class="line">price_list = jsonpath.jsonpath(obj, <span class="string">&#x27;$.store..price&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(price_list)  <span class="comment"># [8.95, 12.99, 8.99, 22.99, 19.95]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. 第三个书</span></span><br><span class="line">book = jsonpath.jsonpath(obj, <span class="string">&#x27;$..book[2]&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(book)</span><br><span class="line"><span class="comment"># [&#123;&#x27;category&#x27;: &#x27;fiction&#x27;, &#x27;author&#x27;: &#x27;Herman Melville&#x27;, &#x27;title&#x27;: &#x27;Moby Dick&#x27;, &#x27;isbn&#x27;: &#x27;0-553-21311-3&#x27;, &#x27;price&#x27;: 8.99&#125;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 6. 最后一本书</span></span><br><span class="line">book = jsonpath.jsonpath(obj, <span class="string">&#x27;$..book[(@.length-1)]&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(book)</span><br><span class="line"><span class="comment"># [&#123;&#x27;category&#x27;: &#x27;fiction&#x27;, &#x27;author&#x27;: &#x27;J. R. R. Tolkien&#x27;, &#x27;title&#x27;: &#x27;The Lord of the Rings&#x27;, &#x27;isbn&#x27;: &#x27;0-395-19395-8&#x27;, &#x27;price&#x27;: 22.99&#125;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 7. 前两本书</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;-------&#x27;</span>)</span><br><span class="line"><span class="comment"># 注意这里[0,1]之间不可以有空格</span></span><br><span class="line">book_list = jsonpath.jsonpath(obj, <span class="string">&#x27;$..book[0,1]&#x27;</span>)</span><br><span class="line"><span class="comment"># 或者 book_list = jsonpath.jsonpath(obj, &#x27;$..book[:2]&#x27;)</span></span><br><span class="line"><span class="built_in">print</span>(book_list)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 8. 过滤出所有包含版本号 isbn 的书（条件过滤, 需要加个问号）</span></span><br><span class="line">book_list = jsonpath.jsonpath(obj, <span class="string">&#x27;$..book[?(@.isbn)]&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(book_list)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 9. 哪本书超过了10块钱</span></span><br><span class="line">book_list = jsonpath.jsonpath(obj, <span class="string">&#x27;$..book[?(@.price&gt;10)]&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(book_list)</span><br></pre></td></tr></table></figure><h3 id="2-2-JsonPath-解析淘票票"><a href="#2-2-JsonPath-解析淘票票" class="headerlink" title="2.2 JsonPath 解析淘票票"></a>2.2 JsonPath 解析淘票票</h3><ul><li><p>网址：<code>https://dianying.taobao.com/ </code></p></li><li><p>需求：获取所有的能买票的城市信息</p><ul><li><p>找接口，看下会不会有些反爬，请求地址：</p><p><code>https://dianying.taobao.com/cityAction.json?activityId&amp;_ksTS=1695987569488_108&amp;jsoncallback=jsonp109&amp;action=cityAction&amp;n_s=new&amp;event_submit_doGetAllRegion=true</code></p><p><img src="/../img/Spider%E5%85%A5%E9%97%A8.assets/1695987733171.png" alt="1695987733171"></p></li><li><p>访问一下，发现没给我们数据，应该是做了限制，不仅仅只校验UA，待会在请求头里我们还要给它点东西</p><p><img src="/../img/Spider%E5%85%A5%E9%97%A8.assets/1695987705920.png" alt="1695987705920"></p></li><li><p>复制所有请求头，尝试下</p></li></ul></li><li><p>代码实现</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;https://dianying.taobao.com/cityAction.json?activityId&amp;_ksTS=1695987569488_108&amp;jsoncallback=jsonp109&amp;action=cityAction&amp;n_s=new&amp;event_submit_doGetAllRegion=true&#x27;</span></span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&#x27;Accept&#x27;</span>: <span class="string">&#x27;text/javascript, application/javascript, application/ecmascript, application/x-ecmascript, */*; q=0.01&#x27;</span>,</span><br><span class="line">    <span class="comment"># &#x27;Accept-Encoding&#x27;: &#x27;gzip, deflate, br&#x27;,</span></span><br><span class="line">    <span class="string">&#x27;Accept-Language&#x27;</span>: <span class="string">&#x27;zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Bx-V&#x27;</span>: <span class="string">&#x27;2.5.3&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Cache-Control&#x27;</span>: <span class="string">&#x27;no-cache&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Cookie&#x27;</span>: <span class="string">&#x27;t=7cec2d4496f4b4f1e67f2b3781af9f07; cookie2=1a7dff465bd9981f135e2c3fa2c17538; v=0; _tb_token_=e17995433ee3e; cna=IJqeHFQN328BASQOBHM61WKq; xlly_s=1; tfstk=d499nsXEs20geUMNDShngOneRDnntdKZjF-7nZbgGeLpzFnNi5AMMrQpVc7igf8v9ETFsN9v0-IXcEoNoclHbhWVh40kkYxwbMatr4VCK8uh3tgorW2f_YB2ySUCsTrU--aUYRvMHGG4F89vkS6fX1QYnwex8mjO6dx1J4g5Qo9keZM_raI01DnLgS51YN4Rrb1..; l=fBIl_TtePNX1FeifBOfwnurza77OhIRAguPzaNbMi9fP_JCH5QTlW1HPceLMCnGVFsewR3rNfwdWBeYBqC2sjqj4axom45HmnmOk-Wf..; isg=BGBg3JJQEbUhTK2xJ5kiT7IFMW4yaUQz8Y4DhdpxQnsO1QD_gnjDw3rrbX3V5fwL&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Pragma&#x27;</span>: <span class="string">&#x27;no-cache&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Referer&#x27;</span>: <span class="string">&#x27;https://dianying.taobao.com/&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Sec-Ch-Ua&#x27;</span>: <span class="string">&#x27;&quot;Chromium&quot;;v=&quot;116&quot;, &quot;Not)A;Brand&quot;;v=&quot;24&quot;, &quot;Microsoft Edge&quot;;v=&quot;116&quot;&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Sec-Ch-Ua-Mobile&#x27;</span>: <span class="string">&#x27;?0&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Sec-Ch-Ua-Platform&#x27;</span>: <span class="string">&#x27;&quot;Windows&quot;&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Sec-Fetch-Dest&#x27;</span>: <span class="string">&#x27;empty&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Sec-Fetch-Mode&#x27;</span>: <span class="string">&#x27;cors&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Sec-Fetch-Site&#x27;</span>: <span class="string">&#x27;same-origin&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/116.0.0.0 Safari/537.36 Edg/116.0.1938.69&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;X-Requested-With&#x27;</span>: <span class="string">&#x27;XMLHttpRequest&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">request = urllib.request.Request(url=url, headers=headers)</span><br><span class="line">response = urllib.request.urlopen(request)</span><br><span class="line"></span><br><span class="line">content = response.read().decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(content)  <span class="comment"># 获取到的 json 文件前面有 jsonp109(&#123;&quot;returnCode&quot;:&quot;0&quot;,&quot;ret...</span></span><br><span class="line"><span class="comment"># 也就是 jsonp, jsonp 是跨域的一种解决方案, 但是我们不要前面的这个以及末尾对应的圆括号</span></span><br><span class="line"><span class="comment"># 利用 split 对获取到的 json 串进行开头和末尾的切割</span></span><br><span class="line">content = content.split(<span class="string">&#x27;(&#x27;</span>)[<span class="number">1</span>].split(<span class="string">&#x27;)&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;05_jsonpath_ticket.json&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> fp:</span><br><span class="line">    fp.write(content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> jsonpath</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将前面下载下来的json数据的本地打开文件, 然后再用jsonpath进行筛选想要的数据</span></span><br><span class="line">obj = json.load(<span class="built_in">open</span>(<span class="string">&#x27;05_jsonpath_ticket.json&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line">city_list = jsonpath.jsonpath(obj, <span class="string">&#x27;$..regionName&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(city_list)  <span class="comment"># 成功获取所有的城市</span></span><br></pre></td></tr></table></figure><ul><li>成功获取到数据</li></ul><p><img src="/../img/Spider%E5%85%A5%E9%97%A8.assets/1695988630074.png" alt="1695988630074"></p><ul><li>然后用 jsonpath 对保存到本地的json文件进行解析，筛选我们想要的所有的城市列表：</li></ul><p><img src="/../img/Spider%E5%85%A5%E9%97%A8.assets/1695988930026.png" alt="1695988930026"></p><h2 id="3-BeautifulSoup-即bs4"><a href="#3-BeautifulSoup-即bs4" class="headerlink" title="3. BeautifulSoup(即bs4)"></a>3. BeautifulSoup(即bs4)</h2><blockquote><p>和 xpath 是同一重量级的技术</p></blockquote><h3 id="3-1-基本使用"><a href="#3-1-基本使用" class="headerlink" title="3.1 基本使用"></a>3.1 基本使用</h3><h4 id="3-1-1-简介"><a href="#3-1-1-简介" class="headerlink" title="3.1.1 简介"></a>3.1.1 简介</h4><ul><li><p>和 lxml 一样，是一个 html 的解析器，主要功能也是解析和提取数据</p></li><li><p>优缺</p><ul><li>缺点：效率没有 lxml 高</li></ul><blockquote><p>这缺点感觉有点不太可</p></blockquote><ul><li>优点：接口设计人性化，使用方便</li></ul></li></ul><h4 id="3-1-2-安装及创建"><a href="#3-1-2-安装及创建" class="headerlink" title="3.1.2 安装及创建"></a>3.1.2 安装及创建</h4><ul><li>安装：<code>pip install bs4</code></li></ul><p><img src="/../img/Spider%E5%85%A5%E9%97%A8.assets/1695989570174.png" alt="1695989570174"></p><ul><li>导入：<code>from bs4 import BeautifulSoup</code></li><li>创建对象：<ul><li>服务器响应的文件生成对象：<code>soup = BeautifulSoup(response.read().decode(), &#39;lxml&#39;)</code></li><li>本地文件生成对象：<code>soup = BeautifulSoup(open(&#39;1.html&#39;), &#39;lxml&#39;)</code></li></ul></li></ul><h4 id="3-1-3-节点定位"><a href="#3-1-3-节点定位" class="headerlink" title="3.1.3 节点定位"></a>3.1.3 节点定位</h4><p><img src="/../img/Spider%E5%85%A5%E9%97%A8.assets/1695990102206.png" alt="1695990102206"></p><p><img src="/../img/Spider%E5%85%A5%E9%97%A8.assets/1695990133905.png" alt="1695990133905"></p><h4 id="3-1-4-节点信息"><a href="#3-1-4-节点信息" class="headerlink" title="3.1.4 节点信息"></a>3.1.4 节点信息</h4><p><img src="/../img/Spider%E5%85%A5%E9%97%A8.assets/1695990148101.png" alt="1695990148101"></p><h4 id="3-1-5-代码演示"><a href="#3-1-5-代码演示" class="headerlink" title="3.1.5 代码演示"></a>3.1.5 代码演示</h4><ul><li>html</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">&quot;l1&quot;</span>&gt;</span>张三<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">&quot;l2&quot;</span>&gt;</span>李四<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>王五<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&quot;</span> <span class="attr">class</span>=<span class="string">&quot;a1&quot;</span>&gt;</span>thr<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">span</span>&gt;</span>hhh<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&quot;</span> <span class="attr">title</span>=<span class="string">&quot;a2&quot;</span>&gt;</span>百度<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;d1&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span>&gt;</span></span><br><span class="line">            hahaha</span><br><span class="line">        <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;p1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;p1&quot;</span>&gt;</span>hehehe<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>py</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过解析本地文件来学习bs4的基础语法</span></span><br><span class="line"><span class="comment"># 记得指定编码格式, 默认打开的文件编码格式是 gbk</span></span><br><span class="line">soup = BeautifulSoup(<span class="built_in">open</span>(<span class="string">&#x27;06_bs4.html&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>), <span class="string">&#x27;lxml&#x27;</span>)</span><br><span class="line"><span class="comment"># print(soup)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># (一) 节点定位</span></span><br><span class="line"><span class="comment"># 1. 根据标签名字查找节点</span></span><br><span class="line"><span class="comment"># 找到的是第一个符合条件的数据</span></span><br><span class="line"><span class="built_in">print</span>(soup.a)  <span class="comment"># &lt;a href=&quot;&quot;&gt;thr&lt;/a&gt;</span></span><br><span class="line"><span class="comment"># 获取标签的属性和属性值</span></span><br><span class="line"><span class="built_in">print</span>(soup.a.attrs)  <span class="comment"># &#123;&#x27;href&#x27;: &#x27;&#x27;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. bs4 的一些函数</span></span><br><span class="line"><span class="comment"># 2.1 find</span></span><br><span class="line"><span class="comment"># 2.1.1 返回第一个符合条件的数据</span></span><br><span class="line"><span class="built_in">print</span>(soup.find(<span class="string">&#x27;a&#x27;</span>))  <span class="comment"># &lt;a href=&quot;&quot;&gt;thr&lt;/a&gt;</span></span><br><span class="line"><span class="comment"># 2.1.2 根据属性的值找到对应的标签对象</span></span><br><span class="line"><span class="built_in">print</span>(soup.find(<span class="string">&#x27;a&#x27;</span>, title=<span class="string">&#x27;a2&#x27;</span>))</span><br><span class="line"><span class="comment"># 2.1.3 由于 class 与关键字冲突, 因此加个下划线以示区别</span></span><br><span class="line"><span class="built_in">print</span>(soup.find(<span class="string">&#x27;a&#x27;</span>, class_=<span class="string">&#x27;a1&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.2 find_all</span></span><br><span class="line"><span class="comment"># 2.2.1 返回包含所有符合条件的标签对象的列表</span></span><br><span class="line"><span class="built_in">print</span>(soup.find_all(<span class="string">&#x27;a&#x27;</span>))  <span class="comment"># [&lt;a class=&quot;a1&quot; href=&quot;&quot;&gt;thr&lt;/a&gt;, &lt;a href=&quot;&quot; title=&quot;a2&quot;&gt;百度&lt;/a&gt;]</span></span><br><span class="line"><span class="comment"># 2.2.2 如果想获取的是多个标签的数据, 需要在find_all参数中添加列表的数据</span></span><br><span class="line"><span class="built_in">print</span>(soup.find_all([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;span&#x27;</span>]))</span><br><span class="line"><span class="comment"># 2.2.3 limit 参数可以查找前几个数据</span></span><br><span class="line"><span class="built_in">print</span>(soup.find_all(<span class="string">&#x27;li&#x27;</span>, limit=<span class="number">2</span>))  <span class="comment"># [&lt;li&gt;张三&lt;/li&gt;, &lt;li&gt;李四&lt;/li&gt;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.3 select(推荐, 但一般情况下会结合上面两种使用)</span></span><br><span class="line"><span class="comment"># 2.3.1 select 方法返回的是一个列表 并且返回多个数据</span></span><br><span class="line"><span class="built_in">print</span>(soup.select(<span class="string">&#x27;a&#x27;</span>))  <span class="comment"># [&lt;a class=&quot;a1&quot; href=&quot;&quot;&gt;thr&lt;/a&gt;, &lt;a href=&quot;&quot; title=&quot;a2&quot;&gt;百度&lt;/a&gt;]</span></span><br><span class="line"><span class="comment"># 2.3.2 可以通过 . 代表 class, 用类选择器的方法进行筛选</span></span><br><span class="line"><span class="built_in">print</span>(soup.select(<span class="string">&#x27;.a1&#x27;</span>))  <span class="comment"># &lt;a class=&quot;a1&quot; href=&quot;&quot;&gt;thr&lt;/a&gt;]</span></span><br><span class="line"><span class="comment"># 2.3.3 也可以用属性选择器进行筛选和查找（用的多些）</span></span><br><span class="line"><span class="built_in">print</span>(soup.select(<span class="string">&#x27;#l1&#x27;</span>))  <span class="comment"># [&lt;li id=&quot;l1&quot;&gt;张三&lt;/li&gt;]</span></span><br><span class="line"><span class="comment"># 2.3.4.1 查找 li 标签中有 id 属性的标签</span></span><br><span class="line"><span class="built_in">print</span>(soup.select(<span class="string">&#x27;li[id]&#x27;</span>))  <span class="comment"># [&lt;li id=&quot;l1&quot;&gt;张三&lt;/li&gt;, &lt;li id=&quot;l2&quot;&gt;李四&lt;/li&gt;]</span></span><br><span class="line"><span class="comment"># 2.3.4.2 查找 li 标签中 id 为 l2 的标签</span></span><br><span class="line"><span class="built_in">print</span>(soup.select(<span class="string">&#x27;li[id=&quot;l2&quot;]&#x27;</span>))  <span class="comment"># [&lt;li id=&quot;l2&quot;&gt;李四&lt;/li&gt;]</span></span><br><span class="line"><span class="comment"># 2.3.5 层级选择器 获取div下面的li的方式</span></span><br><span class="line"><span class="comment"># 2.3.5.1 后代选择器</span></span><br><span class="line"><span class="built_in">print</span>(soup.select(<span class="string">&#x27;div li&#x27;</span>))  <span class="comment"># [&lt;li id=&quot;l1&quot;&gt;张三&lt;/li&gt;, &lt;li id=&quot;l2&quot;&gt;李四&lt;/li&gt;, &lt;li&gt;王五&lt;/li&gt;]</span></span><br><span class="line"><span class="comment"># 2.3.5.2 子代选择器 注意: 很多的计算机编程语言中, 如果不加空格不会输出内容, 但在bs4中, 不会报错, 也会显示内容</span></span><br><span class="line"><span class="built_in">print</span>(soup.select(<span class="string">&#x27;div &gt; ul &gt; li&#x27;</span>))</span><br><span class="line"><span class="comment"># 2.3.2.3 找到a标签和li标签所有的对象</span></span><br><span class="line"><span class="built_in">print</span>(soup.select(<span class="string">&#x27;a,li&#x27;</span>))  <span class="comment"># [&lt;li id=&quot;l1&quot;&gt;张三&lt;/li&gt;, &lt;li id=&quot;l2&quot;&gt;李四&lt;/li&gt;, &lt;li&gt;王五&lt;/li&gt;, &lt;a class=&quot;a1&quot; href=&quot;&quot;&gt;thr&lt;/a&gt;, &lt;a href=&quot;&quot; title=&quot;a2&quot;&gt;百度&lt;/a&gt;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># (二) 节点信息</span></span><br><span class="line"><span class="comment"># 1. 获取节点内容</span></span><br><span class="line">obj = soup.select(<span class="string">&#x27;#d1&#x27;</span>)[<span class="number">0</span>]  <span class="comment"># 返回一个列表</span></span><br><span class="line"><span class="comment"># 如果标签对象中只有内容, 那么 string 和 get_text() 都可以使用</span></span><br><span class="line"><span class="comment"># 但是如果标签对象中除了内容还有标签, 那么 string 就获取不到数据, 而 get_text() 是可以获取数据的</span></span><br><span class="line"><span class="comment"># 一般情况下推荐 get_text()</span></span><br><span class="line"><span class="built_in">print</span>(obj.string)  <span class="comment"># None</span></span><br><span class="line"><span class="built_in">print</span>(obj.get_text())  <span class="comment"># hahaha</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 节点的属性</span></span><br><span class="line"><span class="comment"># 注意 select 返回的是列表！！</span></span><br><span class="line">obj = soup.select(<span class="string">&#x27;#p1&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line"><span class="comment"># name 是标签的名字</span></span><br><span class="line"><span class="built_in">print</span>(obj.name)  <span class="comment"># p</span></span><br><span class="line"><span class="comment"># attrs 是将属性值作为字典返回</span></span><br><span class="line"><span class="built_in">print</span>(obj.attrs)  <span class="comment"># &#123;&#x27;id&#x27;: &#x27;p1&#x27;, &#x27;class&#x27;: [&#x27;p1&#x27;]&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 获取节点属性 3中方式</span></span><br><span class="line">obj = soup.select(<span class="string">&#x27;#p1&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(obj.attrs.get(<span class="string">&#x27;class&#x27;</span>))  <span class="comment"># [&#x27;p1&#x27;] 推荐这种</span></span><br><span class="line"><span class="built_in">print</span>(obj.get(<span class="string">&#x27;class&#x27;</span>))  <span class="comment"># [&#x27;p1&#x27;]</span></span><br><span class="line"><span class="built_in">print</span>(obj[<span class="string">&#x27;class&#x27;</span>])  <span class="comment"># [&#x27;p1&#x27;]</span></span><br></pre></td></tr></table></figure><h3 id="3-2-bs4-爬取星巴克数据"><a href="#3-2-bs4-爬取星巴克数据" class="headerlink" title="3.2 bs4 爬取星巴克数据"></a>3.2 bs4 爬取星巴克数据</h3><blockquote><p>主要学习如何抓取服务器响应的文件</p><p>把菜单部分的图片以及产品的名字抓取并保存：</p><p><code>https://www.starbucks.com.cn/menu/</code></p></blockquote><ul><li><p>抓接口，看下只有一页，比较容易，找到接口：</p><p><code>https://www.starbucks.com.cn/menu/ </code></p></li></ul><p><img src="/../img/Spider%E5%85%A5%E9%97%A8.assets/1696036608147.png" alt="1696036608147"></p><ul><li>先写 xpath 语法，再改成 bs4</li></ul><p><img src="/../img/Spider%E5%85%A5%E9%97%A8.assets/1696037282802.png" alt="1696037282802"></p><ul><li>抓取图片有点难，需要分析并拼接url</li></ul><p><img src="/../img/Spider%E5%85%A5%E9%97%A8.assets/1696038072885.png" alt="1696038072885"></p><p><img src="/../img/Spider%E5%85%A5%E9%97%A8.assets/1696038098710.png" alt="1696038098710"></p><ul><li>代码示例：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;https://www.starbucks.com.cn/menu/&#x27;</span></span><br><span class="line"></span><br><span class="line">response = urllib.request.urlopen(url)</span><br><span class="line">content = response.read().decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"><span class="comment"># print(content)  # 没做反爬, 直接拿到源码</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 进行解析</span></span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 加载服务器响应文件</span></span><br><span class="line">soup = BeautifulSoup(content, <span class="string">&#x27;lxml&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. xpath 语法: //ul[@class=&quot;grid padded-3 product&quot;]//strong/text()</span></span><br><span class="line">name_list = soup.select(<span class="string">&#x27;ul[class=&quot;grid padded-3 product&quot;] strong&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> name_list:</span><br><span class="line">    <span class="built_in">print</span>(name.string)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 爬取图片</span></span><br><span class="line">pic_list = soup.select(<span class="string">&#x27;ul[class=&quot;grid padded-3 product&quot;] div[class=&quot;preview circle&quot;]&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> pic <span class="keyword">in</span> pic_list:</span><br><span class="line">    <span class="comment"># 大佬的答案, 好强！！</span></span><br><span class="line">    completePicUrl = <span class="string">&#x27;https://www.starbucks.com.cn&#x27;</span>+pic.attrs.get(<span class="string">&#x27;style&#x27;</span>).split(<span class="string">&#x27;url(&quot;&#x27;</span>)[<span class="number">1</span>].split(<span class="string">&#x27;&quot;)&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">    <span class="built_in">print</span>(completePicUrl)</span><br></pre></td></tr></table></figure><h1 id="Selenium"><a href="#Selenium" class="headerlink" title="Selenium"></a>Selenium</h1><blockquote><p>中文意思：[化学]硒</p></blockquote><h2 id="1-Selenium"><a href="#1-Selenium" class="headerlink" title="1. Selenium"></a>1. Selenium</h2><h3 id="1-1-介绍"><a href="#1-1-介绍" class="headerlink" title="1.1 介绍"></a>1.1 介绍</h3><ul><li><strong>什么是 Selenium</strong><ul><li>是一个用于 Web 应用程序测试的工具</li><li>其测试直接运行在浏览器中，就像真正的用户在操作一样</li><li>支持通过各种 driver 驱动真实浏览器完成测试</li><li>也支持无界面浏览器操作</li></ul></li><li><strong>为什么使用 selenium</strong><ul><li>模拟浏览器功能，自动执行网页中的js代码，实现<strong>动态加载</strong></li></ul></li><li><strong>缺点</strong>：原生selenium有点慢，之后加东西使它效率变快</li><li><strong>代码演示</strong>：</li></ul><blockquote><p>本次将要演示urllib获取京东的网页源码，从而说明使用的urllib获取京东的网页源码会缺失秒杀的一些数据，进而引入下一节将要使用的selenium </p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"></span><br><span class="line">url = <span class="string">&quot;https://www.jd.com/&quot;</span></span><br><span class="line"></span><br><span class="line">response = urllib.request.urlopen(url)</span><br><span class="line">content = response.read().decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(content)</span><br></pre></td></tr></table></figure><p><img src="/../img/Spider%E5%85%A5%E9%97%A8.assets/1696400628402.png" alt="1696400628402"></p><p><img src="/../img/Spider%E5%85%A5%E9%97%A8.assets/1696400643464.png" alt="1696400643464"></p><blockquote><p>使用的urllib获取京东的网页源码，搜索秒杀中的数据，发现确实是少了秒杀的内容，因此，下一节将学习并说明selenium能驱动真实浏览器去获取数据，不会缺少内容 </p></blockquote><h3 id="1-2-基本使用"><a href="#1-2-基本使用" class="headerlink" title="1.2 基本使用"></a>1.2 基本使用</h3><h4 id="1-2-1-安装-selenium"><a href="#1-2-1-安装-selenium" class="headerlink" title="1.2.1 安装 selenium"></a>1.2.1 安装 selenium</h4><ul><li><p><strong>谷歌浏览器</strong>：</p><ul><li><p>驱动地址下载：<code>http://chromedriver.storage.googleapis.com/index.html</code></p><p><img src="/../img/Spider%E5%85%A5%E9%97%A8.assets/1696401211274.png" alt="1696401211274"></p></li><li><p>谷歌驱动和谷歌浏览器版本之间的映射表：<code>http://blog.csdn.net/huilan_same/article/details/51896672</code></p></li><li><p>查看谷歌浏览器版本：谷歌浏览器右上角–&gt;帮助–&gt;关于</p><blockquote><p>貌似最高才 114，我这 116 的它还没有，暂时放弃</p></blockquote></li></ul><p><img src="/../img/Spider%E5%85%A5%E9%97%A8.assets/1696401112871.png" alt="1696401112871"></p><ul><li><code>pip install selenium</code></li></ul></li><li><p>使用 <strong>Edge 浏览器</strong></p><ul><li><p>同理，先看浏览器版本号(帮助与反馈-&gt;关于)，再去 <code>https://developer.microsoft.com/en-us/microsoft-edge/tools/webdriver/ </code> 中下载</p><p><img src="/../img/Spider%E5%85%A5%E9%97%A8.assets/1696401400568.png" alt="1696401400568"></p><p><img src="/../img/Spider%E5%85%A5%E9%97%A8.assets/1696401510188.png" alt="1696401510188"></p></li><li><p>解压文件：</p></li></ul><p><img src="/../img/Spider%E5%85%A5%E9%97%A8.assets/1696401624552.png" alt="1696401624552"></p><ul><li>放在代码目录下并安装：</li></ul><blockquote><p>注意selenium版本和urllib3版本不兼容的问题！</p><p>弹幕大佬建议：在selenium后面加个&#x3D;&#x3D;3.141.0，否则后面会因为下载的selenium版本过高操作不同，个人认为高版本不好用，用法还得自己找</p></blockquote><p><img src="/../img/Spider%E5%85%A5%E9%97%A8.assets/1696401889003.png" alt="1696401889003"></p><p><img src="/../img/Spider%E5%85%A5%E9%97%A8.assets/1696401875922.png" alt="1696401875922"></p></li></ul><h4 id="1-2-2-版本兼容问题解决"><a href="#1-2-2-版本兼容问题解决" class="headerlink" title="1.2.2 版本兼容问题解决"></a>1.2.2 版本兼容问题解决</h4><ul><li>由于版本不兼容的问题，这里还需要改下，我改了两个位置<ul><li>selenium 改成 3.141.0 版本</li><li>urllib3 改成 1.2.6.2 版本</li></ul></li><li>修改参考如下步骤：</li></ul><p><img src="/../img/Spider%E5%85%A5%E9%97%A8.assets/1696402920101.png" alt="1696402920101"></p><h4 id="1-2-3-代码演示"><a href="#1-2-3-代码演示" class="headerlink" title="1.2.3 代码演示"></a>1.2.3 代码演示</h4><ul><li><strong>访问百度</strong>：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 导入 selenium</span></span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 创建浏览器操作对象</span></span><br><span class="line">path = <span class="string">&quot;msedgedriver.exe&quot;</span>  <span class="comment"># 驱动文件的路径</span></span><br><span class="line">browser = webdriver.Edge(path)  <span class="comment"># 创建浏览器</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 访问网站</span></span><br><span class="line"><span class="comment"># 访问地址</span></span><br><span class="line">url = <span class="string">&#x27;https://www.baidu.com&#x27;</span></span><br><span class="line"><span class="comment"># 浏览器打开网址</span></span><br><span class="line">browser.get(url)</span><br></pre></td></tr></table></figure><p><img src="/../img/Spider%E5%85%A5%E9%97%A8.assets/1696403107071.png" alt="1696403107071"></p><ul><li><strong>访问京东并获取带有秒杀界面的源码</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 导入 selenium</span></span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 创建浏览器操作对象</span></span><br><span class="line">path = <span class="string">&#x27;msedgedriver.exe&#x27;</span>  <span class="comment"># 驱动文件的路径</span></span><br><span class="line">browser = webdriver.Edge(path)  <span class="comment"># 创建浏览器</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 访问网站</span></span><br><span class="line">url = <span class="string">&#x27;https://www.jd.com&#x27;</span></span><br><span class="line">browser.get(url)</span><br><span class="line"><span class="comment"># page_source 获取网页源码</span></span><br><span class="line">content = browser.page_source</span><br><span class="line"><span class="built_in">print</span>(content)</span><br></pre></td></tr></table></figure><p><img src="/../img/Spider%E5%85%A5%E9%97%A8.assets/1696403258751.png" alt="1696403258751"></p><h3 id="1-3-元素定位"><a href="#1-3-元素定位" class="headerlink" title="1.3 元素定位"></a>1.3 元素定位</h3><blockquote><p>如果我们需要使用程序在百度（<code>https://www.baidu.com/</code>）中输入“周杰伦”，然后点击“百度一下”，会跳到一个新的页面。其中，使用程序找到“百度一下”的过程称为元素定位</p></blockquote><h4 id="1-3-1-元素定位的定义与方法"><a href="#1-3-1-元素定位的定义与方法" class="headerlink" title="1.3.1 元素定位的定义与方法"></a>1.3.1 元素定位的定义与方法</h4><p><img src="/../img/Spider%E5%85%A5%E9%97%A8.assets/1696403449710.png" alt="1696403449710"></p><h4 id="1-3-2-代码演示"><a href="#1-3-2-代码演示" class="headerlink" title="1.3.2 代码演示"></a>1.3.2 代码演示</h4><blockquote><p>不过这是老版本的，新版本好像把这些都结合成一个方法了</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建浏览器操作对象</span></span><br><span class="line">path = <span class="string">&#x27;msedgedriver.exe&#x27;</span>  <span class="comment"># 驱动文件的路径</span></span><br><span class="line">browser = webdriver.Edge(path)  <span class="comment"># 创建浏览器</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 访问网站</span></span><br><span class="line">url = <span class="string">&#x27;https://www.baidu.com&#x27;</span></span><br><span class="line">browser.get(url)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 元素定位</span></span><br><span class="line"><span class="comment"># 1. 根据 id 找到对象  &lt;input type=&quot;submit&quot; id=&quot;su&quot; value=&quot;百度一下&quot; class=&quot;bg s_btn&quot;&gt;</span></span><br><span class="line">button = browser.find_element_by_id(<span class="string">&#x27;su&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(button)  <span class="comment"># &lt;selenium.webdriver.remote.webelement.WebElement (session=&quot;f8da6a0d36bcf1b411dbbd04fb181d99&quot;, element=&quot;1F0CAAC086FFF88546C0873E34B579E2_element_6&quot;)&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 根据标签属性的属性值来获取对象 &lt;input id=&quot;kw&quot; name=&quot;wd&quot; class=&quot;s_ipt&quot; value=&quot;&quot; maxlength=&quot;255&quot; autocomplete=&quot;off&quot;&gt;</span></span><br><span class="line">button = browser.find_element_by_name(<span class="string">&#x27;wd&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(button)  <span class="comment"># selenium.webdriver.remote.webelement.WebElement (session=&quot;0ec1958b0e548f1ff0d1c001c0b604f2&quot;, element=&quot;857A99072AE0926284925BCCD1F8543E_element_5&quot;)&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 根据 xpath 语句获取对象</span></span><br><span class="line">button = browser.find_elements_by_xpath(<span class="string">&#x27;//input[@id=&quot;su&quot;]&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(button)  <span class="comment"># [&lt;selenium.webdriver.remote.webelement.WebElement (session=&quot;e8f80626515e815272fc55fb2e8bf237&quot;, element=&quot;663F3737137A55001C2D941F6E5BCB8F_element_6&quot;)&gt;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 根据标签的名字来获取对象</span></span><br><span class="line">button = browser.find_elements_by_tag_name(<span class="string">&#x27;input&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(button)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. 使用 bs4 的语法来获取对象</span></span><br><span class="line">button = browser.find_elements_by_css_selector(<span class="string">&#x27;#su&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(button)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 6. 根据链接的文本来获取对象</span></span><br><span class="line">button = browser.find_element_by_link_text(<span class="string">&#x27;新闻&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(button)  <span class="comment"># &lt;selenium.webdriver.remote.webelement.WebElement (session=&quot;9f4847fd6b8da07b16d46fa265b7047c&quot;, element=&quot;E9A97B94E3D31089587AAF9916E657BF_element_25&quot;)&gt;</span></span><br></pre></td></tr></table></figure><h3 id="1-4-元素信息"><a href="#1-4-元素信息" class="headerlink" title="1.4 元素信息"></a>1.4 元素信息</h3><h4 id="1-4-1-访问元素信息"><a href="#1-4-1-访问元素信息" class="headerlink" title="1.4.1 访问元素信息"></a>1.4.1 访问元素信息</h4><ul><li>获取元素属性： <code>.get_attribute(&#39;class&#39;)</code></li><li>获取元素文本：<code>text</code> </li><li>获取标签名：<code>tag_name</code></li></ul><h4 id="1-4-2-代码演示"><a href="#1-4-2-代码演示" class="headerlink" title="1.4.2 代码演示"></a>1.4.2 代码演示</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line">path = <span class="string">&#x27;msedgedriver.exe&#x27;</span></span><br><span class="line">browser = webdriver.Edge(path)</span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;http://www.baidu.com&#x27;</span></span><br><span class="line">browser.get(url)</span><br><span class="line"></span><br><span class="line"><span class="comment"># selenium 访问元素信息</span></span><br><span class="line"><span class="built_in">input</span> = browser.find_element_by_id(<span class="string">&#x27;su&#x27;</span>)</span><br><span class="line"><span class="comment"># 1. 获取元素属性</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">input</span>.get_attribute(<span class="string">&#x27;class&#x27;</span>))  <span class="comment"># bg s_btn</span></span><br><span class="line"><span class="comment"># 2. 获取标签名</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">input</span>.tag_name)  <span class="comment"># input</span></span><br><span class="line"><span class="comment"># 3. 获取元素文本</span></span><br><span class="line">a = browser.find_element_by_link_text(<span class="string">&#x27;新闻&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a.text)  <span class="comment"># 新闻</span></span><br></pre></td></tr></table></figure><h3 id="1-5-selenium-的交互"><a href="#1-5-selenium-的交互" class="headerlink" title="1.5 selenium 的交互"></a>1.5 selenium 的交互</h3><h4 id="1-5-1-交互"><a href="#1-5-1-交互" class="headerlink" title="1.5.1 交互"></a>1.5.1 交互</h4><ul><li>点击：<code>click()</code></li><li>输入：<code>send_keys()</code></li><li>后退操作：<code>browser.back()</code></li><li>前进操作：<code>browser.forword()</code></li><li>模拟JS滚动： <code>js=&#39;document.documentElement.scrollTop=100000&#39;</code>   <code>browser.execute_script(js)</code></li><li>执行js代a码 获取网页代码：<code>page_source</code></li><li>退出：<code>browser.quit()</code></li></ul><h4 id="1-5-2-代码演示"><a href="#1-5-2-代码演示" class="headerlink" title="1.5.2 代码演示"></a>1.5.2 代码演示</h4><blockquote><p>本次需要通过程序使浏览器使用百度搜索“周杰伦”，然后点到第2页，再使用一下后退、前进操作，然后再滚动到页末 </p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建浏览器对象</span></span><br><span class="line">path = <span class="string">&#x27;msedgedriver.exe&#x27;</span></span><br><span class="line">browser = webdriver.Edge(path)</span><br><span class="line"></span><br><span class="line"><span class="comment"># url</span></span><br><span class="line">url = <span class="string">&#x27;http://www.baidu.com&#x27;</span></span><br><span class="line">browser.get(url)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">time.sleep(<span class="number">2</span>)  <span class="comment"># 睡眠两秒</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取文本框的对象</span></span><br><span class="line"><span class="built_in">input</span> = browser.find_element_by_id(<span class="string">&#x27;kw&#x27;</span>)</span><br><span class="line"><span class="comment"># 在文本框中输入文本</span></span><br><span class="line"><span class="built_in">input</span>.send_keys(<span class="string">&#x27;周杰伦&#x27;</span>)</span><br><span class="line">time.sleep(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取点击按钮</span></span><br><span class="line">button = browser.find_element_by_id(<span class="string">&#x27;su&#x27;</span>)</span><br><span class="line"><span class="comment"># 点击按钮</span></span><br><span class="line">button.click()</span><br><span class="line">time.sleep(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 滑倒顶部</span></span><br><span class="line">js_bottom = <span class="string">&#x27;document.documentElement.scrollTop=100000&#x27;</span></span><br><span class="line">browser.execute_script(js_bottom)</span><br><span class="line">time.sleep(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取下一页的按钮</span></span><br><span class="line"><span class="built_in">next</span> = browser.find_element_by_xpath(<span class="string">&#x27;//a[@class=&quot;n&quot;]&#x27;</span>)</span><br><span class="line"><span class="comment"># 点击下一页</span></span><br><span class="line"><span class="built_in">next</span>.click()</span><br><span class="line">time.sleep(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 回到上一页</span></span><br><span class="line">browser.back()</span><br><span class="line">time.sleep(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 回去</span></span><br><span class="line">browser.forward()</span><br><span class="line">time.sleep(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 退出</span></span><br><span class="line">browser.quit()</span><br></pre></td></tr></table></figure><h2 id="2-Phantomjs"><a href="#2-Phantomjs" class="headerlink" title="2. Phantomjs"></a>2. Phantomjs</h2><blockquote><p>在前面的学习中，发现Selenium，每次执行过程中都需打开浏览器、关闭浏览器、中间还有一堆操作，这是因为它有页面，而页面里面会有js、css等等很多文件，因此打开页面会导致代码的性能很慢</p><p>因此提出Phantomjs、Chrome handless,目前Phantomjs已逐渐淘汰，<strong>这里就不学了我</strong></p></blockquote><h3 id="2-1-介绍"><a href="#2-1-介绍" class="headerlink" title="2.1 介绍"></a>2.1 介绍</h3><ul><li>是一个无界面浏览器</li><li>支持页面元素查找，js 的执行等</li><li>由于不进行 css 和 gui 渲染，运行效率比真实的浏览器要快的多</li></ul><h3 id="2-2-如何使用-Phantomjs"><a href="#2-2-如何使用-Phantomjs" class="headerlink" title="2.2 如何使用 Phantomjs"></a>2.2 如何使用 Phantomjs</h3><ul><li>获取Phantomjs.exe文件路径path </li><li>browser&#x3D; webdriver.PhantomJs(path) </li><li>browser.get(url)</li></ul><blockquote><p>扩展：保存屏幕快照：browser.save_screenshot(‘baidu.png’) </p></blockquote><h2 id="3-Chrome-handless"><a href="#3-Chrome-handless" class="headerlink" title="3. Chrome handless"></a>3. Chrome handless</h2><ul><li><strong>基本配置</strong>：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver  <span class="comment"># 导入selenium库</span></span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.chrome.options <span class="keyword">import</span> Options  <span class="comment"># 导入浏览器设置相关的类</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 无可视化界面设置</span></span><br><span class="line">chrome_options = Options()</span><br><span class="line"><span class="comment"># 使用无头模式</span></span><br><span class="line">chrome_options.add_argument(<span class="string">&#x27;--headless&#x27;</span>)</span><br><span class="line"><span class="comment"># 禁用GPU，防止无头模式出现莫名的BUG</span></span><br><span class="line">chrome_options.add_argument(<span class="string">&#x27;--disable-gpu&#x27;</span>)</span><br><span class="line"></span><br><span class="line">path = <span class="string">r&#x27;C:\Program Files\Google\Chrome\Application\chrome.exe&#x27;</span></span><br><span class="line">chrome_options.binary_location = path</span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrome(chrome_options=chrome_options)</span><br><span class="line">browser.get(<span class="string">&#x27;http://www/baidu.com/&#x27;</span>)</span><br></pre></td></tr></table></figure><h1 id="requests"><a href="#requests" class="headerlink" title="requests"></a>requests</h1><blockquote><p>只属于 python？其他编程语言没有？</p></blockquote><h2 id="1-基本使用"><a href="#1-基本使用" class="headerlink" title="1. 基本使用"></a>1. 基本使用</h2><ul><li><p><strong>文档</strong></p><ul><li>官方文档：    <code>https://requests.readthedocs.io/projects/cn/zh_CN/latest</code></li><li>快速上手    <code>https://requests.readthedocs.io/projects/cn/zh_CN/latest/user/quickstart.html</code></li></ul></li><li><p><strong>安装</strong></p><ul><li><code>pip install requests</code></li></ul><p><img src="/../img/Spider%E5%85%A5%E9%97%A8.assets/1696039537783.png" alt="1696039537783"></p></li><li><p><strong>response 的属性以及类型</strong></p></li></ul><table><thead><tr><th>类型</th><th>models.Response</th></tr></thead><tbody><tr><td>r.text</td><td>获取网站源码</td></tr><tr><td>r.encoding</td><td>访问或定制编码方式</td></tr><tr><td>r.url</td><td>获取请求的url</td></tr><tr><td>r.content</td><td>响应的字节类型</td></tr><tr><td>r.status_code</td><td>响应的状态码</td></tr><tr><td>r.headers</td><td>响应的头信息</td></tr></tbody></table><ul><li><strong>代码示例</strong>：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;http://www.baidu.com&#x27;</span></span><br><span class="line">response = requests.get(url=url)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 一个类型和六个属性</span></span><br><span class="line"><span class="comment"># Response 类型, 和 urllib 不一样(HTTPResponse类型)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(response))  <span class="comment"># &lt;class &#x27;requests.models.Response&#x27;&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 六个属性</span></span><br><span class="line"><span class="comment"># 1. encoding 设置响应的编码格式</span></span><br><span class="line">response.encoding = <span class="string">&#x27;utf-8&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. text 以字符串形式返回网页的源码</span></span><br><span class="line"><span class="built_in">print</span>(response.text)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 获取请求的 url</span></span><br><span class="line"><span class="built_in">print</span>(response.url)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 返回的是二进制的数据</span></span><br><span class="line"><span class="built_in">print</span>(response.content)  <span class="comment"># b&#x27;&lt;!DOCTYPE html&gt;\r\n&lt;!--STATUS OK--...</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. 返回响应的状态码</span></span><br><span class="line"><span class="built_in">print</span>(response.status_code)  <span class="comment"># 200</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 6. 获取响应头信息</span></span><br><span class="line"><span class="built_in">print</span>(response.headers)  <span class="comment"># &#123;&#x27;Cache-Control&#x27;: &#x27;private, no-cache, no-store...</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="2-get-请求"><a href="#2-get-请求" class="headerlink" title="2. get 请求"></a>2. get 请求</h2><ul><li><strong>总结</strong>：<ul><li>参数使用 params 传递</li><li>参数无需 urlencode 编码</li><li>不需要请求对象的定制</li><li>请求资源路径中的<code>?</code>可以加也可以不加</li></ul></li><li><strong>代码示例</strong>：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># urllib VS requests</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. urllib</span></span><br><span class="line"><span class="comment"># 1.1 一个类型六个方法</span></span><br><span class="line"><span class="comment"># 1.2 get 请求</span></span><br><span class="line"><span class="comment"># 1.3 post 请求</span></span><br><span class="line"><span class="comment"># 1.4 ajax 的 get 请求</span></span><br><span class="line"><span class="comment"># 1.5 ajax 的 post 请求</span></span><br><span class="line"><span class="comment"># 1.6 cookie 登录</span></span><br><span class="line"><span class="comment"># 1.7 代理</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. request</span></span><br><span class="line"><span class="comment"># 2.1 一个类型六个属性</span></span><br><span class="line"><span class="comment"># 2.2 get 请求</span></span><br><span class="line"><span class="comment"># 2.3 post 请求</span></span><br><span class="line"><span class="comment"># 2.4 代理</span></span><br><span class="line"><span class="comment"># 2.5 cookie 验证码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;http://www.baidu.com/s?&#x27;</span></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/116.0.0.0 Safari/537.36 Edg/116.0.1938.69&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Cookie&#x27;</span>: <span class="string">&#x27;BDUSS=E5yeFZUSFRyTUxzUEhVbXhzUkZOV3lyeDlGLUMyVWFranBDNlRiV21tTWlnRDVrSVFBQUFBJCQAAAAAAAAAAAEAAAB~ymGB06O7qGNhbzAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACLzFmQi8xZkT; BDUSS_BFESS=E5yeFZUSFRyTUxzUEhVbXhzUkZOV3lyeDlGLUMyVWFranBDNlRiV21tTWlnRDVrSVFBQUFBJCQAAAAAAAAAAAEAAAB~ymGB06O7qGNhbzAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACLzFmQi8xZkT; BIDUPSID=B26B49048A0C9099B1456DF64F0279FF; PSTM=1684546051; BAIDUID=C70948D5D545EED0115F390D9D6C8143:SL=0:NR=10:FG=1; BD_UPN=12314753; BDORZ=B490B5EBF6F3CD402E515D22BCDA1598; BDRCVFR[feWj1Vr5u3D]=I67x6TjHwwYf0; delPer=0; BD_CK_SAM=1; PSINO=5; BAIDUID_BFESS=C70948D5D545EED0115F390D9D6C8143:SL=0:NR=10:FG=1; BA_HECTOR=ag01ag2g8k2hak81242k81001ihcet51p; B64_BOT=1; RT=&quot;z=1&amp;dm=baidu.com&amp;si=bee5a4dd-dfb0-43a8-8226-878c0904dd53&amp;ss=ln47d4cw&amp;sl=0&amp;tt=0&amp;bcn=https%3A%2F%2Ffclog.baidu.com%2Flog%2Fweirwood%3Ftype%3Dperf&amp;ul=1xd&amp;hd=1xx&quot;; COOKIE_SESSION=0_0_0_0_1_0_1_0_0_0_0_0_0_0_3_0_1695967725_0_1695967722%7C1%230_0_1695967722%7C1; ZFY=jKLYva:AwW:AlQpwrTh6Gt4SREDbR7NGeps2ei6L3zLXg:C; H_PS_PSSID=39323_39353_39399_39396_39407_39097_39412_39436_39358_39308_39375_39233_39406_26350_39219_22158_39427; baikeVisitId=cff92722-9312-4f8d-8d48-c7ba4ffa672e; sug=3; sugstore=0; ORIGIN=2; bdime=21111; H_PS_645EC=30ackYSFvlTVDOWoTBZDrGzNnqQmMHFCdPeK0%2BLRZ1OYuKcXF7ps3bKsk04&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">data = &#123;</span><br><span class="line">    <span class="string">&#x27;wd&#x27;</span>: <span class="string">&#x27;北京&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># requests.get 的参数有三个</span></span><br><span class="line"><span class="comment"># url:请求资源路径  params 参数 kwargs:字典</span></span><br><span class="line">response = requests.get(url=url, params=data, headers=headers)</span><br><span class="line">content = response.text  <span class="comment"># 注意这是属性</span></span><br><span class="line"><span class="built_in">print</span>(content)</span><br></pre></td></tr></table></figure><h2 id="3-post-请求"><a href="#3-post-请求" class="headerlink" title="3. post 请求"></a>3. post 请求</h2><ul><li>抓取百度翻译  <code>https://fanyi.baidu.com/sug </code></li></ul><p><img src="/../img/Spider%E5%85%A5%E9%97%A8.assets/1696041178762.png" alt="1696041178762"></p><ul><li><strong>代码实现</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;https://fanyi.baidu.com/sug&#x27;</span></span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/116.0.0.0 Safari/537.36 Edg/116.0.1938.69&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">data = &#123;</span><br><span class="line">   <span class="string">&#x27;kw&#x27;</span>: <span class="string">&#x27;math&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># requests.post 该句使用到的参数说明:</span></span><br><span class="line"><span class="comment"># url请求地址 data请求参数 kwargs字典</span></span><br><span class="line">response = requests.post(url=url, data=data, headers=headers)</span><br><span class="line"></span><br><span class="line">content = response.text</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line">obj = json.loads(content.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(obj)  <span class="comment"># &#123;&#x27;errno&#x27;: 0, &#x27;data&#x27;: [&#123;&#x27;k&#x27;: &#x27;math&#x27;, &#x27;v&#x27;: &#x27;n. 数...</span></span><br></pre></td></tr></table></figure><ul><li><strong>总结</strong>：<ul><li>post请求 是不需要编解码</li><li>post请求的参数是data</li><li>不需要请求对象的定制</li></ul></li></ul><h2 id="4-代理"><a href="#4-代理" class="headerlink" title="4. 代理"></a>4. 代理</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置其他ip</span></span><br><span class="line">proxy=&#123;</span><br><span class="line">    <span class="string">&#x27;http&#x27;</span>:<span class="string">&#x27;58.20.184.187:9091&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">response = requests.get(url=url, params=data, headers=headers,proxies=proxy)</span><br></pre></td></tr></table></figure><h2 id="5-cookie-定制"><a href="#5-cookie-定制" class="headerlink" title="5. cookie 定制"></a>5. cookie 定制</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">cookie登陆古诗文网（含验证码）</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 通过登陆  然后进入到主页面</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过找登陆接口我们发现 登陆的时候需要的参数很多</span></span><br><span class="line"><span class="comment"># __VIEWSTATE: wzavkIiUpeGeXT-Gu4jEWSBcHAneSt4SJdDa3y/PEP5sDZuLEWgE1r37kEQzlJ/pVVbYYMe7vrMvtm3NUmkX2KGAuPYULzyiZDcfhry5nbmFCtGY/RrDbqJIDMu0KDOYRMeQRs/Xwv2vH/1ZpkEoSK0lGoA0=</span></span><br><span class="line"><span class="comment"># __VIEWSTATEGENERATOR: C93BE1AE</span></span><br><span class="line"><span class="comment"># from: http://so.gushiwen.cn/user/collect.aspx</span></span><br><span class="line"><span class="comment"># email: cney6tcn@linshiyouxiang.net</span></span><br><span class="line"><span class="comment"># pwd: 8YW8GYET78933ETR</span></span><br><span class="line"><span class="comment"># code: 32GV</span></span><br><span class="line"><span class="comment"># denglu: 登录</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们观察到_VIEWSTATE   __VIEWSTATEGENERATOR  code是一个可以变化的量</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 难点:(1)_VIEWSTATE   __VIEWSTATEGENERATOR  一般情况看不到的数据 都是在页面的源码中</span></span><br><span class="line"><span class="comment">#     我们观察到这两个数据在页面的源码中 所以我们需要获取页面的源码 然后进行解析就可以获取了</span></span><br><span class="line"><span class="comment">#     (2)验证码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这是登陆页面的url地址</span></span><br><span class="line">url = <span class="string">&#x27;https://so.gushiwen.cn/user/login.aspx?from=http://so.gushiwen.cn/user/collect.a&#x27;</span></span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) Ap-pleWebKit/537.36 (KHTML, like Gecko) Chrome/115.0.0.0 Mobile Safari/537.36 Edg/115.0.1901.200&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line">response = requests.get(url=url, headers=headers)</span><br><span class="line">content = response.text</span><br><span class="line"><span class="built_in">print</span>(content)  <span class="comment"># 测试代码，验证能否获取网页源码</span></span><br></pre></td></tr></table></figure><h1 id="scrapy"><a href="#scrapy" class="headerlink" title="scrapy"></a>scrapy</h1><h2 id="1-srcapy-安装"><a href="#1-srcapy-安装" class="headerlink" title="1. srcapy 安装"></a>1. srcapy 安装</h2><h3 id="1-1-什么是-srcapy"><a href="#1-1-什么是-srcapy" class="headerlink" title="1.1 什么是 srcapy"></a>1.1 什么是 srcapy</h3><ul><li>scray 是一个为了爬取网站数据，提取结构性数据而编写的<strong>应用框架</strong>。可以应用在包括数据挖掘、信息处理或存储历史数据等一系列的程序中。   </li><li>什么是结构性数据？<ul><li>结构性就是类似的具有相同特征的东西，里面的数据就是结构性数据。   </li><li>选中一本书进行定位（即在某本书处打开检查），发现这些书的信息有一个相同的结构，比如书名都在结构“&#x2F;html&#x2F;body&#x2F;div[6]&#x2F;div&#x2F;div[2]&#x2F;div[2]&#x2F;ul&#x2F;li&#x2F;div&#x2F;h3&#x2F;a”下，它们具有相同的结构，这就是结构性的例子。至于结构性数据，比如书名就是该结构下的数据。</li></ul></li><li>优点<ul><li>爬取速度快</li><li>代码简单好用</li></ul></li></ul><h3 id="1-2-srcapy-的安装"><a href="#1-2-srcapy-的安装" class="headerlink" title="1.2 srcapy 的安装"></a>1.2 srcapy 的安装</h3><ul><li>安装命令：<code>pip install scrapy </code></li></ul><h2 id="2-基本使用"><a href="#2-基本使用" class="headerlink" title="2. 基本使用"></a>2. 基本使用</h2><ul><li>使用步骤</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">1. 创建爬虫的项目     </span><br><span class="line">    scrapy startproject 项目名字</span><br><span class="line">    注意：项目的名字不允许使用数字开头   也不能包含中文</span><br><span class="line">2. 创建爬虫文件</span><br><span class="line">    要在spiders文件夹中去创建爬虫文件</span><br><span class="line"></span><br><span class="line">    进入spiders文件夹：cd 项目的名字\项目的名字\spiders，</span><br><span class="line">    - 本次演示使用的命令为    cd scrapy_baidu_091\scrapy_baidu_091\spiders</span><br><span class="line"></span><br><span class="line">    创建爬虫文件</span><br><span class="line">    scrapy genspider 爬虫的名字 要爬取的网页</span><br><span class="line">    eg:scrapy genspider baidu http://www.baidu.com</span><br><span class="line">3. 运行爬虫代码</span><br><span class="line">    scrapy crawl 爬虫的名字</span><br><span class="line">    eg:scrapy crawl baidu</span><br><span class="line">   注：在运行爬虫程序时，需注释掉文件“setting.py”中的“ROBOTSTXT_OBEY = True”,  </span><br><span class="line">       即不遵守君子协议</span><br></pre></td></tr></table></figure><ul><li>代码演示</li></ul><h1 id="补充知识"><a href="#补充知识" class="headerlink" title="补充知识"></a>补充知识</h1><blockquote><p><a href="https://www.bilibili.com/video/BV1ha4y1H7sx?p=8&vd_source=ce97d263f08af76fc25ff49de530fe92">Day2 - 4.requests模块巩固深入案例之破解百度翻译_哔哩哔哩_bilibili</a> </p></blockquote><ul><li><strong>ajax</strong> 技术可以实现<strong>动态页面局部刷新</strong>，<strong>文件类型一般为xhr或fetch</strong></li></ul><p><img src="/../img/Spider%E5%85%A5%E9%97%A8.assets/1696077406694.png" alt="1696077406694"></p><p><img src="/../img/Spider%E5%85%A5%E9%97%A8.assets/1696077448796.png" alt="1696077448796"></p><ul><li>如果直接访问页面url，请求获取的静态页面<strong>缺少一些的局部数据</strong>，可以考虑<strong>所抓取的数据并不是通过 url 请求到的，可能是由 ajax 动态加载请求到的</strong>，可以进行下列方式验证：</li></ul><p><img src="/../img/Spider%E5%85%A5%E9%97%A8.assets/1696078327549.png" alt="1696078327549"></p><h2 id="1-模拟登录"><a href="#1-模拟登录" class="headerlink" title="1. 模拟登录"></a>1. 模拟登录</h2><blockquote><p>爬取基于某些用户的用户信息</p></blockquote><ul><li><p><strong>cookie</strong>：用来让服务器端记录客户端的相关状态</p><ul><li><strong>不建议用手动cookie处理</strong>，即：通过f12里的抓包工具获取cookie值，将该值封装到 headers 中</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&#x27;Cookie&#x27;</span>: <span class="string">&#x27;xxx&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>自动处理</strong><ul><li>cookie 值的来源？&#x3D;&#x3D;&#x3D;&gt; 去页面抓包，找到响应头信息中包含 <code>Set-Cookie</code> 字段的请求</li><li>session 的会话对象：可以进行请求的发送；如果请求过程中产生了 cookie，则该 cookie 会被自动存储&#x2F;携带在该 session 对象中；那么之后就可以用这个已经存储了cookie的session对象发起请求</li></ul></li></ul></li><li><p><strong>自动处理 cookie 进行模拟登录的流程</strong>：</p><ul><li>创建一个 session 对象：<code>requests.Session()</code></li><li>使用 session 对象进行模拟登录 post 请求的发送(cookie 就会被存储在session中)</li><li>session对象对个人主页对应的get请求进行发送(携带了 cookie)</li></ul></li></ul><h2 id="2-sign-反爬-js-逆向"><a href="#2-sign-反爬-js-逆向" class="headerlink" title="2. sign 反爬-js 逆向"></a>2. sign 反爬-js 逆向</h2><blockquote><p><a href="https://www.bilibili.com/video/BV1tm4y1h7RL/?spm_id_from=333.337.search-card.all.click&vd_source=ce97d263f08af76fc25ff49de530fe92">【爬虫实战】有道翻译的JS逆向技巧，透彻讲解教你如何破解sign参数！_哔哩哔哩_bilibili</a> </p></blockquote><ul><li><strong>断点方式</strong>：<ul><li>xhr 断点  发包位置  加密参数之后断点<ul><li>对通用参数进行处理    往上找加密点</li></ul></li><li>dom 断点  执行某一个事件  加密参数之前断点<ul><li>往下找加密点</li></ul></li></ul></li><li>网页加密</li></ul><h2 id="3-浏览器调试-Dev-Tools"><a href="#3-浏览器调试-Dev-Tools" class="headerlink" title="3. 浏览器调试 Dev Tools"></a>3. 浏览器调试 Dev Tools</h2><blockquote><p>开发常用浏览器 Chrom，firefox</p><p>这里主要介绍 Chrom</p><p><a href="https://www.bilibili.com/video/BV1KM4y1G7EF/?spm_id_from=333.337.search-card.all.click&vd_source=ce97d263f08af76fc25ff49de530fe92">【浏览器调试工具精讲】Chrome Dev Tools精讲，前端必看！_哔哩哔哩_bilibili</a> </p></blockquote><h3 id="3-1-各个-Tab-介绍"><a href="#3-1-各个-Tab-介绍" class="headerlink" title="3.1 各个 Tab 介绍"></a>3.1 各个 Tab 介绍</h3><ul><li>打开 Dev Tool<ul><li>菜单&gt;更多工具&gt;开发者工具</li><li>快捷键：F12</li></ul></li><li>打开命令菜单：<code>ctrl+shift+P</code></li><li><strong>常用的 Tab</strong><ul><li>Element</li><li>Console</li><li>Source</li><li>Network</li><li>Application</li></ul></li></ul><h3 id="3-2-控制台-Console"><a href="#3-2-控制台-Console" class="headerlink" title="3.2 控制台(Console)"></a>3.2 控制台(Console)</h3><ul><li>快捷键：<code>ctrl + Shift + J</code></li><li>控制台输入：<ul><li><code>$_</code> 可以返回上一条语句的执行结果</li></ul></li><li><code>$0</code> 可以返回上一个选择的DOM节点，以此类推，<code>$1</code> 就是上一个，<code>$2</code> 就是上上一个</li></ul><h3 id="3-3-JS-调试"><a href="#3-3-JS-调试" class="headerlink" title="3.3 JS 调试"></a>3.3 JS 调试</h3><ul><li>在 js 代码的某一行写上 <code>debugger</code>，回到页面运行时就会暂停在那行</li></ul><p><img src="/../img/Spider%E5%85%A5%E9%97%A8.assets/1696155905278.png" alt="1696155905278"></p><p><img src="/../img/Spider%E5%85%A5%E9%97%A8.assets/1696155935075.png" alt="1696155935075"></p><ul><li>也可以直接<strong>点行号</strong>进行调试<ul><li>右侧 watch 部分还可以监测某一个变量</li></ul></li></ul><p><img src="/../img/Spider%E5%85%A5%E9%97%A8.assets/1696156009157.png" alt="1696156009157"></p><ul><li>其他加断点方式</li></ul><p><img src="/../img/Spider%E5%85%A5%E9%97%A8.assets/1696156367090.png" alt="1696156367090"></p><p><img src="/../img/Spider%E5%85%A5%E9%97%A8.assets/1696156516180.png" alt="1696156516180"></p><h3 id="3-4-Network"><a href="#3-4-Network" class="headerlink" title="3.4 Network"></a>3.4 Network</h3><ul><li>记住跳转页面前的上一个页面的请求，需要勾选 <code>Preserve log</code></li></ul><p><img src="/../img/Spider%E5%85%A5%E9%97%A8.assets/1696156691181.png" alt="1696156691181"></p><h2 id="4-案例：抓取网易云评论"><a href="#4-案例：抓取网易云评论" class="headerlink" title="4. 案例：抓取网易云评论"></a>4. 案例：抓取网易云评论</h2><blockquote><p>这个案例很完整，建议好好学！</p><p><a href="https://www.bilibili.com/video/BV1q44y1N7hz/?p=50&spm_id_from=333.1007.top_right_bar_window_history.content.click&vd_source=ce97d263f08af76fc25ff49de530fe92">3 5 综合训练 抓取网易云音乐评论信息（6）_哔哩哔哩_bilibili</a> </p><p><code>https://music.163.com/#/song?id=1325905146 </code></p></blockquote><h3 id="4-1-分析接口"><a href="#4-1-分析接口" class="headerlink" title="4.1 分析接口"></a>4.1 分析接口</h3><ul><li>在f12抓包工具里的 XHR 选项下，可以找到获取评论的 post 接口：<code>https://music.163.com/weapi/comment/resource/comments/get?csrf_token=</code></li></ul><p><img src="/../img/Spider%E5%85%A5%E9%97%A8.assets/1696408535195.png" alt="1696408535195"></p><ul><li>可以看到需要有两个参数，但都是加密的</li></ul><blockquote><p>我们需要找到其 没加密之前是咋样的？加密的过程是咋样的？最后在程序里模拟其加密过程，加密完后再请求</p></blockquote><p><img src="/../img/Spider%E5%85%A5%E9%97%A8.assets/1696408515949.png" alt="1696408515949"></p><ul><li>在 <code>发起程序</code> 选项卡下有个请求调用堆栈，可以在这里查看所调用的 js：</li></ul><p><img src="/../img/Spider%E5%85%A5%E9%97%A8.assets/1696408952124.png" alt="1696408952124"></p><h3 id="4-2-逆向-js"><a href="#4-2-逆向-js" class="headerlink" title="4.2 逆向 js"></a>4.2 逆向 js</h3><ul><li>尝试点击最上面的 js，也就是最后一次调用的 js，然后对代码进行分析</li></ul><p><img src="/../img/Spider%E5%85%A5%E9%97%A8.assets/1696413885869.png" alt="1696413885869"></p><p><img src="/../img/Spider%E5%85%A5%E9%97%A8.assets/1696414122424.png" alt="1696414122424"></p><p><img src="/../img/Spider%E5%85%A5%E9%97%A8.assets/1696414266868.png" alt="1696414266868"></p><ul><li>找到加密的js，回去对其进行分析</li></ul><p><img src="/../img/Spider%E5%85%A5%E9%97%A8.assets/1696414586163.png" alt="1696414586163"></p><p><img src="/../img/Spider%E5%85%A5%E9%97%A8.assets/1696414966073.png" alt="1696414966073"></p><ul><li>找到加密的函数，设断点，再进行分析</li></ul><p><img src="/../img/Spider%E5%85%A5%E9%97%A8.assets/1696415569684.png" alt="1696415569684"></p><p><img src="/../img/Spider%E5%85%A5%E9%97%A8.assets/1696415827300.png" alt="1696415827300"></p><p><img src="/../img/Spider%E5%85%A5%E9%97%A8.assets/1696416034803.png" alt="1696416034803"></p><ul><li>继续执行，验证猜想</li></ul><p><img src="/../img/Spider%E5%85%A5%E9%97%A8.assets/1696416158876.png" alt="1696416158876"></p><ul><li><p>得出结论：</p><ul><li><p>我们要的两个参数：</p><ul><li>params：encText</li><li>encSecKey：encSecKey</li></ul></li><li><p>都是由这个函数进行生成的：</p><p><code>var bKC6w = window.asrsea(JSON.stringify(i8a), bvh7a([&quot;流泪&quot;, &quot;强&quot;]), bvh7a(Re1x.md), bvh7a([&quot;爱心&quot;, &quot;女孩&quot;, &quot;惊恐&quot;, &quot;大笑&quot;]));</code></p></li></ul></li></ul><h3 id="4-3-对加密过程进行分析"><a href="#4-3-对加密过程进行分析" class="headerlink" title="4.3 对加密过程进行分析"></a>4.3 对加密过程进行分析</h3><ul><li>接下来分析下这个加密过程，直接 <code>ctrl+f</code> 找下这个 <code>window.asrsea</code> 是啥？除了这句话之外，整个代码里只有下面这个地方有这个参数：<code>window.asrsea = d</code></li></ul><p><img src="/../img/Spider%E5%85%A5%E9%97%A8.assets/1696416743521.png" alt="1696416743521"></p><ul><li>对 d 这个函数，结合加密语句进行分析</li></ul><p><code>var bKC6w = window.asrsea(JSON.stringify(i8a), bvh7a([&quot;流泪&quot;, &quot;强&quot;]), bvh7a(Re1x.md), bvh7a([&quot;爱心&quot;, &quot;女孩&quot;, &quot;惊恐&quot;, &quot;大笑&quot;]));</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function d(d, e, f, g) &#123;  <span class="comment"># d: 数据 e: 010001 f: 很长的一个定值 g: &#x27;0CoJUm6Qyw8W8jud&#x27;</span></span><br><span class="line">    var h = &#123;&#125;</span><br><span class="line">      , i = a(<span class="number">16</span>);</span><br><span class="line">    <span class="keyword">return</span> h.encText = b(d, g),</span><br><span class="line">    h.encText = b(h.encText, i),</span><br><span class="line">    h.encSecKey = c(i, e, f),</span><br><span class="line">    h</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>可以发现，参数的 d 就是数据，后面的我们可以通过 console.log 获取其内容</p><p><img src="/../img/Spider%E5%85%A5%E9%97%A8.assets/1696416995573.png" alt="1696416995573"></p><p><img src="/../img/Spider%E5%85%A5%E9%97%A8.assets/1696417194452.png" alt="1696417194452"></p></blockquote><p><img src="/../img/Spider%E5%85%A5%E9%97%A8.assets/1696418007641.png" alt="1696418007641"></p><p><img src="/../img/Spider%E5%85%A5%E9%97%A8.assets/1696418150552.png" alt="1696418150552"></p><h3 id="4-4-编写代码，得到结果"><a href="#4-4-编写代码，得到结果" class="headerlink" title="4.4 编写代码，得到结果"></a>4.4 编写代码，得到结果</h3><blockquote><p>太厉害了这个，好难</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 需求：</span></span><br><span class="line"><span class="comment"># 1. 找到未加密的参数                      # window.arsea(参数, xxx, xxx, xxx)</span></span><br><span class="line"><span class="comment"># 2. 想办法把参数进行加密(必须参考网易的逻辑), params =&gt; encText, encSecKey =&gt; encSecKey</span></span><br><span class="line"><span class="comment"># 3. 请求到网易, 拿到评论信息</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">from</span> base64 <span class="keyword">import</span> b64encode</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">url = <span class="string">&quot;https://music.163.com/weapi/comment/resource/comments/get?csrf_token=&quot;</span></span><br><span class="line"><span class="comment"># 请求方式是 post</span></span><br><span class="line">data = &#123;  <span class="comment"># 通过 js 源码, 我们分析出来了真实的参数</span></span><br><span class="line">    <span class="string">&quot;rid&quot;</span>: <span class="string">&quot;R_SO_4_1325905146&quot;</span>,</span><br><span class="line">    <span class="string">&quot;threadId&quot;</span>: <span class="string">&quot;R_SO_4_1325905146&quot;</span>,</span><br><span class="line">    <span class="string">&quot;pageNo&quot;</span>: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">    <span class="string">&quot;pageSize&quot;</span>: <span class="string">&quot;20&quot;</span>,</span><br><span class="line">    <span class="string">&quot;cursor&quot;</span>: <span class="string">&quot;-1&quot;</span>,</span><br><span class="line">    <span class="string">&quot;offset&quot;</span>: <span class="string">&quot;0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;orderType&quot;</span>: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">    <span class="string">&quot;csrf_token&quot;</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 服务于d的</span></span><br><span class="line">f = <span class="string">&#x27;00e0b509f6259df8642dbc35662901477df22677ec152b5ff68ace615bb7b725152b3ab17a876aea8a5aa76d2e417629ec4ee341f56135fccf695280104e0312ecbda92557c93870114af6c9d05c4f7f0c3685b7a46bee255932575cce10b424d813cfe4875d3e82047b97ddef52741d546b8e289dc6935b3ece0462db0a22b8e7&#x27;</span></span><br><span class="line">g = <span class="string">&#x27;0CoJUm6Qyw8W8jud&#x27;</span></span><br><span class="line">e = <span class="string">&#x27;010001&#x27;</span></span><br><span class="line">i = <span class="string">&quot;SClpUDdZIpmWGncw&quot;</span>  <span class="comment"># 手动固定的</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_encSecKey</span>():  <span class="comment"># 由于 i 固定, 那么 encSecText 就是固定的, c() 函数的结果就是固定的</span></span><br><span class="line">    encSecKey = <span class="string">&quot;b40a2c971903961570378115316e7173a0d2a13532ebf67854866ffd90606842830f9713f2dbcb2db23e52c5ea5b9e48f1fed259ec15a82ab3d38228c90d88ced7885e69153a7cf4f0628983c0b427f15d4955f5afc34e0c332ca12cf47f359b7a68a5ab29bb774cd985638a733b824987a4548f8969fe2516e3de67b101426a&quot;</span></span><br><span class="line">    <span class="keyword">return</span> encSecKey</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_params</span>(<span class="params">data</span>):  <span class="comment"># 默认这里接收到的是字符串</span></span><br><span class="line">    first = enc_params(data, g)</span><br><span class="line">    second = enc_params(first, i)</span><br><span class="line">    <span class="keyword">return</span> second  <span class="comment"># 返回的就是 params</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 转化成 16 的倍数, 为下方的 AES 加密算法服务</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">to_16</span>(<span class="params">data</span>):</span><br><span class="line">    pad = <span class="number">16</span> - <span class="built_in">len</span>(data) % <span class="number">16</span></span><br><span class="line">    data += <span class="built_in">chr</span>(pad) * pad</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">enc_params</span>(<span class="params">data, key</span>):  <span class="comment"># 加密过程（最恶心的部分, 要还原js源码里的函数b）</span></span><br><span class="line">    <span class="comment"># 引入 AES 包后, 接下来进行 AES 加密</span></span><br><span class="line">    iv = <span class="string">&quot;0102030405060708&quot;</span></span><br><span class="line">    data = to_16(data)</span><br><span class="line">    aes = AES.new(key=key.encode(<span class="string">&quot;utf-8&quot;</span>), IV=iv.encode(<span class="string">&#x27;utf-8&#x27;</span>), mode=AES.MODE_CBC)</span><br><span class="line">    bs = aes.encrypt(data.encode(<span class="string">&#x27;utf-8&#x27;</span>))  <span class="comment"># 加密, 要求加密的内容的长度必须是16的倍数(而且补齐还是有逻辑的！), 涉及到AES加密的原理</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">str</span>(b64encode(bs), <span class="string">&quot;utf-8&quot;</span>)  <span class="comment"># 转化成字符串返回</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 处理加密过程</span></span><br><span class="line"><span class="comment"># var bKC6w = window.asrsea(JSON.stringify(i8a), bvh7a([&quot;流泪&quot;, &quot;强&quot;]), bvh7a(Re1x.md), bvh7a([&quot;爱心&quot;, &quot;女孩&quot;, &quot;惊恐&quot;, &quot;大笑&quot;]));</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">function a(a = 16) &#123;  # 返回随机的16位字符串</span></span><br><span class="line"><span class="string">    var d, e, b = &quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&quot;, c = &quot;&quot;;</span></span><br><span class="line"><span class="string">    for (d = 0; a &gt; d; d += 1)  # d 从 0-15, 循环 16 次, 产生 16 个随机的字母或数字</span></span><br><span class="line"><span class="string">        e = Math.random() * b.length,  # 随机数 假设1.2345</span></span><br><span class="line"><span class="string">        e = Math.floor(e),  # 取整 假设1</span></span><br><span class="line"><span class="string">        c += b.charAt(e);  # 去字符串中的xxx位置: 由上面假设, 此处就是 b</span></span><br><span class="line"><span class="string">    return c</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">function b(a, b) &#123;  # 参数a是要加密的内容, </span></span><br><span class="line"><span class="string">    var c = CryptoJS.enc.Utf8.parse(b)  # 所以 b 就是密钥</span></span><br><span class="line"><span class="string">      , d = CryptoJS.enc.Utf8.parse(&quot;0102030405060708&quot;)</span></span><br><span class="line"><span class="string">      , e = CryptoJS.enc.Utf8.parse(a)  # e是数据</span></span><br><span class="line"><span class="string">      , f = CryptoJS.AES.encrypt(e, c, &#123;  # AES加密算法? 这里的c就是加密的密钥</span></span><br><span class="line"><span class="string">        iv: d,  # AES加密里 iv 是偏移量</span></span><br><span class="line"><span class="string">        mode: CryptoJS.mode.CBC  # mode 是模式, 表示这里用的是 CBC 模式进行的加密</span></span><br><span class="line"><span class="string">    &#125;);</span></span><br><span class="line"><span class="string">    return f.toString()</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">function c(a, b, c) &#123;  # c里面不产生随机数</span></span><br><span class="line"><span class="string">    var d, e;</span></span><br><span class="line"><span class="string">    return setMaxDigits(131),</span></span><br><span class="line"><span class="string">    d = new RSAKeyPair(b,&quot;&quot;,c),</span></span><br><span class="line"><span class="string">    e = encryptedString(d, a)</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">function d(d, e, f, g) &#123;  # d: 数据 e: 010001 f: 很长的一个定值 g: &#x27;0CoJUm6Qyw8W8jud&#x27;</span></span><br><span class="line"><span class="string">    var h = &#123;&#125;  # 空对象</span></span><br><span class="line"><span class="string">      , i = a(16);  # i 就是一个16位的随机值, 可以把i设置成定值, 那么 encSecKey 就也是定的</span></span><br><span class="line"><span class="string">    h.encText = b(d, g),  # 分析函数b, 可以得出g是密钥</span></span><br><span class="line"><span class="string">    h.encText = b(h.encText, i),  # 返回的就是 params, i也是密钥</span></span><br><span class="line"><span class="string">    h.encSecKey = c(i, e, f),  # 返回的就是 encSecKey</span></span><br><span class="line"><span class="string">    # 分析 encSecKey, 参数e和f都是定死的, i是随机的, 如果此时固定i, 那么从c的函数中可以看出其不产生随机数, 那么最后得到的 encSecKey 一定也是定死的</span></span><br><span class="line"><span class="string">    return h</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    # 现在分析 params, 进行了两次的加密</span></span><br><span class="line"><span class="string">    # 数据+g =&gt; b =&gt; 第一次加密的结果+i =&gt; b = params</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 发送请求, 得到评论</span></span><br><span class="line">    resp = requests.post(url, data=&#123;</span><br><span class="line">        <span class="string">&quot;params&quot;</span>: get_params(json.dumps(data)),</span><br><span class="line">        <span class="string">&quot;encSecKey&quot;</span>: get_encSecKey()</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="built_in">print</span>(resp.text)</span><br></pre></td></tr></table></figure><ul><li>结果，成功：</li></ul><p><img src="/../img/Spider%E5%85%A5%E9%97%A8.assets/1696420016729.png" alt="1696420016729"></p><h2 id="5-python-并发编程"><a href="#5-python-并发编程" class="headerlink" title="5. python 并发编程"></a>5. python 并发编程</h2><h3 id="5-1-简介"><a href="#5-1-简介" class="headerlink" title="5.1 简介"></a>5.1 简介</h3><ul><li>引入并发，就是为了提升程序的运行速度</li><li>程序提速的方法：<ul><li><strong>单线程串行</strong>：不加改造的程序</li><li><strong>多线程并发</strong>：py 的 threading 模块</li><li><strong>多 CPU 并行</strong>：multiprocessing</li><li><strong>多机器并行</strong>：hadoop&#x2F;hive&#x2F;spark</li></ul></li></ul><p><img src="/../img/Spider%E5%85%A5%E9%97%A8.assets/1697174911332.png" alt="1697174911332"></p><ul><li>python 对并发编程的支持<ul><li>多线程：<strong>threading</strong>，利用 CPU 和 IO 可以同时执行的原理，让 CPU 不会干巴巴等待 IO 完成</li><li>多进程：<strong>multiprocessing</strong>，利用多核 CPU 的能力，真正的并行执行任务</li><li>异步 IO：<strong>asyncio</strong>，在单线程利用 CPU 和 IO 同时执行的原理，实现函数异步执行</li><li>使用 <strong>Lock</strong> 对资源加锁，防止冲突访问</li><li>使用 <strong>Queue</strong> 实现不同线程&#x2F;进程之间的数据通信，实现<strong>生产者(边爬取)-消费者(边解析)模式</strong></li><li>使用<strong>线程池Pool&#x2F;进程池Pool</strong>，简化线程&#x2F;进程的任务提交、等待结束、获取结果</li><li>使用 <strong>subprocess</strong> 启动外部程序的进程，并进行输入输出交互</li></ul></li></ul><h3 id="5-2-如何选择多线程多进程多协程"><a href="#5-2-如何选择多线程多进程多协程" class="headerlink" title="5.2 如何选择多线程多进程多协程"></a>5.2 如何选择多线程多进程多协程</h3><blockquote><p>python 并发编程有三种方式：多线程 Thread、多进程 Process、多协程Coroutine</p></blockquote><h4 id="5-2-1-什么是-CPU-密集型计算、IO-密集型计算"><a href="#5-2-1-什么是-CPU-密集型计算、IO-密集型计算" class="headerlink" title="5.2.1 什么是 CPU 密集型计算、IO 密集型计算"></a>5.2.1 什么是 CPU 密集型计算、IO 密集型计算</h4><p><img src="/../img/Spider%E5%85%A5%E9%97%A8.assets/1697175455216.png" alt="1697175455216"></p><h4 id="5-2-2-多线程多进程多协程的对比"><a href="#5-2-2-多线程多进程多协程的对比" class="headerlink" title="5.2.2 多线程多进程多协程的对比"></a>5.2.2 多线程多进程多协程的对比</h4><p><img src="/../img/Spider%E5%85%A5%E9%97%A8.assets/1697175588626.png" alt="1697175588626"></p><h4 id="5-2-3-如何选择对应技术"><a href="#5-2-3-如何选择对应技术" class="headerlink" title="5.2.3 如何选择对应技术"></a>5.2.3 如何选择对应技术</h4><ul><li>python 速度慢的原因：<ul><li>动态类型语言，边解释边执行</li><li>GIL(全局解释器锁)，无法利用多核CPU并发执行</li></ul></li></ul><p><img src="/../img/Spider%E5%85%A5%E9%97%A8.assets/1697175628421.png" alt="1697175628421"></p><h3 id="5-3-python-利用多线程加速爬虫"><a href="#5-3-python-利用多线程加速爬虫" class="headerlink" title="5.3 python 利用多线程加速爬虫"></a>5.3 python 利用多线程加速爬虫</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">urls = [</span><br><span class="line">    <span class="string">f&quot;https://www.cnblogs.com/#p<span class="subst">&#123;page&#125;</span>&quot;</span></span><br><span class="line">    <span class="keyword">for</span> page <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">50</span>+<span class="number">1</span>)</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">craw</span>(<span class="params">url</span>):</span><br><span class="line">    r = requests.get(url)</span><br><span class="line">    <span class="built_in">print</span>(url, <span class="built_in">len</span>(r.text))</span><br><span class="line"></span><br><span class="line">craw(urls[<span class="number">0</span>])</span><br></pre></td></tr></table></figure><ul><li>多线程</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> blog_spider</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">single_thread</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;single_thread begin&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> url <span class="keyword">in</span> blog_spider.urls:</span><br><span class="line">        blog_spider.craw(url)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;single_thread end&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">multi_thread</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;multi_thread begin&quot;</span>)</span><br><span class="line">    threads = []</span><br><span class="line">    <span class="keyword">for</span> url <span class="keyword">in</span> blog_spider.urls:</span><br><span class="line">        threads.append(  <span class="comment"># 创建多线程, 每个线程传入函数和函数所需参数</span></span><br><span class="line">            threading.Thread(target=blog_spider.craw, args=(url,))</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> thread <span class="keyword">in</span> threads:  <span class="comment"># 启动</span></span><br><span class="line">        thread.start()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> thread <span class="keyword">in</span> threads:  <span class="comment"># 等待结束</span></span><br><span class="line">        thread.join()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;multi_thread end&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    start = time.time()</span><br><span class="line">    single_thread()</span><br><span class="line">    end = time.time()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;single_thread cost: &quot;</span>, end-start, <span class="string">&quot;seconds&quot;</span>)</span><br><span class="line"></span><br><span class="line">    start = time.time()</span><br><span class="line">    multi_thread()</span><br><span class="line">    end = time.time()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;multi_thread cost: &quot;</span>, end - start, <span class="string">&quot;seconds&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="5-4-实现生产者消费者模式的多线程爬虫"><a href="#5-4-实现生产者消费者模式的多线程爬虫" class="headerlink" title="5.4 实现生产者消费者模式的多线程爬虫"></a>5.4 实现生产者消费者模式的多线程爬虫</h3><h4 id="5-4-1-多组件的-Pipeline-技术架构"><a href="#5-4-1-多组件的-Pipeline-技术架构" class="headerlink" title="5.4.1 多组件的 Pipeline 技术架构"></a>5.4.1 多组件的 Pipeline 技术架构</h4><ul><li>复杂的事情一般会分很多中间步骤一步步完成</li></ul><p><img src="/../img/Spider%E5%85%A5%E9%97%A8.assets/1697178699318.png" alt="1697178699318"></p><h4 id="5-4-2-生产者消费者爬虫的架构"><a href="#5-4-2-生产者消费者爬虫的架构" class="headerlink" title="5.4.2 生产者消费者爬虫的架构"></a>5.4.2 生产者消费者爬虫的架构</h4><p><img src="/../img/Spider%E5%85%A5%E9%97%A8.assets/1697178748014.png" alt="1697178748014"></p><h4 id="5-4-3-多线程数据通信的-queue-Queue"><a href="#5-4-3-多线程数据通信的-queue-Queue" class="headerlink" title="5.4.3 多线程数据通信的 queue.Queue"></a>5.4.3 多线程数据通信的 queue.Queue</h4><ul><li>queue.Queue 可以用于多线程之间的、<strong>线程安全</strong>的数据通信</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> queue</span><br><span class="line"><span class="keyword">import</span> blog_spider</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">do_craw</span>(<span class="params">url_queue:queue.Queue, html_queue:queue.Queue</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    生产者</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        url = url_queue.get()</span><br><span class="line">        html = blog_spider.craw(url)</span><br><span class="line">        html_queue.put(html)</span><br><span class="line">        <span class="built_in">print</span>(threading.current_thread().name, <span class="string">f&quot;craw <span class="subst">&#123;url&#125;</span>&quot;</span>,</span><br><span class="line">              <span class="string">&quot;url_queue.size=&quot;</span>, url_queue.qsize())</span><br><span class="line">        time.sleep(random.randint(<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">do_parse</span>(<span class="params">html_queue:queue.Queue, fout</span>):</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        html = html_queue.get()</span><br><span class="line">        results = blog_spider.parse(html)</span><br><span class="line">        <span class="keyword">for</span> result <span class="keyword">in</span> results:</span><br><span class="line">            fout.write(<span class="built_in">str</span>(result) + <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(threading.current_thread().name, <span class="string">f&quot;results <span class="subst">&#123;results&#125;</span>&quot;</span>,</span><br><span class="line">              <span class="string">&quot;html_queue.size=&quot;</span>, html_queue.qsize())</span><br><span class="line">        time.sleep(random.randint(<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    url_queue = queue.Queue()</span><br><span class="line">    html_queue = queue.Queue()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> url <span class="keyword">in</span> blog_spider.urls:</span><br><span class="line">        url_queue.put(url)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建三个生产者线程</span></span><br><span class="line">    <span class="keyword">for</span> idx <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">        t = threading.Thread(target=do_craw, args=(url_queue, html_queue),</span><br><span class="line">                             name=<span class="string">f&quot;craw<span class="subst">&#123;idx&#125;</span>&quot;</span>)</span><br><span class="line">        t.start()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建两个消费者线程</span></span><br><span class="line">    fout = <span class="built_in">open</span>(<span class="string">&quot;02.data.txt&quot;</span>, <span class="string">&quot;w&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> idx <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">        t = threading.Thread(target=do_parse, args=(html_queue, fout),</span><br><span class="line">                             name=<span class="string">f&quot;parse<span class="subst">&#123;idx&#125;</span>&quot;</span>)</span><br><span class="line">        t.start()</span><br></pre></td></tr></table></figure><h3 id="5-5-线程安全问题以及-Lock-解决方案"><a href="#5-5-线程安全问题以及-Lock-解决方案" class="headerlink" title="5.5 线程安全问题以及 Lock 解决方案"></a>5.5 线程安全问题以及 Lock 解决方案</h3><ul><li><p><strong>线程安全</strong>：指某个函数、函数库在多线程环境中被调用时，能够正确的处理多个线程之间的共享变量，使程序功能正确完成</p></li><li><p><strong>线程不安全</strong>：由于线程的执行随时会发生切换，造成不可预料的结果</p></li><li><p><strong>Lock 用于解决线程安全问题</strong>：<code>lock = threading.Lock()</code></p><ul><li>用法一：<code>try-finally</code> 模式</li><li>用法二：<code>with</code> 模式</li></ul></li><li><p><strong>代码示例</strong>：</p><ul><li>错误示范：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, balance</span>):</span><br><span class="line">        self.balance = balance</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">draw</span>(<span class="params">account, amount</span>):</span><br><span class="line">    <span class="keyword">if</span> account.balance &gt;= amount:</span><br><span class="line">        time.sleep(<span class="number">0.1</span>)</span><br><span class="line">        <span class="built_in">print</span>(threading.current_thread().name,</span><br><span class="line">              <span class="string">&quot;取钱成功&quot;</span>)</span><br><span class="line"></span><br><span class="line">        account.balance -= amount</span><br><span class="line">        <span class="built_in">print</span>(threading.current_thread().name,</span><br><span class="line">              <span class="string">&quot;余额: &quot;</span>, account.balance)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(threading.current_thread().name,</span><br><span class="line">              <span class="string">&quot;取钱失败, 余额不足&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    account = Account(<span class="number">1000</span>)</span><br><span class="line">    ta = threading.Thread(name=<span class="string">&quot;ta&quot;</span>, target=draw, args=(account, <span class="number">800</span>))</span><br><span class="line">    tb = threading.Thread(name=<span class="string">&quot;tb&quot;</span>, target=draw, args=(account, <span class="number">800</span>))</span><br><span class="line"></span><br><span class="line">    ta.start()</span><br><span class="line">    tb.start()</span><br></pre></td></tr></table></figure><p><img src="/../img/Spider%E5%85%A5%E9%97%A8.assets/1697246248156.png" alt="1697246248156"></p><ul><li>正确示范：加上 lock</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">lock = threading.Lock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, balance</span>):</span><br><span class="line">        self.balance = balance</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">draw</span>(<span class="params">account, amount</span>):</span><br><span class="line">    <span class="keyword">with</span> lock:</span><br><span class="line">        <span class="keyword">if</span> account.balance &gt;= amount:</span><br><span class="line">            time.sleep(<span class="number">0.1</span>)</span><br><span class="line">            <span class="built_in">print</span>(threading.current_thread().name,</span><br><span class="line">                  <span class="string">&quot;取钱成功&quot;</span>)</span><br><span class="line"></span><br><span class="line">            account.balance -= amount</span><br><span class="line">            <span class="built_in">print</span>(threading.current_thread().name,</span><br><span class="line">                  <span class="string">&quot;余额: &quot;</span>, account.balance)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(threading.current_thread().name,</span><br><span class="line">                  <span class="string">&quot;取钱失败, 余额不足&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    account = Account(<span class="number">1000</span>)</span><br><span class="line">    ta = threading.Thread(name=<span class="string">&quot;ta&quot;</span>, target=draw, args=(account, <span class="number">800</span>))</span><br><span class="line">    tb = threading.Thread(name=<span class="string">&quot;tb&quot;</span>, target=draw, args=(account, <span class="number">800</span>))</span><br><span class="line"></span><br><span class="line">    ta.start()</span><br><span class="line">    tb.start()</span><br></pre></td></tr></table></figure><p><img src="/../img/Spider%E5%85%A5%E9%97%A8.assets/1697246351713.png" alt="1697246351713"></p></li></ul><h3 id="5-6-好用的线程池-ThreadPoolExecutor"><a href="#5-6-好用的线程池-ThreadPoolExecutor" class="headerlink" title="5.6 好用的线程池 ThreadPoolExecutor"></a>5.6 好用的线程池 ThreadPoolExecutor</h3><ul><li><strong>线程池的原理</strong>：</li></ul><p><img src="/../img/Spider%E5%85%A5%E9%97%A8.assets/1697246476661.png" alt="1697246476661"></p><ul><li><strong>使用线程池的好处</strong>：<ul><li>提升性能：减去大量新建、终止线程的开销，重用了线程资源</li><li>适用场景：适合处理突发性大量请求或需要大量线程完成任务，但实际任务处理时间较短</li><li>防御功能：能有效避免系统因为创建线程过多，而导致系统负荷过大相应变慢等问题</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spider </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jmeter 压测</title>
      <link href="/2023/08/02/Jmeter/"/>
      <url>/2023/08/02/Jmeter/</url>
      
        <content type="html"><![CDATA[<h1 id="JMeter"><a href="#JMeter" class="headerlink" title="JMeter"></a>JMeter</h1><p>参考：<a href="https://www.byhy.net/tut/others/loadtest/jmeter/01/">JMeter 快速上手 | 白月黑羽 (byhy.net)</a> </p><p>JMeter 这个软件工具 主要用于<strong>服务端系统的性能测试</strong></p><p>比如 测试 web网站，API服务器 的性能，如下图所示</p><p> <img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/Jmeter%E5%8E%8B%E6%B5%8B.assets/1690955200926.png" alt="1690955200926"></p><h2 id="1-安装-JMeter"><a href="#1-安装-JMeter" class="headerlink" title="1. 安装 JMeter"></a>1. 安装 JMeter</h2><blockquote><p>前提要有 JDK8&#x2F;JDK11</p></blockquote><p>官网：<a href="https://jmeter.apache.org/download_jmeter.cgi">Apache JMeter - Download Apache JMeter</a> </p><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/Jmeter%E5%8E%8B%E6%B5%8B.assets/1690955571823.png" alt="1690955571823"></p><ul><li>下载后解压放在 D盘即可</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/Jmeter%E5%8E%8B%E6%B5%8B.assets/1690955752866.png" alt="1690955752866"></p><h2 id="2-打开"><a href="#2-打开" class="headerlink" title="2. 打开"></a>2. 打开</h2><ul><li>进入 bin 目录下，双击 <strong>jmeter.bat</strong> 文件，就会出现如下界面：</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/Jmeter%E5%8E%8B%E6%B5%8B.assets/1690955889212.png" alt="1690955889212"></p><ul><li>修改系统背景和字体大小还有语言，可以点击 option</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/Jmeter%E5%8E%8B%E6%B5%8B.assets/1690956774162.png" alt="1690956774162"></p><h2 id="3-界面简介"><a href="#3-界面简介" class="headerlink" title="3. 界面简介"></a>3. 界面简介</h2><p>性能测试是：验证<strong>在各种性能负载场景下</strong> ，系统的表现是否符合预期</p><blockquote><p>模拟大量用户访问被测系统？</p></blockquote><p>一个性能测试场景， JMeter称之为 <strong>test plan</strong> ，中文翻译为 <code>测试计划</code> 。实际上，<strong>一个 JMeter的测试计划</strong>对应性能测试的一个场景，其实<strong>也就是一个测试用例</strong> 。<strong>应该先准备好性能测试用例</strong>， 然后再用JMeter对应配置好一个测试计划来对应它。每个测试计划都可以保存在一个单独的文件中。</p><p>JMeter的测试计划，具体里面的内容（怎么测），根据你设计好的测试用例，在这个下面<strong>添加相应子节点定义</strong>。JMeter 把每个节点称之为 <code>element</code> ，翻译为中文叫 <code>元件</code> ，或者 <code>元素</code></p><p>首先，必须定义用户访问的行为。 就是用户 先访问哪个网页，发出哪些HTTP请求，再访问哪个网页，发出哪些HTTP请求。 根据用例，往往需要模拟 多种 用户行为， 每种行为的用户有多少个。JMeter 把一<strong>个用户的行为 用一个线程来执行</strong>。JMeter 把<strong>同一种用户的行为和数量， 用线程组来定义，代表有一批用户，都是这样的行为</strong>。</p><h2 id="4-测试计划和线程组"><a href="#4-测试计划和线程组" class="headerlink" title="4. 测试计划和线程组"></a>4. 测试计划和线程组</h2><blockquote><p>例：</p><p>比如，现在我们要做的一个性能测试用例 需要模拟的行为 如下：</p><p>第1种行为(用户数量 5个)：</p><p>先访问首页，再访问 <code>单课页</code> ，再访问 新闻页</p><p>第2种行为(用户数量 10个)：</p><p>先访问首页，再访问 <code>专题页</code> ，再访问 新闻页</p></blockquote><p>我们就要<strong>定义2个线程组</strong>，对应这两种行为的用户。</p><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/Jmeter%E5%8E%8B%E6%B5%8B.assets/1690957715900.png" alt="1690957715900"></p><ul><li><p>线程组中：</p><ul><li><code>Ramp-Up 时间</code> 意思是 所有用户上线的总时间，以秒为单位。</li><li>比如5，就表示总共耗时5秒，如果是 5个用户，那就意味着 每隔1.25秒上线一个： 5秒&#x2F;(5-1) &#x3D; 1.25</li><li><code>循环次数</code> 意思是 每个用户 做线程组里面定义的动作行为 <code>多少轮</code> 。 缺省就做一轮。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/Jmeter%E5%8E%8B%E6%B5%8B.assets/1690958054931.png" alt="1690958054931"></p></li><li><p>接下来 这个线程组里面 的 <strong>行为定义</strong>，也就是这类用户 先访问哪个网页，发出哪些HTTP请求，再访问哪个网页，发出哪些HTTP请求， 这个行为怎么定义呢？</p><ul><li>一个具体的请求，是通过 <code>Sampler 取样器</code> 来 定义的。</li><li>通常最常用的就是这个 HTTP请求取样器。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/Jmeter%E5%8E%8B%E6%B5%8B.assets/1690958170476.png" alt="1690958170476"></p></li><li><p>定义设置好以后，下面就是要运行看看。</p><ul><li>运行前，通常我们要保存这个测试计划</li><li>先选择计划节点，再选择工具栏的 <code>保存</code> 按钮，自己选择合适的保存位置</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/Jmeter%E5%8E%8B%E6%B5%8B.assets/1690958691364.png" alt="1690958691364"></p></li></ul><h2 id="5-调试运行"><a href="#5-调试运行" class="headerlink" title="5. 调试运行"></a>5. 调试运行</h2><p>接下来就可以运行一下看看。</p><p>注意，运行JMeter 有2种运行模式： <code>GUI 图形界面模式</code> 和 <code>CLI 命令行模式</code>，前者是开发调试用的，后者才是真正执行压力测试时用的，现在就是开发阶段，当然先使用 图形界面模式，等调试没有问题，再使用命令行模式</p><p>所以图形界面模式，我们要查看结果，就是加 <code>Listener 监听器</code> 。</p><p>最常见的就是 <code>ViewResultTree查看结果树</code> ，里面会显示HTTP请求具体的细节的信息。</p><blockquote><p>注意右键<strong>根节点</strong></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/Jmeter%E5%8E%8B%E6%B5%8B.assets/1690959259494.png" alt="1690959259494"></p><p>结果树 的 <code>Sample result 页</code> 参数的意义： (若要删除记录，左侧栏右键查看结果树，点击清除即可)</p><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/Jmeter%E5%8E%8B%E6%B5%8B.assets/1690959893695.png" alt="1690959893695"></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Connect Time ： </span><br><span class="line">  jmeter 和 被测系统 建立 TCP 连接的时间，包括<span class="number">3</span>路握手时间，</span><br><span class="line">  如果连接复用， 值为<span class="number">0</span></span><br><span class="line"></span><br><span class="line">lantency：</span><br><span class="line">  从发出请求前 到 接收完第一个响应的时间</span><br><span class="line"></span><br><span class="line">loadtime（以前叫Elapsed time）：</span><br><span class="line">  从发出请求前 到 接收完所有响应的时间</span><br><span class="line">  如果是长消息， 往往时长 &gt;= lantency，因为有多个响应</span><br><span class="line"></span><br><span class="line">Size in bytes ：        整个消息消息大小 = Headers size in bytes + Body size in bytes</span><br><span class="line">Headers size in bytes <span class="punctuation">:</span> 响应消息头大小</span><br><span class="line">Body size in bytes ：   响应消息体大小</span><br></pre></td></tr></table></figure><h2 id="6-HTTP-请求默认值配置"><a href="#6-HTTP-请求默认值配置" class="headerlink" title="6. HTTP 请求默认值配置"></a>6. HTTP 请求默认值配置</h2><p>测试过程中，被测系统换了， 就要换配置的地址， 要手动修改 请求参数，请求取样器多了， 就非常麻烦了。可以使用<code>HTTP请求默认值</code> 解决这个问题。</p><blockquote><p>那么如果具体在写测试行为时，如果没写，就默认使用http请求默认值里配置的信息，比如请求的ip啥的</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/Jmeter%E5%8E%8B%E6%B5%8B.assets/1690960289999.png" alt="1690960289999"></p><hr><p>这边自己试了下，直接测匹配的接口，除了 post 发送时需要在请求头加上点东西，其他没啥，亲测可用，所以接下来看下报告如何打印应该就行，，</p><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/Jmeter%E5%8E%8B%E6%B5%8B.assets/1690962876252.png" alt="1690962876252"></p><hr><h2 id="7-模拟间隔时间"><a href="#7-模拟间隔时间" class="headerlink" title="7. 模拟间隔时间"></a>7. 模拟间隔时间</h2><blockquote><p>补充一下，点右键可以禁用某个用户行为</p></blockquote><p>场景1中两组请求中间没有间隔，不符合实际情况。</p><p>怎么让它们有间隔呢？</p><ul><li><p>可以使用 JMeter的 <code>定时器 Timer</code>，有很多种，这里选择 固定的试下</p><ul><li>但是<strong>注意：定时器 执行优先级高于 取样器， 会先暂停， 可以放在下一个消息的前面</strong></li><li>也就是这个定时器你放一个，就会对它同目录下的所有都起效果，所以慎重使用</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/Jmeter%E5%8E%8B%E6%B5%8B.assets/1690963423636.png" alt="1690963423636"></p></li><li><p>也可以使用 取样器 里面的 <code>测试活动 flow control action</code> 取样器</p><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/Jmeter%E5%8E%8B%E6%B5%8B.assets/1690963791158.png" alt="1690963791158"></p><blockquote><p>这个就是正常等</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/Jmeter%E5%8E%8B%E6%B5%8B.assets/1690963852512.png" alt="1690963852512"></p></li></ul><h2 id="8-执行压力测试-命令行模式"><a href="#8-执行压力测试-命令行模式" class="headerlink" title="8. 执行压力测试-命令行模式"></a>8. 执行压力测试-命令行模式</h2><p><strong>真正实施性能测试应该在命令行模式下运行</strong>（而不是我们看到的 GUI 界面），</p><p>在 .jmx 文件所在位置打开 cmd 命令行，输入命令格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D:\JMeter\apache-jmeter-5.6.2\bin\jmeter -n -t parktest-case1.jmx -l log.jtl</span><br></pre></td></tr></table></figure><blockquote><p>-n 表示命令行</p><p>-t 指定执行的测试计划 保存的 .jmx 文件</p><p>-l 最终生成的测试日志</p></blockquote><p>注意JMeter的路径替换为你的安装路径</p><p>假设 我们有如下的性能测试用例，如下是简化的测试用例，实际工作的会很复杂</p><blockquote><p>注意，一个线程代表一个用户</p><p>如果要测试系统的并发连接数应该如何测试？</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">只有一种用户行为：</span><br><span class="line"></span><br><span class="line">无需登录，先访问首页，再访问  单课页 ，再访问 新闻页</span><br><span class="line">访问页面间隔 10 秒</span><br><span class="line"></span><br><span class="line">用户数量 1200 个，在10分钟依次上线</span><br></pre></td></tr></table></figure><ul><li><p>这就已经开始进行压测了，由于设置的是 600 秒，等十分钟之后就行</p><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/Jmeter%E5%8E%8B%E6%B5%8B.assets/1690965288695.png" alt="1690965288695"></p></li><li><p>结束</p><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/Jmeter%E5%8E%8B%E6%B5%8B.assets/1690965713070.png" alt="1690965713070"></p></li></ul><h2 id="9-dashboard-产生图表"><a href="#9-dashboard-产生图表" class="headerlink" title="9. dashboard 产生图表"></a>9. dashboard 产生图表</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D:\JMeter\apache-jmeter-5.6.2\bin\jmeter -g log.jtl -o report1</span><br></pre></td></tr></table></figure><blockquote><p>就会产生report1目录，里面的index.html 打开就是报告</p><p>注意 <code>-o</code> 后面的目录 一定要不存在，或者内容为空，否则会报错。</p></blockquote><p>执行命令后进入 report1 目录下，点击里面的 index.html 文件，就可以看到如下页面：</p><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/Jmeter%E5%8E%8B%E6%B5%8B.assets/1690965891290.png" alt="1690965891290"></p><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/Jmeter%E5%8E%8B%E6%B5%8B.assets/1690966360901.png" alt="1690966360901"></p>]]></content>
      
      
      <categories>
          
          <category> Jmeter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Jmeter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Fabric 入门</title>
      <link href="/2023/07/29/Fabric%E5%85%A5%E9%97%A8/"/>
      <url>/2023/07/29/Fabric%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Fabric"><a href="#Fabric" class="headerlink" title="Fabric"></a>Fabric</h1><blockquote><p>官方文档：<a href="https://hyperledger-fabric.readthedocs.io/zh-cn/latest/key_concepts.html">关键概念 — hyperledger-fabricdocs master 文档</a></p></blockquote><h2 id="1-关键概念"><a href="#1-关键概念" class="headerlink" title="1. 关键概念"></a>1. 关键概念</h2><h3 id="1-1-区块链网络"><a href="#1-1-区块链网络" class="headerlink" title="1.1 区块链网络"></a>1.1 区块链网络</h3><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/fabric%E5%8C%BA%E5%9D%97%E9%93%BE%E5%B9%B3%E5%8F%B0.assets/1681270713030.png" alt="1681270713030"></p><p>这个 Fabric 区块链网络包括了两个<strong>应用程序通道</strong>以及一个<strong>排序通道</strong>。</p><p>组织 R1 和 R4 负责排序通道，R1 和 R2 负责蓝色的应用程序通道，R2 和 R3 负责红色的应用程序通道。</p><p>客户端应用程序 A1 是组织 R1 的元素，CA1 是它的<strong>证书颁发机构</strong>。</p><p>组织 R2 的节点 P2 可以使用蓝色的通信设施，也可以使用红色的应用程序通道。</p><p>每个应用程序通道具有它自己的<strong>通道配置</strong>，这里是 CC1 和 CC2。</p><p>系统通道的通道配置是<strong>网络配置</strong> NC4 的一部分。</p><blockquote><p>一个有四个组织的网络，带有两个通道和三个 Peer 节点，两个智能合约和一个排序服务。</p><p>并由四个证书颁发机构来支撑。</p><p>它为三个客户端应用程序提供了账本及智能合约服务，这些应用程序可以通过两个通道与账本和智能合约进行交互。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/fabric%E5%8C%BA%E5%9D%97%E9%93%BE%E5%B9%B3%E5%8F%B0.assets/1681271030975.png" alt="1681271030975"></p><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/fabric%E5%8C%BA%E5%9D%97%E9%93%BE%E5%B9%B3%E5%8F%B0.assets/1681270977420.png" alt="1681270977420"></p><h3 id="1-2-身份"><a href="#1-2-身份" class="headerlink" title="1.2 身份"></a>1.2 身份</h3><ul><li>确定了对资源的确切权限以及对参与者在区块链网络中拥有的信息的访问权限</li><li>要使身份可以被<strong>验证</strong>，它必须来自<strong>可信任的</strong>权威机构</li><li>成员服务提供者（Membership Service Provider，MSP）是 Fabirc 中可以信任的权威机构</li><li><strong>MSP 将可验证的身份转变为区块链网络的成员</strong></li></ul><h4 id="1-2-1-PKI"><a href="#1-2-1-PKI" class="headerlink" title="1.2.1 PKI"></a>1.2.1 PKI</h4><ul><li>公钥基础结构（PKI）是一组互联网技术，可在网络中提供安全通信</li><li>关键要素<ul><li><strong>数字证书</strong></li><li><strong>公钥和私钥</strong></li><li><strong>证书授权中心</strong></li><li><strong>证书撤销列表</strong></li></ul></li></ul><h3 id="1-3-成员服务提供者-MSP"><a href="#1-3-成员服务提供者-MSP" class="headerlink" title="1.3 成员服务提供者 (MSP)"></a>1.3 成员服务提供者 (MSP)</h3><blockquote><p>以太坊属于匿名网络，hpyerledger 是实名制的网络</p></blockquote><h3 id="1-4-Peer-节点"><a href="#1-4-Peer-节点" class="headerlink" title="1.4 Peer 节点"></a>1.4 Peer 节点</h3><p>区块链网络主要由 <em>Peer 节点</em>（或者简单称之为 <em>Peer</em>）组成</p><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/fabric%E5%8C%BA%E5%9D%97%E9%93%BE%E5%B9%B3%E5%8F%B0.assets/1681285693747.png" alt="1681285693747">区块链网络是由 Peer 节点组成的，每个节点都保存着账本和智能合约的副本。</p><p>在这个例子中，网络 N 是由节点 P1、P2 和 P3 组成的，每个节点都维护这他们自己的分布式账本 L1。P1、P2 和 P3 使用相同的链码 S1 来访问他们的分布式账本的副本。</p><blockquote><p>在 Fabric 中，链码等同于智能合约，因为它们是使用一个被称为<strong>链码</strong>的技术概念来实现<strong>智能合约</strong>的</p></blockquote><p>Peer 节点是账本及链码的<em>宿主</em>，应用程序及管理员如果想要访问这些资源，他们必须要和 Peer 节点进行交互</p><h4 id="1-4-1-多账本"><a href="#1-4-1-多账本" class="headerlink" title="1.4.1 多账本"></a>1.4.1 多账本</h4><ul><li>一个 Peer 节点可以维护多个账本，并且每个账本具有零个或者多个链码使用账本</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/fabric%E5%8C%BA%E5%9D%97%E9%93%BE%E5%B9%B3%E5%8F%B0.assets/1681285960829.png" alt="1681285960829"></p><p>在这个例子中，我们能够看到 Peer 节点 P1 维护着账本 L1 和 L2。账本 L1 通过链码 S1 来访问。账本 2 通过链码 S1 和 S2 访问</p><h4 id="1-4-2-多链码"><a href="#1-4-2-多链码" class="headerlink" title="1.4.2 多链码"></a>1.4.2 多链码</h4><ul><li>账本数量和访问账本的链码的数量之间没有固定的关系。一个 Peer 节点可能会有很多链码和账本</li></ul><h4 id="1-4-3-应用程序和-Peer-节点"><a href="#1-4-3-应用程序和-Peer-节点" class="headerlink" title="1.4.3 应用程序和 Peer 节点"></a>1.4.3 应用程序和 Peer 节点</h4><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/fabric%E5%8C%BA%E5%9D%97%E9%93%BE%E5%B9%B3%E5%8F%B0.assets/1681287048342.png" alt="1681287048342"></p><h4 id="1-4-4-Peer-节点和排序节点"><a href="#1-4-4-Peer-节点和排序节点" class="headerlink" title="1.4.4 Peer 节点和排序节点"></a>1.4.4 Peer 节点和排序节点</h4><ul><li><p><strong>一个更新的交易和一个查询的交易区别很大</strong>，因为一个单独的 Peer 节点不能够由它自己来更新账本——<strong>更新需要网络中其他节点的同意</strong></p></li><li><p>在一个账本的更新被应用到 Peer 节点的本地账本之前， Peer 节点会请求网络中的其他 Peer 节点来批准这次更新。这个过程被称为<strong>共识</strong>，这会比一个简单的查询花费更长的时间来完成</p></li><li><p>想要更新账本的应用程序会被引入到一个三阶段的流程，这确保了在一个区块链网络中所有的 Peer 节点都彼此保持着一致的账本。</p><ul><li>在第一个阶段，应用程序会跟<em>背书节点</em>的子集一起工作，其中的每个节点都会向应用程序为提案的账本更新提供背书，但是不会将提案的更新应用到他们的账本副本上。</li><li>在第二个阶段，这些分散的背书会被搜集到一起当做交易被打包进区块中。</li><li>在最后一个阶段，这些区块会被分发回每个 Peer 节点，在这些 Peer 节点上每笔交易在被应用到 Peer 节点的账本副本之前会被验证。</li></ul><blockquote><p>排序节点在这个流程中处于中心地位</p></blockquote></li></ul><h3 id="1-5-chaincode-智能合约"><a href="#1-5-chaincode-智能合约" class="headerlink" title="1.5 chaincode 智能合约"></a>1.5 chaincode 智能合约</h3><ul><li>智能合约用可执行的代码定义了不同组织之间的规则。应用程序调用智能合约来生成被记录到账本上的交易。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/fabric%E5%8C%BA%E5%9D%97%E9%93%BE%E5%B9%B3%E5%8F%B0.assets/1681294843518.png" alt="1681294843518"></p><blockquote><p>在上图中，我们可以看到组织 <code>ORG1</code> 和 <code>ORG2</code> 是如何通过定义一个 <code>car</code> 智能合约来实现 <code>查询</code>、<code>转移</code> 和 <code>更新</code> 汽车的。来自这些组织的应用程序调用此智能合约执行业务流程中已商定的步骤，例如将特定汽车的所有权从 <code>ORG1</code> 转移到 <code>ORG2</code></p></blockquote><p>可以将智能合约看成交易的管理者，而链码则管理着如何将智能合约打包以便用于部署。</p><p>一个智能合约定义在一个链码中。而多个智能合约也可以定义在同一个链码中。当一个链码部署完毕，该链码中的所有智能合约都可供应用程序使用。</p><ul><li>智能合约的核心是一组 <code>交易</code> 定义。例如，在 <code>fabcar.js</code>中，你可以看到一个创建了一辆新车的智能合约交易：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="title function_">createCar</span>(<span class="params">ctx, carNumber, make, model, color, owner</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> car = &#123;</span><br><span class="line">        color,</span><br><span class="line">        <span class="attr">docType</span>: <span class="string">&#x27;car&#x27;</span>,</span><br><span class="line">        make,</span><br><span class="line">        model,</span><br><span class="line">        owner,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> ctx.<span class="property">stub</span>.<span class="title function_">putState</span>(carNumber, <span class="title class_">Buffer</span>.<span class="title function_">from</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(car)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-5-1-背书"><a href="#1-5-1-背书" class="headerlink" title="1.5.1 背书"></a>1.5.1 背书</h4><ul><li>每个链码都有一个<strong>背书</strong>策略与之相关联，该背书策略适用于此链码中定义的所有智能合约。背书策略非常重要，它指明了区块链网络中<strong>哪些组织必须对一个给定的智能合约所生成的交易进行签名</strong>，以此来宣布该交易<strong>有效</strong>。<ul><li>一个示例背书策略可能这样定义：参与区块链网络的四个组织中有三个必须在交易被认为<strong>有效</strong>之前签署该交易。所有的交易，无论是<strong>有效的</strong>还是<strong>无效的</strong>，都会被添加到分布式账本中，但只有<strong>有效</strong>交易会更新世界状态。</li><li>背书策略是 Hyperledger Fabric 与以太坊（Ethereum）或比特币（Bitcoin）等其他区块链的区别所在</li></ul></li></ul><h4 id="1-5-2-有效交易"><a href="#1-5-2-有效交易" class="headerlink" title="1.5.2 有效交易"></a>1.5.2 有效交易</h4><p>注意，在执行智能合约时<strong>世界状态没有更新</strong>！</p><ul><li><p>所有的交易都有一个识别符、一个提案和一个被一群组织签名的响应。所有交易，无论是否有效，都会被记录在区块链上，但<strong>仅有效交易会更新世界状态</strong>。</p></li><li><p>有效交易举例：</p><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/fabric%E5%8C%BA%E5%9D%97%E9%93%BE%E5%B9%B3%E5%8F%B0.assets/1681296263304.png" alt="1681296263304"></p><blockquote><p>检查 <code>车辆转移</code> 交易。您可以看到 <code>ORG1</code> 和 <code>ORG2</code> 之间为转移一辆车而进行的交易 <code>t3</code>。看一下交易是如何通过输入 <code>&#123;CAR1，ORG1，ORG2&#125;</code> 和输出 <code>&#123;CAR1.owner=ORG1，CAR1.owner=ORG2&#125;</code> 来表示汽车的所有者从 <code>ORG1</code> 变为了 <code>ORG2</code>。注意输入是如何由应用程序的组织 <code>ORG1</code> 签名的，输出是如何由背书策略标识的<em>两个</em>组织（ <code>ORG1</code> 和 <code>ORG2</code> ）签名的。这些签名是使用每个参与者的私钥生成的，这意味着网络中的任何人都可以验证网络中的所有参与者是否在交易细节上达成了一致</p></blockquote></li><li><p>一项交易被分发给网络中的所有节点，各节点通过两个阶段对其进行<strong>验证</strong>。首先，根据背书策略检查交易，确保该交易已被足够的组织签署。其次，继续检查交易，以确保当该交易在受到背书节点签名时它的交易读集与世界状态的当前值匹配，并且中间过程中没有被更新。如果一个交易通过了这两个测试，它就被标记为<strong>有效</strong>。所有交易，不管是<strong>有效的</strong>还是<strong>无效的</strong>，都会被添加到区块链历史中，但是仅<strong>有效的</strong>交易才会更新世界状态。</p></li></ul><h4 id="1-5-3-通道"><a href="#1-5-3-通道" class="headerlink" title="1.5.3 通道"></a>1.5.3 通道</h4><ul><li>Hyperledger Fabric 允许一个组织利用<strong>通道</strong>同时参与多个、彼此独立的区块链网络。通过加入多个通道，一个组织可以参与一个所谓的<strong>网络的网络</strong></li><li>通道在一群组织之间提供了一种完全独立的通信机制。当链码定义被提交到通道上时，该通道上所有的应用程序都可以使用此链码中的智能合约。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/fabric%E5%8C%BA%E5%9D%97%E9%93%BE%E5%B9%B3%E5%8F%B0.assets/1681296849809.png" alt="1681296849809"></p><blockquote><p>在上面的示例中，<code>car</code> 智能合约被定义在 <code>VEHICLE</code> 通道上，<code>insurance</code> 智能合约被定义在 <code>INSURANCE</code> 通道上。<code>car</code> 的链码定义明确了以下背书策略：任何交易在被认定为有效之前必须由 <code>ORG1</code> 和 <code>ORG2</code> 共同签名。<code>insurance</code> 智能合约的链码定义明确了只需要 <code>ORG3</code> 对交易进行背书即可。<code>ORG1</code> 参与了 <code>VEHICLE</code> 通道和 <code>INSURANCE</code> 通道这两个网络，并且能够跨网络协调与 <code>ORG2</code> 和 <code>ORG3</code> 的活动。</p></blockquote><h3 id="1-6-账本"><a href="#1-6-账本" class="headerlink" title="1.6 账本"></a>1.6 账本</h3><ul><li>由“世界状态“和”区块链“这两部分组成<ul><li><strong>世界状态</strong>是一个数据库，它存储了一组账本状态的<strong>当前值</strong>，通过世界状态，程序可以直接访问一个账本状态的当前值，不需要遍历整个交易日志来计算当前值</li><li><strong>区块链</strong>是交易日志，它记录了促成当前世界状态的所有改变</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/fabric%E5%8C%BA%E5%9D%97%E9%93%BE%E5%B9%B3%E5%8F%B0.assets/1681301669101.png" alt="1681301669101"></p><blockquote><p>账本 L 由区块链 B 和世界状态 W 组成，其中世界状态 W 由区块链 B 决定。我们也可以说世界状态 W 是源自区块链 B</p></blockquote><h4 id="1-6-1-世界状态"><a href="#1-6-1-世界状态" class="headerlink" title="1.6.1 世界状态"></a>1.6.1 世界状态</h4><ul><li><strong>世界状态被作为数据库来实现</strong></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/fabric%E5%8C%BA%E5%9D%97%E9%93%BE%E5%B9%B3%E5%8F%B0.assets/1681301818989.png" alt="1681301818989"></p><blockquote><p>示例展示的是 CAR1 和 CAR2 这两辆车的账本状态，二者都各有一个值和一个键。应用程序可以调用智能合约，该合约使用简单的账本 API 来<strong>获取</strong>、<strong>写入</strong>和<strong>删除</strong>状态。注意状态值可以是简单值（Audi…），也可以是复合值（type:BMW…）。经常会通过查询世界状态来检索具有某些特定属性的对象，例如查找所有红色宝马汽车。</p></blockquote><ul><li>应用程序提交那些会更改世界状态的交易，这些交易最终被提交到账本区块链上。</li><li>应用程序无法看到 Hyperledger Fabric SDK（软件开发工具包）设定的共识机制的细节内容，它们能做的只是调用智能合约以及在交易被收进区块链时收到通知（<strong>所有被提交的交易，无论有效与否，都会被收进区块链</strong>），但是只有那些受到相关<strong>背书组织签名</strong>的交易才会更新世界状态。如果一个交易没有得到足够背书节点的签名，那么它不会更新世界状态</li><li>每个状态都有一个版本号，版本号是供 Hyperledger Fabric 内部使用的，并且每次状态更改时版本号会发生递增。每当更新状态时，都会检查该状态的版本，以确保当前状态与背书时的版本相匹配。</li></ul><h4 id="1-6-2-区块链"><a href="#1-6-2-区块链" class="headerlink" title="1.6.2 区块链"></a>1.6.2 区块链</h4><ul><li><strong>世界状态</strong>存储了与业务对象<strong>当前状态</strong>相关的事实信息</li><li>而<strong>区块链</strong>是一种<strong>历史记录</strong>，它记录了这些业务对象是如何到达各自当前状态的相关事实。区块链记录了每个账本状态之前的所有版本以及状态是如何被更改的</li><li>区块链的结构是一群相互链接的区块的序列化日志，其中每个区块都包含一系列交易，各项交易代表了一个对世界状态进行的查询或更新操作</li><li>区块链总是以文件实现，而与之相反的是，世界状态以数据库实现</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/fabric%E5%8C%BA%E5%9D%97%E9%93%BE%E5%B9%B3%E5%8F%B0.assets/1681302297465.png" alt="1681302297465"></p><blockquote><p>B0 是该区块链的第一个区块，也叫创世区块</p><p>它并不包含任何用户交易，但却是账本的起始点</p><p>相反的，创世区块包含了一个配置交易，该交易含有网络配置（未显示）的初始状态</p></blockquote><h4 id="1-6-3-区块"><a href="#1-6-3-区块" class="headerlink" title="1.6.3 区块"></a>1.6.3 区块</h4><p>组成</p><ul><li><p><strong>区块头</strong></p><ul><li><strong>区块编号</strong>：编号从0（初始区块）开始，每在区块链上增加一个新区块，编号的数字都会加1。</li><li><strong>当前区块的哈希值</strong>：当前区块中包含的所有交易的哈希值。</li><li><strong>前一个区块头的哈希值</strong>：区块链中前一个区块头的哈希值。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/fabric%E5%8C%BA%E5%9D%97%E9%93%BE%E5%B9%B3%E5%8F%B0.assets/1681302542402.png" alt="1681302542402"></p><blockquote><p><em>区块头详情：区块 B2 的区块头 H2 包含了区块编号 2，当前区块数据 D2 的哈希值 CH2，以及前一个区块头 H1 的哈希值。</em></p></blockquote></li><li><p><strong>区块数据</strong></p><ul><li>这部分包含了一个<strong>有序的交易列表</strong>。区块数据是在排序服务创建区块时被写入的</li></ul></li><li><p><strong>区块元数据</strong></p><ul><li>这个部分包含了区块被写入的时间，还有区块写入者的证书、公钥以及签名。随后，区块的提交者也会为每一笔交易添加一个有效或无效的标记，但由于这一信息与区块同时产生，所以它不会被包含在哈希中。</li></ul></li></ul><h4 id="1-6-4-交易"><a href="#1-6-4-交易" class="headerlink" title="1.6.4 交易"></a>1.6.4 交易</h4><ul><li>交易记录了世界状态发生的更新</li><li>把交易包含在区块中的<strong>区块数据</strong>结构</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/fabric%E5%8C%BA%E5%9D%97%E9%93%BE%E5%B9%B3%E5%8F%B0.assets/1681303391932.png" alt="1681303391932"></p><blockquote><p><em>交易详情：交易 T4 位于区块 B1 的区块数据 D1 中，T4包括的内容如下：交易头 H4，一个交易签名 S4，一个交易提案 P4，一个交易响应 R4 和一系列背书 E4。</em></p><p><strong>头</strong></p><p>这部分用 H4 表示，它记录了关于交易的一些重要元数据，比如，相关链码的名字以及版本。</p><p><strong>签名</strong></p><p>这部分用 S4 表示，它包含了一个由客户端应用程序创建的加密签名。该字段是用来检查交易细节是否未经篡改，<strong>因为交易签名的生成需要用到应用程序的私钥。</strong></p><p><strong>提案</strong></p><p>这部分用 P4 表示，它负责对应用程序供给智能合约的输入参数进行编码，随后该智能合约生成提案账本更新。在智能合约运行时，这个提案提供了一套输入参数，这些参数同当前的世界状态一起决定了新的账本世界状态。</p><p><strong>响应</strong></p><p>这部分用 R4 表示，它是以<strong>读写集</strong> （RW-set）的形式记录下世界状态之前和之后的值。交易响应是智能合约的输出，如果交易验证成功，那么该交易会被应用到账本上，从而更新世界状态。</p><p><strong>背书</strong></p></blockquote><ul><li><p>示例账本</p><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/fabric%E5%8C%BA%E5%9D%97%E9%93%BE%E5%B9%B3%E5%8F%B0.assets/1681304156885.png" alt="1681304156885"></p><blockquote><p>账本 L包含了一个世界状态 W 和一个区块链 B。其中 W 包含了四个状态，各状态的键分别是：CAR0，CAR1，CAR2 和 CAR3 。而 B 包含了两个区块 0和 1。区块1包含了四笔交易：T1，T2，T3，T4</p></blockquote></li></ul><h3 id="1-7-排序服务"><a href="#1-7-排序服务" class="headerlink" title="1.7 排序服务"></a>1.7 排序服务</h3><ul><li>Hyperledger Fabric 的工作方式不同。它有一种称为<strong>排序节点</strong>的节点使交易有序，并与其他排序节点一起形成一个<strong>排序服务</strong>。因为 Fabric 的设计依赖于<strong>确定性</strong>的共识算法，所以 Peer 节点所验证的区块都是最终的和正确的。账本不会像其他分布式的以及无需许可的区块链中那样产生分叉</li><li>排序节点还维护着允许创建通道的组织列表。此组织列表称为“联盟”</li><li>排序节点还对通道执行基本访问控制，限制谁可以读写数据，以及谁可以配置数据</li></ul><h4 id="1-7-1-排序节点和交易流程"><a href="#1-7-1-排序节点和交易流程" class="headerlink" title="1.7.1 排序节点和交易流程"></a>1.7.1 排序节点和交易流程</h4><blockquote><p><strong>更新账本的应用程序涉及到三个阶段</strong>，该过程确保区块链网络中的所有节点保持它们的账本彼此一致。</p><p>在第一阶段，客户端应用程序将交易提案发送给一组节点，这些节点将调用智能合约来生成一个账本更新提案，然后背书该结果。背书节点此时不将提案中的更新应用于其账本副本。相反，背书节点将向客户端应用程序返回一个提案响应。</p><p>已背书的交易提案最终将在第二阶段经过排序生成区块，</p><p>然后在第三阶段分发给所有节点进行最终验证和提交。</p></blockquote><ul><li>将交易排序并打包到区块中<ul><li>在此阶段，应用程序客户端把包含已背书交易提案响应的交易提交到排序服务节点。排序服务创建交易区块，这些交易区块最终将分发给通道上的所有 Peer 节点，以便在第三阶段进行最终验证和提交。</li><li>排序服务节点的工作是将提交的交易按定义好的顺序安排成批次，并将它们打包成<em>区块</em>。这些区块将成为区块链的<em>区块</em>！</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/fabric%E5%8C%BA%E5%9D%97%E9%93%BE%E5%B9%B3%E5%8F%B0.assets/1681360371573.png" alt="1681360371573"></p><blockquote><p><em>排序节点的第一个角色是打包提案的账本更新。在本例中，应用程序 A1 向排序节点 O1 发送由 E1 和 E2 背书的交易 T1。同时，应用程序 A2 将 E1 背书的交易 T2 发送给排序节点 O1。O1 将来自应用程序 A1 的交易 T1 和来自应用程序 A2 的交易 T2 以及来自网络中其他应用程序的交易打包到区块 B2 中。我们可以看到，在 B2 中，交易顺序是 T1、T2、T3、T4、T6、T5，但这可能不是这些交易到达排序节点的顺序！（这个例子显示了一个非常简单的排序服务配置，只有一个排序节点。）</em></p></blockquote><ul><li>验证和提交</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/fabric%E5%8C%BA%E5%9D%97%E9%93%BE%E5%B9%B3%E5%8F%B0.assets/1681360785332.png" alt="1681360785332"></p><blockquote><p><em>排序节点的第二个角色是将区块分发给 Peer 节点。在本例中，排序节点 O1 将区块 B2 分配给节点 P1 和 P2。节点 P1 处理区块 B2，在 P1 上的账本 L1 中添加一个新区块。同时，节点 P2 处理区块 B2，从而将一个新区块添加到 P2 上的账本 L1中。一旦这个过程完成，节点 P1 和 P2 上的账本 L1 就会保持一致的更新，并且每个节点都可以通知与之连接的应用程序交易已经被处理。</em></p></blockquote><h4 id="1-7-2-排序服务的实现"><a href="#1-7-2-排序服务的实现" class="headerlink" title="1.7.2 排序服务的实现"></a>1.7.2 排序服务的实现</h4><ul><li>推荐 <strong>Raft</strong><ul><li>Raft 是一种基于 <code>etcd</code>中 Raft 协议实现的崩溃容错（Crash Fault Tolerant，CFT）排序服务。Raft 遵循“领导者跟随者”模型，这个模型中，在每个通道上选举领导者节点，其决策被跟随者复制。Raft 排序服务会比基于 Kafka 的排序服务更容易设置和管理，它的设计允许不同的组织为分布式排序服务贡献节点。</li><li>节点总是处于以下三种状态之一：跟随者、候选人或领导者。所有节点最初都是作为<strong>跟随者</strong>开始的。在这种状态下，他们可以接受来自领导者的日志条目（如果其中一个已经当选），或者为领导者投票。如果在一段时间内没有接收到日志条目或心跳（例如，5秒），节点将自己提升到<strong>候选</strong>状态。在候选状态中，节点从其他节点请求选票。如果候选人获得法定人数的选票，那么他就被提升为领导者。领导者必须接受新的日志条目并将其复制到跟随者。</li></ul></li></ul><h2 id="2-入门"><a href="#2-入门" class="headerlink" title="2. 入门"></a>2. 入门</h2><h3 id="2-1-配置环境"><a href="#2-1-配置环境" class="headerlink" title="2.1 配置环境"></a>2.1 配置环境</h3><blockquote><p>此处参考b站视频，虽然可能不全，并且后半段实现不了</p><p>但是前面的跟下来都还不错！但是要注意自己的版本问题！</p><p><a href="https://www.bilibili.com/video/BV1g3411h71Z/?spm_id_from=333.337.search-card.all.click&vd_source=ce97d263f08af76fc25ff49de530fe92">从0开始快速安装Hyperledger Fabric_哔哩哔哩_bilibili</a></p></blockquote><h4 id="2-1-1-ubuntu-联网"><a href="#2-1-1-ubuntu-联网" class="headerlink" title="2.1.1 ubuntu 联网"></a>2.1.1 ubuntu 联网</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl restart NetworkManager.service</span><br><span class="line">sudo apt-get install network-manager</span><br><span class="line">sudo systemctl restart NetworkManager.service</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/fabric%E5%8C%BA%E5%9D%97%E9%93%BE%E5%B9%B3%E5%8F%B0.assets/1681387612411.png" alt="1681387612411"></p><h4 id="2-1-2-apt-换源"><a href="#2-1-2-apt-换源" class="headerlink" title="2.1.2 apt 换源"></a>2.1.2 apt 换源</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/</span><br><span class="line">sudo gedit /etc/apt/sources.list</span><br><span class="line">sudo apt update</span><br></pre></td></tr></table></figure><h4 id="2-1-3-安装-docker"><a href="#2-1-3-安装-docker" class="headerlink" title="2.1.3 安装 docker"></a>2.1.3 安装 docker</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 安装docker、docker-compose</span><br><span class="line">sudo apt install docker docker-compose</span><br><span class="line">sudo systemctl enable docker</span><br><span class="line">sudo usermod -a -G docker &lt;username&gt;</span><br></pre></td></tr></table></figure><h4 id="2-1-4-安装-golang"><a href="#2-1-4-安装-golang" class="headerlink" title="2.1.4 安装 golang"></a>2.1.4 安装 golang</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 安装golang</span><br><span class="line">https://go.dev/doc/install</span><br><span class="line">sudo su</span><br><span class="line">rm -rf /usr/local/go &amp;&amp; tar -C /usr/local -xzf go1.17.6.linux-amd64.tar.gz</span><br><span class="line">gedit /etc/profile</span><br><span class="line">export PATH=$PATH:/usr/local/go/bin</span><br><span class="line">gedit ~/.bashrc</span><br><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure><h4 id="2-1-5-docker-加速器"><a href="#2-1-5-docker-加速器" class="headerlink" title="2.1.5 docker 加速器"></a>2.1.5 docker 加速器</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// docker加速器</span><br><span class="line">https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors</span><br></pre></td></tr></table></figure><h4 id="2-1-6-安装fabric-sample"><a href="#2-1-6-安装fabric-sample" class="headerlink" title="2.1.6 安装fabric-sample"></a>2.1.6 安装fabric-sample</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1、手动创建脚本，安装samples、docker</span><br><span class="line">https://github.com/hyperledger/fabric/blob/main/scripts/bootstrap.sh</span><br><span class="line">修改binaries=false</span><br><span class="line">sudo chmod u+x bootstrap.sh</span><br><span class="line">./bootstrap.sh</span><br><span class="line"></span><br><span class="line">2、安装binaries</span><br><span class="line">https://github.com/hyperledger/fabric/releases/download/v2.4.1/hyperledger-fabric-linux-amd64-2.4.1.tar.gz</span><br><span class="line">https://github.com/hyperledger/fabric-ca/releases/download/v1.5.2/hyperledger-fabric-ca-linux-amd64-1.5.2.tar.gz</span><br><span class="line">tar -xzvf 压缩包名 -C 目的地</span><br><span class="line"></span><br><span class="line">3、配置go代理</span><br><span class="line">go env -w GO111MODULE=on</span><br><span class="line">go env -w GOPROXY=https://goproxy.cn,direct</span><br></pre></td></tr></table></figure><h2 id="3-开发"><a href="#3-开发" class="headerlink" title="3. 开发"></a>3. 开发</h2><h3 id="3-1-分析"><a href="#3-1-分析" class="headerlink" title="3.1 分析"></a>3.1 分析</h3><h4 id="3-1-1-商业票据"><a href="#3-1-1-商业票据" class="headerlink" title="3.1.1 商业票据"></a>3.1.1 商业票据</h4><ul><li><p>票据 00001 是 5 月 31 号由 MagnetoCorp 发行的。该票据的第一个<strong>状态</strong>，它具有不同的属性和值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Issuer = MagnetoCorp</span><br><span class="line">Paper = 00001</span><br><span class="line">Owner = MagnetoCorp</span><br><span class="line">Issue date = 31 May 2020</span><br><span class="line">Maturity = 30 November 2020</span><br><span class="line">Face value = 5M USD</span><br><span class="line">Current state = issued</span><br></pre></td></tr></table></figure><blockquote><p>票据的状态是 <strong>发行</strong> 交易的结果，它使得 MagnetoCorp 公司的第一张商业票据面世！注意该票据在今年晚些时候如何兑换面值 500 万美元。当票据 00001 发行后 <code>Issuer</code> 和 <code>Owner</code> 具有相同的值。该票据有唯一标识 <code>MagnetoCorp00001</code>——它是 <code>Issuer</code> 属性和 <code>Paper</code> 属性的组合。最后，属性 <code>Current state = issued</code> 快速识别了 MagnetoCorp 票据 00001 在它生命周期中的阶段。</p></blockquote></li><li><p>发行后不久，该票据被 DigiBank 购买。由于<strong>购买</strong>交易，同一个商业票据如何发生变化：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Issuer = MagnetoCorp</span><br><span class="line">Paper = 00001</span><br><span class="line">Owner = DigiBank</span><br><span class="line">Issue date = 31 May 2020</span><br><span class="line">Maturity date = 30 November 2020</span><br><span class="line">Face value = 5M USD</span><br><span class="line">Current state = trading</span><br></pre></td></tr></table></figure><blockquote><p>最重要的变化是 <code>Owner</code> 的改变——票据初始拥有者是 <code>MagnetoCorp</code> 而现在是 <code>DigiBank</code>。我们可以想象该票据后来如何被出售给 BrokerHouse 或 HedgeMatic，以及相应的变更为相应的 <code>Owner</code>。注意 <code>Current state</code> 允许我们轻松的识别该票据目前状态是 <code>trading</code>。</p></blockquote></li><li><p>6 个月后，如果 DigiBank 仍然持有商业票据，它就可以从 MagnetoCorp 那里兑换：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Issuer = MagnetoCorp</span><br><span class="line">Paper = 00001</span><br><span class="line">Owner = MagnetoCorp</span><br><span class="line">Issue date = 31 May 2020</span><br><span class="line">Maturity date = 30 November 2020</span><br><span class="line">Face value = 5M USD</span><br><span class="line">Current state = redeemed</span><br></pre></td></tr></table></figure><blockquote><p>最终的<strong>兑换</strong>交易结束了这个商业票据的生命周期——它可以被认为票据已经终止。通常必须保留已兑换的商业票据的记录，并且 <code>redeemed</code> 状态允许我们快速识别这些。通过将 <code>Owner</code> 跟交易创建者的身份进行比较，一个票据的 <code>Owner</code> 值可以被用来在<strong>兑换</strong>交易上进行访问控制</p></blockquote></li></ul><h4 id="3-1-2-交易"><a href="#3-1-2-交易" class="headerlink" title="3.1.2 交易"></a>3.1.2 交易</h4><ul><li><p>我们已经看到票据 00001 的生命周期相对简单——由于<strong>发行</strong>，<strong>购买</strong>和<strong>兑换</strong>交易，它在 <code>issued</code>, <code>trading</code> 和 <code>redeemed</code> 状态之间转移</p></li><li><p>注意交易和票据不同！！</p><ul><li>发行交易</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Txn = issue</span><br><span class="line">Issuer = MagnetoCorp</span><br><span class="line">Paper = 00001</span><br><span class="line">Issue time = 31 May 2020 09:00:00 EST</span><br><span class="line">Maturity date = 30 November 2020</span><br><span class="line">Face value = 5M USD</span><br></pre></td></tr></table></figure><ul><li>购买交易</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Txn = buy</span><br><span class="line">Issuer = MagnetoCorp</span><br><span class="line">Paper = 00001</span><br><span class="line">Current owner = MagnetoCorp</span><br><span class="line">New owner = DigiBank</span><br><span class="line">Purchase time = 31 May 2020 10:00:00 EST</span><br><span class="line">Price = 4.94M USD</span><br></pre></td></tr></table></figure><ul><li>兑换交易</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Txn = redeem</span><br><span class="line">Issuer = MagnetoCorp</span><br><span class="line">Paper = 00001</span><br><span class="line">Current owner = HedgeMatic</span><br><span class="line">Redeem time = 30 Nov 2020 12:00:00 EST</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-2-流程和数据设计"><a href="#3-2-流程和数据设计" class="headerlink" title="3.2 流程和数据设计"></a>3.2 流程和数据设计</h3><h4 id="3-2-1-生命周期"><a href="#3-2-1-生命周期" class="headerlink" title="3.2.1 生命周期"></a>3.2.1 生命周期</h4><ul><li><p>在处理商业票据时有两个重要的概念：<strong>状态</strong>和<strong>交易</strong></p></li><li><p>对状态和交易的有效分析是成功实施的重要起点，可以用状态转移表来表示商业票据的生命周期：</p><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/fabric%E5%8C%BA%E5%9D%97%E9%93%BE%E5%B9%B3%E5%8F%B0.assets/1681607417562.png" alt="1681607417562"></p><blockquote><p><em>商业票据的状态转移表。商业票据通过<strong>发行</strong>，<strong>购买</strong>和<strong>兑换</strong>交易在<strong>已发行</strong>、<strong>交易中</strong>和<strong>已兑换</strong>之间进行状态转移。</em></p></blockquote></li></ul><h4 id="3-2-2-账本状态"><a href="#3-2-2-账本状态" class="headerlink" title="3.2.2 账本状态"></a>3.2.2 账本状态</h4><ul><li><p>商业票据的结构：</p><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/fabric%E5%8C%BA%E5%9D%97%E9%93%BE%E5%B9%B3%E5%8F%B0.assets/1681607716814.png" alt="1681607716814"></p><blockquote><p><em>商业票据可以被表示为属性集，每个属性都对应一个值。通常，这些属性的组合会为每个票据提供一个唯一键</em></p><p>结合来看，属性的完整集合构成了商业票据的<strong>状态</strong>。此外，这些商业票据的全部集合构成了账本的世界状态。</p></blockquote></li><li><p>查看 MagnetoCorp 的票据 <code>00001</code> 如何表示为一个状态向量，根据不同的交易刺激进行转换:</p><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/fabric%E5%8C%BA%E5%9D%97%E9%93%BE%E5%B9%B3%E5%8F%B0.assets/1681607900927.png" alt="1681607900927"></p><blockquote><p>注意每个独立的票据都起于空状态，技术上被称作 <a href="https://en.wikipedia.org/wiki/Null_(SQL)">nil</a>，来表示票据不存在！通过<strong>发行</strong>交易，票据 <code>00001</code> 问世，然后由于<strong>购买</strong>和<strong>兑换</strong>交易而更新状态</p></blockquote></li></ul><h4 id="3-2-3-状态键值"><a href="#3-2-3-状态键值" class="headerlink" title="3.2.3 状态键值"></a>3.2.3 状态键值</h4><ul><li>大多数的实际应用中，状态会有一个属性组合在给定的上下文中唯一识别它——它就是<strong>主键</strong></li><li>PaperNet 商业票据的主键是通过 <code>Issuer</code> 属性和 <code>paper</code> 属性拼接得到的，所以 MagnetoCorp 的第一个票据的主键就是 <code>MagnetoCorp00001</code></li><li>Fabric 需要账本中的每个状态都有唯一的主键</li><li>当唯一主键在可用的属性集中不能获得，应用决定的唯一键会被指定为交易的输入来创建状态。<strong>这个唯一键的形式一般是 UUID</strong></li></ul><h4 id="3-2-3-逻辑表示"><a href="#3-2-3-逻辑表示" class="headerlink" title="3.2.3 逻辑表示"></a>3.2.3 逻辑表示</h4><blockquote><p>为了满足不同类型的查询任务，把所有相关的商业票据按逻辑顺序排列在一起是很有帮助的。PaperNet 的设计包含了商业票据列表的思想——一个逻辑容器，每当商业票据发行或发生其他更改时，该容器都会更新</p></blockquote><ul><li><p>把所有的 PaperNet 商业票据放在一个商业票据列表中是有帮助的：</p><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/fabric%E5%8C%BA%E5%9D%97%E9%93%BE%E5%B9%B3%E5%8F%B0.assets/1681608349698.png" alt="1681608349698"></p><blockquote><p>新票据由于<strong>发行</strong>交易被加入到列表中，然后列表中已存在的票据因为<strong>购买</strong>交易和<strong>兑换</strong>交易可以被更新状态。列表有一个描述性的名称：<code>org.papernet.papers</code>；使用这种DNS 名真的是一个好主意，因为适当的名称会让你的区块链设计对其他人来说是直观的。这种想法同样也适用于智能合约的名字。</p></blockquote></li></ul><h4 id="3-2-4-物理表现"><a href="#3-2-4-物理表现" class="headerlink" title="3.2.4 物理表现"></a>3.2.4 物理表现</h4><ul><li><p>我们可以正确地想到 PaperNet 中的单个票据列表—— <code>org.papernet.papers</code> ——列表最好作为一组单独的 Fabric 状态来实现，其复合键将状态与其列表关联起来。这样，每个状态的复合键都是惟一的，并支持有效的列表查询</p><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/fabric%E5%8C%BA%E5%9D%97%E9%93%BE%E5%B9%B3%E5%8F%B0.assets/1681608524162.png" alt="1681608524162"></p></li><li><p>状态向量的物理设计对于优化性能和行为<strong>非常重要</strong>。保持状态的独立！</p></li></ul><h3 id="3-3-智能合约处理"><a href="#3-3-智能合约处理" class="headerlink" title="3.3 智能合约处理"></a>3.3 智能合约处理</h3><blockquote><p> 连接到网络的所有应用程序必须使用相同版本的智能合约，以便它们共同实现相同的共享业务流程和数据。</p></blockquote><blockquote><p>在 Java 中，类必须使用 <code>@Contract(...)</code> 标注进行包装。它支持额外的智能合约信息，比如许可和作者。 <code>@Default()</code> 标注表明该智能合约是默认合约类。在智能合约中标记默认合约类在一些有多个合约类的智能合约中会很有用。</p><p><a href="https://github.com/hyperledger/fabric-samples/blob/master/commercial-paper/organization/magnetocorp//contract-java/src/main/java/org/example/CommercialPaperContract.java">fabric-samples&#x2F;CommercialPaperContract.java at master · hyperledger&#x2F;fabric-samples (github.com)</a></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">SPDX-License-Identifier: Apache-2.0</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">package</span> org.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.logging.Logger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.example.ledgerapi.State;</span><br><span class="line"><span class="keyword">import</span> org.hyperledger.fabric.contract.Context;</span><br><span class="line"><span class="keyword">import</span> org.hyperledger.fabric.contract.ContractInterface;</span><br><span class="line"><span class="keyword">import</span> org.hyperledger.fabric.contract.annotation.Contact;</span><br><span class="line"><span class="keyword">import</span> org.hyperledger.fabric.contract.annotation.Contract;</span><br><span class="line"><span class="keyword">import</span> org.hyperledger.fabric.contract.annotation.Default;</span><br><span class="line"><span class="keyword">import</span> org.hyperledger.fabric.contract.annotation.Info;</span><br><span class="line"><span class="keyword">import</span> org.hyperledger.fabric.contract.annotation.License;</span><br><span class="line"><span class="keyword">import</span> org.hyperledger.fabric.contract.annotation.Transaction;</span><br><span class="line"><span class="keyword">import</span> org.hyperledger.fabric.shim.ChaincodeStub;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A custom context provides easy access to list of all commercial papers</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Define commercial paper smart contract by extending Fabric Contract class</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Contract(name = &quot;org.papernet.commercialpaper&quot;, info = @Info(title = &quot;MyAsset contract&quot;, description = &quot;&quot;, version = &quot;0.0.1&quot;, license = @License(name = &quot;SPDX-License-Identifier: Apache-2.0&quot;, url = &quot;&quot;), contact = @Contact(email = &quot;java-contract@example.com&quot;, name = &quot;java-contract&quot;, url = &quot;http://java-contract.me&quot;)))</span></span><br><span class="line"><span class="meta">@Default</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommercialPaperContract</span> <span class="keyword">implements</span> <span class="title class_">ContractInterface</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// use the classname for the logger, this way you can refactor</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">Logger</span> <span class="variable">LOG</span> <span class="operator">=</span> Logger.getLogger(CommercialPaperContract.class.getName());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Context <span class="title function_">createContext</span><span class="params">(ChaincodeStub stub)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CommercialPaperContext</span>(stub);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CommercialPaperContract</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Define a custom context for commercial paper</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Instantiate to perform any setup of the ledger that might be required.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;Context&#125; ctx the transaction context</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Transaction</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">instantiate</span><span class="params">(CommercialPaperContext ctx)</span> &#123;</span><br><span class="line">        <span class="comment">// No implementation required with this example</span></span><br><span class="line">        <span class="comment">// It could be where data migration is performed, if necessary</span></span><br><span class="line">        LOG.info(<span class="string">&quot;No data migration to perform&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Issue commercial paper</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;Context&#125; ctx the transaction context</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;String&#125; issuer commercial paper issuer</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;Integer&#125; paperNumber paper number for this issuer</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;String&#125; issueDateTime paper issue date</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;String&#125; maturityDateTime paper maturity date</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;Integer&#125; faceValue face value of paper</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Transaction</span></span><br><span class="line">    <span class="keyword">public</span> CommercialPaper <span class="title function_">issue</span><span class="params">(CommercialPaperContext ctx, String issuer, String paperNumber, String issueDateTime,</span></span><br><span class="line"><span class="params">            String maturityDateTime, <span class="type">int</span> faceValue)</span> &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(ctx);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// create an instance of the paper</span></span><br><span class="line">        <span class="type">CommercialPaper</span> <span class="variable">paper</span> <span class="operator">=</span> CommercialPaper.createInstance(issuer, paperNumber, issueDateTime, maturityDateTime,</span><br><span class="line">                faceValue,issuer,<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Smart contract, rather than paper, moves paper into ISSUED state</span></span><br><span class="line">        paper.setIssued();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Newly issued paper is owned by the issuer</span></span><br><span class="line">        paper.setOwner(issuer);</span><br><span class="line"></span><br><span class="line">        System.out.println(paper);</span><br><span class="line">        <span class="comment">// Add the paper to the list of all similar commercial papers in the ledger</span></span><br><span class="line">        <span class="comment">// world state</span></span><br><span class="line">        ctx.paperList.addPaper(paper);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Must return a serialized paper to caller of smart contract</span></span><br><span class="line">        <span class="keyword">return</span> paper;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Buy commercial paper</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;Context&#125; ctx the transaction context</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;String&#125; issuer commercial paper issuer</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;Integer&#125; paperNumber paper number for this issuer</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;String&#125; currentOwner current owner of paper</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;String&#125; newOwner new owner of paper</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;Integer&#125; price price paid for this paper</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;String&#125; purchaseDateTime time paper was purchased (i.e. traded)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Transaction</span></span><br><span class="line">    <span class="keyword">public</span> CommercialPaper <span class="title function_">buy</span><span class="params">(CommercialPaperContext ctx, String issuer, String paperNumber, String currentOwner,</span></span><br><span class="line"><span class="params">            String newOwner, <span class="type">int</span> price, String purchaseDateTime)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Retrieve the current paper using key fields provided</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">paperKey</span> <span class="operator">=</span> State.makeKey(<span class="keyword">new</span> <span class="title class_">String</span>[] &#123; paperNumber &#125;);</span><br><span class="line">        <span class="type">CommercialPaper</span> <span class="variable">paper</span> <span class="operator">=</span> ctx.paperList.getPaper(paperKey);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Validate current owner</span></span><br><span class="line">        <span class="keyword">if</span> (!paper.getOwner().equals(currentOwner)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Paper &quot;</span> + issuer + paperNumber + <span class="string">&quot; is not owned by &quot;</span> + currentOwner);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// First buy moves state from ISSUED to TRADING</span></span><br><span class="line">        <span class="keyword">if</span> (paper.isIssued()) &#123;</span><br><span class="line">            paper.setTrading();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check paper is not already REDEEMED</span></span><br><span class="line">        <span class="keyword">if</span> (paper.isTrading()) &#123;</span><br><span class="line">            paper.setOwner(newOwner);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(</span><br><span class="line">                    <span class="string">&quot;Paper &quot;</span> + issuer + paperNumber + <span class="string">&quot; is not trading. Current state = &quot;</span> + paper.getState());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Update the paper</span></span><br><span class="line">        ctx.paperList.updatePaper(paper);</span><br><span class="line">        <span class="keyword">return</span> paper;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Redeem commercial paper</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;Context&#125; ctx the transaction context</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;String&#125; issuer commercial paper issuer</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;Integer&#125; paperNumber paper number for this issuer</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;String&#125; redeemingOwner redeeming owner of paper</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;String&#125; redeemDateTime time paper was redeemed</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Transaction</span></span><br><span class="line">    <span class="keyword">public</span> CommercialPaper <span class="title function_">redeem</span><span class="params">(CommercialPaperContext ctx, String issuer, String paperNumber, String redeemingOwner,</span></span><br><span class="line"><span class="params">            String redeemDateTime)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">paperKey</span> <span class="operator">=</span> CommercialPaper.makeKey(<span class="keyword">new</span> <span class="title class_">String</span>[] &#123; paperNumber &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">CommercialPaper</span> <span class="variable">paper</span> <span class="operator">=</span> ctx.paperList.getPaper(paperKey);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check paper is not REDEEMED</span></span><br><span class="line">        <span class="keyword">if</span> (paper.isRedeemed()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Paper &quot;</span> + issuer + paperNumber + <span class="string">&quot; already redeemed&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Verify that the redeemer owns the commercial paper before redeeming it</span></span><br><span class="line">        <span class="keyword">if</span> (paper.getOwner().equals(redeemingOwner)) &#123;</span><br><span class="line">            paper.setOwner(paper.getIssuer());</span><br><span class="line">            paper.setRedeemed();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Redeeming owner does not own paper&quot;</span> + issuer + paperNumber);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ctx.paperList.updatePaper(paper);</span><br><span class="line">        <span class="keyword">return</span> paper;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4-应用"><a href="#3-4-应用" class="headerlink" title="3.4 应用"></a>3.4 应用</h3><h4 id="3-4-1-基本流程"><a href="#3-4-1-基本流程" class="headerlink" title="3.4.1 基本流程"></a>3.4.1 基本流程</h4><ul><li><p>应用程序如何调用商业票据智能合约的简化图表：</p><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/fabric%E5%8C%BA%E5%9D%97%E9%93%BE%E5%B9%B3%E5%8F%B0.assets/1681609886914.png" alt="1681609886914"></p></li><li><p>应用程序必须遵循六个基本步骤来提交交易：</p><ul><li>从钱包中选择一个身份</li><li>连接到网关</li><li>访问所需的网络</li><li>构建智能合约的交易请求</li><li>将交易提交到网络</li><li>处理响应</li></ul></li></ul><h2 id="4-工作流程"><a href="#4-工作流程" class="headerlink" title="4. 工作流程"></a>4. 工作流程</h2><p><img src="https://cdn.jsdelivr.net/gh/Tangsmallrong/myPico/fabric%E5%8C%BA%E5%9D%97%E9%93%BE%E5%B9%B3%E5%8F%B0.assets/1681614315146.png" alt="1681614315146"></p>]]></content>
      
      
      <categories>
          
          <category> Blockchain </category>
          
      </categories>
      
      
        <tags>
            
            <tag> fabric </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis</title>
      <link href="/2023/01/05/MyBatis/"/>
      <url>/2023/01/05/MyBatis/</url>
      
        <content type="html"><![CDATA[<h2 id="一、MyBatis"><a href="#一、MyBatis" class="headerlink" title="一、MyBatis"></a>一、MyBatis</h2><h3 id="1-MyBatis-简介"><a href="#1-MyBatis-简介" class="headerlink" title="1. MyBatis 简介"></a>1. MyBatis 简介</h3><h4 id="1-1-MyBatis-历史"><a href="#1-1-MyBatis-历史" class="headerlink" title="1.1 MyBatis 历史"></a>1.1 MyBatis 历史</h4><ul><li><p><strong>MyBatis</strong> 本是 Apache 的一个开源项目 <strong>iBatis</strong>，2010年这个项目由 Apache Software Foundation 迁移到了 Google Code，并且改名为 MyBatis 。代码于2013年11月迁移 Github。</p></li><li><p>iBatis 一词来源于 “internet” 和 “abatis” 的组合，是一个<strong>基于Java的持久层框架</strong>。iBatis 提供的持久层框架包括 <strong>SQL Maps</strong>(sql 映射) 和 <strong>Data Access Objects</strong>（DAO）。</p></li></ul><h4 id="1-2-MyBatis-特性"><a href="#1-2-MyBatis-特性" class="headerlink" title="1.2 MyBatis 特性"></a>1.2 MyBatis 特性</h4><ul><li>MyBatis 是支持定制化 SQL、存储过程以及高级映射的优秀的持久层框架</li><li>MyBatis <strong>避免</strong>了几乎所有的 JDBC 代码和手动设置参数以及获取结果集</li><li>MyBatis可以使用简单的<strong>XML</strong>或<strong>注解</strong>用于配置和原始映射，将接口和 Java 的 <strong>POJO（Plain Old Java Objects，普通的 Java 对象）</strong>映射成数据库中的记录</li><li>MyBatis 是一个 <strong>半自动的ORM</strong>（Object Relation Mapping 对象关系[关系型数据库]映射）框架</li></ul><h4 id="1-3-MyBatis-下载"><a href="#1-3-MyBatis-下载" class="headerlink" title="1.3 MyBatis 下载"></a>1.3 MyBatis 下载</h4><ul><li>下载地址：<a href="https://github.com/mybatis/mybatis-3">https://github.com/mybatis/mybatis-3</a></li></ul><p><img src="/../img/SSM%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88.assets/1669881015705.png" alt="图1.3.1"></p><p><img src="/../img/SSM%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88.assets/1670076569225.png" alt="图1.3.2"></p><h4 id="1-4-和其它的持久层技术对比"><a href="#1-4-和其它的持久层技术对比" class="headerlink" title="1.4 和其它的持久层技术对比"></a>1.4 和其它的持久层技术对比</h4><ul><li><strong>JDBC</strong><ul><li>SQL 夹杂在Java代码中耦合度高，导致硬编码内伤</li><li>维护不易且实际开发需求中 SQL 有变化，频繁修改的情况多见</li><li>代码冗长，开发效率低</li></ul></li><li><strong>Hibernate 和 JPA</strong><ul><li>操作简便，开发效率高</li><li>程序中的长难复杂 SQL 需要绕过框架</li><li>内部自动生产的 SQL，不容易做特殊优化</li><li>基于全映射的全自动框架，大量字段的 POJO 进行部分映射时比较困难</li><li>反射操作太多，导致数据库性能下降</li></ul></li><li><strong>MyBatis</strong><ul><li>轻量级，性能出色</li><li>SQL 和 Java 编码分开，功能边界清晰。<strong>Java代码专注业务、SQL语句专注数据</strong></li><li>开发效率稍逊于HIbernate，但是完全能够接受</li></ul></li></ul><h3 id="2-搭建-MyBatis"><a href="#2-搭建-MyBatis" class="headerlink" title="2. 搭建 MyBatis"></a>2. 搭建 MyBatis</h3><h4 id="2-1-开发环境"><a href="#2-1-开发环境" class="headerlink" title="2.1 开发环境"></a>2.1 开发环境</h4><ul><li>IDE：idea 2020.3.2</li><li>构建工具：maven 3.6.1</li><li>MySQL版本：MySQL 5.7.19</li><li>MyBatis版本：MyBatis 3.5.10</li></ul><blockquote><p>MySQL 不同版本注意事项</p><p>1、 驱动类 driver-class-name</p><p>MySQL 5 版本使用 jdbc5 驱动，驱动类使用：com.mysql.jdbc.Driver</p><p>MySQL 8 版本使用 jdbc8 驱动，驱动类使用：com.mysql.cj.jdbc.Driver</p><p>2、连接地址 url</p><p>MySQL 5 版本的 url：</p><p>jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;ssm</p><p>MySQL 8 版本的 url：</p><p>jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;ssm?serverTimezone&#x3D;UTC</p><p>否则报错</p></blockquote><h4 id="2-2-创建-maven-工程"><a href="#2-2-创建-maven-工程" class="headerlink" title="2.2 创建 maven 工程"></a>2.2 创建 maven 工程</h4><p>（1）empty project?然后直接新建模块(module)?</p><p><img src="/../img/SSM%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88.assets/1670113569083.png" alt="图2.2.1"></p><p>（2）<strong>打包方式 –&gt; jar</strong>(在 pom.xml 中)</p><p><img src="/../img/SSM%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88.assets/1670113654328.png" alt="图2.2.2"></p><p>（3）导入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Mybatis核心 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- junit测试 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- MySQL驱动 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.47<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--因为我的maver库李MySQL版本为5.1.3所以我的版本号为5.1.3 根据自身版本修改--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>（4）创建数据库和表</p><p><img src="/../img/SSM%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88.assets/1670114147444.png" alt="图2.2.3"></p><p>（5）创建对应的实体类</p><p><img src="/../img/SSM%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88.assets/1670114414801.png" alt="图2.2.4"></p><h4 id="2-3-创建-MyBatis-的核心配置文件夹"><a href="#2-3-创建-MyBatis-的核心配置文件夹" class="headerlink" title="2.3 创建 MyBatis 的核心配置文件夹"></a>2.3 创建 MyBatis 的核心配置文件夹</h4><blockquote><p>习惯上命名为 <strong>mybatis-config.xml</strong>，这个文件名仅仅只是建议，并非强制要求。将来整合Spring之后，这个配置文件可以省略，所以操作时可以直接复制、粘贴。</p><p><strong>核心配置文件主要用于配置连接数据库的环境以及MyBatis的全局配置信息</strong>(设置如何连接数据库，而 MyBatis 的映射文件是设置如何操作数据库)</p><p>核心配置文件<strong>存放的位置是 src&#x2F;main&#x2F;resources 目录</strong>下</p><p>核心配置文件的内容可以从mybatis的官方文档中的 Getting Started 获得</p></blockquote><p>（1）官方文档中找配置文件里要写的内容</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置连接数据库的环境 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/ssm?serverTimezone=UTC<span class="symbol">&amp;amp;</span>useSSL=false<span class="symbol">&amp;amp;</span></span></span></span><br><span class="line"><span class="string"><span class="tag">                           useUnicode=true<span class="symbol">&amp;amp;</span>characterEncoding=UTF-8&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;thr&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 引入 mybatis 的映射文件(映射文件里头写的是 sql 语句) </span></span><br><span class="line"><span class="comment">            通过读取核心配置文件来获取一个操作数据库的对象, 就可以直接执行 sql</span></span><br><span class="line"><span class="comment">            而 sql 语句在映射文件中, 所以要把映射文件配置到核心配置文件中, </span></span><br><span class="line"><span class="comment">            才可以通过加载核心配置文件去找到对应映射文件中的 sql 去执行以便实现效果 </span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;mappers/UserMapper.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="/../img/SSM%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88.assets/1670336511797.png" alt="图2.3.1"></p><p><img src="/../img/SSM%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88.assets/1672366373796.png" alt="图2.3.2"></p><h4 id="2-4-创建-mapper-接口"><a href="#2-4-创建-mapper-接口" class="headerlink" title="2.4 创建 mapper 接口"></a>2.4 创建 mapper 接口</h4><blockquote><p>MyBatis 中的 mapper 接口相当于以前的dao，但是区别在于，<strong>mapper仅仅是接口，我们不需要提供实现类</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.thr.mybatis.mapper;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    创建一个 mapper 接口(不用实现类) --&gt; mapper 接口中的一个方法对应映射文件的一个 sql 语句</span></span><br><span class="line"><span class="comment">    即可通过 mybatis 里头的一些功能来为它创建一个代理实现类</span></span><br><span class="line"><span class="comment">    当我们去调用接口里的方法时, 就可以直接对应一个 sql 语句并执行该语句</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    接口的起名规则: 我们所操作的表叫 t_user, 表当前对应的实体类叫 User 类,</span></span><br><span class="line"><span class="comment">                    所以当前的 mapper 接口就叫 UserMapper</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        实现添加功能的方法</span></span><br><span class="line"><span class="comment">        返回值: 增删改的返回值是固定的, 是受影响的行数, 故返回值设为 int 型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">insertUser</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-5-创建-MyBatis-的映射文件"><a href="#2-5-创建-MyBatis-的映射文件" class="headerlink" title="2.5 创建 MyBatis 的映射文件"></a>2.5 创建 MyBatis 的映射文件</h4><p>关系梳理：</p><ul><li>一张表 ——&gt; 实体类 —-&gt; 对应当前的mapper接口—-&gt;对应一个映射文件</li><li>mapper接口中的方法 —&gt; 对应映射文件中的SQL语句</li></ul><p><strong>相关概念</strong>：<strong>ORM</strong>（<strong>O</strong>bject <strong>R</strong>elationship <strong>M</strong>apping）对象关系映射。</p><ul><li><p>对象：Java的实体类对象</p></li><li><p>关系：关系型数据库</p></li><li><p>映射：二者之间的对应关系</p></li></ul><table><thead><tr><th><strong>Java概念</strong></th><th><strong>数据库概念</strong></th></tr></thead><tbody><tr><td>类</td><td>表</td></tr><tr><td>属性</td><td>字段 &#x2F; 列</td></tr><tr><td>对象</td><td>记录 &#x2F; 行</td></tr></tbody></table><blockquote><p>1、映射文件的命名规则</p><p><strong>表所对应的实体类的类名+Mapper.xml</strong></p><p>例如：<strong>表</strong> t_user，映射的实体<strong>类</strong>为 User，所对应的<strong>映射文件</strong>为 UserMapper.xml，<strong>mapper 接口</strong>就叫 UserMapper</p><p><strong>因此一个映射文件对应一个实体类，对应一张表的操作</strong></p><p>MyBatis 映射文件用于编写 SQL，访问以及操作表中的数据</p><p>2、MyBatis 中可以面向接口操作数据，要保证两个一致</p><p>(1) mapper 接口的全类名和映射文件的命名空间（namespace）保持一致</p><p>(2) mapper 接口中方法的方法名和映射文件中编写SQL的标签的id属性保持一致</p><p>3、<strong>映射文件的内容同样可以从官方文档</strong>的 Getting Started 中获得（第四页）</p></blockquote><p><img src="/../img/SSM%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88.assets/1670385439032.png" alt="图2.5.1"></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 映射文件里头写 sql 语句 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.thr.mybatis.mapper.UserMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        mapper 接口和映射文件需保证两个一致：</span></span><br><span class="line"><span class="comment">        1、mapper 接口的 全类名 和 映射文件 的 namespace 保持一致</span></span><br><span class="line"><span class="comment">        2、mapper 接口中方法的方法名和映射文件中 sql 的 id属性 保持一致</span></span><br><span class="line"><span class="comment">            (建议把 mapper 接口中的方法复制一份到所写的对应的 sql 语句上方)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       保证两个一致后, 当我们调用 mapper 接口中的方法时, 就会根据当前 mapper 接口的全类名来找到咱们的映射文件,</span></span><br><span class="line"><span class="comment">        并且根据我们当前调用的方法的方法名来找到 sql 语句, 来获取这个标签中的 sql 并执行该 sql</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- int insertUser(); --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertUser&quot;</span>&gt;</span></span><br><span class="line">        insert into ssm.t_user values(null, &#x27;admin&#x27;, &#x27;123456&#x27;, 23, &#x27;男&#x27;, &#x27;1234@qq.com&#x27;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="/../img/SSM%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88.assets/1672383994244.png" alt="图2.5.2"></p><p>然后修改 mybatis-config.xml 中引入映射文件的路径 </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 引入映射文件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;mappers/UserMapper.xml&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-6-通过-junit-测试功能"><a href="#2-6-通过-junit-测试功能" class="headerlink" title="2.6 通过 junit 测试功能"></a>2.6 通过 junit 测试功能</h4><p>（1）创建测试类</p><p><img src="/../img/SSM%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88.assets/1672384450032.png" alt="图2.6.1"></p><ul><li>概念补充：<ul><li>SqlSession：代表<strong>Java程序和数据库之间的会话</strong>（HttpSession是Java程序和浏览器之间的会话）</li><li>SqlSessionFactory：是 “生产” SqlSession的 “工厂”</li><li>工厂模式：如果创建某一个对象，使用的<strong>过程基本固定</strong>，那么我们就<strong>可以把创建这个对象的相关代码封装到一个 “工厂类” 中</strong>，以后都<strong>使用这个工厂类来 “生产” 我们需要的对象</strong></li></ul></li><li>代码：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.thr.mybatis.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBatisTest</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testInsert</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 获取核心配置文件的输入流(读的功能), 注意此处的 Resources 是 org.apache.ibatis.io 里的</span></span><br><span class="line">        <span class="comment">// Resources.getResourceAsStream 用于获取当前的某一个文件(这里是核心配置文件)所对应的字节输入流</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> Resources.getResourceAsStream(<span class="string">&quot;mybatis-config.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取 sqlSessionFactoryBuilder 对象</span></span><br><span class="line">        <span class="comment">// 用于构建一个 SqlSessionFactory, 而 SqlSessionFactory 是一个工厂对象, 使用的是工厂模式, 能够为我们提供 SqlSession 对象</span></span><br><span class="line">        <span class="type">SqlSessionFactoryBuilder</span> <span class="variable">sqlSessionFactoryBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取 SqlSessionFactory 对象(通过 build 方法, 根据核心配置文件所对应的输入流来创建所对应的对象)</span></span><br><span class="line">        <span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> sqlSessionFactoryBuilder.build(is);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取 sql 的会话对象 SqlSession, 是 MyBatis 提供的操作数据库的对象</span></span><br><span class="line">        <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession();</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 重点！(因为一个 mapper 接口不能直接创建对象, 所以通过代理模式创建当前 mapper 接口的代理实现类, 并且自动找到对应的 sql 语句去执行)</span></span><br><span class="line">        <span class="comment">// 获取 UserMapper 的代理实现类对象(代理模式 --&gt; 帮助创建了 mapper 接口的代理实现类), 返回当前接口的实现类的对象</span></span><br><span class="line">        <span class="type">UserMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(UserMapper.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用 mapper 接口中的方法, 实现添加用户信息的功能</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> mapper.insertUser();</span><br><span class="line">        System.out.println(<span class="string">&quot;结果: &quot;</span> + result);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 手动提交事务</span></span><br><span class="line">        sqlSession.commit();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭会话 sqlSession</span></span><br><span class="line">        sqlSession.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>优化(<strong>自动提交事务</strong>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取核心配置文件的输入流</span></span><br><span class="line"><span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> Resources.getResourceAsStream(<span class="string">&quot;mybatis-config.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取SqlSessionFactoryBuilder对象</span></span><br><span class="line"><span class="type">SqlSessionFactoryBuilder</span> <span class="variable">sqlSessionFactoryBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取SqlSessionFactory对象</span></span><br><span class="line"><span class="type">SqlSessionFactory</span> <span class="variable">build</span> <span class="operator">=</span> sqlSessionFactoryBuilder.build(is);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取SQL的会话对象SqlSession()不会自动提交事务,是MyBatis提供的操作数据库的对象</span></span><br><span class="line"><span class="comment">//SqlSession sqlSession = build.openSession();</span></span><br><span class="line"><span class="comment">//获取SQL的会话对象SqlSession(true)会自动提交事务,是MyBatis提供的操作数据库的对象</span></span><br><span class="line"><span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> build.openSession(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重点！(因为一个 mapper 接口不能直接创建对象, 所以通过代理模式创建当前 mapper 接口的代理实现类, 并且自动找到对应的 sql 语句去执行)</span></span><br><span class="line"><span class="comment">// 获取 UserMapper 的代理实现类对象(代理模式 --&gt; 帮助创建了 mapper 接口的代理实现类), 返回当前接口的实现类的对象</span></span><br><span class="line"><span class="type">UserMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(UserMapper.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用 mapper 接口中的方法, 实现添加用户信息的功能</span></span><br><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> mapper.insertUser();</span><br><span class="line">System.out.println(<span class="string">&quot;结果: &quot;</span> + result);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        //演示不用 mapper 接口时(用的不多)</span></span><br><span class="line"><span class="comment">//        // 通过 sql 语句的唯一标识找到 sql 并执行, 唯一标识是 namespace.sqlId</span></span><br><span class="line"><span class="comment">//        int result1 = sqlSession.insert(&quot;com.thr.mybatis.mapper.UserMapper.insertUser&quot;);</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;结果:&quot; + result1);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭会话 sqlSession</span></span><br><span class="line">sqlSession.close();</span><br></pre></td></tr></table></figure></li></ul><p>（2）测试</p><ul><li><p>SQLyog 中右键点击表名，在 更多表操作中选择 <strong>截断表</strong></p><blockquote><p><strong>截断和清空的区别</strong>：</p><p>清空：把表中的数据删除</p><p>截断：其底层是先将表删掉，再重新创建一个一模一样的表，故 id 会从一开始自增 (截断很危险，其不支持事务，执行了不能回滚)</p></blockquote><p><img src="/../img/SSM%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88.assets/1672415508054.png" alt="图2.6.2"></p></li><li><p>执行成功</p><p><img src="/../img/SSM%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88.assets/1672415765414.png" alt="图2.6.3"></p><p><img src="/../img/SSM%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88.assets/1672415752389.png" alt="图2.6.4"></p></li></ul><h4 id="2-7-加入-log4j-日志功能"><a href="#2-7-加入-log4j-日志功能" class="headerlink" title="2.7 加入 log4j 日志功能"></a>2.7 加入 log4j 日志功能</h4><ul><li><p><strong>加入依赖</strong>，在 pom.xml 里添加配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- log4j日志 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>加入 log4j(日志框架) 的配置文件</strong></p><blockquote><p>log4j 的配置文件为 <strong>log4j.xml</strong>，存放位置是 <strong>src&#x2F;main&#x2F;resources</strong> 目录下</p></blockquote><p>注：报错提示 URI 未注册 可以不用管 </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">log4j</span>:configuration <span class="keyword">SYSTEM</span> <span class="string">&quot;log4j.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">log4j:configuration</span> <span class="attr">xmlns:log4j</span>=<span class="string">&quot;http://jakarta.apache.org/log4j/&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;STDOUT&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.apache.log4j.ConsoleAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;Encoding&quot;</span> <span class="attr">value</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">layout</span> <span class="attr">class</span>=<span class="string">&quot;org.apache.log4j.PatternLayout&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;ConversionPattern&quot;</span> <span class="attr">value</span>=<span class="string">&quot;%-5p %d&#123;MM-dd HH:mm:ss,SSS&#125; %m (%F:%L) \n&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;java.sql&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">level</span> <span class="attr">value</span>=<span class="string">&quot;debug&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;org.apache.ibatis&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">level</span> <span class="attr">value</span>=<span class="string">&quot;info&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">level</span> <span class="attr">value</span>=<span class="string">&quot;debug&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;STDOUT&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">log4j:configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>日志的级别</strong></p><p>FATAL(致命) &gt; ERROR(错误) &gt; WARN(警告) &gt; INFO(信息) &gt; DEBUG(调试) </p><p>从左到右打印的内容越来越详细，故当我们选择了一个级别后，打印的是大于等于当前这个日志级别的日志信息(我们这里选的是 debug)</p></blockquote></li><li><p>运行结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DEBUG <span class="number">12</span>-<span class="number">31</span> <span class="number">00</span>:08:<span class="number">52</span>,<span class="number">243</span> ==&gt;  Preparing: insert into ssm.t_user <span class="title function_">values</span><span class="params">(<span class="literal">null</span>, <span class="string">&#x27;admin&#x27;</span>, <span class="string">&#x27;123456&#x27;</span>, <span class="number">23</span>, <span class="string">&#x27;男&#x27;</span>, <span class="string">&#x27;1234@qq.com&#x27;</span>)</span> (BaseJdbcLogger.java:<span class="number">137</span>) </span><br><span class="line">DEBUG <span class="number">12</span>-<span class="number">31</span> <span class="number">00</span>:08:<span class="number">52</span>,<span class="number">281</span> ==&gt; Parameters:  (BaseJdbcLogger.java:<span class="number">137</span>) </span><br><span class="line">DEBUG <span class="number">12</span>-<span class="number">31</span> <span class="number">00</span>:08:<span class="number">52</span>,<span class="number">293</span> &lt;==    Updates: <span class="number">1</span> (BaseJdbcLogger.java:<span class="number">137</span>) </span><br><span class="line">结果: <span class="number">1</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="3-MyBatis-的-增-删改查"><a href="#3-MyBatis-的-增-删改查" class="headerlink" title="3. MyBatis 的(增)删改查"></a>3. MyBatis 的(增)删改查</h3><h4 id="3-1-创建工具类"><a href="#3-1-创建工具类" class="headerlink" title="3.1 创建工具类"></a>3.1 创建工具类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.thr.mybatis.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SqlSessionUtil</span> &#123;</span><br><span class="line">    <span class="comment">// 静态方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SqlSession <span class="title function_">getSqlSession</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1. 获取核心配置文件的输入流(捕获异常 ctrl + alt + t, 选择第六个 try/catch)</span></span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> Resources.getResourceAsStream(<span class="string">&quot;mybatis-config.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2. 获取 sqlSessionFactoryBuilder 对象</span></span><br><span class="line">            <span class="type">SqlSessionFactoryBuilder</span> <span class="variable">sqlSessionFactoryBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3. 获取 sqlSessionFactory 对象</span></span><br><span class="line">            <span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> sqlSessionFactoryBuilder.build(is);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4. 获取 sqlSession 对象(自动提交事务)</span></span><br><span class="line">            sqlSession = sqlSessionFactory.openSession(<span class="literal">true</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sqlSession;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-Update"><a href="#3-2-Update" class="headerlink" title="3.2 Update"></a>3.2 Update</h4><ul><li><p><strong>在 mapper 接口中创建方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.thr.mybatis.mapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加用户信息</span></span><br><span class="line"><span class="comment">     * 返回值: 增删改的返回值是固定的, 是受影响的行数, 故返回值设为 int 型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">insertUser</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 修改用户信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">updateUser</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>在映射文件中写对应的 sql 语句</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.thr.mybatis.mapper.UserMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- int insertUser(); --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertUser&quot;</span>&gt;</span></span><br><span class="line">        insert into ssm.t_user values(null, &#x27;admin&#x27;, &#x27;123456&#x27;, 23, &#x27;男&#x27;, &#x27;1234@qq.com&#x27;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- void updateUser(); --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateUser&quot;</span>&gt;</span></span><br><span class="line">        update ssm.t_user set username=&#x27;root&#x27;, password=&#x27;123&#x27; where id = 3</span><br><span class="line">    <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>测试</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="comment">// 修改用户信息(用工具类实现)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testUpdate</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 通过工具类先获取 sqlSession 对象</span></span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> SqlSessionUtil.getSqlSession();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 获取 mapper 接口的代理实现类对象, 直接调用接口中的方法即可</span></span><br><span class="line">    <span class="type">UserMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(UserMapper.class);</span><br><span class="line">    mapper.updateUser();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 关闭 sqlSession</span></span><br><span class="line">    sqlSession.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="3-3-Delete"><a href="#3-3-Delete" class="headerlink" title="3.3 Delete"></a>3.3 Delete</h4><ul><li><p><strong>在 mapper 接口中创建方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">deleteUser</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>在映射文件中写对应的 sql 语句</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- void deleteUser(); --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteUser&quot;</span>&gt;</span></span><br><span class="line">    delete from ssm.t_user where id = 4</span><br><span class="line"><span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>测试</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="comment">// 删除用户信息(用工具类实现)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDelete</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> SqlSessionUtil.getSqlSession();</span><br><span class="line"></span><br><span class="line">    <span class="type">UserMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(UserMapper.class);</span><br><span class="line">    mapper.deleteUser();</span><br><span class="line"></span><br><span class="line">    sqlSession.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="3-4-Retrieve"><a href="#3-4-Retrieve" class="headerlink" title="3.4 Retrieve"></a>3.4 Retrieve</h4><p>（1）<strong>查询单个用户信息(根据用户 id)</strong></p><ul><li><p><strong>在 mapper 接口中创建方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据 id 查询用户信息</span></span><br><span class="line"><span class="comment"> * 返回一个对象(只查询一条用户信息)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">User <span class="title function_">getUserById</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>在映射文件中写对应的 sql 语句</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 由于返回值是一个对象, 所以要写 resultType/resultMap,</span></span><br><span class="line"><span class="comment">         因为当前的字段名和属性名完全相同, 故此处直接选 resultType 即可</span></span><br><span class="line"><span class="comment">           resultType: 设置结果类型, 即查询的数据要转换为的 java 类型(此处要写全类名)</span></span><br><span class="line"><span class="comment">           resultMap: 自定义映射, 处理多对一或一对多的映射关系</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- User getUserById(); --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserById&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.thr.mybatis.pojo.User&quot;</span>&gt;</span></span><br><span class="line">    select * from ssm.t_user where id = 1</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>此处若没写 resultType，测试时会报错如下：</p><p>报错信息：<strong>A query was run and no Result Maps</strong> were found for the Mapped Statement ‘com.thr.mybatis.mapper.UserMapper.getUserById’. </p><p> It’s likely that <strong>neither a Result Type nor a Result Map</strong> was specified.</p></blockquote></li><li><p><strong>测试</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="comment">// 查询用户信息(用工具类实现)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testGetUserById</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> SqlSessionUtil.getSqlSession();</span><br><span class="line"></span><br><span class="line">    <span class="type">UserMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(UserMapper.class);</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> mapper.getUserById();</span><br><span class="line">    System.out.println(user);</span><br><span class="line">    <span class="comment">// 结果: User&#123;id=1, username=&#x27;admin&#x27;, password=&#x27;123456&#x27;, age=23, gender=&#x27;男&#x27;, email=&#x27;1234@qq.com&#x27;&#125;</span></span><br><span class="line"></span><br><span class="line">    sqlSession.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>（2）<strong>查询所有用户信息</strong></p><ul><li><p><strong>在 mapper 接口中创建方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查询所有的用户信息</span></span><br><span class="line"><span class="comment"> * 返回一个对象集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">List&lt;User&gt; <span class="title function_">getAllUser</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>在映射文件中写对应的 sql 语句</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 先转换为实体类对象后再放到集合里头 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- List&lt;User&gt; getAllUser(); --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getAllUser&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.thr.mybatis.pojo.User&quot;</span>&gt;</span></span><br><span class="line">    select * from ssm.t_user</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>测试</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="comment">// 查询所有用户信息(用工具类实现)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testGetAllUser</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> SqlSessionUtil.getSqlSession();</span><br><span class="line"></span><br><span class="line">    <span class="type">UserMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(UserMapper.class);</span><br><span class="line">    List&lt;User&gt; list = mapper.getAllUser();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环输出(这写法???!)</span></span><br><span class="line">    <span class="comment">// System.out::println 等价于 x -&gt; &#123; System.out.println(x) &#125;</span></span><br><span class="line">    list.forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 结果:</span></span><br><span class="line"><span class="comment">            User&#123;id=1, username=&#x27;admin&#x27;, password=&#x27;123456&#x27;, age=23, gender=&#x27;男&#x27;, email=&#x27;1234@qq.com&#x27;&#125;</span></span><br><span class="line"><span class="comment">            User&#123;id=2, username=&#x27;admin&#x27;, password=&#x27;123456&#x27;, age=23, gender=&#x27;男&#x27;, email=&#x27;1234@qq.com&#x27;&#125;</span></span><br><span class="line"><span class="comment">            User&#123;id=3, username=&#x27;root&#x27;, password=&#x27;123&#x27;, age=23, gender=&#x27;男&#x27;, email=&#x27;1234@qq.com&#x27;&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    sqlSession.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="4-MyBatis-的核心配置文件详解"><a href="#4-MyBatis-的核心配置文件详解" class="headerlink" title="4. MyBatis 的核心配置文件详解"></a>4. MyBatis 的核心配置文件详解</h3><h4 id="4-1-environments-标签"><a href="#4-1-environments-标签" class="headerlink" title="4.1 environments 标签"></a>4.1 environments 标签</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        environments: 配置连接数据库的环境</span></span><br><span class="line"><span class="comment">        属性: default: 设置默认使用的环境的 id (这里是 development 开发环境)</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">            environment: 设置一个具体的连接数据库的环境</span></span><br><span class="line"><span class="comment">            属性: id: 设置环境的唯一标识(即不能重复)</span></span><br><span class="line"><span class="comment">            其拥有两个子标签:</span></span><br><span class="line"><span class="comment">                transactionManager: 事务管理器(设置数据库的管理方式)</span></span><br><span class="line"><span class="comment">                dataSource: 数据源</span></span><br><span class="line"><span class="comment">     --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置连接数据库的环境(此处是开发环境) --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">                 transactionManager: 设置事务管理器</span></span><br><span class="line"><span class="comment">                 属性: type: 设置事务管理的方式 type=&quot;JDBC/MANAGED&quot;</span></span><br><span class="line"><span class="comment">                            JDBC: 表示使用 JDBC 中原生的事务管理方式</span></span><br><span class="line"><span class="comment">                            MANAGED: 被管理, 例如 Spring 管理事务</span></span><br><span class="line"><span class="comment">         --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">                dataSource: 设置数据源</span></span><br><span class="line"><span class="comment">                属性: type: 设置数据源的类型 type=&quot;POOLED/UNPOOLED/JNDI&quot;</span></span><br><span class="line"><span class="comment">                            POOLED: 表示使用数据库连接池(创建完连接后交给连接池管理, 下一次创建连接时直接从连接池里获取就行)</span></span><br><span class="line"><span class="comment">                            UNPOOLED: 表示不使用数据库连接池(每次获取都是重新获取/重新创建连接)</span></span><br><span class="line"><span class="comment">                            JNDI: 表示使用上下文中的数据源</span></span><br><span class="line"><span class="comment">         --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/ssm?serverTimezone=UTC<span class="symbol">&amp;amp;</span>useSSL=false<span class="symbol">&amp;amp;</span></span></span></span><br><span class="line"><span class="string"><span class="tag">                                        useUnicode=true<span class="symbol">&amp;amp;</span>characterEncoding=UTF-8&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;thr&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置连接数据库的环境(此处是测试环境) --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;test&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/ssm?serverTimezone=UTC<span class="symbol">&amp;amp;</span>useSSL=false<span class="symbol">&amp;amp;</span></span></span></span><br><span class="line"><span class="string"><span class="tag">                                        useUnicode=true<span class="symbol">&amp;amp;</span>characterEncoding=UTF-8&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;thr&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="4-2-properties-标签"><a href="#4-2-properties-标签" class="headerlink" title="4.2 properties 标签"></a>4.2 properties 标签</h4><ul><li><p><strong>新建一个 properties 文件</strong></p><p><img src="/../img/SSM%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88.assets/1672503199775.png" alt="图4.2.1"></p><p><img src="/../img/SSM%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88.assets/1672503232875.png" alt="图4.2.2"></p></li><li><p><strong>编写配置文件</strong></p><blockquote><p>因为xml解析转移的原因，<code>&amp;amp;</code> 都改成 &amp; </p><p><strong>注意：useSSL&#x3D;false 需写在最前面！！！</strong></p></blockquote><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">jdbc.driver</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="attr">jdbc.url</span>=<span class="string">jdbc:mysql://localhost:3306/ssm?useSSL=false&amp;serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=UTF-8</span></span><br><span class="line"><span class="attr">jdbc.username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">jdbc.password</span>=<span class="string">thr</span></span><br></pre></td></tr></table></figure></li><li><p>将 <strong>配置文件</strong>(jdbc.properties) <strong>引入到核心配置文件</strong>(mybatis-config.xml)</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 引入 properties 文件, 此后就可以在当前文件中使用 $&#123;key&#125; 的方式访问 value --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">&quot;jdbc.properties&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="4-3-typeAliases-标签"><a href="#4-3-typeAliases-标签" class="headerlink" title="4.3 typeAliases 标签"></a>4.3 typeAliases 标签</h4><ul><li><p>配置文件里头进行配置</p><blockquote><p><strong>MyBatis 核心配置文件中的标签必须按照指定的顺序配置</strong>：            properties?,settings?,typeAliases?,typeHandlers?,         objectFactory?,objectWrapperFactory?,reflectorFactory?,plugins?,environments?,databaseIdProvider?,mappers?</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        MyBatis 核心配置文件中的标签必须按照指定的顺序配置:</span></span><br><span class="line"><span class="comment">            properties?,settings?,typeAliases?,typeHandlers?,</span></span><br><span class="line"><span class="comment">            objectFactory?,objectWrapperFactory?,reflectorFactory?,plugins?,</span></span><br><span class="line"><span class="comment">            environments?,databaseIdProvider?,mappers?</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 引入 properties 文件, 此后就可以在当前文件中使用 $&#123;key&#125; 的方式访问 value --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">&quot;jdbc.properties&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        typeAliases(这是一个复数标签): 设置类型别名</span></span><br><span class="line"><span class="comment">                 在 MyBatis 的范围中, 就可以使用别名表示一个具体的类型</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">           typeAlias: 为某个具体的类型设置一个别名</span></span><br><span class="line"><span class="comment">           属性:</span></span><br><span class="line"><span class="comment">                type: 设置需要起别名的类型</span></span><br><span class="line"><span class="comment">                alias: 设置某个类型的别名</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;typeAlias type=&quot;com.thr.mybatis.pojo.User&quot; alias=&quot;abc&quot;&gt;&lt;/typeAlias&gt;--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--若不设置 alias, 其默认别名为类名 User, 且不区分大小写 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;typeAlias type=&quot;com.thr.mybatis.pojo.User&quot;&gt;&lt;/typeAlias&gt;--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 通过包来设置类型别名, 指定包下所有的类型将全部拥有默认的别名, 即类名且不区分大小写 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.thr.mybatis.pojo&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>映射文件里头修改，测试结果无误</p><p><img src="/../img/SSM%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88.assets/1672505696179.png" alt="图4.3.1"></p></li></ul><h4 id="4-4-mappers-标签"><a href="#4-4-mappers-标签" class="headerlink" title="4.4 mappers 标签"></a>4.4 mappers 标签</h4><ul><li><p><strong>在 resources 下创建多级目录</strong>(注意使用 &#x2F; 分割，而不是 . 分割)</p><blockquote><p>因为 resources 下只能建目录不能建包</p></blockquote><p><img src="/../img/SSM%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88.assets/1672506221981.png" alt="图4.4.1"></p><p><img src="/../img/SSM%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88.assets/1672506279689.png" alt="图4.4.2"></p><p><img src="/../img/SSM%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88.assets/1672507201101.png" alt="图4.4.3"></p></li><li><p><strong>在核心配置文件中引入映射文件</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;mapper resource=&quot;mappers/UserMapper.xml&quot;/&gt;--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">            以包的方式来引入映射文件, 但是必须满足两个条件:</span></span><br><span class="line"><span class="comment">                1. mapper接口 和 映射文件 所在的包必须一致</span></span><br><span class="line"><span class="comment">                2. mapper接口的名字 和 映射文件的名字 必须一致</span></span><br><span class="line"><span class="comment">      --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.thr.mybatis.mapper&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>注： <strong>改之后报错需要重构一下！！</strong></p><p>(如果报错Invalid bound statement的去右边maven打开clean一下)</p></blockquote></li><li><p>编译后可以在 target 目录下的 <strong>classes(主程序编译之后的类)</strong> 目录下看到<strong>它们实际上被加载到了同一个目录下</strong></p><p><img src="/../img/SSM%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88.assets/1672506979687.png" alt="图4.4.4"></p></li></ul><h3 id="5-配置核心配置文件和映射文件模板"><a href="#5-配置核心配置文件和映射文件模板" class="headerlink" title="5. 配置核心配置文件和映射文件模板"></a>5. 配置核心配置文件和映射文件模板</h3><h4 id="5-1-配置模板"><a href="#5-1-配置模板" class="headerlink" title="5.1 配置模板"></a>5.1 配置模板</h4><p>（1）<strong>核心配置文件的模板</strong></p><ul><li><p>在 settings 里头配置</p><p><img src="/../img/SSM%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88.assets/1672507887309.png" alt="图5.1.1"></p></li><li><p>之后右键就可以看到了</p><p><img src="/../img/SSM%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88.assets/1672507932353.png" alt="图5.1.2"></p><p><img src="/../img/SSM%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88.assets/1672507969288.png" alt="图5.1.3"></p></li></ul><p>（2）<strong>映射文件的模板</strong></p><ul><li><p>同理</p><p><img src="/../img/SSM%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88.assets/1672508246355.png" alt="图5.1.4"></p></li></ul><h4 id="5-2-使用模板"><a href="#5-2-使用模板" class="headerlink" title="5.2 使用模板"></a>5.2 使用模板</h4><p>（1）创建新 Module</p><p><img src="/../img/SSM%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88.assets/1672509931041.png" alt="图5.2.1"></p><p>（2）把原来的依赖和一些配置文件复制粘贴过来</p><p><img src="/../img/SSM%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88.assets/1672510172270.png" alt="图5.2.1"></p><p>（3）搭建 MyBatis 框架</p><ul><li>利用前面创建的<strong>模板新建核心配置文件</strong></li><li>创建 <strong>mapper 接口</strong></li><li>创建 <strong>映射文件</strong>，在 namespace 里头写上接口的全类名</li></ul><p><img src="/../img/SSM%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88.assets/1672510553461.png" alt="图5.2.2"></p><ul><li><p>创建<strong>主体类</strong> User (从之前那个工程里头复制过来即可)</p><p><img src="/../img/SSM%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88.assets/1672510746378.png" alt="图5.2.3"></p></li><li><p><strong>将核心配置文件中别名和映射文件的全类名补充上</strong></p><p><img src="/../img/SSM%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88.assets/1672557681099.png" alt="图5.2.4"></p></li></ul><h3 id="6-MyBatis-获取参数值的两种方式"><a href="#6-MyBatis-获取参数值的两种方式" class="headerlink" title="6. MyBatis 获取参数值的两种方式"></a>6. MyBatis 获取参数值的两种方式</h3><blockquote><p>MyBatis 获取参数值的两种方式：**${} 和 #{}**</p><p><strong>${} 的本质就是字符串拼接，#{} 的本质就是占位符赋值</strong>(后者比较常用，因为其可以自动添加单引号，还可以避免 sql 注入)</p><p><strong>${}</strong> 使用字符串拼接的方式拼接 sql，<strong>若为字符串类型或日期类型的字段进行赋值时，需要手动加单引号</strong></p><p><strong>#{}</strong> 使用占位符赋值的方式拼接 sql，此时为字符串类型或日期类型的字段进行赋值时，<strong>可以自动添加单引号</strong></p></blockquote><h4 id="6-1-单个字面量类型的参数"><a href="#6-1-单个字面量类型的参数" class="headerlink" title="6.1 单个字面量类型的参数"></a>6.1 单个字面量类型的参数</h4><blockquote><p>若mapper接口中的方法参数为单个的字面量类型</p><p>此时可以使用 <code>$&#123;&#125;</code> 和 <code>#&#123;&#125;</code> 以任意的名称获取参数的值，注意 <code>$&#123;&#125;</code> 需要<strong>手动加单引号</strong> </p></blockquote><ul><li><p>在 mapper 接口里<strong>编写方法</strong>(根据用户名查询用户信息)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.thr.mybatis.mapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据用户名查询用户信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> username 单个字面量类型的参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回 User 对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    User <span class="title function_">getUserByUsername</span><span class="params">(String username)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在映射文件里<strong>写 sql 语句</strong></p><blockquote><p>注：  </p><p>此处 #{} 的 {} 里写啥都没关系，只是最好见名知意</p><p>而此处若用 ${} 需在外头加单引号！！</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- User getUserByUsername(String username); --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserByUsername&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- select * from t_user where username = #&#123;username&#125; --&gt;</span></span><br><span class="line">    select * from t_user where username = &#x27;$&#123;username&#125;&#x27;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><blockquote><p><strong>表名爆红的解决方案</strong>：(好像没啥用，后面又改回来了，莫名其妙就好了)</p><p>File-&gt;Settings-&gt;Languages&amp;Frameworks-&gt;SQL Dialects-&gt;Global SQL Dialect设为None</p></blockquote><p><img src="/../img/SSM%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88.assets/1672556310152.png" alt="图6.1.1"></p><ul><li><p><strong>编写测试类</strong>（#{} 被当作占位符来解析）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.thr.mybatis.test;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ParameterTest</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testGetUserByUsername</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 获取 sqlSession 对象</span></span><br><span class="line">        <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> SqlSessionUtil.getSqlSession();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取 UserMapper 的代理实现类对象</span></span><br><span class="line">        <span class="type">UserMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(UserMapper.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用 mapper 里头的方法</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> mapper.getUserByUsername(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="6-2-多个字面量类型的参数"><a href="#6-2-多个字面量类型的参数" class="headerlink" title="6.2 多个字面量类型的参数"></a>6.2 多个字面量类型的参数</h4><blockquote><p>若 mapper 接口中的<strong>方法参数为多个</strong>时，此时MyBatis<strong>会自动将这些参数放在一个 map集合 中</strong>，因此只需要通过<code>$&#123;&#125;</code>和<code>#&#123;&#125;</code><strong>访问map集合的键</strong>就可以<strong>获取相对应的值</strong>，注意<code>$&#123;&#125;</code>需要手动加单引号</p></blockquote><ul><li><p>在 mapper 接口里<strong>编写方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line">    User <span class="title function_">getUserByUsername</span><span class="params">(String username)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 验证登录(多个字面量类型的参数)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> username 用户名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> password 密码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回 User 对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    User <span class="title function_">checkLogin</span><span class="params">(String username, String password)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在映射文件里<strong>写 sql 语句</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- User checkLogin(String username, String password); --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;checkLogin&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 此处可用 #&#123;arg0&#125; #&#123;arg1&#125; 或者 #&#123;param1&#125; #&#123;param2&#125; --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- select * from t_user where username = #&#123;arg0&#125; and password = #&#123;arg1&#125; --&gt;</span></span><br><span class="line">    select * from t_user where username = &#x27;$&#123;param1&#125;&#x27; and password = &#x27;$&#123;param2&#125;&#x27;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>若写成 #{username} 和 #{password} 则会报错！！</p><p>报错提示：<strong>Available parameters are [arg1, arg0, param1, param2]</strong></p></blockquote></li><li><p><strong>测试</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testCheckLogin</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> SqlSessionUtil.getSqlSession();</span><br><span class="line">    <span class="type">UserMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(UserMapper.class);</span><br><span class="line"></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> mapper.checkLogin(<span class="string">&quot;admin&quot;</span>, <span class="string">&quot;123456&quot;</span>);</span><br><span class="line">    System.out.println(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="6-3-map-集合类型的参数"><a href="#6-3-map-集合类型的参数" class="headerlink" title="6.3 map 集合类型的参数"></a>6.3 map 集合类型的参数</h4><blockquote><p>若 mapper 接口中的方法需要的参数为多个时，此时可以<strong>手动创建 map 集合</strong>，将这些数据放在map中只需要通过 <code>$&#123;&#125;</code> 和 <code>#&#123;&#125;</code> <strong>访问map集合的键就可以获取相对应的值</strong>，注意 <code>$&#123;&#125;</code> 需要手动加单引号 </p></blockquote><ul><li><p>在 mapper 接口里<strong>编写方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line">    User <span class="title function_">getUserByUsername</span><span class="params">(String username)</span>;</span><br><span class="line">    User <span class="title function_">checkLogin</span><span class="params">(String username, String password)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 验证登录(map 集合类型的参数)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> map 集合里头存储用户名和密码, 用户名的键为 username, 密码的键为 password</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回 User 对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    User <span class="title function_">checkLoginByMap</span><span class="params">(Map&lt;String, Object&gt; map)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在映射文件里<strong>写 sql 语句</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- User checkLoginByMap(Map&lt;String, Object&gt; map); --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;checkLoginByMap&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">    select * from t_user where username = #&#123;username&#125; and password = #&#123;password&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>测试</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testCheckLoginByMap</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> SqlSessionUtil.getSqlSession();</span><br><span class="line">    <span class="type">UserMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(UserMapper.class);</span><br><span class="line"></span><br><span class="line">    Map&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;admin&quot;</span>);</span><br><span class="line">    map.put(<span class="string">&quot;password&quot;</span>, <span class="string">&quot;123456&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> mapper.checkLoginByMap(map);</span><br><span class="line">    System.out.println(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="6-4-实体类类型的参数"><a href="#6-4-实体类类型的参数" class="headerlink" title="6.4 实体类类型的参数"></a>6.4 实体类类型的参数</h4><blockquote><p>若 mapper 接口中的方法<strong>参数为实体类对象</strong>时此时可以使用 <code>$&#123;&#125;</code> 和 <code>#&#123;&#125;</code>，通过<strong>访问实体类对象中的属性名获取属性值</strong>，注意 <code>$&#123;&#125;</code> 需要手动加单引号 </p></blockquote><ul><li><p>在 mapper 接口里<strong>编写方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line">    User <span class="title function_">getUserByUsername</span><span class="params">(String username)</span>;</span><br><span class="line">    User <span class="title function_">checkLogin</span><span class="params">(String username, String password)</span>;</span><br><span class="line">    User <span class="title function_">checkLoginByMap</span><span class="params">(Map&lt;String, Object&gt; map)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加用户信息(实体类类型的参数)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> user 参数是 user 对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">insertUser</span><span class="params">(User user)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在映射文件里<strong>写 sql 语句</strong></p><blockquote><p><strong>属性和成员变量</strong>？</p><p>属性对应数据库对象的属性，成员变量是程序的变量。</p><p>到 springboot 的时候还要写代码把属性和成员变量对应起来</p><p>意思是：如果你的 <strong>getId 方法</strong>，return 的是你 name 的值，那我不管，我就认为你的这个 name 叫 <strong>id 属性</strong></p><p>不要将成员变量和方法搞混，我新建一个类，没有成员变量只有方法有没有问题？我将这个方法命名为get方法有没有问题？肯定都没问题呀</p><p>如果是个实体类，一般都是成员变量和getset方法一一对应的，但是总会出现一些非一般的情况。老师是给大家提个醒，别到时候一脸懵逼，哈哈哈</p><p>没有成员变量不影响你写一个getter&#x2F;setter方法</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- void insertUser(User user); --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertUser&quot;</span>&gt;</span></span><br><span class="line">    insert into t_user values(null, #&#123;username&#125;, #&#123;password&#125;, #&#123;age&#125;, #&#123;gender&#125;, #&#123;email&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>测试</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testInsertUser</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> SqlSessionUtil.getSqlSession();</span><br><span class="line">    <span class="type">UserMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(UserMapper.class);</span><br><span class="line"></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="literal">null</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;123456&quot;</span>, <span class="number">33</span>, <span class="string">&quot;女&quot;</span>, <span class="string">&quot;123@qq.com&quot;</span>);</span><br><span class="line">    mapper.insertUser(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="6-5-使用-Param-标识参数"><a href="#6-5-使用-Param-标识参数" class="headerlink" title="6.5 使用 @Param 标识参数"></a>6.5 使用 @Param 标识参数</h4><blockquote><p>该方法较为常用，可以通过 <strong>@Param 注解</strong> 标识 mapper 接口中的方法参数，此时，会将这些<strong>参数放在map集合中</strong>（以 <strong>@Param 中的值为键，参数为值 或 以param1，param2，… 为键，参数为值</strong>），只需要通过<code>$&#123;&#125;</code>和<code>#&#123;&#125;</code><strong>访问map集合的键</strong>就可以获取相对应的值，注意<code>$&#123;&#125;</code>需要手动加单引号</p></blockquote><ul><li><p>在 mapper 接口里<strong>编写方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line">    User <span class="title function_">getUserByUsername</span><span class="params">(String username)</span>;</span><br><span class="line">    User <span class="title function_">checkLogin</span><span class="params">(String username, String password)</span>;</span><br><span class="line">    User <span class="title function_">checkLoginByMap</span><span class="params">(Map&lt;String, Object&gt; map)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">insertUser</span><span class="params">(User user)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 验证登录(使用 <span class="doctag">@Param</span> 标识参数), 该方法比较常用</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> username 用户名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> password 密码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回 User 对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    User <span class="title function_">checkLoginByParam</span><span class="params">(<span class="meta">@Param(value = &quot;username&quot;)</span> String username, <span class="meta">@Param(&quot;password&quot;)</span> String password)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在映射文件里<strong>写 sql 语句</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- User checkLoginByParam(@Param(value = &quot;username&quot;) String username, @Param(&quot;password&quot;) String password); --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;checkLoginByParam&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 这里不仅可以用 @Param 的 value 属性值为键, 也可以用 param1, param2 为键(即 #&#123;param1&#125;) --&gt;</span></span><br><span class="line">    select * from t_user where username = #&#123;username&#125; and password = #&#123;password&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>测试</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testCheckLoginByParam</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> SqlSessionUtil.getSqlSession();</span><br><span class="line">    <span class="type">UserMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(UserMapper.class);</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> mapper.checkLoginByParam(<span class="string">&quot;admin&quot;</span>, <span class="string">&quot;123456&quot;</span>);</span><br><span class="line">    System.out.println(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="6-6-总结"><a href="#6-6-总结" class="headerlink" title="6.6 总结"></a>6.6 总结</h4><ul><li>在使用过程中最好使用 <strong>实体类型的参数</strong> 和 <strong>@Param注解</strong> 来获取参数值(实际只要记住最后两种方法即可)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * MyBatis 获取参数值的两种方式: #&#123;&#125; 和 $&#123;&#125;</span></span><br><span class="line"><span class="comment"> *  #&#123;&#125; 的本质是占位符赋值, $&#123;&#125; 的本质是字符串拼接</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1. 若 mapper 接口方法的参数为单个的字面量类型</span></span><br><span class="line"><span class="comment"> *    此时可以通过 #&#123;&#125; 和 $&#123;&#125; 以任意的内容获取参数值, 一定要注意 $&#123;&#125; 的单引号问题</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 2. 若 mapper 接口方法的参数为多个的字面量类型</span></span><br><span class="line"><span class="comment"> *    此时 MyBatis 会将参数放在 map 集合中, 以两种方式存储数据</span></span><br><span class="line"><span class="comment"> *    a&gt; 以 arg0,arg1... 为键, 以参数为值</span></span><br><span class="line"><span class="comment"> *    b&gt; 以 param1,param2... 为键, 以参数为值</span></span><br><span class="line"><span class="comment"> *    因此, 只需要通过 #&#123;&#125; 和 $&#123;&#125; 访问 map 集合的键, 就可以获取相对应的值, 一定要注意 $&#123;&#125; 的单引号问题</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 3. 若 mapper 接口方法的参数为 map 集合类型的参数</span></span><br><span class="line"><span class="comment"> *    只需要通过 #&#123;&#125; 和 $&#123;&#125; 访问 map 集合的键, 就可以获取相对应的值, 一定要注意 $&#123;&#125; 的单引号问题</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 4. 若 mapper 接口方法的参数为实体类类型的参数</span></span><br><span class="line"><span class="comment"> *    只需要通过 #&#123;&#125; 和 $&#123;&#125; 访问实体类的属性名, 就可以获取相对应的属性值, 一定要注意 $&#123;&#125; 的单引号问题</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 5. 可以在 mapper 接口方法的参数上设置 <span class="doctag">@Param</span> 注解</span></span><br><span class="line"><span class="comment"> *    此时 MyBatis 会将这些参数放在 map 中, 以两种方式进行存储</span></span><br><span class="line"><span class="comment"> *    a&gt; 以 <span class="doctag">@Param</span> 注解的 value 属性值为键, 以参数为值</span></span><br><span class="line"><span class="comment"> *    b&gt; 以 param1, param2... 为键, 以参数为值</span></span><br><span class="line"><span class="comment"> *    只需要通过 #&#123;&#125; 和 $&#123;&#125; 访问 map 集合的键, 就可以获取相对应的值, 一定要注意 $&#123;&#125; 的单引号问题</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h3 id="7-MyBatis-的各种查询功能"><a href="#7-MyBatis-的各种查询功能" class="headerlink" title="7. MyBatis 的各种查询功能"></a>7. MyBatis 的各种查询功能</h3><h4 id="7-1-查询一个实体类对象"><a href="#7-1-查询一个实体类对象" class="headerlink" title="7.1 查询一个实体类对象"></a>7.1 查询一个实体类对象</h4><blockquote><p>若 sql 语句<strong>查询的结果为多条</strong>时，一定<strong>不能以实体类类型作为方法的返回值</strong>，否则会抛出异常 TooManyResultsException</p><p>若 sql 语句<strong>查询的结果为1条</strong>时，此时<strong>可以使用实体类类型或 list 集合类型</strong>作为方法的返回值</p></blockquote><ul><li><p>创建 mapper 接口、映射文件以及测试类</p><p><img src="/../img/SSM%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88.assets/1672652728402.png" alt="图7.1.1"></p></li><li><p>在 mapper 接口里<strong>编写方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.thr.mybatis.mapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SelectMapper</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 id 查询用户信息(查询一个实体类对象)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id 用户 id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回一个实体类对象(此处是User 类的对象)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    User <span class="title function_">getUserById</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span> Integer id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在映射文件里<strong>写 sql 语句</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- User getUserById(@Param(&quot;id&quot;) Integer id); --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserById&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">    select * from t_user where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>测试</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testGetUserById</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> SqlSessionUtil.getSqlSession();</span><br><span class="line">    <span class="type">SelectMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(SelectMapper.class);</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> mapper.getUserById(<span class="number">1</span>);</span><br><span class="line">    System.out.println(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="7-2-查询一个-list-集合"><a href="#7-2-查询一个-list-集合" class="headerlink" title="7.2 查询一个 list 集合"></a>7.2 查询一个 list 集合</h4><ul><li><p>在 mapper 接口里<strong>编写方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SelectMapper</span> &#123;</span><br><span class="line">    User <span class="title function_">getUserById</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span> Integer id)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询所有的用户信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回一个 list 集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    List&lt;User&gt; <span class="title function_">getAllUser</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在映射文件里<strong>写 sql 语句</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- List&lt;User&gt; getAllUser(); --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getAllUser&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">    select * from t_user</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>测试</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testGetAllUser</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> SqlSessionUtil.getSqlSession();</span><br><span class="line">    <span class="type">SelectMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(SelectMapper.class);</span><br><span class="line">    List&lt;User&gt; list = mapper.getAllUser();</span><br><span class="line">    list.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="7-3-查询单个数据"><a href="#7-3-查询单个数据" class="headerlink" title="7.3 查询单个数据"></a>7.3 查询单个数据</h4><ul><li><p>在 mapper 接口里<strong>编写方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SelectMapper</span> &#123;</span><br><span class="line">    User <span class="title function_">getUserById</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span> Integer id)</span>;</span><br><span class="line">    List&lt;User&gt; <span class="title function_">getAllUser</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询用户的总数量(查询单个数据)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回用户数量(int 类型)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Integer <span class="title function_">getCount</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在映射文件里<strong>写 sql 语句</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Integer getCount(); --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        此处的 resultType 写 int/Integer 也行(不区分大小写)</span></span><br><span class="line"><span class="comment">        因为 MyBatis 中为 Java 中常用的类型设置了类型别名</span></span><br><span class="line"><span class="comment">        Integer: Integer, int</span></span><br><span class="line"><span class="comment">        int: _int, _integer</span></span><br><span class="line"><span class="comment">        String: string</span></span><br><span class="line"><span class="comment">        Map: map</span></span><br><span class="line"><span class="comment">        HashMap: hashmap   </span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getCount&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;java.lang.Integer&quot;</span>&gt;</span></span><br><span class="line">    select count(*) from t_user</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>测试</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testGetCount</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> SqlSessionUtil.getSqlSession();</span><br><span class="line">    <span class="type">SelectMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(SelectMapper.class);</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">count</span> <span class="operator">=</span> mapper.getCount();</span><br><span class="line">    System.out.println(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="7-4-查询一条数据为-map-集合"><a href="#7-4-查询一条数据为-map-集合" class="headerlink" title="7.4 查询一条数据为 map 集合"></a>7.4 查询一条数据为 map 集合</h4><ul><li><p>在 mapper 接口里<strong>编写方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SelectMapper</span> &#123;</span><br><span class="line">    User <span class="title function_">getUserById</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span> Integer id)</span>;</span><br><span class="line">    List&lt;User&gt; <span class="title function_">getAllUser</span><span class="params">()</span>;</span><br><span class="line">    Integer <span class="title function_">getCount</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过 id 查询用户信息, 以 map 集合来获取(查询一条数据为 map 集合)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回一个 map 集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Map&lt;String, Object&gt; <span class="title function_">getUserByIdToMap</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span> Integer id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在映射文件里<strong>写 sql 语句</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Map&lt;String, Object&gt; getUserByIdToMap(@Param(&quot;id&quot;) Integer id); --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserByIdToMap&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;map&quot;</span>&gt;</span></span><br><span class="line">    select * from t_user where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>测试</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testGetUserByIdToMap</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> SqlSessionUtil.getSqlSession();</span><br><span class="line">    <span class="type">SelectMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(SelectMapper.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出是以 字段名为键, 以 字段的值为值的 map(若某个字段的值为 null, 则不会被放在 map 里)</span></span><br><span class="line">    <span class="comment">// (map 集合中的 key 是无序的不可重复的, 其排序是按照 key 所在类重写的equals()和hashcode()来进行的)</span></span><br><span class="line">    <span class="comment">// &#123;password=123456, gender=男, id=1, age=23, email=12345@qq.com, username=admin&#125;</span></span><br><span class="line">    Map&lt;String, Object&gt; map = mapper.getUserByIdToMap(<span class="number">1</span>);</span><br><span class="line">    System.out.println(map);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="7-5-查询多条数据为-map-集合"><a href="#7-5-查询多条数据为-map-集合" class="headerlink" title="7.5 查询多条数据为 map 集合"></a>7.5 查询多条数据为 map 集合</h4><blockquote><p>若查询的数据有多条时，并且要将每条数据转换为 map 集合</p><p>此时有两种解决方案：（法一用的较多）</p><p>a&gt; 如果不确定返回几条结果，建议将 mapper 接口方法的<strong>返回值设置为泛型是 map 的 list</strong> 集合(即 List&lt;Map&lt;String, Object&gt;&gt; getAllUserToMap();)</p><p>b&gt; 可以将<strong>每条数据转换的 map 集合放在一个大的 map 中</strong>，但是必须要<strong>通过 @MapKey 注解将查询的某个字段的字作为大的 map 的键</strong>(json 格式？)</p><p>小技巧：</p><p>查询的结果有实体类，用实体类对象接收</p><p>查询的结果无实体类，用map集合方式接收</p></blockquote><p>（1）方法一：List&lt;Map&lt;&gt;&gt;</p><ul><li><p>在 mapper 接口里<strong>编写方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查询所有的用户信息为 map 集合(查询多条数据为 map 集合)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回一个存放着 每一条数据转换成的 map 集合 的 list 集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">List&lt;Map&lt;String, Object&gt;&gt; <span class="title function_">getAllUserToMap</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure></li><li><p>在映射文件里<strong>写 sql 语句</strong></p><blockquote><p>注意此处的 resultType&#x3D;”map” ？？</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- List&lt;Map&lt;String, Object&gt;&gt; getAllUserToMap(); --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getAllUserToMap&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;map&quot;</span>&gt;</span></span><br><span class="line">    select * from t_user</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>测试</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testAllUserToMap</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> SqlSessionUtil.getSqlSession();</span><br><span class="line">    <span class="type">SelectMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(SelectMapper.class);</span><br><span class="line"></span><br><span class="line">    List&lt;Map&lt;String, Object&gt;&gt; list = mapper.getAllUserToMap();</span><br><span class="line">    System.out.println(list);</span><br><span class="line">    <span class="comment">/*  运行结果:</span></span><br><span class="line"><span class="comment">            [&#123;password=123456, gender=男, id=1, age=23, email=12345@qq.com, username=admin&#125;,</span></span><br><span class="line"><span class="comment">            &#123;password=123456, gender=女, id=4, age=33, email=123@qq.com, username=root&#125;]</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>（2）方法二：@MapKey</p><ul><li><p>在 mapper 接口里<strong>编写方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 采用注解方式</span></span><br><span class="line"><span class="comment">  * 查询所有的用户信息为 map 集合(查询多条数据为 map 集合)</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> 返回一个装着 map 的 map 集合</span></span><br><span class="line"><span class="comment">  * (这里用查询出来的 id 为外层 map 的键, 值就是当前的每一条数据所转换为的 map 集合)</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="meta">@MapKey(&quot;id&quot;)</span></span><br><span class="line">Map&lt;String, Object&gt; <span class="title function_">getAllUserToMapByMapKey</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure></li><li><p>在映射文件里<strong>写 sql 语句</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Map&lt;String, Object&gt; getAllUserToMapByMapKey(); --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getAllUserToMapByMapKey&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;map&quot;</span>&gt;</span></span><br><span class="line">    select * from t_user</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>测试</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testAllUserToMapByMapKey</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> SqlSessionUtil.getSqlSession();</span><br><span class="line">    <span class="type">SelectMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(SelectMapper.class);</span><br><span class="line"></span><br><span class="line">    Map&lt;String, Object&gt; map = mapper.getAllUserToMapByMapKey();</span><br><span class="line">    System.out.println(map);</span><br><span class="line">    <span class="comment">/*  运行结果:</span></span><br><span class="line"><span class="comment">            &#123;1=&#123;password=123456, gender=男, id=1, age=23, email=12345@qq.com, username=admin&#125;,</span></span><br><span class="line"><span class="comment">            4=&#123;password=123456, gender=女, id=4, age=33, email=123@qq.com, username=root&#125;&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="8-特殊-SQL-的执行"><a href="#8-特殊-SQL-的执行" class="headerlink" title="8. 特殊 SQL 的执行"></a>8. 特殊 SQL 的执行</h3><h4 id="8-1-模糊查询"><a href="#8-1-模糊查询" class="headerlink" title="8.1 模糊查询"></a>8.1 模糊查询</h4><blockquote><p>直接用 <code>#&#123;&#125;</code> 会报错(因为 ? 在引号里头, 不会被当成占位符解析, 而是被当成了字符串)，因此采用如下三种方法：</p><p>a&gt; <strong>${}</strong> (慎用, 会有 sql 注入的风险)</p><p>b&gt; <strong>concat 字符串拼接函数 和 #{}</strong></p><p>c&gt; <strong>双引号 和 #{}</strong> (该方式比较<strong>常用</strong>)</p></blockquote><p>（1）直接用 ${}</p><ul><li><p>创建 mapper 接口和 映射文件</p><p><img src="/../img/SSM%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88.assets/1672677489247.png" alt="图8.1.1"></p></li><li><p>在 mapper 接口里<strong>编写方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.thr.mybatis.mapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SpecialSQLMapper</span> &#123;</span><br><span class="line">    <span class="comment">// 如果不确定查询出来的结果有几条, 建议使用 list 集合来获取(即用 list 作为返回值)</span></span><br><span class="line">    <span class="comment">// 因为如果用实体类对象来接收的话, 会报错(TooManyResultException)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过用户名模糊查询用户信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> blur 模糊查询的限定条件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回存放 User 对象的 list 集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    List&lt;User&gt; <span class="title function_">getUserByLike</span><span class="params">(<span class="meta">@Param(&quot;blur&quot;)</span> String blur)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在映射文件里<strong>写 sql 语句</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- List&lt;User&gt; getUserByLike(@Param(&quot;blur&quot;) String blur); --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserByLike&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">    select * from t_user where username like &#x27;%$&#123;blur&#125;%&#x27;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>测试</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testGetUserByLike</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> SqlSessionUtil.getSqlSession();</span><br><span class="line">    <span class="type">SpecialSQLMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(SpecialSQLMapper.class);</span><br><span class="line"></span><br><span class="line">    List&lt;User&gt; list = mapper.getUserByLike(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">    list.forEach(System.out::println);</span><br><span class="line">    <span class="comment">// 结果: User&#123;id=1, username=&#x27;admin&#x27;, password=&#x27;123456&#x27;, age=23, gender=&#x27;男&#x27;, email=&#x27;12345@qq.com&#x27;&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>（2）使用 mysql 中的 concat 字符串拼接函数 和 #{}</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- List&lt;User&gt; getUserByLike(@Param(&quot;blur&quot;) String blur); --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserByLike&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">    select * from t_user where username like concat(&#x27;%&#x27;, #&#123;blur&#125;, &#x27;%&#x27;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>（3）使用 双引号 和 #{}</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- List&lt;User&gt; getUserByLike(@Param(&quot;blur&quot;) String blur); --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserByLike&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">    select * from t_user where username like &quot;%&quot;#&#123;blur&#125;&quot;%&quot;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="8-2-批量删除"><a href="#8-2-批量删除" class="headerlink" title="8.2 批量删除"></a>8.2 批量删除</h4><blockquote><p>mysql 中写的 sql 语句：</p><p>DELETE FROM t_user WHERE id &#x3D; 5 OR id &#x3D; 6;<br>DELETE FROM t_user WHERE id IN(7,8);</p><p>由于 #{} 会在参数两边自动拼接单引号，会导致出错，但不会报错，只是更新的数据为0条，例如：如果使用#{}，则解析后的sql语句为 delete from t_user where id in (‘1,2,3’)，这样是将1,2,3看做是一个整体，只有id为 1,2,3 的数据会被删除。正确的语句应该是delete from t_user where id in (1,2,3)，或者delete from t_user where id in (‘1’,’2’,’3’) 。所以<strong>只能使用 ${}</strong></p></blockquote><ul><li><p>在 mapper 接口里<strong>编写方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 批量删除的功能</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> ids 用户 id</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">deleteMoreUser</span><span class="params">(<span class="meta">@Param(&quot;ids&quot;)</span> String ids)</span>;</span><br></pre></td></tr></table></figure></li><li><p>在映射文件里<strong>写 sql 语句</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- void deleteMoreUser(@Param(&quot;ids&quot;) String ids);  // eg. ids: 9, 10--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteMoreUser&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 此处不能直接用 in(#&#123;ids&#125;), 因为其本质是占位符赋值,</span></span><br><span class="line"><span class="comment">             所以其会为我们所赋的值自动加上单引号, 解析后变成 in(&#x27;9,10&#x27;), 故报错</span></span><br><span class="line"><span class="comment">             该处用 in() 进行批量删除时只能采用 $&#123;&#125; </span></span><br><span class="line"><span class="comment">     --&gt;</span></span><br><span class="line">    delete from t_user where id in($&#123;ids&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>测试</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDeleteMoreUser</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> SqlSessionUtil.getSqlSession();</span><br><span class="line">    <span class="type">SpecialSQLMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(SpecialSQLMapper.class);</span><br><span class="line"></span><br><span class="line">    mapper.deleteMoreUser(<span class="string">&quot;9, 10&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="8-3-动态设置表名"><a href="#8-3-动态设置表名" class="headerlink" title="8.3 动态设置表名"></a>8.3 动态设置表名</h4><blockquote><p>**只能使用 ${}**，因为表名不能加单引号 </p></blockquote><ul><li><p>在 mapper 接口里<strong>编写方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 动态设置表名, 查询对应表当前所有用户信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> tableName 表名</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回存放 当前表每条信息转换成的 User对象 的 list 集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">List&lt;User&gt; <span class="title function_">getUserList</span><span class="params">(<span class="meta">@Param(&quot;tableName&quot;)</span> String tableName)</span>;</span><br></pre></td></tr></table></figure></li><li><p>在映射文件里<strong>写 sql 语句</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- List&lt;User&gt; getUserList(@Param(&quot;tableName&quot;) String tableName); --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserList&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 注意！表名是不能加单引号的, 所以直接用 #&#123;&#125; 会报错！</span></span><br><span class="line"><span class="comment">             所有该处动态设置表名时只能使用 $&#123;&#125;</span></span><br><span class="line"><span class="comment">     --&gt;</span></span><br><span class="line">    select * from $&#123;tableName&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>测试</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testGetUserList</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> SqlSessionUtil.getSqlSession();</span><br><span class="line">    <span class="type">SpecialSQLMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(SpecialSQLMapper.class);</span><br><span class="line"></span><br><span class="line">    List&lt;User&gt; list = mapper.getUserList(<span class="string">&quot;t_user&quot;</span>);</span><br><span class="line">    list.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="8-4-添加功能获取自增的主键-常用！难理解"><a href="#8-4-添加功能获取自增的主键-常用！难理解" class="headerlink" title="8.4 添加功能获取自增的主键(常用！难理解)"></a>8.4 添加功能获取自增的主键(常用！难理解)</h4><blockquote><p>也就是说，这个insertUser方法的目的是为了实现添加一个数据，并且获取他的自增列然后把jdbc自增列的值赋给我们实体类对应的属性</p><p><strong>注意看，最后的user不是查出来的，是传进数据库操作的对象，user的id值在进行xml操作时，被赋了值</strong></p><p>其实就一个功能 你没设置前在控制台看不到 id 多少 但是数据库已经自动设置好了，设置后能在控制台看到</p><p><strong>实际上就是添加了一个数据并在 id 上回显添加成功的这次 id</strong></p><p><strong>场景模拟</strong>：假设现在有两张表：</p><p>t_clazz(clazz_id,clazz_name)   <strong>学生表</strong></p><p>t_student(student_id,student_name,clazz_id)   <strong>班级表</strong></p><p>需求：<strong>在添加班级信息的同时为班级分配学生</strong>(需要在多的一方设置主键，即在学生里面设置班级的 id)</p><p>1、添加班级信息  </p><p>2、获取新添加的班级的 id  </p><p>3、为班级分配学生，即将某学生的班级 id 修改为新添加的班级的 id</p></blockquote><ul><li><p>在 mapper 接口里<strong>编写方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加用户信息并获取自增的主键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> user User 对象</span></span><br><span class="line"><span class="comment"> * useGeneratedKeys: 设置使用自增的主键</span></span><br><span class="line"><span class="comment"> * keyProperty: 因为增删改有统一的返回值(是受影响的行数),</span></span><br><span class="line"><span class="comment"> *             因此只能将获取的自增的主键放在传输的参数 user 对象的某个属性中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">insertUser</span><span class="params">(User user)</span>;</span><br></pre></td></tr></table></figure></li><li><p>在映射文件里<strong>写 sql 语句</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- void insertUser(User user); --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertUser&quot;</span> <span class="attr">useGeneratedKeys</span>=<span class="string">&quot;true&quot;</span> <span class="attr">keyProperty</span>=<span class="string">&quot;id&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">            useGeneratedKeys: 表示当前的添加功能使用了自增的主键</span></span><br><span class="line"><span class="comment">            keyProperty: 将添加的数据的自增主键为实体类类型的参数的属性赋值</span></span><br><span class="line"><span class="comment">     --&gt;</span></span><br><span class="line">    insert into t_user values(null, #&#123;username&#125;, #&#123;password&#125;, #&#123;age&#125;, #&#123;gender&#125;, #&#123;email&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>测试</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testInsertUser</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> SqlSessionUtil.getSqlSession();</span><br><span class="line">    <span class="type">SpecialSQLMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(SpecialSQLMapper.class);</span><br><span class="line"></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="literal">null</span>, <span class="string">&quot;xiaoming&quot;</span>, <span class="string">&quot;123456&quot;</span>, <span class="number">23</span>, <span class="string">&quot;男&quot;</span>, <span class="string">&quot;123@qq.com&quot;</span>);</span><br><span class="line">    mapper.insertUser(user);</span><br><span class="line">    System.out.println(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="9-自定义映射-resultMap"><a href="#9-自定义映射-resultMap" class="headerlink" title="9. 自定义映射 resultMap"></a>9. 自定义映射 resultMap</h3><h4 id="9-0-准备工作"><a href="#9-0-准备工作" class="headerlink" title="9.0 准备工作"></a>9.0 准备工作</h4><ul><li><p>创建一个新模块</p><p><img src="/../img/SSM%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88.assets/1672763714001.png" alt="图9.0.1"></p></li><li><p>将原先的 jdbc 配置文件、log4j 文件和 util 类复制过来，再创建包、核心配置文件等(搭建 MyBatis 框架)</p><p><img src="/../img/SSM%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88.assets/1672764073181.png" alt="图9.0.2"></p></li><li><p><strong>创建员工表和部门表</strong></p><blockquote><p>员工 和 部门 是 多对一 的关系 </p><p>在多的一方，即员工表中添上部门的 id 这一字段</p></blockquote><p><img src="/../img/SSM%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88.assets/1672764522519.png" alt="图9.0.3"></p><p><img src="/../img/SSM%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88.assets/1672764341273.png" alt="图9.0.4"></p></li><li><p>添加一些测试数据</p><p><img src="/../img/SSM%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88.assets/1672764721770.png" alt="图9.0.5"></p><p><img src="/../img/SSM%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88.assets/1672764736186.png" alt="图9.0.6"></p></li><li><p><strong>创建 主体类</strong>(包含有参无参构造、getter和setter、toString方法) <strong>和 mapper 接口</strong></p><blockquote><p>此处的 Emp 中 缺少 dept_id 字段对应的属性</p><p>并且注意此处 Emp 类中与 <strong>emp_id</strong> 和 emp_name 字段名对应的属性名是 <strong>empId</strong> 和 empName（一个是下划线，一个是驼峰式命名，导致<strong>字段和属性名不一致</strong>）</p></blockquote><p><img src="/../img/SSM%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88.assets/1672765149801.png" alt="图9.0.7"></p></li></ul><h4 id="9-1-resultMap-处理字段和属性的映射关系-字段和属性名不一致"><a href="#9-1-resultMap-处理字段和属性的映射关系-字段和属性名不一致" class="headerlink" title="9.1 resultMap 处理字段和属性的映射关系(字段和属性名不一致)"></a>9.1 resultMap 处理字段和属性的映射关系(字段和属性名不一致)</h4><blockquote><p> 若<strong>字段名和属性名不一致</strong>，则<strong>查询的结果</strong>中，属性名和字段名<strong>不一致的属性值为 null</strong> </p></blockquote><p>（1）解决方法一：在 SQL 语句中起别名</p><ul><li><p>在 mapper 接口里<strong>编写方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.thr.mybatis.mapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">EmpMapper</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 id 查询员工信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> empId 员工 id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回一个 Emp 对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Emp <span class="title function_">getEmpByEmpId</span><span class="params">(<span class="meta">@Param(&quot;empId&quot;)</span> Integer empId)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在映射文件里<strong>写 sql 语句</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Emp getEmpByEmpId(@Param(&quot;empId&quot;) Integer empId); --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpByEmpId&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Emp&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 1. 在 SQL 语句中起别名(不用 select * , 而是用 select 具体的字段) --&gt;</span></span><br><span class="line">        select emp_id empId, emp_name empName, age, gender from t_emp where emp_id = #&#123;empId&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>测试</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testGetEmpByEmpId</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> SqlSessionUtil.getSqlSession();</span><br><span class="line">    <span class="type">EmpMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(EmpMapper.class);</span><br><span class="line"></span><br><span class="line">    <span class="type">Emp</span> <span class="variable">emp</span> <span class="operator">=</span> mapper.getEmpByEmpId(<span class="number">1</span>);</span><br><span class="line">    System.out.println(emp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>（2）解决方法二：在核心配置文件的 settings 标签设置全局配置</p><ul><li><p>在 官方文档里头找到并<strong>复制到核心配置文件</strong>中</p><blockquote><p>注意核心配置文件里的<strong>标签顺序</strong>：properties?,settings?,typeAliases?….</p><p>可以把这块代码直接放在 模板文件 里头</p></blockquote><p><img src="/../img/SSM%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88.assets/1672766963965.png" alt="图9.1.1"></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 自动将下划线映射为驼峰 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;mapUnderscoreToCamelCase&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在映射文件里<strong>写 sql 语句</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Emp getEmpByEmpId(@Param(&quot;empId&quot;) Integer empId); --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpByEmpId&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Emp&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 2. 在核心配置文件的 settings 标签设置全局配置 --&gt;</span></span><br><span class="line">        select * from t_emp where emp_id = #&#123;empId&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><p>（3）解决方法三：使用 resultMap 自定义映射处理</p><ul><li><p>在映射文件里<strong>写 sql 语句</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 3. 使用 resultMap 自定义映射处理(编写自定义映射)</span></span><br><span class="line"><span class="comment">            id: 唯一标识</span></span><br><span class="line"><span class="comment">            type: 处理映射关系的实体类类型</span></span><br><span class="line"><span class="comment">            常用的标签:</span></span><br><span class="line"><span class="comment">                id: 处理主键和实体类中属性的映射关系</span></span><br><span class="line"><span class="comment">                result: 处理普通字段和实体类中属性的映射</span></span><br><span class="line"><span class="comment">            标签里头的属性:</span></span><br><span class="line"><span class="comment">                column: 设置映射关系中的字段名, 必须是 sql 查询出的某个字段</span></span><br><span class="line"><span class="comment">                property: 设置映射关系中的属性的属性名, 必须是实体类类型中的属性名</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;empResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Emp&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;emp_id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;empId&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;emp_name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;empName&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;age&quot;</span> <span class="attr">property</span>=<span class="string">&quot;age&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">property</span>=<span class="string">&quot;gender&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Emp getEmpByEmpId(@Param(&quot;empId&quot;) Integer empId); --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpByEmpId&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;empResultMap&quot;</span>&gt;</span></span><br><span class="line">    select * from t_emp where emp_id = #&#123;empId&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="9-2-多对一映射处理"><a href="#9-2-多对一映射处理" class="headerlink" title="9.2 多对一映射处理"></a>9.2 多对一映射处理</h4><blockquote><p>场景模拟：查询员工信息以及员工所对应的部门信息</p><p>首先在 Emp 类添加 private Dept dept; 属性 </p><p>在 <strong>员工Emp类 中设置 部门Dept类型 的属性</strong>，表示当前所对应的员工的部门(<strong>一是对象，多是集合，多对一则在”多“的类中创建”一“的类型的属性</strong>)，同时添加 getter and setter 并重写 toString 方法 </p><p>就是<strong>通过一个sql查询emp，要把里面的dept属性赋值的问题</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">2. 处理多对一的映射关系(就是通过一个sql查询emp，要把里面的dept属性赋值的问题)</span><br><span class="line">   下面的方法都用的是 resultMap !!</span><br><span class="line">   2.1 级联方式处理</span><br><span class="line">   2.2 association 标签(javaType: 设置要处理的属性的类型)</span><br><span class="line">   处理多对一(或一对一)的映射关系(实际是处理实体类类型的属性)</span><br><span class="line">   2.3 分步查询(先查员工, 查完员工后知道员工所对应的部门 id,</span><br><span class="line">   再把部门 id 作为条件去部门表里查部门信息, 查询的结果再赋值给 emp类 里头的 dept对象)</span><br><span class="line">   (相当于用第一步结果中的 dept_id 这个结果作为第二部查询的条件)</span><br></pre></td></tr></table></figure></blockquote><p>（1）级联方式处理映射关系</p><ul><li><p>在 mapper 接口里<strong>编写方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取员工以及所对应的部门信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> empId 员工 id</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回一个 Emp 对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Emp <span class="title function_">getEmpAndDeptByEmpId</span><span class="params">(<span class="meta">@Param(&quot;empId&quot;)</span> Integer empId)</span>;</span><br></pre></td></tr></table></figure></li><li><p>在映射文件里<strong>写 sql 语句</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 2.1 级联(将 emp类 中的属性(对象类型的属性)的属性映射到字段)--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;empAndDeptResultMapOne&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Emp&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;emp_id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;empId&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;emp_name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;empName&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;age&quot;</span> <span class="attr">property</span>=<span class="string">&quot;age&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">property</span>=<span class="string">&quot;gender&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;dept_id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;dept.deptId&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;dept_name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;dept.deptName&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Emp getEmpAndDeptByEmpId(@Param(&quot;empId&quot;) Integer empId); --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpAndDeptByEmpId&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;empAndDeptResultMapOne&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 多表查询(该处采用左外连接, 查询所有员工及其部门, 如部门为空, 显示 null) --&gt;</span></span><br><span class="line">    select t_emp.*, t_dept.*</span><br><span class="line">    from t_emp left join t_dept</span><br><span class="line">    on t_emp.dept_id = t_dept.dept_id</span><br><span class="line">    where t_emp.emp_id = #&#123;empId&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>测试</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testGetEmpAndDeptByEmpId</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> SqlSessionUtil.getSqlSession();</span><br><span class="line">    <span class="type">EmpMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(EmpMapper.class);</span><br><span class="line"></span><br><span class="line">    <span class="type">Emp</span> <span class="variable">emp</span> <span class="operator">=</span> mapper.getEmpAndDeptByEmpId(<span class="number">1</span>);</span><br><span class="line">    System.out.println(emp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>（2）使用 association 处理映射关系</p><ul><li><p>在映射文件里<strong>写 sql 语句</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 2.2 association 标签 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;empAndDeptResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Emp&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;emp_id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;empId&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;emp_name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;empName&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;age&quot;</span> <span class="attr">property</span>=<span class="string">&quot;age&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">property</span>=<span class="string">&quot;gender&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">            association 标签: 处理多对一(或一对一)的映射关系(实际是处理实体类类型的属性)</span></span><br><span class="line"><span class="comment">            该标签里头的属性:</span></span><br><span class="line"><span class="comment">                property: 设置需要处理映射关系的属性的属性名</span></span><br><span class="line"><span class="comment">                javaType: 设置要处理的属性的类型</span></span><br><span class="line"><span class="comment">     --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;dept&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;Dept&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;dept_id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;deptId&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;dept_name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;deptName&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><p>（3）分步查询</p><ul><li><p> 在 <strong>EmpMapper</strong> 接口<strong>添加分步查询的第一步</strong> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过分步查询获取员工以及所对应的部门信息的第一步</span></span><br><span class="line"><span class="comment"> * 分步查询第一步：查询员工信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> empId 员工 id</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回一个 Emp 对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Emp <span class="title function_">getEmpAndDeptByStepOne</span><span class="params">(<span class="meta">@Param(&quot;empId&quot;)</span> Integer empId)</span>;</span><br></pre></td></tr></table></figure></li><li><p>再创建一个 <strong>DeptMapper</strong> 接口<strong>添加分步查询的第二步</strong> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.thr.mybatis.mapper;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查哪张表就写在其对应的接口中</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DeptMapper</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过分步查询获取员工以及所对应的部门信息的第二步</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> deptId 在第一步查询到的员工信息里的部门 id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回一个 部门Dept类 对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Dept <span class="title function_">getEmpAndDeptByStepTwo</span><span class="params">(<span class="meta">@Param(&quot;deptId&quot;)</span> Integer deptId)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在 映射文件中<strong>添加 SQL 语句及 resultMap</strong> </p><blockquote><p>获取方法的唯一标识：</p></blockquote><p><img src="/../img/SSM%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88.assets/1672831119262.png" alt="图9.2.1"></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 2.3 分步查询 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;empAndDeptByStepResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Emp&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;emp_id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;empId&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;emp_name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;empName&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;age&quot;</span> <span class="attr">property</span>=<span class="string">&quot;age&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">property</span>=<span class="string">&quot;gender&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">            property: 设置需要处理映射关系的属性的属性名</span></span><br><span class="line"><span class="comment">            select: 设置分步查询的 sql 的唯一标识(mapper 接口的全类名 + 查询语句的 id)</span></span><br><span class="line"><span class="comment">            column: 将查询出的某个字段作为分步查询的 sql 的条件</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;dept&quot;</span></span></span><br><span class="line"><span class="tag">                 <span class="attr">select</span>=<span class="string">&quot;com.thr.mybatis.mapper.DeptMapper.getEmpAndDeptByStepTwo&quot;</span></span></span><br><span class="line"><span class="tag">                 <span class="attr">column</span>=<span class="string">&quot;dept_id&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Emp getEmpAndDeptByStepOne(@Param(&quot;empId&quot;) Integer empId); --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpAndDeptByStepOne&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;empAndDeptByStepResultMap&quot;</span>&gt;</span></span><br><span class="line">    select * from t_emp where emp_id = #&#123;empId&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.thr.mybatis.mapper.DeptMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Dept getEmpAndDeptByStepTwo(@Param(&quot;deptId&quot;) Integer deptId); --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpAndDeptByStepTwo&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Dept&quot;</span>&gt;</span></span><br><span class="line">        select * from t_dept where dept_id = #&#123;deptId&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>测试</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testGetEmpAndDeptByStep</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> SqlSessionUtil.getSqlSession();</span><br><span class="line">    <span class="type">EmpMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(EmpMapper.class);</span><br><span class="line"></span><br><span class="line">    <span class="type">Emp</span> <span class="variable">emp</span> <span class="operator">=</span> mapper.getEmpAndDeptByStepOne(<span class="number">2</span>);</span><br><span class="line">    System.out.println(emp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>（4）<strong>分步查询的优点：延迟加载(懒加载)</strong></p><blockquote><p>分步查询的优点：可以实现延迟加载</p><p>但是必须在核心配置文件中<strong>设置全局配置信息</strong>(在 settings 标签中进行设置)：</p><p><strong>lazyLoadingEnabled</strong>：延迟加载的全局开关。当开启时，所有关联对象都会延迟加载。这里需要<strong>设置为 true</strong></p><p><strong>aggressiveLazyLoading</strong>：当开启时，<strong>任何方法的调用都会加载该对象的所有属性</strong>。 否则，每个属性会按需加载。这里需要<strong>设置为 false</strong>(mybatis 版本小于等于3.4.1时，默认为 true，其他版本默认为 false，所以高版本可以不用设置)</p><p>此时就可以实现按需加载，<strong>获取的数据是什么，就只会执行相应的sql</strong>。此时可通过 association 和 collection 中的<strong>fetchType 属性设置当前的分步查询是否使用延迟加载</strong>，<strong>fetchType&#x3D;”lazy(延迟加载)|eager(立即加载)”</strong></p><p>延迟加载就是我需要分步加载中的哪一步就只执行哪一步</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 自动将下划线映射为驼峰 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;mapUnderscoreToCamelCase&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 开启延迟加载 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;lazyLoadingEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 按需加载 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;aggressiveLazyLoading&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="9-3-一对多映射处理"><a href="#9-3-一对多映射处理" class="headerlink" title="9.3 一对多映射处理"></a>9.3 一对多映射处理</h4><blockquote><p>一个部门里有多个员工（对多对应集合）</p><p>需求：查询部门信息并把当前部门中的所有员工也查出来</p><p><strong>在 Dept 类中添加属性 private List&lt;Emp&gt; emps;</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3. 处理一对多的映射关系</span><br><span class="line">3.1 collection -&gt; 处理一对多或者多对多的映射关系(处理集合类型的属性)</span><br><span class="line">ofType: 设置当前集合中的属性</span><br><span class="line">3.2 分步查询</span><br></pre></td></tr></table></figure></blockquote><p>（1）collection</p><ul><li><p>在 <strong>DeptMapper 接口中添加方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查询部门以及部门中的员工信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> deptId 部门 id</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回一个部门对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Dept <span class="title function_">getDeptAndEmpByDeptId</span><span class="params">(<span class="meta">@Param(&quot;deptId&quot;)</span> Integer deptId)</span>;</span><br></pre></td></tr></table></figure></li><li><p>在 DeptMapper <strong>映射文件中写 sql 语句</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 3.1 collection 标签(处理一对多或者多对多的映射关系(处理集合类型的属性)) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;DeptAndEmpResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Dept&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;dept_id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;deptId&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;dept_name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;deptName&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">            ofType: 设置集合类型的属性中存储的数据的类型</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;emps&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;Emp&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;emp_id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;empId&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;emp_name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;empName&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;age&quot;</span> <span class="attr">property</span>=<span class="string">&quot;age&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">property</span>=<span class="string">&quot;gender&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Dept getDeptAndEmpByDeptId(@Param(&quot;deptId&quot;) Integer deptId); --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getDeptAndEmpByDeptId&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;DeptAndEmpResultMap&quot;</span>&gt;</span></span><br><span class="line">    select *</span><br><span class="line">    from t_dept left join t_emp</span><br><span class="line">    on t_dept.dept_id = t_emp.dept_id</span><br><span class="line">    where t_dept.dept_id = #&#123;deptId&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>测试</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testGetDeptAndAEmpByDeptId</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> SqlSessionUtil.getSqlSession();</span><br><span class="line">    <span class="type">DeptMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(DeptMapper.class);</span><br><span class="line"></span><br><span class="line">    <span class="type">Dept</span> <span class="variable">dept</span> <span class="operator">=</span> mapper.getDeptAndEmpByDeptId(<span class="number">1</span>);</span><br><span class="line">    System.out.println(dept);</span><br><span class="line">    <span class="comment">/* 运行结果</span></span><br><span class="line"><span class="comment">        Dept&#123;deptId=1, deptName=&#x27;A&#x27;, emps=[</span></span><br><span class="line"><span class="comment">                Emp&#123;empId=1, empName=&#x27;张三&#x27;, age=20, gender=&#x27;男&#x27;, dept=null&#125;,</span></span><br><span class="line"><span class="comment">                Emp&#123;empId=4, empName=&#x27;赵六&#x27;, age=24, gender=&#x27;男&#x27;, dept=null&#125;</span></span><br><span class="line"><span class="comment">                ]</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>（2）分步查询</p><ul><li><p>在 <strong>DeptMapper 接口中添加方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过分步查询查询部门以及部门中的员工信息第一步(一对多)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> deptId 部门 id</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回一个部门对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Dept <span class="title function_">getDeptAndEmpByStepOne</span><span class="params">(<span class="meta">@Param(&quot;deptId&quot;)</span> Integer deptId)</span>;</span><br></pre></td></tr></table></figure></li><li><p>在 <strong>EmpMapper 接口中添加方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过分步查询查询部门以及部门中的员工信息第二步(一对多)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> deptId 部门 id</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回一个包含 Emp 对象的 List 集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">List&lt;Emp&gt; <span class="title function_">getDeptAndEmpByStepTwo</span><span class="params">(<span class="meta">@Param(&quot;deptId&quot;)</span> Integer deptId)</span>;</span><br></pre></td></tr></table></figure></li><li><p>在 映射文件中<strong>添加 SQL 语句及 resultMap</strong> </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 3.2 分步查询第一步 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;deptAndEmpResultMapByStep&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Dept&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;dept_id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;deptId&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;dept_name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;deptName&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;emps&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">select</span>=<span class="string">&quot;com.thr.mybatis.mapper.EmpMapper.getDeptAndEmpByStepTwo&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">column</span>=<span class="string">&quot;dept_id&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Dept getDeptAndEmpByStepOne(@Param(&quot;deptId&quot;) Integer deptId); --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getDeptAndEmpByStepOne&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;deptAndEmpResultMapByStep&quot;</span>&gt;</span></span><br><span class="line">    select * from t_dept where dept_id = #&#123;deptId&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 3.2 分步查询第二步 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- List&lt;Emp&gt; getDeptAndEmpByStepTwo(@Param(&quot;deptId&quot;) Integer deptId); --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getDeptAndEmpByStepTwo&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Emp&quot;</span>&gt;</span></span><br><span class="line">    select * from t_emp where dept_id = #&#123;deptId&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>测试</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testGetDeptAndAEmpByStep</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> SqlSessionUtil.getSqlSession();</span><br><span class="line">    <span class="type">DeptMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(DeptMapper.class);</span><br><span class="line"></span><br><span class="line">    <span class="type">Dept</span> <span class="variable">dept</span> <span class="operator">=</span> mapper.getDeptAndEmpByStepOne(<span class="number">1</span>);</span><br><span class="line">    System.out.println(dept);</span><br><span class="line">    System.out.println(dept.getDeptName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="10-动态-SQL"><a href="#10-动态-SQL" class="headerlink" title="10. 动态 SQL"></a>10. 动态 SQL</h3><blockquote><p>MyBatis 框架的 动态SQL 技术是一种<strong>根据特定条件动态拼装SQL语句的功能</strong>，它存在的意义是为了解决拼接SQL语句字符串时的痛点问题</p><p>比如说根据图书编号，图书名，作者查询，只填一个，或者两个，或者三个，如果填了就添加在 sql 语句中，没填就不用(动态 sql)</p><p><strong>不是 null 或者 空字符串 就进行拼接</strong>，是 null 或者 空字符串 就不拼接</p><p>若都是空，需求一般就是要打印所有记录信息的</p></blockquote><ul><li><p>创建新的工程，设置好配置文件啥的</p><p><img src="/../img/MyBatis%E5%85%A5%E9%97%A8.assets/1672854914967.png" alt="图10.0.1"></p></li></ul><h4 id="10-1-if"><a href="#10-1-if" class="headerlink" title="10.1 if"></a>10.1 if</h4><blockquote><p>if标签可通过 test 属性（即传递过来的数据）的表达式进行判断，若表达式的结果为true，则标签中的内容会执行；反之标签中的内容不会执行</p><p>if: 通过 test 属性中的表达式<strong>判断标签中的内容是否有效(是否会拼接到 sql 中)</strong></p></blockquote><ul><li><p>在 mapper <strong>接口中添加方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据条件查询员工信息(多条件查询)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> emp 一个员工对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回 list 集合(因为不确定有几条返回值)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">List&lt;Emp&gt; <span class="title function_">getEmpByCondition</span><span class="params">(Emp emp)</span>;</span><br></pre></td></tr></table></figure></li><li><p>在 映射文件中<strong>添加 SQL 语句</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- List&lt;Emp&gt; getEmpByCondition(Emp emp); --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 1. if 标签 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpByCondition&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Emp&quot;</span>&gt;</span></span><br><span class="line">    select * from t_emp where</span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;empName != null and empName != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">        emp_name = #&#123;empName&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;age != null and age != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">        and age = #&#123;age&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;gender != null and gender != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">        and gender = #&#123;gender&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>测试</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testGetEmpByCondition</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> SqlSessionUtil.getSqlSession();</span><br><span class="line">    <span class="type">DynamicSQLMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(DynamicSQLMapper.class);</span><br><span class="line"></span><br><span class="line">    <span class="type">Emp</span> <span class="variable">emp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Emp</span>(<span class="literal">null</span>, <span class="string">&quot;张三&quot;</span>, <span class="number">20</span>, <span class="string">&quot;男&quot;</span>);</span><br><span class="line">    List&lt;Emp&gt; list = mapper.getEmpByCondition(emp);</span><br><span class="line">    list.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="10-2-where"><a href="#10-2-where" class="headerlink" title="10.2 where"></a>10.2 where</h4><blockquote><p>为了解决后面条件不成立导致 sql 语句多出来的 where 的问题，<strong>一种方法是在 where 后头加上 ”1&#x3D;1“ 的恒成立条件</strong>，再将后头判断语句的前面都加上 ”and“ 即可，<strong>另一种方法是使用 where 标签</strong></p><p>where 和 if一般结合使用：</p><ul><li><strong>若 where 标签中的 if 条件都不满足</strong>，则where标签没有任何功能，即<strong>不会添加where关键字</strong></li><li><strong>若 where 标签中的 if 条件满足</strong>，则where标签会<strong>自动添加 where 关键字，并将条件最前方多余的 and 和 or 去掉</strong></li></ul><p><strong>注意：where标签不能去掉条件最后多余的and</strong></p></blockquote><ul><li><p>映射文件里的 sql 语句</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- List&lt;Emp&gt; getEmpByCondition(Emp emp); --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 2. where 标签 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpByCondition&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Emp&quot;</span>&gt;</span></span><br><span class="line">    select * from t_emp</span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;empName != null and empName != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">            emp_name = #&#123;empName&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;age != null and age != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">            and age = #&#123;age&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;gender != null and gender != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">            and gender = #&#123;gender&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="10-3-trim"><a href="#10-3-trim" class="headerlink" title="10.3 trim"></a>10.3 trim</h4><blockquote><p>trim 用于<strong>去掉或添加标签中的内容</strong></p><p>常用属性:</p><p><strong>prefix</strong>：在trim标签中的内容的<strong>前面添加</strong>某些内容</p><p><strong>suffix</strong>：在trim标签中的内容的<strong>后面添加</strong>某些内容</p><p><strong>prefixOverrides</strong>：在trim标签中的内容的<strong>前面去掉</strong>某些内容</p><p><strong>suffixOverrides</strong>：在trim标签中的内容的<strong>后面去掉</strong>某些内容</p></blockquote><ul><li><p>映射文件里的 sql 语句</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- List&lt;Emp&gt; getEmpByCondition(Emp emp); --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 3. trim 标签 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpByCondition&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Emp&quot;</span>&gt;</span></span><br><span class="line">    select * from t_emp</span><br><span class="line">    <span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">&quot;where&quot;</span> <span class="attr">suffixOverrides</span>=<span class="string">&quot;and&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;empName != null and empName != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">            emp_name = #&#123;empName&#125; and</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;age != null and age != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">            age = #&#123;age&#125; and</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;gender != null and gender != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">            gender = #&#123;gender&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="10-4-choose、when、otherwise"><a href="#10-4-choose、when、otherwise" class="headerlink" title="10.4 choose、when、otherwise"></a>10.4 choose、when、otherwise</h4><blockquote><p>choose、when、otherwise <strong>相当于 if …… else if …… else ……</strong>  一个成立后面便不再执行, 所以也不用加 and</p><p>因此 where 后头最多只能加一个条件, 不能多条件查询了</p><p><strong>when(表示 if..elif) 至少设置一个</strong>, <strong>otherwise(表示 else) 最多设置一个</strong></p></blockquote><ul><li><p>在 mapper <strong>接口中添加方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用 choose 查询员工信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> emp 一个员工对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回 list 集合(因为不确定有几条返回值)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">List&lt;Emp&gt; <span class="title function_">getEmpByChoose</span><span class="params">(Emp emp)</span>;</span><br></pre></td></tr></table></figure></li><li><p>在 映射文件中<strong>添加 SQL 语句</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- List&lt;Emp&gt; getEmpByChoose(Emp emp); --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 4. choose, when, otherwise 标签 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpByChoose&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Emp&quot;</span>&gt;</span></span><br><span class="line">    select * from t_emp</span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">choose</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;empName != null and empName != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">                emp_name = #&#123;empName&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;age != null and age != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">                age = #&#123;age&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;gender != null and gender != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">                gender = #&#123;gender&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">choose</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="10-5-foreach-重要"><a href="#10-5-foreach-重要" class="headerlink" title="10.5 foreach(重要)"></a>10.5 foreach(重要)</h4><blockquote><p>foreach: <strong>循环执行该标签里头的内容</strong>, 其<strong>具体属性</strong>有:<br>           <strong>collection</strong>: 设置要循环的数组或集合<br>           <strong>item</strong>: 用一个字符串来表示数组或集合中的每一个数据<br>           <strong>separator</strong>: 设置每次循环的数据之间的分隔符<br>           <strong>open</strong>: 循环的所有内容以什么开始<br>           <strong>close</strong>: 循环的所有内容以什么结束</p></blockquote><p>（1）批量添加</p><ul><li><p>在 mapper <strong>接口中添加方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 批量添加员工信息</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> emps 存放 Emp对象的集合</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">insertMoreEmp</span><span class="params">(<span class="meta">@Param(&quot;emps&quot;)</span> List&lt;Emp&gt; emps)</span>;</span><br></pre></td></tr></table></figure></li><li><p>在 映射文件中<strong>添加 SQL 语句</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- void insertMoreEmp(@Param(&quot;emps&quot;) List&lt;Emp&gt; emps); --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 5.1 foreach 批量添加 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;insertMoreEmp&quot;</span>&gt;</span></span><br><span class="line">    insert into t_emp values</span><br><span class="line">    <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;emps&quot;</span> <span class="attr">item</span>=<span class="string">&quot;emp&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span>&gt;</span></span><br><span class="line">        (null, #&#123;emp.empName&#125;, #&#123;emp.age&#125;, #&#123;emp.gender&#125;, null)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>测试</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testInsertMoreEmp</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> SqlSessionUtil.getSqlSession();</span><br><span class="line">    <span class="type">DynamicSQLMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(DynamicSQLMapper.class);</span><br><span class="line"></span><br><span class="line">    <span class="type">Emp</span> <span class="variable">emp1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Emp</span>(<span class="literal">null</span>, <span class="string">&quot;小明1&quot;</span>, <span class="number">20</span>, <span class="string">&quot;男&quot;</span>);</span><br><span class="line">    <span class="type">Emp</span> <span class="variable">emp2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Emp</span>(<span class="literal">null</span>, <span class="string">&quot;小明2&quot;</span>, <span class="number">20</span>, <span class="string">&quot;男&quot;</span>);</span><br><span class="line">    <span class="type">Emp</span> <span class="variable">emp3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Emp</span>(<span class="literal">null</span>, <span class="string">&quot;小明3&quot;</span>, <span class="number">20</span>, <span class="string">&quot;男&quot;</span>);</span><br><span class="line">    List&lt;Emp&gt; list = Arrays.asList(emp1, emp2, emp3);</span><br><span class="line">    mapper.insertMoreEmp(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>（2）批量删除</p><ul><li><p>在 mapper <strong>接口中添加方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 批量删除用户信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> empIds 存放 用户id 的数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">deleteMoreEmp</span><span class="params">(<span class="meta">@Param(&quot;empIds&quot;)</span> Integer[] empIds)</span>;</span><br></pre></td></tr></table></figure></li><li><p>在 映射文件中<strong>添加 SQL 语句</strong></p><blockquote><p>此处删除可用两种方法 </p><ul><li><strong>where id in(???)</strong></li><li><strong>where or…or…</strong></li></ul></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- void deleteMoreEmp(@Param(&quot;empIds&quot;) Integer[] empIds); --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 5.2 foreach 批量删除 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;deleteMoreEmp&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 5.2.1 用 where..in(?,?,?) --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--delete from t_emp where emp_id in</span></span><br><span class="line"><span class="comment">        &lt;foreach collection=&quot;empIds&quot; item=&quot;empId&quot; separator=&quot;,&quot; open=&quot;(&quot; close=&quot;)&quot;&gt;</span></span><br><span class="line"><span class="comment">             #&#123;empId&#125;</span></span><br><span class="line"><span class="comment">        &lt;/foreach&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 5.2.1 用 where...or... --&gt;</span></span><br><span class="line">    delete from t_emp where</span><br><span class="line">    <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;empIds&quot;</span> <span class="attr">item</span>=<span class="string">&quot;empId&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;or&quot;</span>&gt;</span></span><br><span class="line">        emp_id = #&#123;empId&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>测试</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDeleteMoreEmp</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> SqlSessionUtil.getSqlSession();</span><br><span class="line">    <span class="type">DynamicSQLMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(DynamicSQLMapper.class);</span><br><span class="line"></span><br><span class="line">    Integer[] empIds = <span class="keyword">new</span> <span class="title class_">Integer</span>[]&#123;<span class="number">6</span>, <span class="number">7</span>&#125;;</span><br><span class="line">    mapper.deleteMoreEmp(empIds);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="10-6-SQL-片段"><a href="#10-6-SQL-片段" class="headerlink" title="10.6 SQL 片段"></a>10.6 SQL 片段</h4><blockquote><p><strong>select * 少用</strong>，数据多了的话查询效率特低，因为查询的时候会先把<em>查询成所有字段，所以<strong>建议写全</strong>，写全以后又很麻烦，*<em>直接用sql标签，然后引用，减少代码冗余</em></em></p><p>sql片段，可以<strong>记录一段公共sql片段，在使用的地方通过 include 标签进行引入</strong></p></blockquote><ul><li><p><strong>声明</strong> sql 片段 </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;empColumns&quot;</span>&gt;</span></span><br><span class="line">    emp_id, emp_name, age, gender, dept_id</span><br><span class="line"><span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>引用</strong> sql 片段 </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;empColumns&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">include</span>&gt;</span> from t_emp</span><br></pre></td></tr></table></figure></li></ul><h3 id="11-MyBatis-的缓存"><a href="#11-MyBatis-的缓存" class="headerlink" title="11. MyBatis 的缓存"></a>11. MyBatis 的缓存</h3><ul><li><p>创建新的工程</p><p><img src="/../img/MyBatis%E5%85%A5%E9%97%A8.assets/1672862472810.png" alt="图11.0.1"></p></li></ul><h4 id="11-1-MyBatis-的一级缓存"><a href="#11-1-MyBatis-的一级缓存" class="headerlink" title="11.1 MyBatis 的一级缓存"></a>11.1 MyBatis 的一级缓存</h4><blockquote><p><strong>一级缓存是默认开启的</strong>，且是 SqlSession 级别的，也就是通过同一个 SqlSession 查询的数据会被缓存，<strong>下次查询相同的数据，就会从缓存中直接获取，不会从数据库重新访问</strong></p><p>使<strong>一级缓存失效</strong>的四种情况：</p><p>1）<strong>不同的 SqlSession</strong> 对应不同的一级缓存</p><p>2）<strong>同一个 SqlSession 但是查询条件不同</strong></p><p>3）<strong>同一个 SqlSession 两次查询期间执行了任何一次增删改操作</strong>(因为任意一次增删改执行完后会自动清空缓存)</p><p>4）<strong>同一个 SqlSession 两次查询期间手动清空了缓存</strong>（清空缓存可以使用）</p></blockquote><ul><li><p>在 mapper <strong>接口中添加方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据员工 id 查询员工信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> empId 员工 id</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回一个 Emp 对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Emp <span class="title function_">getEmpById</span><span class="params">(<span class="meta">@Param(&quot;empId&quot;)</span> Integer empId)</span>;</span><br></pre></td></tr></table></figure></li><li><p>在 映射文件中<strong>添加 SQL 语句</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Emp getEmpById(@Param(&quot;empId&quot;) Integer empId); --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpById&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Emp&quot;</span>&gt;</span></span><br><span class="line">    select * from t_emp where emp_id = #&#123;empId&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>测试</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testGetEmpById</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">            MyBatis的一级缓存: (默认开启)</span></span><br><span class="line"><span class="comment">            sqlSession 级别的, 即通过同一个 sqlSession 查询出来的数据会被缓存</span></span><br><span class="line"><span class="comment">            再次使用同一个 sqlSession 查询同一条数据, 会从缓存中获取</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 第一个 sqlSession</span></span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">sqlSession1</span> <span class="operator">=</span> SqlSessionUtil.getSqlSession();</span><br><span class="line">    <span class="type">CacheMapper</span> <span class="variable">mapper1</span> <span class="operator">=</span> sqlSession1.getMapper(CacheMapper.class);</span><br><span class="line"></span><br><span class="line">    <span class="type">Emp</span> <span class="variable">emp1</span> <span class="operator">=</span> mapper1.getEmpById(<span class="number">1</span>);</span><br><span class="line">    System.out.println(emp1);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 手动清空一级缓存, 会使一级缓存失效</span></span><br><span class="line">    <span class="comment">// sqlSession1.clearCache();</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询相同的数据, 从运行结果可以看出只执行了一次 sql, 返回了两条数据</span></span><br><span class="line">    <span class="comment">// 故 emp1 是从数据库里头查的, emp2 是从缓存里查的</span></span><br><span class="line">    <span class="type">Emp</span> <span class="variable">emp2</span> <span class="operator">=</span> mapper1.getEmpById(<span class="number">1</span>);</span><br><span class="line">    System.out.println(emp2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二个 sqlSession</span></span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">sqlSession2</span> <span class="operator">=</span> SqlSessionUtil.getSqlSession();</span><br><span class="line">    <span class="type">CacheMapper</span> <span class="variable">mapper2</span> <span class="operator">=</span> sqlSession2.getMapper(CacheMapper.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// emp3 会再次从数据库里头查, 因为与上头那个不是同一个 sqlSession</span></span><br><span class="line">    <span class="type">Emp</span> <span class="variable">emp3</span> <span class="operator">=</span> mapper2.getEmpById(<span class="number">1</span>);</span><br><span class="line">    System.out.println(emp3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="11-2-MyBatis-的二级缓存"><a href="#11-2-MyBatis-的二级缓存" class="headerlink" title="11.2 MyBatis 的二级缓存"></a>11.2 MyBatis 的二级缓存</h4><blockquote><p>二级缓存是 <strong>SqlSessionFactory 级别</strong>，通过同一个SqlSessionFactory 创建的 SqlSession 查询的结果会被缓存；此后若再次执行相同的查询语句，结果就会从缓存中获取</p><p>二级缓存<strong>开启的条件</strong>：</p><ul><li>在核心配置文件中，设置全局配置属性<strong>cacheEnabled&#x3D;”true”<strong>，</strong>默认为true</strong>，<strong>不需要设置</strong></li><li>在<strong>映射文件中设置标签 &lt;cache &#x2F;&gt;</strong></li><li>二级缓存必须<strong>在SqlSession关闭或提交之后有效</strong></li><li>查询的数据所转换的<strong>实体类类型必须实现序列化 Serializable 的接口</strong></li></ul><p>使二级缓存<strong>失效</strong>的情况：两次查询之间<strong>执行了任意的增删改，会使一级和二级缓存同时失效</strong></p></blockquote><ul><li><p>查询的数据所转换的实体类类型<strong>实现序列化接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Emp</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;...&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>测试</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testCache</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 测试二级缓存, 故不能直接用工具类, 需要重新获取一个 SqlSessionFactory</span></span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> Resources.getResourceAsStream(<span class="string">&quot;mybatis-config.xml&quot;</span>);</span><br><span class="line">    <span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(is);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 由同一个 sqlSessionFactory 得到的 sqlSession1 和 sqlSession2</span></span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">sqlSession1</span> <span class="operator">=</span> sqlSessionFactory.openSession(<span class="literal">true</span>);</span><br><span class="line">    <span class="type">CacheMapper</span> <span class="variable">mapper1</span> <span class="operator">=</span> sqlSession1.getMapper(CacheMapper.class);</span><br><span class="line">    <span class="type">Emp</span> <span class="variable">emp1</span> <span class="operator">=</span> mapper1.getEmpById(<span class="number">1</span>);</span><br><span class="line">    System.out.println(emp1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 二级缓存必须在 SqlSession 关闭或提交之后有效(关闭后, 保存在一级缓存中的数据才会被保存到二级缓存中)</span></span><br><span class="line">    sqlSession1.close();</span><br><span class="line"></span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">sqlSession2</span> <span class="operator">=</span> sqlSessionFactory.openSession(<span class="literal">true</span>);</span><br><span class="line">    <span class="type">CacheMapper</span> <span class="variable">mapper2</span> <span class="operator">=</span> sqlSession2.getMapper(CacheMapper.class);</span><br><span class="line">    <span class="type">Emp</span> <span class="variable">emp2</span> <span class="operator">=</span> mapper2.getEmpById(<span class="number">1</span>);</span><br><span class="line">    System.out.println(emp2);</span><br><span class="line"></span><br><span class="line">    sqlSession2.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><img src="/../img/MyBatis%E5%85%A5%E9%97%A8.assets/1672905310136.png" alt="图11.2.1"></p><h4 id="11-3-二级缓存的相关配置"><a href="#11-3-二级缓存的相关配置" class="headerlink" title="11.3 二级缓存的相关配置"></a>11.3 二级缓存的相关配置</h4><blockquote><p>cache 标签的<strong>相关属性</strong>：</p><ul><li><strong>eviction属性</strong>：缓存回收策略</li></ul><p>LRU（Least Recently Used） – <strong>最近最少使用的</strong>：移除最长时间不被使用的对象。</p><p>FIFO（First in First out） – 先进先出：按对象进入缓存的顺序来移除它们。</p><p>SOFT – 软引用：移除基于垃圾回收器状态和软引用规则的对象。</p><p>WEAK – 弱引用：更积极地移除基于垃圾收集器状态和弱引用规则的对象。</p><p><strong>默认的是 LRU</strong></p><ul><li><strong>flushInterval属性</strong>：刷新间隔，单位毫秒</li></ul><p><strong>默认情况是不设置，也就是没有刷新间隔，缓存仅仅调用语句（增删改）时刷新</strong></p><ul><li><strong>size属性</strong>：引用数目，正整数</li></ul><p>代表<strong>缓存最多可以存储多少个对象</strong>，太大容易导致内存溢出</p><ul><li><strong>readOnly属性</strong>：<strong>只读</strong>，true&#x2F;false</li></ul><p>true：只读缓存；会给所有调用者返回缓存对象的相同实例(将缓存的数据直接返回给调用者)。因此这些对象不能被修改。这提供了很重要的性能优势。</p><p>false：<strong>读写缓存</strong>；会返回缓存对象的拷贝（通过<strong>序列化</strong>）。这会<strong>慢一些，但是安全，因此默认是false</strong></p></blockquote><h4 id="11-4-MyBatis-缓存查询的顺序"><a href="#11-4-MyBatis-缓存查询的顺序" class="headerlink" title="11.4 MyBatis 缓存查询的顺序"></a>11.4 MyBatis 缓存查询的顺序</h4><blockquote><p>从大范围查到小范围，二级缓存是SqlSessionFactory 范围更大些</p><p>若一级缓存和二级缓存都开启，则<strong>先查询二级缓存</strong>，因为二级缓存中可能会有其他程序已经查出来的数据，可以拿来直接使用</p><p>如果<strong>二级缓存没有命中，再查询一级缓存</strong>(因为可能没关闭，所以一级里头可能有二级没有的)</p><p>二级缓存是要session提交后的数据，而一级缓存里面的数据不一定提交了</p><p>如果<strong>一级缓存也没有命中，则查询数据库</strong></p><p>SqlSession关闭之前，数据默认保存在一级缓存之中，但<strong>SqlSession关闭之后，一级缓存中的数据会写入二级缓存</strong></p></blockquote><h4 id="11-5-整合第三方缓存-EHCache-了解即可"><a href="#11-5-整合第三方缓存-EHCache-了解即可" class="headerlink" title="11.5 整合第三方缓存 EHCache(了解即可)"></a>11.5 整合第三方缓存 EHCache(了解即可)</h4><p>（1）<strong>添加依赖</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Mybatis EHCache整合包 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.caches<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-ehcache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- slf4j日志门面的一个具体实现 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-classic<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>（2）各 jar 包功能</p><table><thead><tr><th align="center"><strong>jar 包名称</strong></th><th align="center"><strong>作用</strong></th></tr></thead><tbody><tr><td align="center">mybatis-ehcache</td><td align="center">Mybatis和EHCache的整合包</td></tr><tr><td align="center">ehcache</td><td align="center">EHCache核心包</td></tr><tr><td align="center">slf4j-api</td><td align="center">SLF4J日志门面包</td></tr><tr><td align="center">logback-classic</td><td align="center">支持SLF4J门面接口的一个具体实现</td></tr></tbody></table><p>（3）<strong>创建 EHCache 的配置文件 ehcache.xml</strong> (名字必须为 ehcache.xml)</p><blockquote><p>爆红不用管，能实现功能就行</p></blockquote><p><img src="/../img/MyBatis%E5%85%A5%E9%97%A8.assets/1672908139529.png" alt="图11.5.1"></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ehcache</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:noNamespaceSchemaLocation</span>=<span class="string">&quot;../config/ehcache.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 磁盘保存路径 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">diskStore</span> <span class="attr">path</span>=<span class="string">&quot;D:\ehcache&quot;</span>/&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">&lt;!-- 设置缓存的信息 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">defaultCache</span></span></span><br><span class="line"><span class="tag">            <span class="attr">maxElementsInMemory</span>=<span class="string">&quot;1000&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">maxElementsOnDisk</span>=<span class="string">&quot;10000000&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">eternal</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">overflowToDisk</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">timeToIdleSeconds</span>=<span class="string">&quot;120&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">timeToLiveSeconds</span>=<span class="string">&quot;120&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">diskExpiryThreadIntervalSeconds</span>=<span class="string">&quot;120&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">memoryStoreEvictionPolicy</span>=<span class="string">&quot;LRU&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">defaultCache</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ehcache</span>&gt;</span></span><br></pre></td></tr></table></figure><p>（4）<strong>设置二级缓存的类型</strong></p><blockquote><p>在xxxMapper.xml文件中设置二级缓存类型</p><p>例如，在 CacheMapper.xml 中设置 </p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache</span> <span class="attr">type</span>=<span class="string">&quot;org.mybatis.caches.ehcache.EhcacheCache&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>（5）<strong>加入 logback 日志</strong></p><blockquote><p><strong>存在SLF4J时，作为简易日志的log4j将失效</strong>，此时我们需要借助SLF4J的具体实现logback来打印日志。</p><p>创建logback的配置文件 logback.xml，<strong>名字固定，不可改变</strong></p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span> <span class="attr">debug</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 指定日志输出的位置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;STDOUT&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 日志输出的格式 --&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 按照顺序分别是：时间、日志级别、线程名称、打印日志的类、日志主体内容、换行 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>[%d&#123;HH:mm:ss.SSS&#125;] [%-5level] [%thread] [%logger] [%msg]%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 设置全局日志级别。日志级别按顺序分别是：DEBUG、INFO、WARN、ERROR --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 指定任何一个日志级别都只打印当前级别和后面级别的日志。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">&quot;DEBUG&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 指定打印日志的appender，这里通过“STDOUT”引用了前面配置的appender --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;STDOUT&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 根据特殊需求指定局部日志级别 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;com.thr.mybatis.mapper&quot;</span> <span class="attr">level</span>=<span class="string">&quot;DEBUG&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="12-MyBatis-的逆向工程"><a href="#12-MyBatis-的逆向工程" class="headerlink" title="12. MyBatis 的逆向工程"></a>12. MyBatis 的逆向工程</h3><blockquote><p><strong>正向工程</strong>：先创建Java实体类，由框架负责根据实体类生成数据库表。Hibernate是支持正向工程的</p><p><strong>逆向工程</strong>(本质是代码生成器)：<strong>先创建数据库表，由框架负责根据数据库表，反向生成如下资源</strong>：</p><ul><li>Java实体类</li><li>Mapper接口</li><li>Mapper映射文件</li></ul><p>逆向工程时，如果出现生成的实体类总是错误，属性命名没有根据命名规则来，甚至出现了在表中没有的属性：</p><p>可以尝试在数据库连接的 URL 后面加上  nullCatalogMeansCurrent&#x3D;true </p></blockquote><h4 id="12-1-创建逆向工程的步骤-简洁版"><a href="#12-1-创建逆向工程的步骤-简洁版" class="headerlink" title="12.1 创建逆向工程的步骤(简洁版)"></a>12.1 创建逆向工程的步骤(简洁版)</h4><p>（1）<strong>设置打包方式为jar，添加依赖和插件</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- MyBatis核心依赖包 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- junit测试 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- MySQL驱动 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.47<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- log4j日志 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 控制Maven在构建过程中相关配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 构建过程中用到的插件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 具体插件，逆向工程的操作是以构建过程中插件形式出现的 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.generator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-generator-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 插件的依赖 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 逆向工程的核心依赖 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.generator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-generator-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- MySQL驱动 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.47<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>（2）创建 MyBatis 的核心配置文件、逆向工程的配置文件</p><blockquote><p>这里 MyBatis 的核心配置文件 可以先不用填写 typeAliase 和 mappers 的包名，可以等到逆向后再填写</p><p> 逆向工程的配置文件名字必须是 generatorConfig.xml，上面的 URI 爆红不用管 </p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">generatorConfiguration</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">generatorConfiguration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        targetRuntime: 执行生成的逆向工程的版本</span></span><br><span class="line"><span class="comment">            MyBatis3Simple: 生成基本的CRUD（清新简洁版）</span></span><br><span class="line"><span class="comment">            MyBatis3: 生成带条件的CRUD（奢华尊享版）</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context</span> <span class="attr">id</span>=<span class="string">&quot;DB2Tables&quot;</span> <span class="attr">targetRuntime</span>=<span class="string">&quot;MyBatis3Simple&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 数据库的连接信息 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">jdbcConnection</span> <span class="attr">driverClass</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">connectionURL</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/ssm?useSSL=false<span class="symbol">&amp;amp;</span></span></span></span><br><span class="line"><span class="string"><span class="tag">                                       serverTimezone=UTC<span class="symbol">&amp;amp;</span>useUnicode=true<span class="symbol">&amp;amp;</span>characterEncoding=UTF-8&quot;</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">userId</span>=<span class="string">&quot;root&quot;</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">password</span>=<span class="string">&quot;thr&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">jdbcConnection</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- javaBean的生成策略--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">javaModelGenerator</span> <span class="attr">targetPackage</span>=<span class="string">&quot;com.thr.mybatis.pojo&quot;</span> <span class="attr">targetProject</span>=<span class="string">&quot;.\src\main\java&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">                enableSubPackages：设置是否能用子包</span></span><br><span class="line"><span class="comment">                    true：targetPackage属性中每一个点对应一层包(目录)</span></span><br><span class="line"><span class="comment">                    false：targetPackage中的名字只作为一层包(目录)</span></span><br><span class="line"><span class="comment">            --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;enableSubPackages&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- trimStrings：去掉字符串前后的空格 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;trimStrings&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">javaModelGenerator</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- SQL映射文件的生成策略 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sqlMapGenerator</span> <span class="attr">targetPackage</span>=<span class="string">&quot;com.thr.mybatis.mapper&quot;</span></span></span><br><span class="line"><span class="tag">                         <span class="attr">targetProject</span>=<span class="string">&quot;.\src\main\resources&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;enableSubPackages&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">sqlMapGenerator</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- Mapper接口的生成策略 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">javaClientGenerator</span> <span class="attr">type</span>=<span class="string">&quot;XMLMAPPER&quot;</span> <span class="attr">targetPackage</span>=<span class="string">&quot;com.thr.mybatis.mapper&quot;</span> <span class="attr">targetProject</span>=<span class="string">&quot;.\src\main\java&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;enableSubPackages&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">javaClientGenerator</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 逆向分析的表 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- tableName：设置表名，若设置为*号，可以对应所有表，此时不写domainObjectName --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- domainObjectName：设置生成出来的实体类的类名 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">table</span> <span class="attr">tableName</span>=<span class="string">&quot;t_emp&quot;</span> <span class="attr">domainObjectName</span>=<span class="string">&quot;Emp&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">table</span> <span class="attr">tableName</span>=<span class="string">&quot;t_dept&quot;</span> <span class="attr">domainObjectName</span>=<span class="string">&quot;Dept&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">generatorConfiguration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>（3）<strong>执行 MBG 插件的 generate 目标</strong>(双击即可)</p><p><img src="/../img/MyBatis%E5%85%A5%E9%97%A8.assets/1672910013957.png" alt="图12.1.1"></p><blockquote><p>执行后，就会在对应位置生成实体类和 xml 文件 </p><p>之后注意完善核心配置文件 mybatis-config.xml</p><p>将 typeAliases 和 mappers 标签对应的包名填上  </p></blockquote><p><img src="/../img/MyBatis%E5%85%A5%E9%97%A8.assets/1672910715864.png" alt="图12.1.2"></p><h4 id="12-2-逆向工程-MyBatis3-生成的方法说明-奢华版"><a href="#12-2-逆向工程-MyBatis3-生成的方法说明-奢华版" class="headerlink" title="12.2 逆向工程 MyBatis3 生成的方法说明(奢华版)"></a>12.2 逆向工程 MyBatis3 生成的方法说明(奢华版)</h4><blockquote><p>1、只要<strong>方法中有 Example</strong>，那就是<strong>根据条件来查询</strong>，<strong>例如</strong> <strong>countByExample 根据条件查询记录数</strong>，deleteByExample 根据条件删除</p><p>2、<strong>普通插入</strong> int <strong>insert</strong>(Emp record) 和 <strong>选择性插入</strong> int <strong>insertSelective</strong>(Emp record) 的区别：若传入的方法参数的实体类的某个属性<strong>含有 null 值</strong>，普通插入会将 null 作为该值赋给对应字段，而<strong>选择性插入只会为属性值不是 null 的字段赋值，不会为属性是 null 的字段赋值</strong>。当然，由于默认值为 null，所以效果并不明显</p><p>3、<strong>普通修改和选择性修改的区别</strong>：若传入的方法参数的实体类的某个属性含有 null 值，<strong>普通修改会将对应字段赋值为 null</strong>，而<strong>选择性修改只会修改属性不是 null 的对应的字段</strong></p></blockquote><ul><li><p>先将前面自动生成目录等的删除掉，然后在 <strong>generatorConfig.xml 文件</strong>中将执行生成的逆向工程的<strong>版本改成 MyBatis3</strong>，再次找到插件双击即可</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        targetRuntime: 执行生成的逆向工程的版本</span></span><br><span class="line"><span class="comment">            MyBatis3Simple: 生成基本的CRUD（清新简洁版）</span></span><br><span class="line"><span class="comment">            MyBatis3: 生成带条件的CRUD（奢华尊享版）</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context</span> <span class="attr">id</span>=<span class="string">&quot;DB2Tables&quot;</span> <span class="attr">targetRuntime</span>=<span class="string">&quot;MyBatis3&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="/../img/MyBatis%E5%85%A5%E9%97%A8.assets/1672926844177.png" alt="图12.2.1"></p><blockquote><p>效果如下：</p><p>自动生成的Emp类和Dept类是没有 toString 方法和无参有参构造的！建议自己加上去</p></blockquote><p><img src="/../img/MyBatis%E5%85%A5%E9%97%A8.assets/1672926936391.png" alt="图12.2.2"></p></li><li><p><strong>测试</strong></p><blockquote><p>对于单表而言很好用，多表查询还是乖乖的自己写 sql 语句</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testMBG</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> SqlSessionUtil.getSqlSession();</span><br><span class="line">    <span class="type">EmpMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(EmpMapper.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 根据主键 id 查用户信息</span></span><br><span class="line">    <span class="comment">/*Emp emp = mapper.selectByPrimaryKey(1);</span></span><br><span class="line"><span class="comment">        System.out.println(emp);*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 查所有用户信息(放个 null 进去即可)</span></span><br><span class="line">    <span class="comment">/*List&lt;Emp&gt; list = mapper.selectByExample(null);</span></span><br><span class="line"><span class="comment">        list.forEach(System.out::println);*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 根据条件查询数据(Query By Criteria: QBC 查询)</span></span><br><span class="line">    <span class="comment">/*EmpExample example = new EmpExample();</span></span><br><span class="line"><span class="comment">        example.createCriteria().andEmpNameEqualTo(&quot;张三&quot;).andAgeGreaterThanOrEqualTo(20);  // 创建条件对象</span></span><br><span class="line"><span class="comment">        example.or().andGenderEqualTo(&quot;男&quot;); // 上一句会和这一句以 or 连接</span></span><br><span class="line"><span class="comment">        List&lt;Emp&gt; list = mapper.selectByExample(example);</span></span><br><span class="line"><span class="comment">        list.forEach(System.out::println);*/</span></span><br><span class="line"></span><br><span class="line">    <span class="type">Emp</span> <span class="variable">emp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Emp</span>(<span class="number">1</span>, <span class="string">&quot;小黑&quot;</span>, <span class="literal">null</span>, <span class="string">&quot;女&quot;</span>);</span><br><span class="line">    <span class="comment">// 4. 测试普通修改功能(即使给的要修改的属性为 null, 也会把 null 赋值给原来的数据)</span></span><br><span class="line">    <span class="comment">// mapper.updateByPrimaryKey(emp);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 测试选择性修改功能(如果给的要修改的属性为 null, 其不会更改原来的数据)</span></span><br><span class="line">    mapper.updateByPrimaryKeySelective(emp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="13-分页插件"><a href="#13-分页插件" class="headerlink" title="13. 分页插件"></a>13. 分页插件</h3><blockquote><p>sql 语句实现分页查询：<strong>limit index,pageSize</strong></p><p><strong>pageSize</strong>：每页显示的条数(已知)</p><p><strong>pageNum</strong>：当前页的页码(已知)</p><p><strong>index</strong>：当前页的<strong>起始索引</strong></p><p>由公式：<strong>index &#x3D; (pageNum - 1) * pageSize</strong></p><p>eg. 每页 4 条，当前是第 3 页 —&gt; 则 index &#x3D; 4 * (3 - 1) &#x3D; 8  —&gt; 此时的 sql 语句：limit 8,4</p><p><strong>count</strong>：当前的总记录数</p><p><strong>totalPage</strong>：总页数   </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">totalPage = count / pageSize;</span><br><span class="line"><span class="keyword">if</span> (count % pageSize != <span class="number">0</span>) &#123;</span><br><span class="line">    totalPage += <span class="number">1</span>；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h4 id="13-1-分页插件的使用步骤"><a href="#13-1-分页插件的使用步骤" class="headerlink" title="13.1 分页插件的使用步骤"></a>13.1 分页插件的使用步骤</h4><p>（1）<strong>添加依赖</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/com.github.pagehelper/pagehelper --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.pagehelper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pagehelper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>（2）<strong>配置分页插件</strong></p><blockquote><p><strong>在 MyBatis 的核心配置文件</strong>（mybatis-config.xml）中配置插件，注意位置在 typeAliases 和 environments 标签之间</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--配置分页插件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span> <span class="attr">interceptor</span>=<span class="string">&quot;com.github.pagehelper.PageInterceptor&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br></pre></td></tr></table></figure><p>（3）<strong>测试分页功能</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="comment">// 在查询功能里头实现分页</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testPage</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> SqlSessionUtil.getSqlSession();</span><br><span class="line">    <span class="type">EmpMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(EmpMapper.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在查询功能之前开启分页功能(此处表示查询第一页, 每页展示 4 条数据)</span></span><br><span class="line">    PageHelper.startPage(<span class="number">1</span>,<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询所有数据</span></span><br><span class="line">    List&lt;Emp&gt; list = mapper.selectByExample(<span class="literal">null</span>);</span><br><span class="line">    list.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="13-2-分页插件的使用-获取分页相关数据"><a href="#13-2-分页插件的使用-获取分页相关数据" class="headerlink" title="13.2 分页插件的使用(获取分页相关数据)"></a>13.2 分页插件的使用(获取分页相关数据)</h4><p>（1）通过<strong>查询之前 PageHelper.startPage(int pageNum, int pageSize) 获取对应对象并输出</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="comment">// 获取分页相关数据(直接通过 page 对象输出)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testGetPageData</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> SqlSessionUtil.getSqlSession();</span><br><span class="line">    <span class="type">EmpMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(EmpMapper.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在查询功能之前开启分页功能(此处表示查询第一页, 每页展示 4 条数据)</span></span><br><span class="line">    Page&lt;Object&gt; page = PageHelper.startPage(<span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询所有数据</span></span><br><span class="line">    List&lt;Emp&gt; list = mapper.selectByExample(<span class="literal">null</span>);</span><br><span class="line">    list.forEach(System.out::println);</span><br><span class="line">    System.out.println(page);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* page 的输出为:</span></span><br><span class="line"><span class="comment">            Page&#123;count=true, pageNum=1, pageSize=4, startRow=0, endRow=4, </span></span><br><span class="line"><span class="comment">                total=30, pages=8, reasonable=false, pageSizeZero=false&#125;</span></span><br><span class="line"><span class="comment">                [Emp&#123;empId=1, empName=&#x27;aaa&#x27;, age=null, gender=&#x27;null&#x27;, deptId=null&#125;, </span></span><br><span class="line"><span class="comment">                 Emp&#123;empId=2, empName=&#x27;aa&#x27;, age=null, gender=&#x27;null&#x27;, deptId=null&#125;, </span></span><br><span class="line"><span class="comment">                 Emp&#123;empId=3, empName=&#x27;a&#x27;, age=null, gender=&#x27;null&#x27;, deptId=null&#125;, </span></span><br><span class="line"><span class="comment">                 Emp&#123;empId=4, empName=&#x27;a&#x27;, age=null, gender=&#x27;null&#x27;, deptId=null&#125;]</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）<strong>通过获取 PageInfo 对象 获取数据</strong></p><blockquote><p>在<strong>查询获取list集合之后</strong>，使用PageInfo&lt;T&gt; pageInfo &#x3D; new PageInfo&lt;&gt;(List&lt;T&gt; list, intnavigatePages) <strong>获取分页相关所有数据</strong>，PageInfo 比 Page 获取的数据多些</p><ul><li>list：分页之后的数据</li><li>navigatePages：导航分页的页码数</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="comment">// 获取分页相关数据</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testGetPageInfo</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> SqlSessionUtil.getSqlSession();</span><br><span class="line">    <span class="type">EmpMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(EmpMapper.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在查询功能之前开启分页功能(此处表示查询第一页, 每页展示 4 条数据)</span></span><br><span class="line">    Page&lt;Object&gt; page = PageHelper.startPage(<span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询所有数据</span></span><br><span class="line">    List&lt;Emp&gt; list = mapper.selectByExample(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询功能之后可以通过 PageInfo 获取分页相关的所有数据</span></span><br><span class="line">    PageInfo&lt;Emp&gt; pageInfo = <span class="keyword">new</span> <span class="title class_">PageInfo</span>&lt;&gt;(list, <span class="number">5</span>);</span><br><span class="line">    list.forEach(System.out::println);</span><br><span class="line">    System.out.println(pageInfo);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* pageInfo 的输出为: (其中 list 就是上面 page 的内容)</span></span><br><span class="line"><span class="comment">            PageInfo&#123;pageNum=1, pageSize=4, size=4, startRow=1, endRow=4, total=30, pages=8, </span></span><br><span class="line"><span class="comment">                    list=Page&#123;count=true, pageNum=1, pageSize=4, startRow=0, endRow=4, total=30, </span></span><br><span class="line"><span class="comment">                        pages=8, reasonable=false, pageSizeZero=false&#125;</span></span><br><span class="line"><span class="comment">                    [Emp&#123;empId=1, empName=&#x27;aaa&#x27;, age=null, gender=&#x27;null&#x27;, deptId=null&#125;, </span></span><br><span class="line"><span class="comment">                    Emp&#123;empId=2, empName=&#x27;aa&#x27;, age=null, gender=&#x27;null&#x27;, deptId=null&#125;, </span></span><br><span class="line"><span class="comment">                    Emp&#123;empId=3, empName=&#x27;a&#x27;, age=null, gender=&#x27;null&#x27;, deptId=null&#125;, </span></span><br><span class="line"><span class="comment">                    Emp&#123;empId=4, empName=&#x27;a&#x27;, age=null, gender=&#x27;null&#x27;, deptId=null&#125;], </span></span><br><span class="line"><span class="comment">                    prePage=0, nextPage=2, isFirstPage=true, isLastPage=false, hasPreviousPage=false, </span></span><br><span class="line"><span class="comment">                    hasNextPage=true, navigatePages=5, navigateFirstPage=1, navigateLastPage=5, </span></span><br><span class="line"><span class="comment">                    navigatepageNums=[1, 2, 3, 4, 5]&#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>常用数据：</p><p>pageNum：当前页的页码</p><p>pageSize：每页显示的条数</p><p>size：当前页显示的真实条数</p><p>total：总记录数</p><p>pages：总页数</p><p>prePage：上一页的页码</p><p>nextPage：下一页的页码</p><p>isFirstPage&#x2F;isLastPage：是否为第一页&#x2F;最后一页</p><p>hasPreviousPage&#x2F;hasNextPage：是否存在上一页&#x2F;下一页</p><p>navigatePages：导航分页的页码数</p><p>navigatepageNums：导航分页的页码，[1,2,3,4,5]</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> SSM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring</title>
      <link href="/2022/12/01/Spring/"/>
      <url>/2022/12/01/Spring/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring5-框架"><a href="#Spring5-框架" class="headerlink" title="Spring5 框架"></a>Spring5 框架</h1><h2 id="1-Spring-概念"><a href="#1-Spring-概念" class="headerlink" title="1. Spring 概念"></a>1. Spring 概念</h2><h3 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h3><p>（1）概念</p><ul><li>Spring 是 <strong>轻量级</strong> 的 <strong>开源</strong> 的 JavaEE <strong>框架</strong></li><li>Spring 可以解决企业应用开发的复杂性</li><li>Spring 有两个核心部分：<strong>IOC</strong> 和 <strong>AOP</strong><ul><li><strong>IOC：控制反转</strong>，把创建对象的过程交给 Spring 进行管理</li><li><strong>AOP：面向切面</strong>，不修改源代码的情况下，进行功能增强</li></ul></li><li>Spring 的特点：<ul><li>方便解耦，简化开发</li><li>Aop 编程支持</li><li>方便程序测试</li><li>方便和其他框架进行整合</li><li>方便进行事务操作</li><li>降低 API 开发难度</li></ul></li></ul><h3 id="1-2-入门案例"><a href="#1-2-入门案例" class="headerlink" title="1.2 入门案例"></a>1.2 入门案例</h3><p>（1）案例：</p><ul><li><p>**下载 Spring5 **</p><ul><li><p>官网地址：<a href="https://spring.io/">https://spring.io/</a></p><p><img src="/../img/Spring%E6%A1%86%E6%9E%B6.assets/1667555997432.png" alt="图1.2.1"></p><p><img src="/../img/Spring%E6%A1%86%E6%9E%B6.assets/1667556139806.png" alt="图1.2.2"></p></li><li><p>点击 github 图标进入(貌似进不去…)</p><p><img src="/../img/Spring%E6%A1%86%E6%9E%B6.assets/1667556230644.png" alt="图1.2.3"></p><p><img src="/../img/Spring%E6%A1%86%E6%9E%B6.assets/1667556272335.png" alt="图1.2.4"></p></li><li><p>下载地址：<a href="https://repo.spring.io/artifactory/release/org/springframework/spring">https://repo.spring.io/artifactory/release/org/springframework/spring</a></p><p><img src="/../img/Spring%E6%A1%86%E6%9E%B6.assets/1667556587439.png" alt="图1.2.5"></p><p><img src="/../img/Spring%E6%A1%86%E6%9E%B6.assets/1667566097517.png" alt="图1.2.6"></p><p><img src="/../img/Spring%E6%A1%86%E6%9E%B6.assets/1667608531644.png" alt="图1.2.7"></p></li></ul></li><li><p><strong>打开 idea 工具，创建普通 Java 工具</strong></p><p><img src="/../img/Spring%E6%A1%86%E6%9E%B6.assets/1667608708537.png" alt="图1.2.8"></p></li><li><p><strong>导入 spring5 相关 jar 包</strong></p><p><img src="/../img/Spring%E6%A1%86%E6%9E%B6.assets/1667608854114.png" alt="图1.2.9"></p><p><img src="/../img/Spring%E6%A1%86%E6%9E%B6.assets/1667609263743.png" alt="图1.2.10"></p><p><img src="/../img/Spring%E6%A1%86%E6%9E%B6.assets/1667609326385.png" alt="图1.2.11"></p><p><img src="/../img/Spring%E6%A1%86%E6%9E%B6.assets/1667609442985.png" alt="图1.2.12"></p></li><li><p><strong>用 spring 的方式创建对象</strong></p><ul><li><p>创建普通类，在这个类创建普通方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;add...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建 spring 的配置文件，在配置文件配置创建的对象</p><blockquote><p>Spring 配置文件使用 xml 格式</p></blockquote><p><img src="/../img/Spring%E6%A1%86%E6%9E%B6.assets/1667609779634.png" alt="图1.2.13"></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.thr.spring5.User&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="/../img/Spring%E6%A1%86%E6%9E%B6.assets/1667609896789.png" alt="图1.2.14"></p></li><li><p>进行测试代码编写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestSpring5</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testAdd</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 加载 spring 的配置文件</span></span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;bean1.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 获取配置创建的对象</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> context.getBean(<span class="string">&quot;user&quot;</span>, User.class);</span><br><span class="line"></span><br><span class="line">        System.out.println(user);</span><br><span class="line">        user.add();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="1-3-Spring-家族"><a href="#1-3-Spring-家族" class="headerlink" title="1.3 Spring 家族"></a>1.3 Spring 家族</h3><p>（1）项目列表：<a href="https://spring.io/projects">https://spring.io/projects</a>  </p><p>（2）<strong>Spring Framework</strong></p><ul><li><p>Spring 基础框架，可以视为 Spring 基础设施，基本上任何其他 Spring 项目都是以 Spring Framework为基础的</p></li><li><p><strong>Spring Framework</strong> 特性</p><blockquote><p><strong>非侵入式</strong>：使用 Spring Framework 开发应用程序时，Spring 对应用程序本身的结构影响非常小。对领域模型可以做到零污染；对功能性组件也只需要使用几个简单的注解进行标记，完全不会破坏原有结构，反而能将组件结构进一步简化。这就使得基于 Spring Framework 开发应用程序时结构清晰、简洁优雅。</p><p><strong>控制反转</strong>：IOC——Inversion of Control，<strong>翻转资源获取方向</strong>。把自己创建资源、向环境索取资源变成环境将资源准备好，我们享受资源注入。（<strong>重点</strong>）</p><p><strong>面向切面编程</strong>：AOP——Aspect Oriented Programming，<strong>在不修改源代码的基础上增强代码功能</strong>。<strong>（重点）</strong></p><p><strong>容器</strong>：Spring IOC 是一个容器，因为它包含并且管理组件对象的生命周期。组件享受到了容器化的管理，替程序员屏蔽了组件创建过程中的大量细节，极大的降低了使用门槛，大幅度提高了开发效率。（理解）</p><p><strong>组件化</strong>：Spring 实现了使用简单的组件配置组合成一个复杂的应用。在 Spring 中可以使用 XML和 Java <strong>注解组合这些对象</strong>。这使得我们可以基于一个个功能明确、边界清晰的组件有条不紊的搭建超大型复杂应用系统。</p><p><strong>声明式</strong>：很多以前需要编写代码才能实现的功能，现在<strong>只需要声明需求即可由框架代为实现</strong>。</p><p><strong>一站式</strong>：在 IOC 和 AOP 的基础上可以<strong>整合各种企业应用的开源框架和优秀的第三方类库</strong>。而且 Spring 旗下的项目已经覆盖了广泛领域，很多方面的功能性需求可以在 Spring Framework 的基础上全部使用 Spring 来实现。</p></blockquote></li><li><p><strong>Spring Framework</strong> 五大功能模块</p><table><thead><tr><th align="center"><strong>功能模块</strong></th><th align="center"><strong>功能介绍</strong></th></tr></thead><tbody><tr><td align="center">Core Container</td><td align="center">核心容器，在 Spring 环境下使用任何功能都必须基于 IOC 容器</td></tr><tr><td align="center">AOP&amp;Aspects</td><td align="center">面向切面编程</td></tr><tr><td align="center">Testing</td><td align="center">提供了对 junit 或 TestNG 测试框架的整合</td></tr><tr><td align="center">Data Access&#x2F;Integration</td><td align="center">提供了对数据访问 &#x2F; 集成的功能</td></tr><tr><td align="center">Spring MVC</td><td align="center">提供了面向 Web 应用程序的集成功能</td></tr></tbody></table></li></ul><h2 id="2-IOC-容器"><a href="#2-IOC-容器" class="headerlink" title="2. IOC 容器"></a>2. IOC 容器</h2><h3 id="2-1-IOC-底层原理"><a href="#2-1-IOC-底层原理" class="headerlink" title="2.1 IOC 底层原理"></a>2.1 IOC 底层原理</h3><p>（1）什么是 IOC？</p><blockquote><p>a&gt; <strong>获取资源的传统方式</strong>：</p><p>自己做饭：买菜、洗菜、择菜、改刀、炒菜，全过程参与，费时费力，<strong>必须清楚了解资源创建整个过程中的全部细节且熟练掌握</strong>，在应用程序中的组件需要获取资源时，传统的方式是<strong>组件 主动 的从容器中获取所需要的资源</strong>，在这样的模式下开发人员往往需要知道在具体容器中特定资源的获取方式，增加了学习成本，同时降低了开发效率</p><p>b&gt; <strong>反转控制方式获取资源</strong>：</p><p>点外卖：下单、等、吃，省时省力，<strong>不必关心资源创建过程的所有细节</strong>，反转控制的思想完全颠覆了应用程序组件获取资源的传统方式：<strong>反转了资源的获取方向 —— 改由容器主动的将资源推送给需要的组件</strong>，开发人员不需要知道容器是如何创建资源对象的，只需要提供接收资源的方式即可，极大的降低了学习成本，提高了开发的效率。这种行为也称为查找的被动形式</p><p>c&gt; <strong>DI</strong>：Dependency Injection ，翻译过来是 <strong>依赖注入(对当前 spring 所管理的对象中的属性进行赋值)</strong> ，<strong>DI 是 IOC 的另一种表述方式</strong>：即<strong>组件以一些预先定义好的方式</strong>（例如： setter 方法）<strong>接受来自于容器 的资源注入</strong>。相对于IOC 而言，这种表述更直接。</p><p>所以结论是： <strong>IOC 就是一种反转控制的思想，而 DI 是对 IOC 的一种具体实现。</strong></p></blockquote><ul><li><strong>Inversion of Control(IOC) 控制反转</strong>，是面向对象编程中的一种设计原则，用来<strong>减低</strong>代码间的<strong>耦合度</strong></li><li>控制反转，<strong>把对象创建和对象之间的调用过程，交给 Spring 进行管理</strong></li><li>前头做的入门案例就是 IOC 实现</li></ul><p>（2）IOC 底层原理</p><ul><li><p>主要用到 <strong>xml 解析、工厂模式、反射</strong></p></li><li><p>画图讲解：</p><ul><li>原始方式</li></ul><p><img src="/../img/Spring%E6%A1%86%E6%9E%B6.assets/1667611028401.png" alt="图2.1.1"></p><ul><li>工厂模式(感觉只是耦合度转移了…)</li></ul><p><img src="/../img/Spring%E6%A1%86%E6%9E%B6.assets/1667611250471.png" alt="图2.1.2"></p><ul><li><p>IOC 过程(这样改的话只要改 xml 即可…)</p><p><img src="/../img/Spring%E6%A1%86%E6%9E%B6.assets/1667611781019.png" alt="图2.1.3"></p></li></ul></li></ul><h3 id="2-2-IOC-接口"><a href="#2-2-IOC-接口" class="headerlink" title="2.2 IOC 接口"></a>2.2 IOC 接口</h3><blockquote><p>Spring 的 IOC 容器就是 IOC 思想的一个落地的产品实现。 <strong>IOC 容器中管理的组件也叫做 bean</strong> 。在创建bean 之前，首先需要创建 IOC 容器。 Spring 提供了 IOC 容器的两种实现方式：</p><p>a&gt; <strong>BeanFactory</strong>：</p><p>这是 IOC 容器的基本实现，是 Spring 内部使用的接口。面向 Spring 本身，不提供给开发人员使用。</p><p>b&gt; <strong>ApplicationContext</strong>：</p><p><strong>BeanFactory 的子接口</strong>，提供了更多高级特性。<strong>面向 Spring 的使用者</strong>，几乎所有场合都使用<br>ApplicationContext 而不是底层的 BeanFactory</p></blockquote><p>（1）IOC 思想基于 IOC 容器完成，<strong>IOC 容器底层就是对象工厂</strong></p><p>（2）Spring 提供 IOC 容器实现的两种方式：(两个接口)</p><ul><li><strong>BeanFactory</strong>：IOC 容器基本实现，是 Spring 内部的使用接口，不提供开发人员进行使用<ul><li>加载配置文件时不会创建对象，在<strong>获取(使用)对象的时候才去创建</strong></li></ul></li><li><strong>ApplicationContext</strong>：BeanFactory 接口的子接口，提供了更多更强大的功能，一般由开发人员进行使用<ul><li><strong>加载配置文件</strong>的时候，就会把在配置文件对象进行<strong>创建</strong></li></ul></li></ul><blockquote><p>后者慢启动但是快响应，后者较前者稍好些?</p></blockquote><p>（3）<strong>ApplicationContext</strong> 接口的实现类：</p><ul><li><p><strong>ctrl + H</strong> 打开类的结构</p><p><img src="/../img/Spring%E6%A1%86%E6%9E%B6.assets/1667612878379.png" alt="图2.2.1"></p></li><li><p>表格：</p></li></ul><table><thead><tr><th align="center"><strong>类型名</strong></th><th align="center"><strong>简介</strong></th></tr></thead><tbody><tr><td align="center">ClassPathXmlApplicationContext</td><td align="center">通过读取类路径下的 XML 格式的配置文件创建 IOC 容器对象</td></tr><tr><td align="center">FileSystemXmlApplicationContext</td><td align="center">通过文件系统路径读取 XML 格式的配置文件创建 IOC 容器对象</td></tr><tr><td align="center">ConfigurableApplicationContext</td><td align="center">ApplicationContext 的子接口，包含一些扩展方法  refresh() 和 close() ， 让 ApplicationContext 具有启动、关闭和刷新上下文的能力</td></tr><tr><td align="center">WebApplicationContext</td><td align="center">专门为 Web 应用准备，基于 Web 环境创建 IOC 容器对象， 并将对象引入存入 ServletContext 域中</td></tr></tbody></table><h3 id="2-3-IOC-操作-Bean-管理"><a href="#2-3-IOC-操作-Bean-管理" class="headerlink" title="2.3 IOC 操作 Bean 管理"></a>2.3 IOC 操作 Bean 管理</h3><p>（1）什么是 Bean 管理</p><ul><li>Bean 管理指的是两个操作<ul><li><strong>Spring 创建对象</strong></li><li><strong>Spring 注入属性</strong></li></ul></li></ul><p>（2）Bean 管理操作的两种方式</p><ul><li>基于 <strong>xml 配置文件</strong>方式</li><li>基于<strong>注解方式</strong>实现</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取 bean 的三种方式:</span></span><br><span class="line"><span class="comment"> * 1. 根据 bean 的 id 获取</span></span><br><span class="line"><span class="comment"> * 2. 根据 bean 的类型获取(常用)</span></span><br><span class="line"><span class="comment"> *    注意: 根据类型获取 bean 时, 要求 IOC 容器中有且只有一类型匹配的 bean</span></span><br><span class="line"><span class="comment"> *          若没有任何一个类型匹配的 bean, 此时抛出异常: NoSuchBeanDefinitionException</span></span><br><span class="line"><span class="comment"> *          若有多个类型匹配的 bean, 此时抛出异常: NoUniqueBeanDefinitionException</span></span><br><span class="line"><span class="comment"> * 3. 根据 bean 的 类型 和 id 获取</span></span><br><span class="line"><span class="comment"> * 4. 用 Student 所实现的接口(或者所继承的父类) Person 来获取</span></span><br><span class="line"><span class="comment"> *  前提是 bean 的类型唯一, 因为如果一个接口有多个实现类, 那么就不可以根据接口类型获取 bean</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  结论: 根据类型来获取 bean 时，在满足 bean 唯一性的前提下,其实只是看：</span></span><br><span class="line"><span class="comment"> * 『对象 instanceof 指定的类型』的返回结果, 只要返回的是 true 就可以认定为和类型匹配, 能够获取到</span></span><br><span class="line"><span class="comment"> *  即通过 bean 的类型, bean 所继承的类的类型, bean 所实现的接口类型都可以获取 bean</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h3 id="2-4-IOC-基于-xml-操作-Bean-管理"><a href="#2-4-IOC-基于-xml-操作-Bean-管理" class="headerlink" title="2.4  IOC 基于 xml 操作 Bean 管理"></a>2.4  IOC 基于 xml 操作 Bean 管理</h3><h4 id="2-4-1-基于-xml-方式创建对象"><a href="#2-4-1-基于-xml-方式创建对象" class="headerlink" title="2.4.1 基于 xml 方式创建对象"></a>2.4.1 <strong>基于 xml 方式创建对象</strong></h4><p>（1）在 spring 配置文件中使用 bean 标签，在标签里添加对应属性，就可以实现对象创建</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置 User类对象创建 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.thr.spring5.User&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>（2）在 bean 标签里的常用属性</p><ul><li><strong>id</strong> 属性：唯一标识(给对象取一个别名)</li><li><strong>class</strong> 属性：类全路径(包类路径)</li><li><strong>name</strong> 属性：类似与 id，区别是可以加特殊符号，现在用的少</li></ul><p>（3）创建对象时，<strong>默认也是执行的无参数的构造方法完成对象的创建</strong>(如果写了有参则把无参覆盖掉，会报错)</p><h4 id="2-4-2-基于-xml-方式注入属性"><a href="#2-4-2-基于-xml-方式注入属性" class="headerlink" title="2.4.2 基于 xml 方式注入属性"></a>2.4.2 <strong>基于 xml 方式注入属性</strong></h4><p>（1）<strong>DI</strong>：依赖注入，**就是注入属性(为当前类中的属性进行赋值)**，需在创建对象的基础上完成(<strong>是 IOC 的一种具体实现</strong>)</p><p>（2）第一种注入方式：<strong>使用 set 方法进行注入</strong></p><ul><li><p>创建类，定义属性和对应的 set 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Book</span> &#123;</span><br><span class="line">    <span class="comment">// 创建属性</span></span><br><span class="line">    <span class="keyword">private</span> String bookName;</span><br><span class="line">    <span class="keyword">private</span> String bookAuthor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建属性对应的 set 方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBookName</span><span class="params">(String bookName)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bookName = bookName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBookAuthor</span><span class="params">(String bookAuthor)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bookAuthor = bookAuthor;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDemo</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(bookName + <span class="string">&quot;:&quot;</span> + bookAuthor + <span class="string">&quot;:&quot;</span> + address);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在 spring 配置文件中配置对象创建，配置属性注入</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- set 方法注入属性 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 1. 创建对象 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;book&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.thr.spring5.Book&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 2. 在 bean 标签里使用 properties 标签完成属性注入</span></span><br><span class="line"><span class="comment">            name: 类里面属性名称</span></span><br><span class="line"><span class="comment">            value: 向属性注入的值</span></span><br><span class="line"><span class="comment">     --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;bookName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;易筋经&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;bookAuthor&quot;</span> <span class="attr">value</span>=<span class="string">&quot;达摩&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testBook</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 加载 spring 的配置文件</span></span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;bean1.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 获取配置创建的对象</span></span><br><span class="line">    <span class="type">Book</span> <span class="variable">book</span> <span class="operator">=</span> context.getBean(<span class="string">&quot;book&quot;</span>, Book.class);</span><br><span class="line"></span><br><span class="line">    System.out.println(book);  <span class="comment">// com.thr.spring5.Book@1b26f7b2</span></span><br><span class="line">    book.testDemo();  <span class="comment">// 易筋经:达摩</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>（2）第二种注入方式：<strong>使用有参构造进行注入</strong></p><ul><li><p>创建类：定义属性，创建属性对应的有参构造</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Orders</span> &#123;</span><br><span class="line">    <span class="comment">// 属性</span></span><br><span class="line">    <span class="keyword">private</span> String orderName;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有参构造</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Orders</span><span class="params">(String orderName, String address)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.orderName = orderName;</span><br><span class="line">        <span class="built_in">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDemo</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(orderName + <span class="string">&quot;:&quot;</span> + address);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在 spring 的配置文件中进行配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 3. 有参构造方法注入属性 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 3.1 创建对象 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;orders&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.thr.spring5.Orders&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 3.2 在 bean 标签里使用 constructor-arg 标签完成属性注入</span></span><br><span class="line"><span class="comment">            name: 类里面属性名称</span></span><br><span class="line"><span class="comment">            value: 向属性注入的值</span></span><br><span class="line"><span class="comment">            也可以用索引值</span></span><br><span class="line"><span class="comment">            index: 0 表示有参构造的第一个参数, 以此类推</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;orderName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;电脑&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;address&quot;</span> <span class="attr">value</span>=<span class="string">&quot;china&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &lt;constructor-arg index=&quot;0&quot; value=&quot;手机&quot;&gt;&lt;/constructor-arg&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testOrders</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 加载 spring 的配置文件</span></span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;bean1.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 获取配置创建的对象</span></span><br><span class="line">        <span class="type">Orders</span> <span class="variable">orders</span> <span class="operator">=</span> context.getBean(<span class="string">&quot;orders&quot;</span>, Orders.class);</span><br><span class="line"></span><br><span class="line">        System.out.println(orders);  <span class="comment">// com.thr.spring5.Orders@78186a70</span></span><br><span class="line">        orders.testDemo();  <span class="comment">// 电脑:china</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>（3）简化方式：<strong>p 名称空间注入</strong>，使用 p 名称空间注入，可以简化 xml 配置方式(底层其实还是 set 方法注入，只是写法上做了简化)</p><ul><li><p>添加 p 名称空间在配置文件中</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns:p</span>=<span class="string">&quot;http://www.springframework.org/schema/p&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>进行属性注入，在 bean 标签里面进行操作</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 4. p 名称空间注入(需要有 set 方法) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;book&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.thr.spring5.Book&quot;</span> <span class="attr">p:bookName</span>=<span class="string">&quot;九阳神功&quot;</span> <span class="attr">p:bookAuthor</span>=<span class="string">&quot;无名氏&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="2-4-3-基于-xml-方式注入空值和特殊符号"><a href="#2-4-3-基于-xml-方式注入空值和特殊符号" class="headerlink" title="2.4.3 基于 xml 方式注入空值和特殊符号"></a>2.4.3 <strong>基于 xml 方式注入空值和特殊符号</strong></h4><p>（1）空值</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 设置 null 值 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;address&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">null</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><p>（2）特殊符号</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 属性值中包含特殊符号, 两种方式</span></span><br><span class="line"><span class="comment">     1. 把 &lt;&gt; 进行转义(可以用转义&amp;lt;和&amp;gt;)</span></span><br><span class="line"><span class="comment">     2. 把特殊符号内容写到 CDATA 结构中</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;address&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>&lt;![CDATA[&lt;&lt;南京&gt;&gt;]]&gt;<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-4-4-注入属性-外部-bean"><a href="#2-4-4-注入属性-外部-bean" class="headerlink" title="2.4.4 注入属性-外部 bean"></a>2.4.4 <strong>注入属性-外部 bean</strong></h4><p>（1）创建两个类 service 类和 dao 类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;service add....&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 原始方式: 创建 UserDao 对象（多态）</span></span><br><span class="line">        <span class="comment">// UserDao userDao = new UserDaoImpl();</span></span><br><span class="line">        <span class="comment">// userDao.update();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;dao update...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）在 service 调用 dao 里面的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建 UserDao 类型属性, 生成 set 方法</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserDao</span><span class="params">(UserDao userDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;service add....&quot;</span>);</span><br><span class="line">        userDao.update();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）在 spring 配置文件中进行配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 1. service 和 dao 对象创建 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.thr.spring5.service.UserService&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 注入 userDao 对象</span></span><br><span class="line"><span class="comment">             name 属性: 类里面属性名称</span></span><br><span class="line"><span class="comment">             ref 属性: 创建的 userDao 对象 bean 标签 id 值</span></span><br><span class="line"><span class="comment">     --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDaoImpl&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDaoImpl&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.thr.spring5.dao.UserDaoImpl&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>（4）测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestBean</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testAdd</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 加载 spring 配置文件</span></span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;bean2.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 获取配置创建的对象</span></span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> context.getBean(<span class="string">&quot;userService&quot;</span>, UserService.class);</span><br><span class="line"></span><br><span class="line">        userService.add();  <span class="comment">// service add.... dao update...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-4-5-注入属性-内部-bean"><a href="#2-4-5-注入属性-内部-bean" class="headerlink" title="2.4.5 注入属性-内部 bean"></a>2.4.5 <strong>注入属性-内部 bean</strong></h4><p>（1）一对多关系：eg.部门(1)和员工(多)</p><p>（2）在实体类中表示一对多关系，员工表示所属部门 –&gt; 使用对象类型属性进行表示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 部门类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dept</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String dname;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDname</span><span class="params">(String dname)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.dname = dname;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 员工类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Emp</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String ename;</span><br><span class="line">    <span class="keyword">private</span> String gender;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 员工属于某一个部门, 使用对象形式表示</span></span><br><span class="line">    <span class="keyword">private</span> Dept dept;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDept</span><span class="params">(Dept dept)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.dept = dept;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setEname</span><span class="params">(String ename)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.ename = ename;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setGender</span><span class="params">(String gender)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.gender = gender;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）在 spring 配置文件中进行配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 内部 bean --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;emp&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.thr.spring5.bean.Emp&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 先设置两个普通属性 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;ename&quot;</span> <span class="attr">value</span>=<span class="string">&quot;lucy&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">value</span>=<span class="string">&quot;girl&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 设置对象类型属性 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dept&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dept&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.thr.spring5.bean.Dept&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dname&quot;</span> <span class="attr">value</span>=<span class="string">&quot;安保部&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>（4）测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testBean2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 加载 spring 配置文件</span></span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;bean3.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 获取配置创建的对象</span></span><br><span class="line">    <span class="type">Emp</span> <span class="variable">emp</span> <span class="operator">=</span> context.getBean(<span class="string">&quot;emp&quot;</span>, Emp.class);</span><br><span class="line"></span><br><span class="line">    emp.add();  <span class="comment">// lucy:girl:Dept&#123;dname=&#x27;安保部&#x27;&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-4-6-注入属性-级联赋值"><a href="#2-4-6-注入属性-级联赋值" class="headerlink" title="2.4.6 注入属性-级联赋值"></a>2.4.6 <strong>注入属性-级联赋值</strong></h4><p>（1）在内部 bean 的基础上重新写一个 bean 文件</p><ul><li><p>第一种写法</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 级联赋值 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;emp&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.thr.spring5.bean.Emp&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 设置两个普通属性 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;ename&quot;</span> <span class="attr">value</span>=<span class="string">&quot;lucy&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">value</span>=<span class="string">&quot;girl&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 设置对象类型属性(用级联赋值) --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dept&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dept&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dept&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.thr.spring5.bean.Dept&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dname&quot;</span> <span class="attr">value</span>=<span class="string">&quot;财务部&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>第二种写法</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 级联赋值 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;emp&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.thr.spring5.bean.Emp&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 设置两个普通属性 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;ename&quot;</span> <span class="attr">value</span>=<span class="string">&quot;lucy&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">value</span>=<span class="string">&quot;girl&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 设置对象类型属性(用级联赋值) --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dept&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dept&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 第二种方法, 但要注意生成 get 方法 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dept.dname&quot;</span> <span class="attr">value</span>=<span class="string">&quot;技术部&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dept&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.thr.spring5.bean.Dept&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dname&quot;</span> <span class="attr">value</span>=<span class="string">&quot;财务部&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testBean3</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 加载 spring 配置文件</span></span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;bean4.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 获取配置创建的对象</span></span><br><span class="line">    <span class="type">Emp</span> <span class="variable">emp</span> <span class="operator">=</span> context.getBean(<span class="string">&quot;emp&quot;</span>, Emp.class);</span><br><span class="line"></span><br><span class="line">    emp.add();  <span class="comment">// lucy:girl:Dept&#123;dname=&#x27;财务部&#x27;&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="2-4-7-xml-注入集合属性"><a href="#2-4-7-xml-注入集合属性" class="headerlink" title="2.4.7 xml 注入集合属性"></a>2.4.7 <strong>xml 注入集合属性</strong></h4><p>（1）分类：</p><ul><li>注入数组类型属性</li><li>注入 List 集合类型属性</li><li>注入 Map 集合类型属性</li></ul><p>（2）具体步骤</p><ul><li><p>创建类，定义数组，list，set，生成对应的 set 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Stu</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 数组类型的属性</span></span><br><span class="line">    <span class="keyword">private</span> String[] courses;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. list 集合类型属性</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; list;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. map 集合类型属性</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,String&gt; maps;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. set 集合类型属性</span></span><br><span class="line">    <span class="keyword">private</span> Set&lt;String&gt; sets;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCourses</span><span class="params">(String[] courses)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.courses = courses;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setList</span><span class="params">(List&lt;String&gt; list)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.list = list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMaps</span><span class="params">(Map&lt;String, String&gt; maps)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.maps = maps;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSets</span><span class="params">(Set&lt;String&gt; sets)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.sets = sets;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(Arrays.toString(courses));</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        System.out.println(maps);</span><br><span class="line">        System.out.println(sets);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在 spring 配置文件进行配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 1. 集合类型属性注入 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;stu&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.thr.spring5.collectiontype.Stu&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 1.1 数组类型属性注入 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;courses&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>java课程<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>数据库课程<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 1.2 list 类型属性注入 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;list&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>张三<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>李四<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 1.3 map 类型属性注入 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maps&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;JAVA&quot;</span> <span class="attr">value</span>=<span class="string">&quot;java&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;PHP&quot;</span> <span class="attr">value</span>=<span class="string">&quot;php&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 1.4 set 类型属性注入 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sets&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>MySQL<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>Redis<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testCollection</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;bean1.xml&quot;</span>);</span><br><span class="line">        <span class="type">Stu</span> <span class="variable">stu</span> <span class="operator">=</span> context.getBean(<span class="string">&quot;stu&quot;</span>, Stu.class);</span><br><span class="line">        stu.test();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// [java课程, 数据库课程]</span></span><br><span class="line"><span class="comment">// [张三, 李四]</span></span><br><span class="line"><span class="comment">// &#123;JAVA=java, PHP=php&#125;</span></span><br><span class="line"><span class="comment">// [MySQL, Redis]</span></span><br></pre></td></tr></table></figure></li></ul><p>（3）在集合里设置对象的值</p><ul><li><p>建一个 course 类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 课程类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Course</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String cname;  <span class="comment">// 课程名称</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCname</span><span class="params">(String cname)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.cname = cname;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在 Stu 类中增加属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 5. 学生所学多门课程</span></span><br><span class="line"><span class="keyword">private</span> List&lt;Course&gt; courseList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCourseList</span><span class="params">(List&lt;Course&gt; courseList)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.courseList = courseList;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCourses</span><span class="params">(String[] courses)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.courses = courses;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>xml 中配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 2.1 注入 list 集合类型, 值是对象(用 ref 标签中的 bean 属性) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;stu&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.thr.spring5.collectiontype.Stu&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;courseList&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;course1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">ref</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;course2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">ref</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 创建多个 course 对象 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;course1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.thr.spring5.collectiontype.Course&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;cname&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Spring5框架课程&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;course2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.thr.spring5.collectiontype.Course&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;cname&quot;</span> <span class="attr">value</span>=<span class="string">&quot;MyBatis框架课程&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><p>（4）把集合注入部分提取出来</p><ul><li><p>在 spring 配置文件中引入名称空间 util</p><p><img src="/../img/Spring%E6%A1%86%E6%9E%B6.assets/1668654440695.png" alt="2.4.7"></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:p</span>=<span class="string">&quot;http://www.springframework.org/schema/p&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:util</span>=<span class="string">&quot;http://www.springframework.org/schema/util&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">                           http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>使用 util 标签完成 list 集合注入提取</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 1. 提取 list 集合类型属性注入 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">util:list</span> <span class="attr">id</span>=<span class="string">&quot;bookList&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>易筋经<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>九阴真经<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>九阳神功<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">util:list</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 2. 提取 list 集合类型属性注入使用 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;book&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.thr.spring5.collectiontype.Book&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;list&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;bookList&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testCollection2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;bean2.xml&quot;</span>);</span><br><span class="line">    <span class="type">Book</span> <span class="variable">book</span> <span class="operator">=</span> context.getBean(<span class="string">&quot;book&quot;</span>, Book.class);</span><br><span class="line">    book.test();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-5-工厂-bean"><a href="#2-5-工厂-bean" class="headerlink" title="2.5 工厂 bean"></a>2.5 工厂 bean</h3><p>（1）Spring 有两种类型的 bean ，一种普通 bean，另外一种工厂bean(FactoryBean 是 Spring 里头内置的一种 bean)</p><ul><li>普通 bean：在配置文件中定义 bean 类型就是返回类型</li><li>工厂 bean：在配置文件中定义 bean 类型可以和返回类型不一样</li></ul><p>（2）怎么做？</p><ul><li><p>创建类，让这个类作为工厂 bean，实现接口 FactoryBean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBean</span> <span class="keyword">implements</span> <span class="title class_">FactoryBean</span>&lt;Course&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义返回 bean</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Course <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Course</span> <span class="variable">course</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Course</span>();</span><br><span class="line">        course.setCname(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> course;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSingleton</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>实现接口里面的方法，在实现的方法中定义返回的 bean 类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;bean3.xml&quot;</span>);</span><br><span class="line">    <span class="type">Course</span> <span class="variable">course</span> <span class="operator">=</span> context.getBean(<span class="string">&quot;myBean&quot;</span>, Course.class);</span><br><span class="line">    System.out.println(course);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.thr.spring5.factorybean.MyBean&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="2-6-Bean-的作用域和生命周期"><a href="#2-6-Bean-的作用域和生命周期" class="headerlink" title="2.6 Bean 的作用域和生命周期"></a>2.6 Bean 的作用域和生命周期</h3><p>（1）<strong>bean 的作用域</strong></p><ul><li><p>在 Spring 里面，默认情况下，bean 是单实例对象</p><p><img src="/../img/Spring%E6%A1%86%E6%9E%B6.assets/1668921775798.png" alt="图2.6.1"></p></li><li><p>在 Spring 里面，如何设置创建 bean 实例是单实例还是多实例</p><ul><li><p>在 spring 配置文件 bean 标签里有属性(<strong>scope</strong>)用于设置单实例还是多实例</p></li><li><p>scope 常用的两个属性值(还有比如 request，session 等)：</p><p>第一个值：默认值，<strong>singleton</strong>，表示单实例对象</p><p>第二个值：<strong>prototype</strong>，表示是多实例对象</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;book&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.thr.spring5.collectiontype.Book&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;prototype&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;list&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;bookList&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testCollection2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;bean2.xml&quot;</span>);</span><br><span class="line">    <span class="type">Book</span> <span class="variable">book1</span> <span class="operator">=</span> context.getBean(<span class="string">&quot;book&quot;</span>, Book.class);</span><br><span class="line">    <span class="type">Book</span> <span class="variable">book2</span> <span class="operator">=</span> context.getBean(<span class="string">&quot;book&quot;</span>, Book.class);</span><br><span class="line">    <span class="comment">// book.test();</span></span><br><span class="line">    <span class="comment">// 地址不同 --&gt; 多实例对象</span></span><br><span class="line">    System.out.println(book1);  <span class="comment">// com.thr.spring5.collectiontype.Book@2641e737</span></span><br><span class="line">    System.out.println(book2);  <span class="comment">// com.thr.spring5.collectiontype.Book@727803de</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>singleton 和 prototype 区别</p><ul><li>singleton 单实例，prototype 多实例</li><li>设置 scope 值是 singleton 的时候，<strong>加载 spring 配置文件时候就会创建单实例对象</strong></li><li>设置 scope 值是 prototype 的时候，不是在加载 spring 配置文件时候创建单实例对象，而是在<strong>调用 getBean 方法的时候创建多实例对象</strong></li></ul></li></ul><p>（2）<strong>bean 的生命周期</strong></p><ul><li><p>生命周期</p><ul><li>从对象创建到对象销毁的过程</li></ul></li><li><p>bean 的生命周期步骤</p><ul><li><strong>通过构造器创建 bean 实例(无参构造)</strong></li><li><strong>为 bean 的属性设置值和对其它 bean 的引用(调用 set 方法)</strong></li><li><strong>调用 bean 的初始化的方法(需要进行配置初始化的方法)</strong></li><li><strong>bean 可以使用了(对象获取到了)</strong></li><li><strong>当容器关闭的时候，调用 bean 的销毁的方法(需要进行配置销毁的方法)</strong></li></ul></li><li><p>代码演示</p><ul><li><p>编写类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Orders</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String oname;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 无参构造</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Orders</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;第一步: 执行无参构造创建 bean 实例&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setOname</span><span class="params">(String oname)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.oname = oname;</span><br><span class="line">        System.out.println(<span class="string">&quot;第二步: 调用 set 方法设置属性值&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建执行的初始化方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;第三步: 执行初始化的方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建执行的销毁方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroyMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;第五步: 执行销毁的方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>配置 xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 演示 bean 的生命周期 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;orders&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.thr.spring5.bean.Orders&quot;</span> <span class="attr">init-method</span>=<span class="string">&quot;initMethod&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;destroyMethod&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;oname&quot;</span> <span class="attr">value</span>=<span class="string">&quot;手机&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testBean3</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// ApplicationContext context =</span></span><br><span class="line">    <span class="comment">// new ClassPathXmlApplicationContext(&quot;bean4.xml&quot;);</span></span><br><span class="line">    <span class="type">ClassPathXmlApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;bean4.xml&quot;</span>);</span><br><span class="line">    <span class="type">Orders</span> <span class="variable">orders</span> <span class="operator">=</span> context.getBean(<span class="string">&quot;orders&quot;</span>, Orders.class);</span><br><span class="line">    System.out.println(<span class="string">&quot;第四步: 获取创建的 bean 实例对象&quot;</span>);</span><br><span class="line">    System.out.println(orders);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 手动让 bean 实例销毁</span></span><br><span class="line">    <span class="comment">// ((ClassPathXmlApplicationContext) context).close();</span></span><br><span class="line">    context.close();  <span class="comment">// 上面改了的话, 这里就可以直接用了(因为原来的那个没有实现这个方法, 需要转换成其子类才行?)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>bean 的后置处理器(加上这个，<strong>bean 的生命周期一共有 7 步</strong>)</p><ul><li>通过构造器创建 bean 实例(无参构造)</li><li>为 bean 的属性设置值和对其它 bean 的引用(调用 set 方法)</li><li><strong>把 bean 实例传递 bean 后置处理器的方法(postProcessBeforeInitialization)</strong></li><li>调用 bean 的初始化的方法(需要进行配置初始化的方法)</li><li><strong>把 bean 实例传递 bean 后置处理器的方法(postProcessAfterInitialization)</strong></li><li>bean 可以使用了(对象获取到了)</li><li>当容器关闭的时候，调用 bean 的销毁的方法(需要进行配置销毁的方法)</li></ul></li><li><p>演示添加 后置处理器 的效果</p><ul><li><p>创建类，实现接口 BeanPostProcessor，创建后置处理器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBeanPost</span> <span class="keyword">implements</span> <span class="title class_">BeanPostProcessor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;在初始化之前执行的方法&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;在初始化之后执行的方法&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>配置文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置后置处理器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myBeanPost&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.thr.spring5.bean.MyBeanPost&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="2-7-xml-自动装配"><a href="#2-7-xml-自动装配" class="headerlink" title="2.7 xml 自动装配"></a>2.7 xml 自动装配</h3><blockquote><p>基于 xml 自动装配用的少，一般是用注解</p></blockquote><p>（1）什么是自动装配</p><ul><li>根据指定装配规则(属性名称或者属性类型)，Spring 自动将匹配的属性值进行注入</li></ul><p>（2）演示自动装配的过程</p><ul><li><p>根据 属性名称(byName) 或者 属性类型(byType) 自动注入</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 实现自动装配</span></span><br><span class="line"><span class="comment">        bean 标签属性 autowire, 配置自动装配</span></span><br><span class="line"><span class="comment">        autowire 属性常用两个值:</span></span><br><span class="line"><span class="comment">            byName 根据属性名称注入 =&gt; 注入值 bean 的 id 值和类属性名称一样</span></span><br><span class="line"><span class="comment">            byType 根据属性类型注入 =&gt;</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;emp&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.thr.spring5.autowire.Emp&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byName&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 外部 bean 注入对象属性（这里是手动装配） --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &lt;property name=&quot;dept&quot; ref=&quot;dept&quot;&gt;&lt;/property&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dept&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.thr.spring5.autowire.Dept&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="2-8-引入外部属性文件"><a href="#2-8-引入外部属性文件" class="headerlink" title="2.8 引入外部属性文件"></a>2.8 引入外部属性文件</h3><p>（1）直接配置数据库信息</p><ul><li><p>配置德鲁伊连接池</p></li><li><p>引入德鲁伊连接池依赖 jar 包</p><p><img src="/../img/Spring%E6%A1%86%E6%9E%B6.assets/1668928652449.png" alt="图2.8.1"></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 直接配置连接池 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/hsp_db02&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;thr&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><p>（2）引入外部属性文件配置数据库的连接池</p><ul><li><p>创建外部属性文件，properties 格式文件，写数据库信息</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">prop.driverClass</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="attr">prop.url</span>=<span class="string">jdbc:mysql://localhost:3306/hsp_db02</span></span><br><span class="line"><span class="attr">prop.username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">prop.password</span>=<span class="string">thr</span></span><br></pre></td></tr></table></figure></li><li><p>把外部 properties 属性文件引入到 spring 配置文件中</p><ul><li><p>引入 context 名称空间</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在 spring 配置文件使用标签引入外部属性文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 2. 引入外部属性文件配置数据库连接池 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 2.1 引入外部属性文件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:jdbc.properties&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 2.2 配置连接池 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;prop.driverClass&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;prop.url&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;prop.username&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;prop.password&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="2-9-IOC-基于注解方式操作-Bean-管理"><a href="#2-9-IOC-基于注解方式操作-Bean-管理" class="headerlink" title="2.9 IOC 基于注解方式操作 Bean 管理"></a>2.9 IOC 基于注解方式操作 Bean 管理</h3><h4 id="2-9-1-注解"><a href="#2-9-1-注解" class="headerlink" title="2.9.1 注解"></a>2.9.1 注解</h4><p>（1）什么是注解</p><ul><li>注解是代码特殊标记</li><li>格式：@注解名称(属性名称&#x3D;属性值，属性名称&#x3D;属性值…..)</li></ul><p>（2）使用注解</p><ul><li>注解作用在类上面，方法上面，属性上面都可</li><li>使用注解目的：简化 xml 配置</li></ul><h4 id="2-9-2-创建对象"><a href="#2-9-2-创建对象" class="headerlink" title="2.9.2 创建对象"></a>2.9.2 创建对象</h4><blockquote><p>下面四个注解的功能是一样的，都可以用来创建 bean 实例</p></blockquote><p>（1）Spring 提供了四个注解</p><ul><li>@Component</li><li>@Service</li><li>@Controller</li><li>@Repository</li></ul><p>（2）基于注解方式实现对象的创建</p><ul><li><p>引入依赖</p><p><img src="/../img/Spring%E6%A1%86%E6%9E%B6.assets/1668929839937.png" alt="图2.9.2.1"></p></li><li><p>开启组件扫描</p><p>添加 context 名称空间，然后配置 xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 1. 开启组件扫描</span></span><br><span class="line"><span class="comment">            1.1 如果要扫描多个包, 多个包之间用逗号隔开</span></span><br><span class="line"><span class="comment">            1.2 也可直接扫描包的上层目录 com.thr</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.thr.spring5.dao, com.thr.spring5.service&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>创建类，在类上面创建对象注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在注解里面 value 属性值可以省略不写, 直接 @Component</span></span><br><span class="line"><span class="comment">// 默认值是首字母小写的类名称</span></span><br><span class="line"><span class="comment">// UserService  --&gt; userService</span></span><br><span class="line"><span class="meta">@Component(value = &quot;userService&quot;)</span>  <span class="comment">// 类似 &lt;bean id=&quot;userService&quot; class=&quot;..&quot; /&gt;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;service add....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testService</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 加载配置文件</span></span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;bean1.xml&quot;</span>);</span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> context.getBean(<span class="string">&quot;userService&quot;</span>, UserService.class);</span><br><span class="line">        System.out.println(userService);  <span class="comment">// com.thr.spring5.service.UserService@53ca01a2</span></span><br><span class="line">        userService.add();  <span class="comment">// service add....</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="2-9-3-组件扫描中的细节配置"><a href="#2-9-3-组件扫描中的细节配置" class="headerlink" title="2.9.3 组件扫描中的细节配置"></a>2.9.3 组件扫描中的细节配置</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 示例1:</span></span><br><span class="line"><span class="comment">         use-default-filters=&quot;false&quot; 表示现在不使用默认 filter, 自己配置 filter</span></span><br><span class="line"><span class="comment">         context:include-filter 设置扫描哪些内容</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.thr&quot;</span> <span class="attr">use-default-filters</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 说明只扫描带 Component 这个注解的类 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:include-filter</span> <span class="attr">type</span>=<span class="string">&quot;annotation&quot;</span></span></span><br><span class="line"><span class="tag">                            <span class="attr">expression</span>=<span class="string">&quot;org.springframework.stereotype.Component&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 示例2:</span></span><br><span class="line"><span class="comment">         下面这段配置扫描包的所有内容</span></span><br><span class="line"><span class="comment">         context:exclude-filter 设置哪些内容不进行扫描</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.thr&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 说明不扫描带 Controller 这个注解的类 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:exclude-filter</span> <span class="attr">type</span>=<span class="string">&quot;annotation&quot;</span></span></span><br><span class="line"><span class="tag">                            <span class="attr">expression</span>=<span class="string">&quot;org.springframework.stereotype.Controller&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-9-4-注入属性"><a href="#2-9-4-注入属性" class="headerlink" title="2.9.4 注入属性"></a>2.9.4 注入属性</h4><p>（1）**@Autowired**：根据属性类型进行自动装配</p><ul><li><p>第一步：把 service 和 dao 对象创建，在 service 和 dao 类添加创建对象注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;dao add...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>第二步：在 service 注入 dao 对象，在 service 类添加 dao 类型属性，在属性上面使用注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="comment">// 定义 dao 类型属性</span></span><br><span class="line">    <span class="comment">// 不需要添加 set 方法</span></span><br><span class="line">    <span class="comment">// 添加注入属性注解</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;service add....&quot;</span>);</span><br><span class="line">        userDao.add();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testService</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 加载配置文件</span></span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;bean1.xml&quot;</span>);</span><br><span class="line">    <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> context.getBean(<span class="string">&quot;userService&quot;</span>, UserService.class);</span><br><span class="line">    System.out.println(userService);  <span class="comment">// com.thr.spring5.service.UserService@53ca01a2</span></span><br><span class="line">    userService.add();  <span class="comment">// service add....  dao add...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>（2）**@Qualifier**：根据属性名称进行注入</p><ul><li><p>这个注解的使用要和上面的 @Autowired 一起使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span>  <span class="comment">// 根据类型进行注入</span></span><br><span class="line"><span class="meta">@Qualifier(value = &quot;userDaoImpl1&quot;)</span>  <span class="comment">// 根据属性名称注入(因为一个接口可能会有多个实现类)</span></span><br><span class="line"><span class="keyword">private</span> UserDao userDao;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository(value = &quot;userDaoImpl1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;dao add...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>（3）**@Resource**：既可以根据类型注入，也可以根据名称注入</p><ul><li><p>因为是 javax(java 的扩展包) 中的，不是 spring 里头的，所以官方不推荐使用</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"></span><br><span class="line"><span class="comment">// @Resource  // 根据类型进行注入</span></span><br><span class="line"><span class="meta">@Resource(name = &quot;userDaoImpl1&quot;)</span>  <span class="comment">// 根据名称进行注入</span></span><br><span class="line"><span class="keyword">private</span> UserDao userDao;</span><br></pre></td></tr></table></figure></li></ul><p>（4）**@Value**：注入普通类型属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Value(value = &quot;abc&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String name;</span><br></pre></td></tr></table></figure><h4 id="2-9-5-完全注解开发"><a href="#2-9-5-完全注解开发" class="headerlink" title="2.9.5 完全注解开发"></a>2.9.5 完全注解开发</h4><p>（1）创建配置类，替代 xml 配置文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>  <span class="comment">// 作为配置类, 替代 xml 配置文件</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &#123;&quot;com.thr&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）编写测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testService2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 加载配置类</span></span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(SpringConfig.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 得到对象</span></span><br><span class="line">    <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> context.getBean(<span class="string">&quot;userService&quot;</span>, UserService.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出</span></span><br><span class="line">    System.out.println(userService);  <span class="comment">// com.thr.spring5.service.UserService@53ca01a2</span></span><br><span class="line">    userService.add();  <span class="comment">// service add....  dao add...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-AOP"><a href="#3-AOP" class="headerlink" title="3. AOP"></a>3. AOP</h2><h3 id="3-1-AOP-基本概念"><a href="#3-1-AOP-基本概念" class="headerlink" title="3.1 AOP 基本概念"></a>3.1 AOP 基本概念</h3><p>（1）什么是 AOP</p><ul><li><p><strong>面向切面(方面)编程</strong>，利用 AOP 可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的<strong>耦合度</strong>降低，提高程序的可重用性，同时提高了开发的效率</p></li><li><p>通俗描述：不通过修改源代码的方式，在主干功能里添加新的功能，使用登录的例子说明如下，</p><p><img src="/../img/Spring%E6%A1%86%E6%9E%B6.assets/1669529408161.png" alt="图3.1.1"></p></li></ul><h3 id="3-2-AOP-底层原理"><a href="#3-2-AOP-底层原理" class="headerlink" title="3.2 AOP 底层原理"></a>3.2 AOP 底层原理</h3><h4 id="3-2-1-AOP-底层使用动态代理"><a href="#3-2-1-AOP-底层使用动态代理" class="headerlink" title="3.2.1 AOP 底层使用动态代理"></a>3.2.1 AOP 底层使用动态代理</h4><p>（1）有两种情况动态代理</p><ul><li><p>有接口情况，使用 <strong>JDK 动态代理</strong></p><p>创建接口<strong>实现类代理对象</strong>，增强类的方法</p><p><img src="/../img/Spring%E6%A1%86%E6%9E%B6.assets/1669529883264.png" alt="图3.2.1.1"></p></li><li><p>没有接口情况，使用 <strong>CGLIB 动态代理</strong></p><p>创建当前类<strong>子类的代理对象</strong>，增强类的方法</p><p><img src="/../img/Spring%E6%A1%86%E6%9E%B6.assets/1669530035956.png" alt="图3.2.1.2"></p></li></ul><p>（2）JDK 动态代理实现思路</p><ul><li><p>使用 JDK 动态代理，使用 <strong>Proxy 类</strong>里面的方法创建代理对象</p><p><img src="/../img/Spring%E6%A1%86%E6%9E%B6.assets/1669530348925.png" alt="图3.2.1.3"></p></li><li><p>调用 <strong>newProxyInstance</strong> 方法：三个参数</p><p>第一个参数：ClassLoader  类加载器</p><p>第二个参数：Interface  增强方法所在的类，这个类实现的接口，支持多个接口</p><p>第三个参数：InvocationHandler  实现这个接口，创建代理对象，写增强的方法</p><p><img src="/../img/Spring%E6%A1%86%E6%9E%B6.assets/1669530414575.png" alt="图3.2.1.4"></p></li></ul><h4 id="3-2-2-编写-JDK-动态代理代码"><a href="#3-2-2-编写-JDK-动态代理代码" class="headerlink" title="3.2.2 编写 JDK 动态代理代码"></a>3.2.2 编写 JDK 动态代理代码</h4><p>（1）创建接口，定义方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">update</span><span class="params">(String id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）创建接口的实现类，实现方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">update</span><span class="params">(String id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）使用 Proxy 类创建接口代理对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JDKProxy</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 创建接口实现类的代理对象</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.1 第二个参数: 我要实现的接口(数组类型?)</span></span><br><span class="line">        Class[] interfaces = &#123;UserDao.class&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.2 第一个参数: 类加载器  第三个参数: 接口(可用匿名内部类的方法写, 如下)</span></span><br><span class="line">        <span class="comment">/*Proxy.newProxyInstance(JDKProxy.class.getClassLoader(), interfaces, new InvocationHandler() &#123;</span></span><br><span class="line"><span class="comment">            @Override</span></span><br><span class="line"><span class="comment">            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span></span><br><span class="line"><span class="comment">                return null;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;);*/</span></span><br><span class="line"></span><br><span class="line">        <span class="type">UserDaoImpl</span> <span class="variable">useDao</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserDaoImpl</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.3 第三个参数不用匿名内部类的形式创建</span></span><br><span class="line">        <span class="type">UserDao</span> <span class="variable">dao</span> <span class="operator">=</span> (UserDao)Proxy.newProxyInstance(JDKProxy.class.getClassLoader(), interfaces, <span class="keyword">new</span> <span class="title class_">UserDaoProxy</span>(useDao));</span><br><span class="line">        <span class="type">int</span> <span class="variable">add</span> <span class="operator">=</span> dao.add(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建代理对象代码</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UserDaoProxy</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object obj;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 创建的是谁的代理对象, 把谁传递过来</span></span><br><span class="line">    <span class="comment">// 有参构造传递</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserDaoProxy</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.obj = obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 增强的逻辑</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">// 方法之前</span></span><br><span class="line">        System.out.println(<span class="string">&quot;方法之前执行...&quot;</span> + method.getName() + <span class="string">&quot; :传递的参数...&quot;</span> + Arrays.toString(args));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 被增强的方法执行</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">res</span> <span class="operator">=</span> method.invoke(obj, args);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 方法之后</span></span><br><span class="line">        System.out.println(<span class="string">&quot;方法之后执行...&quot;</span> + obj);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// 方法之前执行...add :传递的参数...[1, 2]</span></span><br><span class="line"><span class="comment">// add 方法执行了...</span></span><br><span class="line"><span class="comment">// 方法之后执行...com.thr.spring5.UserDaoImpl@2b193f2d</span></span><br></pre></td></tr></table></figure><h3 id="3-3-AOP-操作术语"><a href="#3-3-AOP-操作术语" class="headerlink" title="3.3 AOP 操作术语"></a>3.3 AOP 操作术语</h3><p>（1）<strong>连接点</strong></p><ul><li>类里面的哪些方法可以被增强，这些方法称为连接点</li></ul><p>（2）<strong>切入点</strong></p><ul><li>实际被真正增强的方法，称为切入点</li></ul><p>（3）<strong>通知(增强)</strong></p><ul><li>实际增强的逻辑部分称为通知(增强)</li><li>通知有多种类型<ul><li>前置通知</li><li>后置通知</li><li>环绕通知</li><li>异常通知</li><li>最终通知(类似 finally)</li></ul></li></ul><p>（4）<strong>切面</strong></p><ul><li>是动作，把通知应用到切入点的过程</li></ul><h3 id="3-4-AOP-操作-准备工作"><a href="#3-4-AOP-操作-准备工作" class="headerlink" title="3.4 AOP 操作-准备工作"></a>3.4 AOP 操作-准备工作</h3><p>（1）Spring 框架一般基于 <strong>AspectJ</strong> 实现 AOP 操作</p><ul><li>AspectJ 不是 Spring 组成部分，独立 AOP 框架，一般把 AspectJ 和 Spring 框架一起使用，进行 AOP 操作</li></ul><p>（2）<strong>基于 AspectJ 实现 AOP 操作</strong></p><ul><li>基于 xml 配置文件</li><li>基于注解方式实现(一般使用注解)</li></ul><p>（3）在项目工程里引入 AOP 相关依赖</p><p><img src="/../img/Spring%E6%A1%86%E6%9E%B6.assets/1669601567681.png" alt="图3.4.1"></p><p><img src="/../img/Spring%E6%A1%86%E6%9E%B6.assets/1669602121122.png" alt="图3.4.2"></p><p><img src="/../img/Spring%E6%A1%86%E6%9E%B6.assets/1669602149987.png" alt="图3.4.3"></p><p>（4）<strong>切入点表达式</strong></p><ul><li><p>作用：知道对哪个类里面的哪个方法进行增强</p></li><li><p>语法结构：execution([权限修饰符][返回类型][类全路径][方法名称]([参数列表]))</p></li><li><p>举例1：对 com.thr.dao.BookDao 类里面的 add 方法进行增强(两个点表示参数列表)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execution(* com.thr.dao.BookDao.add(..))</span><br></pre></td></tr></table></figure></li><li><p>举例2：对 com.thr.dao.BookDao 类里面的 所有 方法进行增强</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execution(* com.thr.dao.BookDao.*(..))</span><br></pre></td></tr></table></figure></li><li><p>举例3：对 com.thr.dao 包里面的 所有 类，类里面的所有方法进行增强</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execution(* com.thr.dao.*.*(..))</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-5-AOP-操作-AspectJ-注解"><a href="#3-5-AOP-操作-AspectJ-注解" class="headerlink" title="3.5 AOP 操作(AspectJ 注解)"></a>3.5 AOP 操作(AspectJ 注解)</h3><h4 id="3-5-1-基于注解操作步骤"><a href="#3-5-1-基于注解操作步骤" class="headerlink" title="3.5.1 基于注解操作步骤"></a>3.5.1 基于注解操作步骤</h4><p>（1）创建类，在类里面定义方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;add....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）创建增强类(编写增强逻辑)</p><ul><li><p>在增强类里面，创建方法，让不同方法代表不同的通知类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 增强类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserProxy</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 前置通知</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>（3）进行通知的配置</p><ul><li><p>在 spring 的配置文件中，配置名称空间，开启注解扫描(可以写个类，也可以写个配置文件)</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">                           http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">                           http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 开启注解扫描 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.thr.spring5.aopAnnotation&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>使用注解创建 User 和 UserProxy 对象 </p><p><img src="/../img/Spring%E6%A1%86%E6%9E%B6.assets/1669603491020.png" alt="图3.5.1.1"></p><p><img src="/../img/Spring%E6%A1%86%E6%9E%B6.assets/1669603518559.png" alt="图3.5.1.2"></p></li><li><p>在增强类上面添加注解 @Aspect</p><p><img src="/../img/Spring%E6%A1%86%E6%9E%B6.assets/1669603581738.png" alt="图3.5.1.3"></p></li><li><p>在 spring 配置文件中开启生成代理对象</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 开启 AspectJ 生成代理对象 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 有了这句话, 它就会去找我们上面有 @Aspect 注解的类, 自动给这个类生成代理对象 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:aspectj-autoproxy</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>配置不同类型的通知</p><ul><li><p>在增强类里面，在作为通知的方法上面添加通知类型的注解，并使用切入点表达式配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 增强类</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span>  <span class="comment">//生成代理对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserProxy</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 前置通知</span></span><br><span class="line">    <span class="comment">// @Before 注解, 表示作为前置通知, 即在我的增强方法的前面执行</span></span><br><span class="line">    <span class="meta">@Before(value = &quot;execution(* com.thr.spring5.aopAnnotation.User.add(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 最终通知 after 表示在我的方法执行之后执行(即便有异常也会执行) 无论正常异常都会执行</span></span><br><span class="line">    <span class="meta">@After(value = &quot;execution(* com.thr.spring5.aopAnnotation.User.add(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;after...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 后置(返回)通知  afterReturning 表示在返回值之后执行 只有正常返回才会执行</span></span><br><span class="line">    <span class="meta">@AfterReturning(value = &quot;execution(* com.thr.spring5.aopAnnotation.User.add(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterReturning</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;afterReturning...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 异常通知  有异常才执行</span></span><br><span class="line">    <span class="meta">@AfterThrowing(value = &quot;execution(* com.thr.spring5.aopAnnotation.User.add(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterThrowing</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;afterThrowing...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 环绕通知(方法之前和之后都执行)</span></span><br><span class="line">    <span class="meta">@Around(value = &quot;execution(* com.thr.spring5.aopAnnotation.User.add(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">around</span><span class="params">(ProceedingJoinPoint proceedingJoinPoint)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;环绕之前...&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 被增强的方法执行</span></span><br><span class="line">        proceedingJoinPoint.proceed();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;环绕之后...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从Spring5.2.7开始，改成了根据其类型按照从高到低的优先级进行执行：@Around @Before @After @AfterReturning @AfterThrowing</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testAopAnnotation</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 加载配置文件</span></span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;bean1.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 得到对象</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> context.getBean(<span class="string">&quot;user&quot;</span>, User.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 user 中的 add 方法</span></span><br><span class="line">    user.add();  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    环绕之前...</span></span><br><span class="line"><span class="comment">    before...</span></span><br><span class="line"><span class="comment">    add....</span></span><br><span class="line"><span class="comment">    环绕之后...</span></span><br><span class="line"><span class="comment">    after...</span></span><br><span class="line"><span class="comment">    afterReturning...</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="3-5-2-基于注解操作细节"><a href="#3-5-2-基于注解操作细节" class="headerlink" title="3.5.2 基于注解操作细节"></a>3.5.2 基于注解操作细节</h4><p>（1）相同的切入点抽取(用注解 @Pointcut)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 相同的切入点进行抽取</span></span><br><span class="line"><span class="meta">@Pointcut(value = &quot;execution(* com.thr.spring5.aopAnnotation.User.add(..))&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pointDemo</span><span class="params">()</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 前置通知</span></span><br><span class="line"><span class="comment">// @Before 注解, 表示作为前置通知, 即在我的增强方法的前面执行</span></span><br><span class="line"><span class="meta">@Before(value = &quot;pointDemo()&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;before...&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）若有多个增强类对同一个方法进行增强，可以设置增强类优先级</p><ul><li>在增强类的上面添加注解 @Order(数字类型值)，数字类型值越小优先级越高</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Order(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersonProxy</span> &#123;</span><br><span class="line">    <span class="meta">@Before(value = &quot;execution(* com.thr.spring5.aopAnnotation.User.add(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">personBefore</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;personBefore...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）<strong>完全使用注解开发</strong></p><ul><li><p>创建配置类，不需要创建 xml 配置文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 完全注解开发</span></span><br><span class="line"><span class="meta">@Configuration</span>  <span class="comment">// 配置类</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &#123;&quot;com.thr&quot;&#125;)</span>  <span class="comment">// 开启组件扫描</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy(proxyTargetClass = true)</span>  <span class="comment">// 开启 Aspect 生成代理对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfigAop</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-6-AOP-操作-AspectJ-配置文件"><a href="#3-6-AOP-操作-AspectJ-配置文件" class="headerlink" title="3.6 AOP 操作(AspectJ 配置文件)"></a>3.6 AOP 操作(AspectJ 配置文件)</h3><blockquote><p>了解即可(一般不用)</p></blockquote><p>（1）创建两个类，增强类和被增强类，创建方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 被增强类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Book</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buy</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;buy...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 增强类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookProxy</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）在 spring 配置文件中创建两个类对象</p><p>（3）在 spring 配置文件中配置切入点</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 1. 创建对象 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;book&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.thr.spring5.aopxml.Book&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookProxy&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.thr.spring5.aopxml.BookProxy&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 2. 配置 aop 增强 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 2.1 切入点 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;p&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* com.thr.spring5.aopxml.Book.buy(..))&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 2.2 配置切面 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;bookProxy&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 增强作用在具体的方法上, 此处表示把 before 方法 作用在 buy 方法之前 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">&quot;before&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;p&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>（4）测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testAopXml</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 加载配置文件</span></span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;bean2.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 得到对象</span></span><br><span class="line">    <span class="type">Book</span> <span class="variable">book</span> <span class="operator">=</span> context.getBean(<span class="string">&quot;book&quot;</span>, Book.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 user 中的 add 方法</span></span><br><span class="line">    book.buy();  <span class="comment">// 结果: before..  buy....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-JdbcTemplate"><a href="#4-JdbcTemplate" class="headerlink" title="4. JdbcTemplate"></a>4. JdbcTemplate</h2><h3 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h3><p>（1）什么是 JdbcTemplate？</p><ul><li>Spring 框架对 JDBC 进行封装，使用 JdbcTemplate 可以方便实现对数据库的操作</li></ul><p>（2）准备工作</p><ul><li><p>引入相关 jar 包</p><p><img src="/../img/Spring%E6%A1%86%E6%9E%B6.assets/1669883328152.png" alt="图4.1.1"></p></li><li><p>在 spring 配置文件中配置数据库连接池</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 数据库连接池 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">destroy-method</span>=<span class="string">&quot;close&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql:///spring_db?characterEncoding=utf8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;thr&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>配置 JdbcTemplate 对象，注入 DataSource</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- JdbcTemplate 对象 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;JdbcTemplate&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.core.JdbcTemplate&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 注入 dataSource(用 set 方法注入) --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>创建 service 类，创建 dao 类，在 dao 注入 jdbcTemplate 对象(<strong>service层要用dao层的东西 所以需要注入dao对象 dao层需要连接池来连接数据库 所以要注入 jdbcTemplate 对象</strong>)</p><ul><li><p>配置文件中开启组件扫描</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 开启组件扫描 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.thr&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>service 里面</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span>  <span class="comment">// 创建对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line">    <span class="comment">// 注入 dao</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Dao 里面</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="comment">// 注入 JdbcTemplate</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="4-2-操作数据库-添加功能"><a href="#4-2-操作数据库-添加功能" class="headerlink" title="4.2 操作数据库-添加功能"></a>4.2 操作数据库-添加功能</h3><p>（1）<strong>对于数据库的表创建实体类</strong></p><p><img src="/../img/Spring%E6%A1%86%E6%9E%B6.assets/1669885389835.png" alt="图4.2.1"></p><p>（2）<strong>编写 service 和 dao</strong></p><ul><li>在 dao 里进行数据库添加操作</li><li>调用 JdbcTemplate 对象里面 update 方法实现添加操作<ul><li>有两个参数，第一个参数：sql 语句；第二个参数：可变参数，设置 sql 语句值</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> SSM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
